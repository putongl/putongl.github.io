<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>javaSE | 普通LのBlog</title><meta name="keywords" content="javaSE"><meta name="author" content="刘晗宇"><meta name="copyright" content="刘晗宇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="javaSE1.DOS命令：切换盘符    d： dir              查看当前路径内容 cd 目录      进入当前目录   cd java cd..            回到上级目录 cd 目录1\目录2..     进如多级目录 cd\             退回盘符目录 cls             清屏 exit            退出窗口 2.类12public">
<meta property="og:type" content="article">
<meta property="og:title" content="javaSE">
<meta property="og:url" content="http://putongl.github.io/javaSE.html">
<meta property="og:site_name" content="普通LのBlog">
<meta property="og:description" content="javaSE1.DOS命令：切换盘符    d： dir              查看当前路径内容 cd 目录      进入当前目录   cd java cd..            回到上级目录 cd 目录1\目录2..     进如多级目录 cd\             退回盘符目录 cls             清屏 exit            退出窗口 2.类12public">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://putongl.github.io/img/bizhi8.jpg">
<meta property="article:published_time" content="2023-10-18T08:20:25.324Z">
<meta property="article:modified_time" content="2023-10-18T08:17:05.835Z">
<meta property="article:author" content="刘晗宇">
<meta property="article:tag" content="javaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://putongl.github.io/img/bizhi8.jpg"><link rel="shortcut icon" href="/img/top.jpg"><link rel="canonical" href="http://putongl.github.io/javaSE"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-18 16:17:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xxx.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/biaoqian.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/ziti.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="普通LのBlog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="https://music.163.com/#"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.cz01.vip/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.douyin.com/"><i class="fa-fw fas fa-anchor"></i><span> 抖音</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://www.yinghuavideo.com/"><i class="fa-fw fas fa-gamepad"></i><span> 动漫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-folder-open"></i><span> B站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bizhi8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">普通LのBlog</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="https://music.163.com/#"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.cz01.vip/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.douyin.com/"><i class="fa-fw fas fa-anchor"></i><span> 抖音</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://www.yinghuavideo.com/"><i class="fa-fw fas fa-gamepad"></i><span> 动漫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-folder-open"></i><span> B站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> </span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javaSE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-18T08:20:25.324Z" title="发表于 2023-10-18 16:20:25">2023-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-18T08:17:05.835Z" title="更新于 2023-10-18 16:17:05">2023-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/bizhi8.jpg');"></div><article class="post-content" id="article-container"><h2 id="javaSE"><a href="#javaSE" class="headerlink" title="javaSE"></a>javaSE</h2><h3 id="1-DOS命令："><a href="#1-DOS命令：" class="headerlink" title="1.DOS命令："></a>1.DOS命令：</h3><p>切换盘符    d：</p>
<p>dir              查看当前路径内容</p>
<p>cd 目录      进入当前目录   cd java</p>
<p>cd..            回到上级目录</p>
<p>cd 目录1\目录2..     进如多级目录</p>
<p>cd\             退回盘符目录</p>
<p>cls             清屏</p>
<p>exit            退出窗口</p>
<h3 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class 类名{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码的执行从main开始</p>
<h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p>字符串常量“ “</p>
<p>字符常量‘ ’</p>
<p>空常量null</p>
<p>布尔常量ture false</p>
<h3 id="4-字节"><a href="#4-字节" class="headerlink" title="4.字节"></a>4.字节</h3><p>1B是1字节</p>
<p>1B=8bit</p>
<p>1KB=1024B</p>
<p>4.基本数据类型</p>
<p>整数  占位数</p>
<p>byte   1</p>
<p>short  2</p>
<p>int（默认）4</p>
<p>long   8</p>
<p>浮点（小数）float     4         1.4-3.4</p>
<p>double（默认）8        </p>
<p>字符 char        2</p>
<p>布尔 boolean    1</p>
<p>引用数据类型</p>
<p>类  class</p>
<p>接口 interface</p>
<p>数组  [ ]</p>
<p>小驼峰命名fristName</p>
<p>大驼峰命名GoodStudent</p>
<h3 id="5-报错"><a href="#5-报错" class="headerlink" title="5.报错"></a>5.报错</h3><p>​    非法字符  中英文符号问题</p>
<p>​    不存在    大小写写错了</p>
<h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>自动类型转换       </p>
<p>​    把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p>
<p>​        byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double    </p>
<p>​        char-&gt;int-&gt;long-&gt;float-&gt;double</p>
<p>​    强制类型转换相反        </p>
<p>​        把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
<p>​        目标数据类型 变量名=（目标数据类型）值或变量</p>
<p>​        int k=(int)88.88 double比int大 值的范围比目标数据类型大</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">System.out.println((a);		<span class="comment">//97</span></span><br><span class="line">System.out.println((<span class="type">char</span>) a);  <span class="comment">//a</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p>​    字符串+字符串         拼接</p>
<p>​    字符串+数字+数字         拼接</p>
<p>​    数字+数字+字符串        前面两个数字相加拼接字符串</p>
<h3 id="8-赋值运算符"><a href="#8-赋值运算符" class="headerlink" title="8.赋值运算符"></a>8.赋值运算符</h3><p>​    +=    a=a+b    把左边和右边相加赋值给左边</p>
<p>​    -=    *=    /=    a=a+b</p>
<p>​    %=将a%b的余数给a</p>
<h3 id="9-自增自减"><a href="#9-自增自减" class="headerlink" title="9.自增自减"></a>9.自增自减</h3><p>​    单独使用 相等    i++=i++    i—=—i</p>
<p>​    参与操作使用</p>
<p>（1）放在变量后，先参与操作再++ —</p>
<pre><code>  int j=i++;        i赋值给j后自增

 System.out.println(i);    i=11        i的值为i++

  System.out.println(j);    j=10        j的值为未自增的i
</code></pre><p>（2）放在变量前，先++ — 再参与操作</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int j=++i;		i自增后赋值给j</span><br><span class="line">System.out.println(i);	i=11		i的值为i++</span><br><span class="line">System.out.println(j);	j=11		j的值为自增后的i</span><br></pre></td></tr></tbody></table></figure>
<p>9.关系运算符</p>
<p>​    ==为等于     !=不等于</p>
<p>​    =为赋值        成立为ture，不成立false</p>
<p>9.逻辑运算符</p>
<p>​    &amp; 与     a&amp;b 有false则为false</p>
<p>​    | 或         a|b    有ture则ture</p>
<p>​    ^ 异或    a^b    结果不同为ture 结果相同为false</p>
<p>​    ! 非        !a  结果与a相反</p>
<p>短路运算符</p>
<p>​    &amp;&amp;    短路与    有false则为false</p>
<p>​    ||    短路或    有ture则ture</p>
<p>注意：&amp;无论左边真假，右边都执行</p>
<p>​    &amp;&amp;左边真，右边执行，左边假，右边不执行</p>
<p>​    |无论左边真假，右边都执行</p>
<p>​    ||左边真，右边不执行，左边假，右边执行</p>
<h3 id="10-三元运算符"><a href="#10-三元运算符" class="headerlink" title="10.三元运算符"></a>10.三元运算符</h3><p>​    格式：关系表达式?表达式1:表达式2；</p>
<p>范例：a&gt;b?a:b;</p>
<p>​    首先计算关系表达式a&gt;b</p>
<p>​    若值为ture，输出表达式1 a</p>
<p>​    若值为false，输出表达式2 b</p>
<h3 id="11-switch语句"><a href="#11-switch语句" class="headerlink" title="11.switch语句"></a>11.switch语句</h3><p>表达式和case值比较相等替换</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式){</span><br><span class="line">	case 值1:语句体1; 		（春夏秋冬）case穿透	case 1;</span><br><span class="line"> 		break;								   case 2;</span><br><span class="line">	case 值2:语句体2;							 case 3;	</span><br><span class="line">		break;									春	</span><br><span class="line">...</span><br><span class="line">	default:</span><br><span class="line">		语句体n+1;</span><br><span class="line">		[break;]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="12-循环语句"><a href="#12-循环语句" class="headerlink" title="12.循环语句"></a>12.循环语句</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(1.初始化语句;2.条件判断语句;4.条件控制语句){</span><br><span class="line">	3.循环体语句;</span><br><span class="line">}</span><br><span class="line">for(int i = 1;i &lt;= 5; i++){</span><br><span class="line">	循环体语句;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>任意数字指定位上的数字咋求</p>
<p>先使用整除操作将要求书移动到各位上，再取余操作求最后一位值</p>
<p>123456789        先除10000，在对10取余得5</p>
<p>while循环        先判断后执行</p>
<p>初始化语句；</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(条件判断语句){</span><br><span class="line">	循环体语句；</span><br><span class="line">	条件控制语句；</span><br><span class="line">}</span><br><span class="line">例.int i=1；</span><br><span class="line">while(i&lt;=5){</span><br><span class="line">	循环体语句；</span><br><span class="line">	i++；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>do…while循环        先执行后判断</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化语句；</span><br><span class="line">do{</span><br><span class="line">	循环体语句；</span><br><span class="line">	条件控制语句；</span><br><span class="line">}while（条件判断语句）；</span><br><span class="line">例.int j=1；</span><br><span class="line">do{</span><br><span class="line">	循环体语句；</span><br><span class="line">	j++；</span><br><span class="line">}while（j&lt;=5）;</span><br></pre></td></tr></tbody></table></figure>
<p>死循环</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for（；；）{循环体；}</span><br><span class="line">while（true）{循环体；}</span><br><span class="line">do{}while（true）；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="13-跳转控制语句break句和continue语句"><a href="#13-跳转控制语句break句和continue语句" class="headerlink" title="13.跳转控制语句break句和continue语句"></a>13.跳转控制语句break句和continue语句</h3><p>​    1、break语句:用在switch条件语句和循环语句中，它的作用是终止某个case (或循环)并跳出switch结构（或跳出当前的循环)。</p>
<p>​    2、continue语句:用在循环语句中，它的作用是终止本次循环，执行下—次循环(首先返回到循环是否执行的判断处)</p>
<p>​    continue        跳过某次循环体内容；继续下一次执行</p>
<p>​    break        终止循环体进行</p>
<h3 id="14-数据输入Scanner"><a href="#14-数据输入Scanner" class="headerlink" title="14.数据输入Scanner"></a>14.数据输入Scanner</h3><p>随机值Random</p>
<p>（1）导包     import java.util.Scanner;（Random）</p>
<p>手动导包 import java.util.Scanner;</p>
<p>快捷键导包 Alt +回车</p>
<p>自动导包     Scanner</p>
<p>（2）创建对象Scanner sc = new Scanner(System.in);</p>
<pre><code>  Random r = new Random();
</code></pre><p>（3）接收数据 int hight1 = sc.nextInt();</p>
<pre><code>  获取随机数 int number=r.nextInt(10) + 1;    (从0到10获取随机数)包0不包括10
</code></pre><h3 id="15-数组"><a href="#15-数组" class="headerlink" title="15.数组"></a>15.数组</h3><p>（1）数组动态初始化  </p>
<p>int[ ] arr = new int[3];    </p>
<p>//左边：int：说明数组的元素类型是int类型</p>
<p>​      [ ]：说明这是一个数组</p>
<p>​      arr：数组的名称</p>
<p>//右边：new：为数组申请内存空间</p>
<p>​      int：说明数组的元素类型是int类型</p>
<p>​      [ ]：说明这是一个数组</p>
<p>3:数组长度，其实就是数组的元素个数</p>
<p>​    int[ ] arr 栈内存：储存局部变量 例如：arr；使用完毕立即消失</p>
<p>​    new int[3] 堆内存：储存new出来的内容</p>
<p>​    //只指定数组长度，由系统分配初始值</p>
<p>​    整数：0          浮点数：0.0        布尔：false    </p>
<p>​    字符：空字符    引用数据类型:null</p>
<p>​    每一个new出来的东西都有一个地址值    使用完毕会在垃圾回收器空闲的时被回收</p>
<p>（2）索引：是数组中数据的编号方式    index</p>
<p>​    数组名[索引]等同于变量名，是一种特殊的变量名</p>
<p>​    特征：从0开始连续增加每次加1</p>
<p>（3）静态初始化</p>
<p>​    格式：数组类型[ ] 变量名 = new 数组类型[ ]{数据1，数据2，….}；</p>
<p>​    int[ ] arr      = new int[ ]{1,2,3};</p>
<p>​    简化格式：数组类型[ ] 变量名 = {数据1，数据2，数据3，….}；</p>
<p>（4）数组遍历通用格式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[ ] arr = {11,22,33};</span><br><span class="line">for(int x=0;x&lt;=arr.length;x++){</span><br><span class="line">	System.out.println(arr[x]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>（5）数组获取最值</p>
<p>​    int[] arr = {15,4164,4894,8434,8746};    int max = arr[0];    for(int i=1;i<arr.length;i++){ if(arr[i]=""> max){            max = arr[i];        }    }    System.out.println(max);</arr.length;i++){></p>
<h3 id="16-方法"><a href="#16-方法" class="headerlink" title="16.方法"></a>16.方法</h3><p>两个明确：</p>
<p>返回值类型：void/int</p>
<p>参数：int[ ] arr    </p>
<p>(1).定义: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void getMax (int number1，int number2，.... ){</span><br><span class="line">	方法内容</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>(2)调用：方法名(变量名/常数);</p>
<p>int number1；</p>
<p>int number2；</p>
<p>getMax(number1/10，number2);</p>
<p>形参：方法定义中的参数    int number</p>
<p>实参：方法调用中的参数    10    number</p>
<p>带返回值方法的定义    </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int（数据类型） getMAX（int a,int b）{</span><br><span class="line">	return 100；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>return后的返回值与方法定义类型上的数据类型要匹配</p>
<p>调用格式</p>
<p>int flag = getMax(10,20)</p>
<p>（3）方法不能嵌套</p>
<p>​    void表示无返回值可以省略return；也可以单独写return</p>
<p>（4）方法通用格式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static 返回值类型 方法名（参数）{</span><br><span class="line">	方法体；</span><br><span class="line">	return 数据；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>public static        修饰符，记住这个格式</p>
<p>返回值类型        返回的数据的数据类型，没有数据返回填void，且一班不填return</p>
<p>方法名            调用方法时使用的标识</p>
<p>参数                由数据类型和变量名组成，多个参数之间用逗号隔开</p>
<p>方法体            完成功能的代码块</p>
<p>return            有数据返回，写相应的数据类型，把数据返回给调用者</p>
<ul>
<li>调用时</li>
</ul>
<p>void类型，直接调用</p>
<p>非void类型，推荐用变量接收调用（返回啥类型，用啥类型接收）sout（getMax（10））；</p>
<h3 id="17-方法重载"><a href="#17-方法重载" class="headerlink" title="17.方法重载"></a>17.方法重载</h3><p>多个方法在同一个类中</p>
<p>多个方法有相同方法名</p>
<p>多个方法参数不相同，类型不同或数量不同</p>
<p>（1）基本类型    int number = 100；</p>
<p>​    方法参数传递形参的改变不会改变实参的值</p>
<p>（2）引用类型    int arr [ ] = {10，20，30}；</p>
<p>​    形参的改变影响实参值</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();		输出内容换行</span><br><span class="line">System.out.print();			输出内容不换行</span><br></pre></td></tr></tbody></table></figure>
<h3 id="18-面向对象"><a href="#18-面向对象" class="headerlink" title="18.面向对象"></a>18.面向对象</h3><p>(1)类是有共同属性和行为的抽象</p>
<p>​    类是对象的抽象（数据类型）</p>
<p>​    对象是类的实体</p>
<p>(2)成员变量：类中方法外的变量（堆内存）有默认初始化值</p>
<p>​    局部变量：方法中的变量（栈内存）没有初始化值</p>
<p>(3)private  限制修饰符    //封装</p>
<p>​    作用：保护成员不被别的类使用，被private修饰的成员只能在本类中使用</p>
<p>​    set变量名(参数)    用于设置成员变量的名    用public修饰</p>
<p>​    get变量名()          用于获取成员变量的值    用public修饰</p>
<p>(4)this         //局部变量和成员变量同名时</p>
<p>​    被谁调用指的是谁的变量    this.name修饰成员变量</p>
<p>​    this.name = name            name修饰局部变量</p>
<p>(5)构造方法</p>
<p>无参构造方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Student(){</span><br><span class="line">	System.out.println("默认的构造方法");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class 类名{</span><br><span class="line">	修饰符 类名(参数){</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">例：</span><br><span class="line">public class Student{</span><br><span class="line">	public Student(){</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>若没有定义构造方法，系统自动给与一个无参数构造方法</p>
<p>如果定义了构造方法，系统将不再提供默认构造方法</p>
<p>如果定义了构造方法还要使用无参数构造方法就必须再写一个无参构造方法（手动给出）</p>
<h3 id="19-API"><a href="#19-API" class="headerlink" title="19.API"></a>19.API</h3><p>(1)String构造方法        //不可变</p>
<p>​    public String()                创建一个空白字符串对象，不含任何内容</p>
<p>​    public String(char[] chs)        根据字符数组的内容来创建字符串对象</p>
<p>​    public String(byte[] bys)        根据字节数组的内容来创建字符串对象</p>
<p>​    String s = “abc”；            直接赋值的方式创建字符串对象，内容是abc</p>
<p>(2)字符串的比较</p>
<pre><code> ==         基本类型：比较数值是否相等

 引用类型：比较地址是否相同        字符串String是类也是引用
</code></pre><p>​    public boolean equals(Object anObgect)    比较字符串内容，区分大小写</p>
<p>​    比较字符串的内容equals()</p>
<p>​    sout(s1.equals(s2));    字符串常量放前面不会造成空指针异常</p>
<p>​    public char charAt(int index)        返回指定索引处的char值</p>
<p>​    public lit length()                返回字符串长度</p>
<p>(3)StringBuilder            //可变字符串</p>
<p>​    public StringBuilder()            空白可变字符串</p>
<p>​    public StringBuilder(String str)    根据字符串内容创建可变字符串对象</p>
<p>​    sb.append(“任意数”)            添加数据</p>
<p>​    sb.reverse()                    返回相反数据</p>
<p>​    sb.toString()                    StringBuilder转化为String</p>
<h3 id="20-快捷键"><a href="#20-快捷键" class="headerlink" title="20.快捷键"></a>20.快捷键</h3><p>​    alt+insert    自动生成构造方法和get方法 多选shift</p>
<p>​    \t   等于tab键 </p>
<h3 id="21-面向对象三大特征：封装性，继承性，多态性"><a href="#21-面向对象三大特征：封装性，继承性，多态性" class="headerlink" title="21.面向对象三大特征：封装性，继承性，多态性"></a>21.面向对象三大特征：封装性，继承性，多态性</h3><p>​    继承：共性抽取</p>
<p>​    父类，基类，超类</p>
<p>​    子类，派生类</p>
<p>（1）父子继承关系中，成员变量重名，则创建对象时有两种访问方式：</p>
<p>直接通过子类对象访问成员变量：       new zi.numzi(成员变量)</p>
<p>​    等号左边是谁，则优先用谁，没药则向上找</p>
<p>通过成员方法访问成员变量：           调用方法</p>
<p>​    该方法属于谁则优先用谁，没有则向上找</p>
<p>（2）</p>
<p>局部变量：           直接写成员变量名</p>
<p>本类成员变量：       this.成员变量名</p>
<p>父类成员变量：       super.成员变量名</p>
<p>（3）</p>
<p>成员方法</p>
<p>创建对象是谁，优先用谁，没有则向上找</p>
<p>注意：</p>
<p>无论成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类</p>
<p>重写（Override）</p>
<p>概念：在继承关系中，方法名称一样，参数列表也一样</p>
<p>重写（Override）：方法名称一样，参数列表【也一样】。覆盖、覆写</p>
<p>重载（Overload）：方法名称一样，参数列表【不一样】。</p>
<p>方法覆盖重写的特点，创建的是子类对象，则优先用子类方法。new谁用谁</p>
<p>方法覆盖注意事项：</p>
<p>1.必须保证父子类之间方法名称相同，参数列表也相同</p>
<p>​    @Override：写在方法前面，用来检测是不是有效的正确覆盖重写</p>
<p>​    这个注释就算不写，只要满足要求，也是正确的方法覆盖重写</p>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
<p>​    小扩展提示：java.lang.Object类是是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>​    小扩展提示：public &gt; protected &gt; (default) &gt; private</p>
<p>​    备注：（default）不是关键字default，而是什么都不写留空</p>
<p>（4）构造方法：</p>
<p>​    构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有</p>
<p>​    不能被static、final、synchronized、abstract和native修饰</p>
<p>​    继承关系中，父子类构造方法的访问特点</p>
<p>​        1.子类构造方法中有一个默认隐含的”super()“调用，所以一定是先调用父类构造，后执行子类构造</p>
<p>​        2.子类构造可以通过super关键字调用父类重载构造    //方法名称一样，参数列表【不一样】</p>
<p>​        3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p>
<p>总结：</p>
<p>子类必须调用父类构造方法，不写则赠送super()，写了则用指定的super调用，super只能有一个还必须是第一个</p>
<p>super关键字用来访间父类内容，而this关键字用来访问本类内容。用法也有三种;</p>
<p>​    1.在本类的成员方法中,访间本类的成员变量。</p>
<p>​    2.在本类的成员方法中,访同本类的另一个成员方法。</p>
<p>​    3.在本类的构造法中,访间本类的另一个构造方法。</p>
<p>​        在第三种用法当中专注意:</p>
<p>​        A.this(…)调用也必须是构造方法的第一个语句，唯——个。   构造方法调用直接super(…) 或this(…)</p>
<p>​        B.super和this两种构造调用,不能同时使用。</p>
<h3 id="22-继承特点："><a href="#22-继承特点：" class="headerlink" title="22.继承特点："></a>22.继承特点：</h3><p>（1）Java语言是单维承的。</p>
<p>一个类的直接父类只能有唯——个。</p>
<p>class A{}</p>
<p>class B extends A {}     // 正确</p>
<p>class C{}</p>
<p>class D extends A.C{}    //错误</p>
<p>（2）Java语言可以多级继承。</p>
<p>我有一个父亲。我父亲还有一个父亲。也就是爷爷。</p>
<p>classA {}</p>
<p>class B extends A {}     //正确</p>
<p>class C extends B{}      //正确</p>
<p>（3）—个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。可以有很多个兄弟姐妹。生二胎。</p>
<p>class A {}</p>
<p>class B extends A {}    //正确</p>
<p>class C extends A {}    //正确</p>
<h3 id="23-抽象：子类就是父类，猫就是动物"><a href="#23-抽象：子类就是父类，猫就是动物" class="headerlink" title="23.抽象：子类就是父类，猫就是动物"></a>23.抽象：子类就是父类，猫就是动物</h3><p>抽象方法:就是加上abstract关键字,然后去掉大括号，直接分号结束。</p>
<p>抽象类。抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p>
<p>如何使用抽象类和抽象方法:</p>
<p>​    1.不能直接创建new抽象类对象。</p>
<p>​    2.必须用一个子类来继承抽象父类。</p>
<p>​    3.子类必须覆盖重写抽象父类当中所有的抽象方法。</p>
<p>​        覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</p>
<p>​    4.创建子类对象进行使用。</p>
<p>​        关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<p>1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<p>​    理解:假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>2抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<p>​    理解:子类的构造方法中,有默认的super)，需要访问父类构造方法。</p>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<p>​    理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<p>​    理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
<p>特点：</p>
<p>成员变量：可以是变量也可以是常量</p>
<p>构造方法：有构造方法，但是不能实例化</p>
<p>那么，构造方法的作用是什么呢?用于子类访问父类数据的初始化</p>
<p>成员方法：可以有抽象方法:限定子类必须完成某些动作也可以有非抽象方法:提高代码复用性</p>
<h3 id="24-多态"><a href="#24-多态" class="headerlink" title="24.多态"></a>24.多态</h3><p>多态的好处:提高了程序的扩展性</p>
<p>具体体现:定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作多态的弊端:不能使用子类的特有功能</p>
<h3 id="25-接口"><a href="#25-接口" class="headerlink" title="25.接口"></a>25.接口</h3><p>（1）接口的成员特点</p>
<p>成员变量</p>
<p>​    只能是常量        默认修饰符: public static final构造方法</p>
<p>​    接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在一个类如果没有父类，默认继承自Object类</p>
<p>成员方法</p>
<p>​    只能是抽象方法    默认修饰符: public abstract</p>
<p>特点：</p>
<p>​    接口用关键字interface修饰</p>
<p>​    public interface接口名{}</p>
<p>​    类实现接口用implements表示</p>
<p>​    public class类名implements接口名{}</p>
<p>​    接口不能实例化</p>
<p>​    接口如何实例化呢?参照多态的方式，通过实现类对象实例化，这叫接口多态。多态的形式:具体类多态，抽象类多态，接口多态。</p>
<p>​    多态的前提:有继承或者实现关系;有方法重写;有父(类/接口)引用指向(子/实现)类对象</p>
<p>​    接口的实现类</p>
<p>​    要么重写接口中的所有抽象方法要么是抽象类</p>
<p>（2）类和类的关系</p>
<p>继承关系，只能单继承，但是可以多层继承</p>
<p>类和接口的关系</p>
<p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口和接口的关系</p>
<p>继承关系，可以单继承，也可以多继承</p>
<p>1.类名作为形参和返回值</p>
<p>​    方法的形参是类名，其实需要的是该类的对象</p>
<p>​    方法的返回值是类名，其实返回的是该类的对象</p>
<p>2.抽象类名作为形参和返回值</p>
<p>​    方法的形参是抽象类名，其实需要的是该抽象类的子类对象</p>
<p>​    方法的返回值是抽象类名,其实返回的是该抽象类的子类对象</p>
<p>​    基本数据类型当做形式参数给的是值。           int String</p>
<p>​    引用数据类型当做形式参数给的是地址值。        引用类</p>
<p>3.接口名作为形参和返回值</p>
<p>​    方法的形参是接口名，其实需要的是该接口的实现类对象</p>
<p>​    方法的返回值是接口名，其实返回的是该接口的实现类对象</p>
<h3 id="26-内部类"><a href="#26-内部类" class="headerlink" title="26.内部类"></a>26.内部类</h3><p>(1).内部类的访问特点</p>
<p>​    内部类可以直接访问外部类的成员，包括私有</p>
<p>​    外部类要访问内部类的成员，必须创建对象</p>
<p>(2).局部内部类        class前无修饰词</p>
<p>​    局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>(3).匿名内部类        局部内部类的特殊形式</p>
<p>也要在方法里面写</p>
<p>前提：存在一个类或接口，类可以是具体类也可以是抽象类</p>
<p>本质：是一个继承了该类或实现了该接口的子类匿名对象</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或接口名(){</span><br><span class="line">	重写方法；</span><br><span class="line">}；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="27-Math无构造方法，如果是静态的直接用类名调用方法"><a href="#27-Math无构造方法，如果是静态的直接用类名调用方法" class="headerlink" title="27.Math无构造方法，如果是静态的直接用类名调用方法"></a>27.Math无构造方法，如果是静态的直接用类名调用方法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int abs (int a):返回参数的绝对值</span><br><span class="line"></span><br><span class="line">public static double ceil (double a):返回大于或等于参数的最小double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static double floor (double a)。返回小于或等于参数的最大double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static int round (fLoat a)。按照四舍五入返回最接近参数的int</span><br><span class="line"></span><br><span class="line">public static int max (int a,int b)。返回两个int值中的较大值</span><br><span class="line"></span><br><span class="line">public static int min (int a,int b)。返回两个int值中的较小值(自学)</span><br><span class="line"></span><br><span class="line">public static double pow (double a, double b)，返回a的b次幂的值</span><br><span class="line"></span><br><span class="line">public static double random ()。返回值为double的正值，[0.0,1.0]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="28-System类"><a href="#28-System类" class="headerlink" title="28.System类"></a>28.System类</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//public static void exit(int status):终止当前运行的java虚拟机，非零表示异常终止</span><br><span class="line"></span><br><span class="line">//public static  long currentTimeMillis():返回当前时间，以毫秒为单位 1970年1月1日</span><br></pre></td></tr></tbody></table></figure>
<h3 id="28-Object类"><a href="#28-Object类" class="headerlink" title="28.Object类"></a>28.Object类</h3><p>Object是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或者间接的继承自该类</p>
<p>构造方法: public Object()</p>
<p>回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法?因为它们的顶级父类只有无参构造方法</p>
<p>//看方法的源码，选中方法Ctrl+B</p>
<p>//建议所有子类重写toString方法    自动生成即可</p>
<p>​    public String toString()            返回对象的字符串表示形式。建议所有子类重写该方法，自动生成</p>
<p>​    public boolean equals(Object obj)    比较对象是否相等。默认比较地址，重写可以比较内容，自动生成</p>
<h3 id="29-Arrays"><a href="#29-Arrays" class="headerlink" title="29.Arrays"></a>29.Arrays</h3><p>1冒泡排序</p>
<p>​    如果有n个数据进行排序，总共需要比较n-1次</p>
<p>​    每一次比较完毕，下一次的比较就会少一个数据参与</p>
<p>2.public static String toString(int[]a) 返回指定数组的内容的字符串表示形式    打印数组的中的数据</p>
<p>​    public static void sort(int[] a)            按照数字顺序排列指定的数组</p>
<h3 id="30-基本数据类型包装类"><a href="#30-基本数据类型包装类" class="headerlink" title="30.基本数据类型包装类"></a>30.基本数据类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p>
<p>常用的操作之一:用于基本数据类型与字符串之间的转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>lnteger</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<p>1.int转换为String</p>
<p>​    public static String valueOf(int i):返回int参数的字符串表示形式。该方法是String类中的方法</p>
<p>2.String转换为int</p>
<p>​    public static int parseInt(Strings):将字符串解析为int类型。该方法是Integer类中的方法</p>
<p>3.自动装箱和拆箱</p>
<p>​    装箱:把基本数据类型转换为对应的包装类类型</p>
<p>​    拆箱:把包装类类型转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(100);</span><br><span class="line">Integer i = 100;		//自动装箱</span><br><span class="line">i = i.intValue() + 200;</span><br><span class="line">i += 200;				// i = i + 200; i + 200自动拆箱; i= i + 200;是自动装箱</span><br></pre></td></tr></tbody></table></figure>
<h3 id="31-Date类"><a href="#31-Date类" class="headerlink" title="31.Date类"></a>31.Date类</h3><p>构造方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Date()			分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</span><br><span class="line"></span><br><span class="line">public Date(long date)	分配一个Date对象，并将其初始化为表示从标准基准时间起指定的亳秒数</span><br></pre></td></tr></tbody></table></figure>
<p>常用方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long getTime()			获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值</span><br><span class="line"></span><br><span class="line">public void setTime(long time)	设置时间，给的是毫秒值</span><br></pre></td></tr></tbody></table></figure>
<h3 id="32-SimpleDateFormat-类"><a href="#32-SimpleDateFormat-类" class="headerlink" title="32.SimpleDateFormat 类"></a>32.SimpleDateFormat 类</h3><p>y    年；M     月；d    日；H    时；m    分；s    秒</p>
<p>构造方法;</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public simpLeDateFormat() :构造一个SimpLeDateFormat，使用默认模式和日期格式</span><br><span class="line"></span><br><span class="line">public SimpleDateFormat (String pattern):构造一个SimpleDateFormat使用给定的模式和默认的日期格式格式化:</span><br></pre></td></tr></tbody></table></figure>
<p>从 Date到string</p>
<p>​    public final String format(Date date):将日期格式化成日期/时间字符串解析。</p>
<p>从 String到 Date</p>
<p>​    public Date parse (String source):从给定字符串的开始解析文本以生成日期</p>
<h3 id="33-Calendar类"><a href="#33-Calendar类" class="headerlink" title="33.Calendar类"></a>33.Calendar类</h3><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p>
<p>calendar提供了一个类方法 getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化:</p>
<p>Calendar rightNow = Calendar.getInstance();</p>
<p>常用方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int get(int field)						返回给定日历字段的值 	年月日</span><br><span class="line"></span><br><span class="line">public abstract void add(int field, int amount)		根据日历的规则，将指定的时间量添加或减去给定的日历字段</span><br><span class="line"></span><br><span class="line">public final void set(int year,int month,int date)	设置当前日历的年月日</span><br></pre></td></tr></tbody></table></figure>
<h3 id="34-异常"><a href="#34-异常" class="headerlink" title="34.异常"></a>34.异常</h3><p>1.异常体系</p>
<p>​                Throwable</p>
<p>​    Error                            Exception</p>
<p>RuntimeException        非RuntimeException</p>
<p>Error:严重问题，不需要处理</p>
<p>Exception:称为异常类，它表示程序本身可以处理的问题</p>
<p>RuntimeException:在编译期是不检查的，出现问题后，需要我们回来修改代码</p>
<p>非RuntimeException:编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了</p>
<p>2.JVM的默认处理方案    java虚拟机</p>
<p>如果程序出现了问题，我们没有做任何处理，最终JⅣM会做默认的处理</p>
<p>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台.程序停止执行</p>
<p>3.异常处理之try…catch…</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try {</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">}catch (异常类名 变量名){</span><br><span class="line">	异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>执行流程:</p>
<p>程序从try里面的代码开始执行</p>
<p>出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统</p>
<p>当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理</p>
<p>执行完毕之后，程序还可以继续往下执行</p>
<ol>
<li>Throwable的成员方法</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法名							说明</span><br><span class="line"></span><br><span class="line">public String getMessage()		返回此 throwable的详细消息字符串</span><br><span class="line"></span><br><span class="line">public String toString()		返回此可抛出的简短描述</span><br><span class="line"></span><br><span class="line">public void printStackTrace()	把异常的错误信息输出在控制台</span><br></pre></td></tr></tbody></table></figure>
<p>5.Java 中的异常被分为两大类:编译时异常和运行时异常，也被称为受检异常和非受检异常</p>
<p>所有的 RuntimeException类及其子类的实例被称为运行时异常，其他的异常都是编译时异常</p>
<p>编译时异常:必须显示处理，否则程序就会发生错误,无法通过编译</p>
<p>运行时异常:无需显示处理,也可以和编译时异常一样处理</p>
<p>6.异常处理之throws</p>
<p>虽然我们通过try…catch…可以对异常进行处理，但是并不是所有的情况我们都有权限进行异常的处理也就是说，有些时候可能出现的异常是我们处理不了的，这个时候该怎么办呢?</p>
<p>格式:throws 异常类名;</p>
<p>注意:这个格式是跟在方法的括号后面的</p>
<p>编译时异常必须要进行处理，两种处理方案: try..catch ..或者throws，如果采用throws这种方案，将来谁调用谁处理运行时异常可以不处理，出现问题后，需要我们回来修改代码</p>
<p>7.throws和throw的区别</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">throws										throw</span><br><span class="line"></span><br><span class="line">用在方法声明后面，跟的是异常类名			用在方法体内，跟的是异常对象名</span><br><span class="line"></span><br><span class="line">表示抛出异常，由该方法的调用者来处理		   表示抛出异常，由方法体内的语句处理</span><br></pre></td></tr></tbody></table></figure>
<p>表示出现异常的一种可能性，并不一定会发生这些异常    执行throw一定抛出了某种异常</p>
<h3 id="35-集合"><a href="#35-集合" class="headerlink" title="35.集合"></a>35.集合</h3><p>只能存储引用类型，不能存储基本类型，int类型的包装类lnteger是引用类型</p>
<p>集合类体系结构</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">								集合</span><br><span class="line">		collection单列													Map双列</span><br><span class="line"></span><br><span class="line">接口		List可重复		   			Set不可重复								HashMap</span><br><span class="line"></span><br><span class="line">实现类ArrayList  LinkedList     	HashSet  TreeSet LinkedHashSet</span><br></pre></td></tr></tbody></table></figure>
<p>(1)Collection集合概述    E是元素类型</p>
<p>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素JDK不提供此接口的任何直接实现，它提供更具体的子接口(如Set和List)实现</p>
<p>创建Collection集合的对象</p>
<p>多态的方式</p>
<p>具体的实现类ArrayList</p>
<p>(2)Collection集合常用方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中移除指定的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合中的元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
</div>
<p>(3)Collection集合的遍历</p>
<p>Iterator:迭代器，集合的专用遍历方式</p>
<p>Iterator iterator():返回此集合中元素的迭代器，通过集合的iterator)方法得到</p>
<p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p>
<p>Iterator中的常用方法</p>
<p>​    E next():返回迭代中的下一个元素</p>
<p>​    boolean hasNext():如果迭代具有更多元素，则返回true</p>
<p>(4)List集合概述</p>
<p>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</p>
<p>与Set集合不同，列表通常允许重复的元素</p>
<p>List集合特点</p>
<p>​    有序:存储和取出的元素顺序一致</p>
<p>​    可重复:存储的元素可以重复</p>
<p>List集合特有方法:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>void add(int index,E element)</th>
<th>在此集合中的指定位置插入指定的元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>E  remove( int index)</td>
<td>册除指定索引处的元素，返回被册除的元素</td>
</tr>
<tr>
<td>E set(int index,E element):</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E  get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody>
</table>
</div>
<p>并发修改异常</p>
<p>​    ConcurrentModificationException</p>
<p>产生原因</p>
<p>​    迭代器遍历的过程中，add通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p>
<p>解决方案</p>
<p>​    用for循环遍历，然后用集合对象做对应的操作即可</p>
<p>(5)Listlterator:列表迭代器</p>
<p>通过List集合的listlterator()方法得到，所以说它是List集合特有的迭代器</p>
<p>用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</p>
<p>Listlterator中的常用方法</p>
<p>​    E next():返回迭代中的下一个元素</p>
<p>​    boolean hasNext():如果迭代具有更多元素，则返回true </p>
<p>​    previous():返回列表中的上一个元素</p>
<p>​    boolean hasPrevious():如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</p>
<p>​    void add(E e):将指定的元素插入列表</p>
<p>(6)增强for循环</p>
<p>增强for:简化数组和Collection集合的遍历</p>
<p>实现lterable接口的类允许其对象成为增强型for语句的目标它是JDK5之后出现的，其内部原理是一个lterator迭代器</p>
<p>增强for的格式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(元素数据类型  变量名:数组或者Collection集合){</span><br><span class="line">	//在此处使用变量即可，该变量就是元素</span><br><span class="line">}</span><br><span class="line">范例:</span><br><span class="line">int[]arr = {1,2,3,4,5};</span><br><span class="line">for(int i : arr) {</span><br><span class="line">	System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>(7)List集合常用子类:ArrayList，LinkedList</p>
<p>​    ArrayList:底层数据结构是数组，查询快，增删慢</p>
<p>​    LinkedList:底层数据结构是链表，查询慢，增删快</p>
<p>(8)LinkedList集合的特有功能</p>
<p>​    方法名                                    说明</p>
<p>public void addFirst(E e)            在该列表开头插入指定的元素</p>
<p>public void addLast(E e)            将指定的元索追加到此列表的末尾</p>
<p>public E getFirst()                    返回此列表中的第一个元素</p>
<p>public E getLast()                    返回此列表中的最后一个元素</p>
<p>public E removeFirst()            从此列表中删除并返回第一个元素</p>
<p>public E removeLast()            从此列表中删除并返回最后一个元素</p>
<p>(9)Set集合概述和特点Set集合特点</p>
<p>不包含重复元素的集合</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>(10)哈希值:是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<p>public int hashCode():返回对象的哈希码值</p>
<p>对象的哈希值特点</p>
<p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p>
<p>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</p>
<p>(11)HashSet集合特点</p>
<p>底层数据结构是哈希表</p>
<p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>由于是Set集合，所以是不包含重复元素的集合    保证元素唯一性，重写hashCode和equals方法</p>
<p>先比哈希值，再通过equals比较内容</p>
<p>(12)LinkedHashSet集合特点</p>
<p>哈希表和链表实现的Set接口，具有可预测的迭代次序</p>
<p>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</p>
<p>由哈希表保证元素唯一，也就是说没有重复的元素</p>
<p>(13)TreeSet集合特点</p>
<p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet():根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>由于是Set集合，所以不包含重复元素的集合</p>
<p>无参</p>
<p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</p>
<p>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</p>
<p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>比较器  带参</p>
<p>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</p>
<p>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法</p>
<p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>(14)泛型概述</p>
<p>泛型:是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢?顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型</p>
<p>这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口</p>
<p>泛型定义格式:</p>
<p>​    &lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是形参</p>
<p>​    &lt;类型1,类型2..&gt;︰指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</p>
<p>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</p>
<p>泛型的好处:</p>
<p>​    把运行时期的问题提前到了编译期间</p>
<p>​    避免了强制类型转换</p>
<p>泛型类的定义格式:</p>
<p>​    格式:修饰符class类名&lt;类型&gt;{}</p>
<p>​    范例: public class Generic{ }</p>
<p>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p>
<p>类型通配符</p>
<p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<p>类型通配符:</p>
<p>List:表示元素类型未知的List，它的元素可以匹配任何的类型</p>
<p>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</p>
<p>如果说我们不希望List是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<p>类型通配符上限: </p>
<p>List:它表示的类型是Number或者其子类型</p>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
<p>类型通配符下限:</p>
<p>List :它表示的类型是Number或者其父类型</p>
<p>(15)可变参数</p>
<p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p>
<p>格式:修饰符返回值类型方法名(数据类型…变量名){}</p>
<p>范例: public static int sum(int… a){}</p>
<p>可变参数注意事项</p>
<p>这里的变量其实是一个数组</p>
<p>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</p>
<p>可变参数的使用</p>
<p>Arrays工具类中有一个静态方法:</p>
<p>public static  List asList(T… a):返回由指定数组支持的固定大小的列表</p>
<p>返回的集合不能做增删操作，可以做修改操作</p>
<p>List接口中有一个静态方法:</p>
<p>public static  List of(E… elements):返回包含任意数量元素的不可变列表</p>
<p>返回的集合不能做增删改操作</p>
<p>Set接口中有一个静态方法:</p>
<p>public static  Set of(E… elements):返回一个包含任意数量元素的不可变集合</p>
<p>返回的集合不能做增删操作，没有修改的方法</p>
<p>(16)Map集合概述</p>
<p>lnterface MapK:键的类型;V:值的类型</p>
<p>将键映射到值的对象;不能包含重复的键;每个键可以映射到最多一个值</p>
<p>举例:学生的学号和姓名</p>
<p>itheima001    林青霞</p>
<p>itheima002    张曼玉</p>
<p>itheima003    王祖贤</p>
<p>创建Map集合的对象</p>
<p>多态的方式</p>
<p>具体的实现类HashMap</p>
<p>(17)Map集合的基本功能</p>
<p>方法名                                        说明</p>
<p>v put(K key,V value)                添加元素</p>
<p>v remove(Object key)                根据键删除健值对元素</p>
<p>void clear()                                移除所有的键值对元素</p>
<p>boolean containsKey(Object key)    判断集合是否包含指定的键</p>
<p>boolean containsValue(Object value)判断集合是否包含指定的值</p>
<p>boolean isEmpty()                    判断集合是否为空</p>
<p>int size()                                    集合的长度，也就是集合中键值对的个数</p>
<p>(18)Map集合的获取功能</p>
<p>方法名                                    说明</p>
<p>v get(Object key)                根据键获取值</p>
<p>Set keySet()                    获取所有键的集合</p>
<p>Collection values()            获取所有值的集合</p>
<p>Set &gt; entrySet()                获取所有键值对对象的集合</p>
<p>(19)Map集合的遍历1</p>
<p>获取所有键的集合。用keySet()方法实现</p>
<p>遍历键的集合，获取到每一个键。用增强for实现</p>
<p>根据键去找值。用get(Object key)方法实现</p>
<p>Map集合的遍历2</p>
<p>获取所有键值对对象的集合</p>
<p>Set &gt; entrySet():获取所有键值对对象的集合遍历键值对对象的集合，得到每一个键值对对象</p>
<p>用增强for实现，得到每一个Map.Entry根据键值对对象获取键和值</p>
<p>用getKey()得到键</p>
<p>用getValue()得到值</p>
<p>(20)Collections概述和使用Collections类的概述是针对集合操作的工具类</p>
<p>Collections类的常用方法</p>
<p>public static &gt; void sort(List list):将指定的列表按升序排序</p>
<p>public static void reverse(List list):反转指定列表中元素的顺序</p>
<p>public static void shuffle(List list):使用默认的随机源随机排列指定的列表</p>
<h3 id="36-数据结构"><a href="#36-数据结构" class="headerlink" title="36.数据结构"></a>36.数据结构</h3><p>栈：先进后出</p>
<p>队列：先进先出</p>
<p>数组是一种查询快，增删慢的模型</p>
<p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p>
<p>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低添加数据时，添加位置后的每个数据后移，再添加元素，添加效率极低</p>
<p>链表是一种增删快，查询慢的模型(对比数组)</p>
<h3 id="37-File"><a href="#37-File" class="headerlink" title="37.File"></a>37.File</h3><p>File类概述和构造方法</p>
<p>File:它是文件和目录路径名的抽象表示文件和目录是可以通过File封装成对象的</p>
<p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p>
<p>方法名                                说明</p>
<p>File(String pathname)        通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</p>
<p>File(String parent, String child)从父路径名字符串和子路径名字符串创建新的File实例</p>
<p>File(File parent, String child)    从父抽象路径名和子路径名字符串创建新的File实例</p>
<p>File类创建功能</p>
<p>方法名                        说明</p>
<p>public boolean createNewFile()    当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</p>
<p>public boolean mkdir()            创建由此抽象路径名命名的目录</p>
<p>public boolean mkdirs)            创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</p>
<p>FiLe类的判断和获取功能:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean isDirectory():测试此抽象路径名表示的FiLe是否为目录</span><br><span class="line"></span><br><span class="line">public booLean isFile():测试此抽象路径名表示的FiLe是否为文件</span><br><span class="line"></span><br><span class="line">public boolean exists()。测试此抽象路径名表示的FiLe是否存在</span><br><span class="line"></span><br><span class="line">public String getAbsolutePath():返回此抽象路径名的绝对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getPath()。将此抽象路径名转换为相对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getName()。返回由此抽象路径名表示的文件或自录的名称</span><br><span class="line"></span><br><span class="line">public String[ ] list()，返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span><br><span class="line"></span><br><span class="line">public File[] listFiles()。返回此抽象路径名表示的目录中的文件和目录的File对象数组</span><br></pre></td></tr></tbody></table></figure>
<p>FiLe类删除功能:</p>
<p>public booLean delete( ):册除由此抽象路径名表示的文件或目录</p>
<p>绝对路径和相对路径的区别</p>
<p>绝对路径:完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如: E\itcast\ljava.txt</p>
<p>相对路径:必须使用取自其他路径名的信息进行解释。例如: myFile\Wava.txt</p>
<p>删除目录时的注意事项:</p>
<p>如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h3 id="38-递归"><a href="#38-递归" class="headerlink" title="38.递归"></a>38.递归</h3><p>递归概述:以编程的角度来看，递归指的是方法定义中调用方法本身的现象</p>
<p>递归解决问题的思路:</p>
<p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算</p>
<p>递归解决问题要找到两个内容:</p>
<p>递归出口:否则会出现内存溢出</p>
<p>递归规则:与原问题相似的规模较小的问题</p>
<h3 id="39-字节流写数据"><a href="#39-字节流写数据" class="headerlink" title="39.字节流写数据"></a>39.字节流写数据</h3><p>(1)字节流抽象基类</p>
<p>lnputStream:这个抽象类是表示字节输入流的所有类的超类</p>
<p>OutputStream:这个抽象类是表示字节输出流的所有类的超类</p>
<p>子类名特点:子类名称都是以其父类名作为子类名的后缀</p>
<p>FileOutputStream:文件输出流用于将数据写入File</p>
<p>构造方法:</p>
<p>​    FileOutputStream(String name):创建文件输出流以指定的名称写入文件</p>
<p>​    FileOutputStream (File file):创建文件输出流以写入由指定的 File对象表示的文件</p>
<p>使用字节输出流写数据的步骤:</p>
<p>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)</p>
<p>调用字节输出流对象的写数据方法</p>
<p>​        // void write (int b)。将指定的字节写入此文件输出流</p>
<p>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</p>
<p>​        //void close ()。关闭此文件输出流并释放与此流相关联的任何系统资源。</p>
<p>(2)IO流分类:</p>
<p>按照数据的流向</p>
<p>输入流:读数据</p>
<p>输出流:写数据</p>
<p>按照数据类型来分</p>
<p>字节流:字节输入流;字节输出流</p>
<p>字符流:字符输入流;字符输出流</p>
<p>如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流,否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流</p>
<p>(3)字节流写数据的3种方式</p>
<p>方法名                                                    说明</p>
<p>void write(int b)                            将指定的字节写入此文件输出流—次,写一个字节数据            </p>
<p>void write(byte[] b)将b.length        字节从指定的字节数组写入此文件输出流一次写一个字节数组数据</p>
<p>void write(byte[] b, int off, int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流一次写一个字节数组的部分数据</p>
<p>(4)字节流写数据的两个小问题</p>
<p>字节流写数据如何实现换行呢?</p>
<p>写完数据后，加换行符</p>
<p>windows:\r\n</p>
<p>linux:\n</p>
<p>mac\r</p>
<p>字节流写数据如何实现追加写入呢?</p>
<p>public FileOutputStream(String name,boolean append)</p>
<p>创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头</p>
<p>(5)字节流写数据加异常处理</p>
<p>finally:在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p>
<p>特点:被finally控制的语句一定会执行，除非JVM退出</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">}catch(异常类名  变量名){</span><br><span class="line">	异常的处理代码;</span><br><span class="line">}finally{</span><br><span class="line">	执行所有清除操作;</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>(6)字节缓冲流:</p>
<p>BufferOutputStream:该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</p>
<p>BufferedlnputStream:创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</p>
<p>构造方法:</p>
<p>字节缓冲输出流:BufferedOutputStream(OutputStream out)</p>
<p>字节缓冲输入流: BufferedInputStream(InputStream in)</p>
<p>为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?</p>
<p>字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</p>
<p>byte[] getBytes(String charsetName) 使用命名的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中。 </p>
<h3 id="40-1-字符流"><a href="#40-1-字符流" class="headerlink" title="40.(1)字符流"></a>40.(1)字符流</h3><p>为什么会出现字符流</p>
<p>由于字节流操作中文不是特别的方便，所以Java就提供字符流·</p>
<p>字符流=字节流＋编码表</p>
<p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢?</p>
<p>汉字在存储的时候，无论选择哪种编码存储,第一个字节都是负数</p>
<p>(2)编码表</p>
<p>基础知识:</p>
<p>计算机中储存的信息都是用二进制数表示的;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果</p>
<p>按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。这里强调一下:按照A编码存储，必须按照A编码解析，这样才能显示正确的文本符号。否则就会导致乱码现象</p>
<p>字符编码:就是一套自然语言的字符与二进制数之间的对应规则(A65)</p>
<p>字符集:</p>
<p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p>
<p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCIl字符集、GBXXX字符集. Unicode字符集等</p>
<p>ASCI字符集:</p>
<p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)∶是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)</p>
<p>基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p>
<p>GBXXX字符集:</p>
<p>GB2312:简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了</p>
<p>GBK:最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等</p>
<p>GB18030:最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等</p>
<p>Unicode字符集:</p>
<p>为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF32。最为常用的UTF-8编码</p>
<p>UTF-8编码:可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组(IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码</p>
<p>编码规则:</p>
<p>128个US-ASCI字符，只需一个字节编码拉丁文等字符，需要二个字节编码</p>
<p>大部分常用字(含中文)，使用三个字节编码</p>
<p>其他极少使用的Unicode辅助字符，使用四字节编码</p>
<p>小结:采用何种规则编码，就要采用对应规则解码，否则就会出现乱码</p>
<p>(3)字符串中的编码解码问题</p>
<p>编码:</p>
<p>bytel]getBytes():使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>bytelgetBytes(String charsetName):使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>解码:</p>
<p>String(byte[] bytes):通过使用平台的默认字符集解码指定的字节数组来构造新的String</p>
<p>String(byte[] bytes, String charsetName):通过指定的字符集解码指定的字节数组来构造新的String</p>
<p>字符流抽象基类</p>
<p>Reader:字符输入流的抽象类</p>
<p>Writer:字符输出流的抽象类</p>
<p>字符流中和编码解码问题相关的两个类:</p>
<p>lnputStreamReader:是从字节流到字符流的桥梁</p>
<p>它读取字节,并使用指定的编码将其解码为字符</p>
<p>它使用的字符集可以由名称指定，也可以被明码指定，或者可以接受平台的默认字符集</p>
<p>OutputStreamWriter是从字符流到字节流的桥梁</p>
<p>是从字符流到字节流的桥梁,使用指定的编码将写入的字符编码为字节</p>
<p>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集</p>
<p>构造方法:</p>
<p>OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter。  </p>
<p>OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 </p>
<p>InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader。  </p>
<p>InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader。 </p>
<p>字符流写数据的5种方式</p>
<p>方法名                                                    说明</p>
<p>void write(int c)                                    写一个字符</p>
<p>void write(char[]cbuf)                            写入一个字符数组</p>
<p>void write(char[]cbuf, int off, int len)    写入字符数组的一部分</p>
<p>void write(String str)                            写一个字符串</p>
<p>void write(String str, int off, int len)        写一个字符串的一部分</p>
<p>方法名        说明</p>
<p>flush()        刷新流，还可以继续写数据</p>
<p>close()        关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</p>
<p>字符流读数据</p>
<p>方法名            说明</p>
<p>int read()            —次读一个字符数据</p>
<p>int read(char[] cbuf)—次读一个字符数组数据</p>
<p>字节是byte  字符是char</p>
<p>转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化书写，转换流提供了对应的子类</p>
<p>FileReader:用于读取字符文件的便捷类</p>
<p>FileReader(String fileName)</p>
<p>FileWriter:用于写入字符文件的便捷类</p>
<p>FileWriter(String fileName)</p>
<p>数据源和目的地的分析</p>
<p>数据源: myCharStream)(ConversionStreamDemojava—-读数据——Reader —-InputStreamReader —-FileReader</p>
<p>目的地: myCharStreamll Copy.java —-写数据—-Writer —- OutputStreamWriter —- FileWriter</p>
<p>(4)字符缓冲流:</p>
<p>BufferedWriter:将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p>
<p>BufferedReader:从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p>
<p>构造方法:</p>
<p>​    BufferedWriter(Writer out)</p>
<p>​    BufferedReader(Reader in)</p>
<p>字符缓冲流特有功能</p>
<p>BufferedWriter:</p>
<p>void newLine():写一行行分隔符，行分隔符字符串由系统属性定义</p>
<p>BufferedReader:</p>
<p>public String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null     只读内容不读换行符号</p>
<p>String split(“,”);    //字符串中按逗号分割，分成字符串数组</p>
<p>String转换为int类型</p>
<p>Integer.parseInt（String）方法</p>
<p>parseInt（）是Integer包装类里的一个方法，可以将字符串解析为带符号的整数</p>
<p>TreeSet 比较排序 Student</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Student s) {</span><br><span class="line">    //return 0;   //s2和s1是同一个接口</span><br><span class="line">    //return 1;      //正序   升序</span><br><span class="line">    //return -1;      //倒叙    降序</span><br><span class="line">    //按年龄排序</span><br><span class="line">    int num = this.age-s.age;   //this是s1，s 是s2     this在前，s在后升序  反过来降序</span><br><span class="line">    int num2 = num == 0?this.name.compareTo(s.name):num; //如果年龄相同num=0则比较name，不等于直接输出num</span><br><span class="line">    return num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>TreeSet比较器排序</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() {</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Student s1, Student s2) {</span><br><span class="line">//                int num = (s2.getChinese()+s2.getMath())-(s1.getChinese()+s1.getMath());</span><br><span class="line">                //主要条件  s1-this   s2-s  s在前，this在后  s-this降序</span><br><span class="line">                int num = s2.getSum()-s1.getSum();</span><br><span class="line">                int num2 = num == 0?s1.getChinese()-s2.getChinese():num;    //s1-s2有啥讲究</span><br><span class="line">                int num3 = num2 == 0?s1.getName().compareTo(s2.getName()):num2;</span><br><span class="line">                return num3;</span><br><span class="line">            }</span><br><span class="line">        });</span><br></pre></td></tr></tbody></table></figure>
<p>//s1-s2  升序  s1小    小减大 从小往大</p>
<p>//s2-s1  降序  s2大    大减小 从大往小</p>
<p>static修饰，类名可以直接访问</p>
<p>(5)复制文件的异常处理</p>
<p>try…catch…finally的做法:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">}catch(异常类名变量名){</span><br><span class="line">	异常的处理代码;</span><br><span class="line">}finally {</span><br><span class="line">	执行所有清除操作;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>JDK7改进方案:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try(定义流对象){</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">}catch(异常类名  变量名){</span><br><span class="line">	异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>自动释放资源</p>
<p>JDK9改进方案:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line">try(输入流对象;输出流对象){</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">}catch(异常类名  变量名){</span><br><span class="line">	异常的处理代码;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>自动释放资源</p>
<h3 id="41-标准输入输出流"><a href="#41-标准输入输出流" class="headerlink" title="41.标准输入输出流"></a>41.标准输入输出流</h3><p>System类中有两个静态的成员变量:</p>
<p>public static final lnputStream in:标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源</p>
<p>public static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标</p>
<p>自己实现键盘录入数据:</p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in);</p>
<p>写起来太麻烦，Java就提供了一个类实现键盘录入</p>
<p>Scanner sc = new Scanner(System.in);</p>
<p>输出语句的本质:是一个标准的输出流</p>
<p>PrintStream ps = System.out;</p>
<p>PrintStream类有的方法，System.out都可以使用</p>
<p>打印流分类:</p>
<p>字节打印流:PrintStream</p>
<p>字符打印流:PrintWriter</p>
<p>打印流的特点:</p>
<p>只负责输出数据，不负责读取数据有自己的特有方法</p>
<p>字节打印流</p>
<p>PrintStream(String fileName):使用指定的文件名创建新的打印流</p>
<p>使用继承父类的方法写数据，查看的时候会转码;使用自己的特有方法写数据，查看的数据原样输出</p>
<p>字符打印流PrintWriter的构造方法:</p>
<p>方法名                        说明</p>
<p>PrintWriter(String fileName)        使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新</p>
<p>PrintWriter(Writer out,boolean autoFlush)创建一个新的PrintWriter</p>
<p>out:字符输出流</p>
<p>autoFlush:一个布尔值，如果为真，则println , printf ，或format方法将刷新输出缓冲区</p>
<h3 id="42-对象序列化"><a href="#42-对象序列化" class="headerlink" title="42.对象序列化"></a>42.对象序列化</h3><p>对象序列化:就是将对象保存到磁盘中，或者在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含:对象的类型、对象的数据和对象中存储的属性等信息字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p>
<p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流:</p>
<p>(1)对象序列化流:ObjectOutputStream</p>
<p>将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取(重构)对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象</p>
<p>构造方法:</p>
<p>ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</p>
<p>序列化对象的方法:</p>
<p>void writeObject(Object obj):将指定的对象写入ObjectOutputStream</p>
<p>注意:</p>
<p>一个对象要想被序列化，该对象所属的类必须必须实现Serializable接口</p>
<p>Serializable是一个标记接口，实现该接口，不需要重写任何方法</p>
<p>(2)对象反序列化流:ObiectlnoutStream</p>
<p>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</p>
<p>构造方法:</p>
<p>ObjectInputStream(InputStream in):创建从指定的InputStream读取的ObjectInputStream</p>
<p>反序列化对象的方法:</p>
<p>Object readObject():从ObjectInputStream读取一个对象</p>
<p>(3)对象序列化流问题</p>
<p>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢?</p>
<p>会出问题，抛出InvalidClassException异常</p>
<p>如果出问题了，如何解决呢?</p>
<p>给对象所属的类加一个serialVersionUID</p>
<p>private static final long serialVersionUID = 42L;</p>
<p>如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢?</p>
<p>给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
<p>(4) Properties概述:</p>
<p>是一个Map体系的集合类·</p>
<p>Properties可以保存到流中或从流中加载</p>
<p>练习: Properties作为Map集合的使用</p>
<p>Properties作为集合的特有方法:</p>
<p>方法名                                            说明</p>
<p>Object setProperty(String key, String value)    设置集合的键和值，都是String类型，底层调用Hashtable方法 put</p>
<p>String getProperty(String key)                使用此属性列表中指定的键搜索属性</p>
<p>Set stringPropertyNames()                    从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p>
<p>Properties和IO流结合的方法:</p>
<p>方法名                                    说明</p>
<p>void load(InputStream inStream)            从输入字节流读取属性列表（键和元素对)</p>
<p>void load(Reader reader)                    从输入字符流读取属性列表〔键和元素对)</p>
<p>void store(OutputStream out, Stringcomments)    将此属性列表〔键和元素对)写入此 Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</p>
<p>void store(Writer writer,String comments)    将此属性列表〔键和元素对)写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</p>
<h3 id="43-实现多线程"><a href="#43-实现多线程" class="headerlink" title="43.实现多线程"></a>43.实现多线程</h3><p>1.1进程</p>
<p>进程:是正在运行的程序</p>
<p>是系统进行资源分配和调用的独立单位</p>
<p>每一个进程都有它自己的内存空间和系统资源</p>
<p>1.2线程</p>
<p>线程:是进程中的单个顺序控制流，是一条执行路径</p>
<p>单线程:一个进程如果只有一条执行路径，则称为单线程程序</p>
<p>多线程:一个进程如果有多条执行路径，则称为多线程程序</p>
<p>1.3多线程的实现方式</p>
<p>方式1：继承Threac类</p>
<p>定义一个类MyThread继承Thread类</p>
<p>在MyThread类中重写run()方法</p>
<p>创建MyThread类的对象</p>
<p>启动线程</p>
<p>两个小问题:</p>
<p>为什么要重写run方法?</p>
<p>​    因为run()是用来封装被线程执行的代码</p>
<p>run()方法和start()方法的区别?</p>
<p>​    run():封装线程执行的代码，直接调用，相当于普通方法的调用</p>
<p>​    start():启动线程;然后由JVM调用此线程的run()方法.</p>
<p>1.4设置和获取线程名称Thread类中设置和获取线程名称的方法</p>
<p>void setName(String name):将此线程的名称更改为等于参数name</p>
<p>String getName():返回此线程的名称</p>
<p>通过构造方法也可以设置线程名称</p>
<p>如何获取main()方法所在的线程名称?</p>
<p>public static Thread currentThread():返回对当前正在执行的线程对象的引用</p>
<p>线程有两种调度模型</p>
<p>分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
<p>抢占式调度模型:优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程</p>
<p>获取的CPU时间片相对多一些</p>
<p>Java使用的是抢占式调度模型</p>
<p>假如计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</p>
<p>Thread类中设置和获取线程优先级的方法</p>
<p>public final int getPriority():返回此线程的优先级</p>
<p>public final void setPriority(int newPriority):更改此线程的优先级</p>
<p>线程默认优先级是5;线程优先级的范围是:1-10</p>
<p>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p>
<p>1.6线程控制</p>
<p>方法名                                说明</p>
<p>static void sleep(long millis)        使当前正在执行的线程停留(暂停执行)指定的亳秒数</p>
<p>sleep后没有执行权，会被其他线程抢走,其他线程执行后也sleep，接着等待sleep结束后重新抢执行权</p>
<p>void join()                        等待这个线程死亡</p>
<p>void setDaemon(boolean  on)    将此线程标记为守护线程，当运行的线程都是守护线程时（主线程执行完毕），Java虚拟机将退出        主线程死后，守护线程也会死</p>
<p>多线程的实现方案有两种</p>
<p>继承Thread类</p>
<p>实现Runnable接口</p>
<p>相比继承Thread类，实现Runnable接口的好处</p>
<p>避免了Java单继承的局限性</p>
<p>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p>
<p>2.3同步代码块</p>
<p>锁多条语句操作共享数据，可以使用同步代码块实现</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(任意对象){</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁</p>
<p>同步的好处和弊端</p>
<p>好处:解决了多线程的数据安全问题</p>
<p>弊端:当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p>
<p>2.4同步方法</p>
<p>同步方法:就是把synchronized关键字加到方法上</p>
<p>格式:</p>
<p>修饰符 synchronized 返回值类型 方法名(方法参数){    }</p>
<p>同步方法的锁对象是什么呢?        this</p>
<p>同步静态方法:就是把synchronized关键字加到静态方法上</p>
<p>格式:</p>
<p>修饰符 static synchronized  返回值类型 方法名(方法参数){    }</p>
<p>同步静态方法的锁对象是什么呢?        类名.class</p>
<p>2.5 Lock锁</p>
<p>Lock中提供了获得锁和释放锁的方法</p>
<p>void lock():获得锁</p>
<p>void unlock():释放锁</p>
<p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法</p>
<p>ReentrantLock():创建一个ReentrantLock的实例</p>
<p>Object类的等待和唤醒方法:</p>
<p>方法名            说明</p>
<p>void wait()    导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</p>
<p>void notify()    唤醒正在等待对象监视器的单个线程</p>
<p>void notifyAll()    唤醒正在等待对象监视器的所有线程</p>
<h3 id="44-网络编程三要素"><a href="#44-网络编程三要素" class="headerlink" title="44.网络编程三要素"></a>44.网络编程三要素</h3><ul>
<li>(1)IP地址</li>
</ul>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而lP地址就是这个标识号。也就是设备的标识</p>
<p>常用命令:</p>
<p>ipconfig:查看本机IP地址</p>
<p>ping IP地址:检查网络是否连通</p>
<p>特殊IP地址:</p>
<p>127.0.0.1:是回送地址，可以代表本机地址，一般用来测试使用</p>
<p>lnetAddress:此类表示Internet协议(IP）地址</p>
<p>方法名                    说明</p>
<p>static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</p>
<p>String getHostName()        获取此lP地址的主机名</p>
<p>String getHostAddress()        返回文本显示中的IP地址字符串</p>
<ul>
<li>(2)端口</li>
</ul>
<p>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢?如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</p>
<p>端口:设备上应用程序的唯一标识</p>
<p>端口号:用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p>
<ul>
<li>(3)协议</li>
</ul>
<p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</p>
<p>协议:计算机网络中，连接和通信的规则被称为网络通信协议</p>
<p>UDP协议</p>
<p>用户数据报协议(User Datagram Protocol)</p>
<p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p>
<p>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时,由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</p>
<p>发送数据的步骤</p>
<p>创建发送端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket()</p>
<p>创建数据，并把数据打包</p>
<p>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</p>
<p>调用DatagramSocket对象的方法发送数据</p>
<p>void send(DatagramPacket p)</p>
<p>关闭发送端</p>
<p>void close()</p>
<p>接收数据的步骤</p>
<p>创建接收端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket(int port)</p>
<p>创建一个数据包。用于接收数据</p>
<p>DatagrarmPacket(byte[] buf, int length)</p>
<p>调用DatagramSocket对象的方法接收数据</p>
<p>void receive(DatagramPacketp)</p>
<p>解析数据包，并把数据在控制台显示</p>
<p>byte[] getData()</p>
<p>int getLength()</p>
<p>关闭接收端</p>
<p>void close()</p>
<p>TCP协议</p>
<p>传输控制协议(Transmission Control Protocol)</p>
<p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据,它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p>
<p>三次握手:TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p>
<p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p>
<p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求第三次握手，客户端再次向服务器端发送确认信息，确认连接</p>
<p>发送数据的步骤</p>
<p>创建客户端的Socket对象</p>
<p>(Socket)Socket(String host, int port)</p>
<p>获取输出流，写数据</p>
<p>OutputStreamgetOutputStream()</p>
<p>释放资源</p>
<p>void close()</p>
<p>接收数据的步骤</p>
<p>创建服务器端的Socket对象(ServerSocket)</p>
<p>ServerSocket(int port)</p>
<p>监听客户端连接。返回一个Socket对象</p>
<p>Socket accept()</p>
<p>获取输入流，读数据，并把数据显示在控制台</p>
<p>lnputStream getInputStream()</p>
<p>释放资源</p>
<p>void close()</p>
<p>//public void shutdownOutput()   关闭客户端的输出流。相当于给流中加入一个结束标记-1</p>
<h3 id="45-Lambda"><a href="#45-Lambda" class="headerlink" title="45.Lambda"></a>45.Lambda</h3><p>(1)Lambda表达式的格式</p>
<p>格式:(形式参数)-&gt;{代码块}</p>
<p>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空即可</p>
<p>箭头 -&gt;:由英文中画线和大于符号组成，固定写法。代表指向动作</p>
<p>代码块:是我们具体要做的事情，也就是以前我们写的方法体内容</p>
<p>(2)Lambda表达式的使用前提</p>
<p>有一个接口</p>
<p>接口中有且仅有一个抽象方法</p>
<p>(3)Lambda表达式的省略模式</p>
<p>省略规则:</p>
<p>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p>
<p>如果参数有且仅有一个，那么小括号可以省略</p>
<p>如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</p>
<p>(4)注意事项:</p>
<p>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p>
<p>必须有上下文环境，才能推导出Lambda对应的接口</p>
<p>根据局部变量的赋值得知Lambda对应的接口:Runnable r = () -&gt; System.out.printin(“Lambda表达式T);</p>
<p>根据调用方法的参数得知Lambda对应的接口: new Thread(()-&gt; System.out.printIn(“Lambda表达式”))start();</p>
<p>Lambda表达式和匿名内部类的区别</p>
<p>所需类型不同</p>
<p>匿名内部类:可以是接口，也可以是抽象类,还可以是具体类    new 接口</p>
<p>Lambda表达式:只能是接口</p>
<p>使用限制不同</p>
<p>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</p>
<p>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</p>
<p>实现原理不同</p>
<p>匿名内部类:编译之后，产生一个单独的.class字节码文件</p>
<p>Lambda表达式:编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</p>
<p>(5)接口的组成</p>
<p>常量public static final</p>
<p>抽象方法public abstract</p>
<p>默认方法(Java 8)</p>
<p>静态方法(Java 8)</p>
<p>私有方法(Java 9)</p>
<p>接口中默认方法</p>
<p>接口中默认方法的定义格式:</p>
<p>格式: public default返回值类型方法名(参数列表){}</p>
<p>范例: public default void show3( ){}</p>
<p>接口中默认方法的注意事项:</p>
<p>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字</p>
<p>public可以省略,default不能省略</p>
<p>接口中静态方法</p>
<p>接口中静态方法的定义格式:</p>
<p>格式: public static返回值类型方法名(参数列表){}</p>
<p>范例: public static void show(){}</p>
<p>接口中静态方法的注意事项:</p>
<p>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</p>
<p>public可以省略,static不能省略</p>
<p>接口中私有方法</p>
<p>当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java9增加私有方法的必然性</p>
<p>接口中私有方法的定义格式:</p>
<p>格式1: private返回值类型方法名(参数列表){}</p>
<p>范例1: private void show(){ }</p>
<p>格式2: private static返回值类型方法名(参数列表){}</p>
<p>范例2: private static void method0{}</p>
<p>接口中私有方法的注意事项:</p>
<p>默认方法可以调用私有的静态方法和非静态方法.</p>
<p>静态方法只能调用私有的静态方法</p>
<p>(6)方法引用符</p>
<p>::该符号为引用运算符，而它所在的表达式被称为方法引用</p>
<p>Lambda表达式: usePrintable(s-&gt; System.out.println(s));</p>
<p>分析:拿到参数s 之后通过Lambda表达式，传递合System.out.println方法去处理</p>
<p>方法引用:usePrintable(System.out:printIn);</p>
<p>分析:直接使用System.out中的printIn方法来取代Lambda，代码更加的简洁</p>
<p>推导与省略</p>
<p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导</p>
<p>如果使用方法引用，也是同样可以根据上下文进行推导</p>
<p>方法引用是Lambda的孪生兄弟</p>
<p>(7)引用对象的实例方法。其实就引用类中的成员方法</p>
<p>得先创建对象  new 对象</p>
<p>格式:对象::成员方法</p>
<p>范例:“HelloWorld”:toUpperCase</p>
<p>String类中的方法: public String toUpperCase()将此String所有字符转换为大写</p>
<p>(8)引用类的实例方法，其实就是引用类中的成员方法</p>
<p>格式:类名::成员方法</p>
<p>范例: String::substring</p>
<p>String类中的方法: public String substring(int beginIndex,int endIndex)</p>
<p>从beginIndex开始到endlndex结束，截取字符串。返回一个子串，子串的长度为endlndex-beginIndex</p>
<p>(9)引用构造器，其实就是引用构造方法</p>
<p>格式:类名::new</p>
<p>范例:Student::new</p>
<h3 id="46-1-函数式接口"><a href="#46-1-函数式接口" class="headerlink" title="46(1)函数式接口"></a>46(1)函数式接口</h3><p>:有且仅有一个抽象方法的接口</p>
<p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>
<p>如何检测一个接口是不是函数式接口呢?</p>
<p>@Functionallnterface</p>
<p>放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是，编译失败</p>
<p>注意</p>
<p>我们自己定义函数式接口的时候，@Functionallnterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</p>
<p>(2)如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</p>
<p>startThread( ()  -&gt;  System.out.println(Thread.currentThread().getName() +”线程启动了”));</p>
<p>(3)函数式接口作为方法的返回值</p>
<p>如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static Comparator getComparator() {</span><br><span class="line">	return (s1, s2) -&gt; s1.length( - s2.length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>(4)Supplier接口</p>
<p>Supplier:包含一个无参的方法</p>
<p>T get():获得结果</p>
<p>该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</p>
<p>Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用</p>
<p>(5)Predicate接口</p>
<p>Predicate:常用的四个方法</p>
<p>​    boolean test(T t):对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值</p>
<p>​    default Predicate negate():返回一个逻辑的否定，对应逻辑非</p>
<p>​    default Predicate and(Predicate other):返回一个组合判断，对应短路与default </p>
<p>​    Predicate or(Predicate other):返回一个组合判断，对应短路或</p>
<p>Predicate接口通常用于判断参数是否满足指定的条件</p>
<p>(6)Function接口</p>
<p>Function:常用的两个方法  将T转换为R</p>
<p>R apply(T t):将此函数应用于给定的参数</p>
<p>default  Function andThen(Function after):返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</p>
<p>Function接口通常用于对参数讲行外理，转换(休理逻罗辑由Lambda表达式实现)，然后返回一个新的值</p>
<h3 id="47-使用Stream流的方式"><a href="#47-使用Stream流的方式" class="headerlink" title="47.使用Stream流的方式"></a>47.使用Stream流的方式</h3><p>(1)完成filter过滤操作</p>
<p>void forEach(Consumer action)：逐一处理流中的元素</p>
<p>list.stream().filter(s -&gt; s.startsWith(“张”)).filter(s-&gt; s.length()== 3).forEach(System.out::printIn);</p>
<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义:生成流、过滤姓张、过滤长度为3、逐一打印</p>
<p>Stream流把真正的函数式编程风格引入到ava中</p>
<p>Stream流的使用</p>
<p>生成流</p>
<p>通过数据源(集合,数组等)生成流    </p>
<p>list.stream()</p>
<p>中间操作</p>
<p>一个流后面可以跟随零个或多个中间操作，其目的主要是打开流，做出某种程度的数据过滤/映射，然后返回一个新的流,交给下一个操作使用</p>
<p>filter()</p>
<p>终结操作</p>
<p>一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作</p>
<p>forEach()</p>
<p>(2)Stream流的常见生成方式</p>
<p>1 : ColLection体系的集合可以使用默认方法stream()生成流</p>
<p>default Stream stream ()</p>
<p>2 : Map体系的集合间接的生成流</p>
<p>3∶数组可以通过stream接口的静态方法of (T… values )生成流</p>
<p>(3)Stream流的常见中间操作方法</p>
<p>Stream filter(Predicate predicate):用于对流中的数据进行过滤</p>
<p>Predicate接口中的方法        boolean test(T t):对给定的参数进行判断，返回—个布尔值</p>
<p>Stream limit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</p>
<p>Stream skip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流.</p>
<p>static  Stream concat(Stream a, Stream b):合并a和b两个流为一个流</p>
<p>Stream distinct():返回由该流的不同元素（根据Object equals(Object))组成的流，消除重复元素</p>
<p>Stream sorted():返回由此流的元素组成的流，根据自然顺序排序</p>
<p>Stream sorted(Comparator comparator):返回由该流的元素组成的流，根据提供的Comparator进行排序</p>
<p> Stream map(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</p>
<p>Function接口中的方法        R apply(Tt)</p>
<p>Intstream mapToInt(TolntFunction mapper):返回一个ntStream其中包含将给定函数应用于此流的元素的结果        sum()方法 求和  结束   流终止操作</p>
<p>lntStream:表示原始int流</p>
<p>TolntFunction接口中的方法    int applyAsInt(T value)</p>
<p>(4)Stream流的常见终结操作方法</p>
<p>void forEach(Consumer action):对此流的每个元素执行操作</p>
<p>Consumer接口中的方法            void accept(T t):对给定的参数执行此操作</p>
<p>long count():返回此流中的元素数</p>
<p>(5)Stream流的收集方法</p>
<p>R collect(Collector collector)        但是这个收集方法的参数是一个Collector接口</p>
<p>工具类Collectors提供了具体的收集方式</p>
<p>public static  Collector toList():把元素收集到List集合中</p>
<p>publicstatic  Collector toSet(:把元素收集到Set集合年</p>
<p>public static Collector toMap(Function keyMapper,Function valueMapper):把元素收集到Map集合中</p>
<h3 id="48-1-类加载类的初始化步骤"><a href="#48-1-类加载类的初始化步骤" class="headerlink" title="48.(1)类加载类的初始化步骤"></a>48.(1)类加载类的初始化步骤</h3><p>假如类还未被加载和连接，则程序先加载并连接该类</p>
<p>假如该类的直接父类还未被初始化。则先初始化其直接父类</p>
<p>假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>注意:在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3</p>
<p>类的初始化时机:</p>
<p>创建类的实例</p>
<p>调用类的类方法</p>
<p>访问类或者接口的类变量，或者为该类变量赋值</p>
<p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>初始化某个类的子类</p>
<p>直接使用java.exe命苓来运行某个主类</p>
<p>(2)类加载器</p>
<p>ClassLoader:是负责加载类的对象</p>
<p>Java运行时具有以下内置类加载器</p>
<p>Bootstrap class loader:它是虚拟机的内置类加载器，通常表示为null，并且没有父null</p>
<p>Platform class loader:平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</p>
<p>System class loader:它也被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径,模块路径和JDK特定工具上的类</p>
<p>类加载器的继承关系:System的父加载器为Platform，而Platform的父加载器为Bootstrap</p>
<p>ClassLoader中的两个方法</p>
<p>static ClassLoader getSystemClassLoader():返回用于委派的系统类加载器</p>
<p>ClassLoader getParent():返回父类加载器进行委派</p>
<p>(3)反射概述</p>
<p>Java反射机制:是指在运行时去获取一个类的变呈和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p>
<p>这里我们提供三种方式获取Class类型的对象</p>
<p>使用类的class属性来获取该类对应的Class对象。举例: Studentclass将会返回Student类对应的Class对象</p>
<p>调用对象的getClass()方法，返回该对象所属类对应的Class对象        该方法是Object类中的方法，所有的Java对象都可以调用该方法</p>
<p>使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</p>
<p>(4)反射获取构造方法并使用</p>
<p>Class类中用于获取构造方法的方法</p>
<p>Constructor[]getConstructors():返回所有公共构造方法对象的数组</p>
<p>Constructor[]getDeclaredConstructors():返回所有构造方法对象的数组</p>
<p>Constructor getConstructor(Class… parameterTypes):返回单个公共构造方法对象</p>
<p>Constructor getDeclaredConstructor(Class… parameterTypes):返回单个构造方法对象</p>
<p>Constructor类中用于创建对象的方法</p>
<p>T newInstance(Object… initargs):根据指定的构造方法创建对象</p>
<p>暴力反射：</p>
<p>public void setAccessible(boolean flag):值为true，取消访问检查</p>
<p>(5)Class类中用于获取成员变量的方法</p>
<p>Field[] getFields():返回所有公共成员变量对象的数组</p>
<p>Field[] getDeclaredFields():返回所有成员变量对象的数组</p>
<p>Field getField(String name):返回单个公共成员变量对象</p>
<p>Field getDeclaredField(String name):返回单个成员变呈对象</p>
<p>Field类中用于给成员变量赋值的方法</p>
<p>void set(Object obj, Object value):给obj对象的成员变量赋值为value</p>
<p>(6)Class类中用于获取成员方法的方法</p>
<p>Method getMethods(:返回所有公共成员方法对象的数组，包括继承的</p>
<p>Method[]getDeclaredMethods(:返回所有成员方法对象的数组，不包括继承的</p>
<p>Method getMethod(String name, Class… parameterTypes):返回单个公共成员方法对象</p>
<p>Method getDeclaredMethod(String name, Class… parameterTypes):返回单个成员方法对象</p>
<p>Method类中用于调用成员方法的方法    执行方法</p>
<p>Object invoke(Object obj, Object…args):调用obj对象的成员方法，参数是args,返回值是Object类型</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘晗宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://putongl.github.io/javaSE.html">http://putongl.github.io/javaSE.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://putongl.github.io" target="_blank">普通LのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javaSE/">javaSE</a></div><div class="post_share"><div class="social-share" data-image="/img/bizhi8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/SSM.html"><img class="prev-cover" src="/img/bizhi8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SSM</div></div></a></div><div class="next-post pull-right"><a href="/JavaWeb.html"><img class="next-cover" src="/img/bizhi16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaWeb</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"><div class="author-info__name">刘晗宇</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/putongl"><i class="fab fa-github"></i><span>Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/putongl" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liu15373992353@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">各</font> <font color="#e66d98">花</font> <font color="#e66cc6">各</font> <font color="#cc6de6">有</font> <font color="#9770e6">各</font> <font color="#6d93e6">花</font> <font color="#6fcde6">香</font> <p align="center"><img src="/img/cebian.gif"></p> <p align="center">邮箱:shuai132325@gmail.com</p> <p align="center">QQ号:1826627978</p></b></div><b><timing></timing></b></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><b><i class="fas fa-stream"></i><span>目录</span></b></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><b><a class="toc-link" href="#javaSE"><span class="toc-number">1.</span> <span class="toc-text">javaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DOS%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1.DOS命令：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">2.类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3.常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E8%8A%82"><span class="toc-number">1.4.</span> <span class="toc-text">4.字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8A%A5%E9%94%99"><span class="toc-number">1.5.</span> <span class="toc-text">5.报错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">6.类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.</span> <span class="toc-text">7.字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">8.赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F"><span class="toc-number">1.9.</span> <span class="toc-text">9.自增自减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.10.</span> <span class="toc-text">10.三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.11.</span> <span class="toc-text">11.switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.</span> <span class="toc-text">12.循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5break%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.13.</span> <span class="toc-text">13.跳转控制语句break句和continue语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5Scanner"><span class="toc-number">1.14.</span> <span class="toc-text">14.数据输入Scanner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%95%B0%E7%BB%84"><span class="toc-number">1.15.</span> <span class="toc-text">15.数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.</span> <span class="toc-text">16.方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">1.17.</span> <span class="toc-text">17.方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.18.</span> <span class="toc-text">18.面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-API"><span class="toc-number">1.19.</span> <span class="toc-text">19.API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.20.</span> <span class="toc-text">20.快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%8C%E7%BB%A7%E6%89%BF%E6%80%A7%EF%BC%8C%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">1.21.</span> <span class="toc-text">21.面向对象三大特征：封装性，继承性，多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%BB%A7%E6%89%BF%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.22.</span> <span class="toc-text">22.继承特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%8A%BD%E8%B1%A1%EF%BC%9A%E5%AD%90%E7%B1%BB%E5%B0%B1%E6%98%AF%E7%88%B6%E7%B1%BB%EF%BC%8C%E7%8C%AB%E5%B0%B1%E6%98%AF%E5%8A%A8%E7%89%A9"><span class="toc-number">1.23.</span> <span class="toc-text">23.抽象：子类就是父类，猫就是动物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%A4%9A%E6%80%81"><span class="toc-number">1.24.</span> <span class="toc-text">24.多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.25.</span> <span class="toc-text">25.接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.26.</span> <span class="toc-text">26.内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Math%E6%97%A0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%B1%BB%E5%90%8D%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.27.</span> <span class="toc-text">27.Math无构造方法，如果是静态的直接用类名调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-System%E7%B1%BB"><span class="toc-number">1.28.</span> <span class="toc-text">28.System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-Object%E7%B1%BB"><span class="toc-number">1.29.</span> <span class="toc-text">28.Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-Arrays"><span class="toc-number">1.30.</span> <span class="toc-text">29.Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.31.</span> <span class="toc-text">30.基本数据类型包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-Date%E7%B1%BB"><span class="toc-number">1.32.</span> <span class="toc-text">31.Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-SimpleDateFormat-%E7%B1%BB"><span class="toc-number">1.33.</span> <span class="toc-text">32.SimpleDateFormat 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-Calendar%E7%B1%BB"><span class="toc-number">1.34.</span> <span class="toc-text">33.Calendar类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.35.</span> <span class="toc-text">34.异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E9%9B%86%E5%90%88"><span class="toc-number">1.36.</span> <span class="toc-text">35.集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.37.</span> <span class="toc-text">36.数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-File"><span class="toc-number">1.38.</span> <span class="toc-text">37.File</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E9%80%92%E5%BD%92"><span class="toc-number">1.39.</span> <span class="toc-text">38.递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">1.40.</span> <span class="toc-text">39.字节流写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-1-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.41.</span> <span class="toc-text">40.(1)字符流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.42.</span> <span class="toc-text">41.标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.43.</span> <span class="toc-text">42.对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.44.</span> <span class="toc-text">43.实现多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.45.</span> <span class="toc-text">44.网络编程三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-Lambda"><span class="toc-number">1.46.</span> <span class="toc-text">45.Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.47.</span> <span class="toc-text">46(1)函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%BD%BF%E7%94%A8Stream%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.48.</span> <span class="toc-text">47.使用Stream流的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.49.</span> <span class="toc-text">48.(1)类加载类的初始化步骤</span></a></li></ol></b></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><b><i class="fas fa-history"></i><span>最新文章</span></b></div><div class="aside-list"><div class="aside-list-item"><b><a class="thumbnail" href="/python.html" title="anaconda的默认位置修改pkgs以及默认创建环境踩坑"><img src="/img/anaconda.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="anaconda的默认位置修改pkgs以及默认创建环境踩坑"></a><div class="content"><a class="title" href="/python.html" title="anaconda的默认位置修改pkgs以及默认创建环境踩坑">anaconda的默认位置修改pkgs以及默认创建环境踩坑</a><time datetime="2023-12-12T00:50:56.508Z" title="发表于 2023-12-12 08:50:56">2023-12-12</time></div></b></div><div class="aside-list-item"><b><a class="thumbnail" href="/git.html" title="将项目上传到gitee上面"><img src="/img/bizhi1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将项目上传到gitee上面"></a><div class="content"><a class="title" href="/git.html" title="将项目上传到gitee上面">将项目上传到gitee上面</a><time datetime="2023-11-09T00:22:08.317Z" title="发表于 2023-11-09 08:22:08">2023-11-09</time></div></b></div><div class="aside-list-item"><b><a class="thumbnail" href="/SpringBoot.html" title="SpringBoot"><img src="/img/bizhi8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"></a><div class="content"><a class="title" href="/SpringBoot.html" title="SpringBoot">SpringBoot</a><time datetime="2023-10-18T11:41:56.613Z" title="发表于 2023-10-18 19:41:56">2023-10-18</time></div></b></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><b><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></b></p></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>  @media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></div></footer></div><div id="rightside"><div id="rightside-config-hide"><b><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></b></div><div id="rightside-config-show"><b><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></b></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title"><b>搜索</b></div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><b><input class="local-search-box--input" placeholder="搜索文章" type="text"></b></div></div></div><hr><div id="local-search-results"></div><b><span class="search-close-button"><i class="fas fa-times"></i></span></b></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
    document.getElementById('loading-box').style.opacity = '0'
    setTimeout(function(){
      document.getElementById('loading-box').classList.add("loaded")
    }, 3000);
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').style.transition = '';
    document.getElementById('loading-box').style.opacity = '1'
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 3000);</script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/sakura.js"></script><script src="/js/timing.js"></script><script src="/js/biaoqian.js"></script><script src="/js/mouse_move.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>