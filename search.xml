<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IKUN</title>
    <url>//888.html</url>
    <content><![CDATA[<h2 id="回忆录"><a href="#回忆录" class="headerlink" title="回忆录"></a>回忆录</h2><p>一个真正的IKUN，他会跳舞，比如这样</p>
<p><img src="https://s2.loli.net/2023/08/02/ucfJQoM1SIgnzVC.png" alt="3bfc6928d18ff1188d5e5a6a69778fa"></p>
<p>他用他优美的舞姿，展现出不一样的风采，一个练习时常两年半的真正的MAN</p>
<p>著名的麦克阿瑟表示，没想到谷桑成不欺我，他差点又说出那句练习两年半的深田坤桑最爱的话:哎呦，你干嘛！！我上我也行！！大型传奇纪录片:谷门吹牛逼术，持续为您播出！！</p>
]]></content>
      <categories>
        <category>帅哥</category>
      </categories>
      <tags>
        <tag>IKUN</tag>
      </tags>
  </entry>
  <entry>
    <title>JS</title>
    <url>//js.html</url>
    <content><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="1-判断相等或者不等于（-、-、-、-）运算符"><a href="#1-判断相等或者不等于（-、-、-、-）运算符" class="headerlink" title="1.判断相等或者不等于（==、===、!=、!==）运算符"></a>1.判断相等或者不等于（==、===、!=、!==）运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>等值检测运算符</th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==（相等）</td>
<td>比较两个操作数的值是否相等，会自动进行隐式转换，比如：18 == ‘18’，会为true</td>
</tr>
<tr>
<td>!=（不想等）</td>
<td>比较两个操作数的值是否不相等</td>
</tr>
<tr>
<td>===（全等）</td>
<td>比较两个操作数的值是否相等，同时检测它们的类型是否相同</td>
</tr>
<tr>
<td>!==（不全等）</td>
<td>比较两个操作数的值是否不相等，同时检测它们的类型是否不相同</td>
</tr>
</tbody>
</table>
</div>
<p>在相等运算中，应注意以下几个问题：</p>
<ul>
<li>如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。</li>
<li>如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。</li>
<li>如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。</li>
<li>如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。</li>
<li>如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。</li>
</ul>
<h2 id="2-短路运算"><a href="#2-短路运算" class="headerlink" title="2.短路运算"></a>2.短路运算</h2><h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>​    短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的 值; </p>
<h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><ul>
<li><p>​    语法： 表达式1 &amp;&amp; 表达式2 </p>
</li>
<li><p>如果第一个表达式的值为真，则返回表达式2 </p>
</li>
<li><p>如果第一个表达式的值为假，则返回表达式1</p>
</li>
<li><pre><code>console.log( 123 &amp;&amp; 456 ); // 456
console.log( 0 &amp;&amp; 456 ); // 0
console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 逻辑或 </span><br><span class="line"></span><br><span class="line">- ​	语法： 表达式1 || 表达式2 </span><br><span class="line">- 如果第一个表达式的值为真，则返回表达式1</span><br><span class="line">- 如果第一个表达式的值为假，则返回表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
console.log( 123 || 456 ); // 123
console.log( 0 || 456 ); // 456
console.log( 123 || 456 || 789 ); // 123
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3.函数的参数</span><br><span class="line"></span><br><span class="line">### 3.1形参和实参</span><br><span class="line"></span><br><span class="line">在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br><span class="line">| 参数 | 说明                                                        |</span><br><span class="line">| ---- | ----------------------------------------------------------- |</span><br><span class="line">| 形参 | 形式上的参数 函数定义的时候，传递的参数，当时并不知道是什么 |</span><br><span class="line">| 实参 | 实际上的参数 函数调用的时候，传递的参数，实参是传递给形参的 |</span><br><span class="line"></span><br><span class="line">参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</span><br><span class="line"></span><br><span class="line">- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔
 // 函数体
&#125;
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...);
</code></pre></li>
</ul>
<h3 id="3-2函数形参和实参个数不匹配问题"><a href="#3-2函数形参和实参个数不匹配问题" class="headerlink" title="3.2函数形参和实参个数不匹配问题"></a>3.2函数形参和实参个数不匹配问题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数个数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实参的个数等于形参的个数</td>
<td>输出正确结果</td>
</tr>
<tr>
<td>实参的个数多于形参的个数</td>
<td>只取到形参的个数</td>
</tr>
<tr>
<td>实参的个数小于形参的个数</td>
<td>多的形参定义为undefined，结果为NaN</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-3arguments的使用"><a href="#3-3arguments的使用" class="headerlink" title="3.3arguments的使用"></a>3.3arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上 它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的 所有实参。</p>
<p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>可以有无数多个参数，实参有几个，arguments就有几个</li>
<li>具有 length 属性 </li>
<li>按索引方式储存数据</li>
<li>不具有数组的 push , pop 等方法</li>
</ul>
<h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4.预解析"></a>4.预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两 步：预解析和代码执行。</p>
<ul>
<li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提 前声明或者定义。</p>
</li>
<li><p>代码执行： 从上到下执行JS语句。</p>
</li>
</ul>
<p>预解析会把变量和函数的声明在代码执行之前执行完成。</p>
<ul>
<li>函数预解析</li>
<li>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</li>
</ul>
<h2 id="5-事件对象"><a href="#5-事件对象" class="headerlink" title="5.事件对象"></a>5.事件对象</h2><p>e.target 和 this 的区别：</p>
<p>​    this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素），谁绑定了这个点击事件，那么就返回谁 </p>
<p>​    e.target 是事件触发的元素。点击了哪个元素，就返回哪个元素</p>
<p>给ul绑定事件，this指向的是ul，e.target指向的是li</p>
<p>eventTarget.addEventListener(‘click’, function(event) { </p>
<p>​        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </p>
<p>}）</p>
<ul>
<li>addEventListener(‘click’, function(event)，true)</li>
<li>第三个参数为true，则为捕获阶段</li>
<li>省略不写，或为false，为冒泡阶段</li>
</ul>
<h2 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h2><ul>
<li>定义:执行代码和收集异步任务的模型，在调用栈空闲，反复调用任务队列里回调函数的执行机制，就叫事件循环</li>
</ul>
<p>执行过程</p>
<p>1.执行同步代码，遇到异步代码交给宿主浏览器环境</p>
<p>2.执行异步有了结果后，把回调函数放入任务队列排队</p>
<p>3.当调用栈空闲后，反复调用任务队列里的回调函数</p>
<p><img src="https://s2.loli.net/2023/08/27/qLNrMJUvgkXTQom.png" alt="image-20230827115025297"></p>
<h2 id="7-宏任务和微任务"><a href="#7-宏任务和微任务" class="headerlink" title="7.宏任务和微任务"></a>7.宏任务和微任务</h2><ul>
<li>1．什么是宏任务?</li>
<li>浏览器执行的异步代码</li>
<li>例如:JS执行脚本事件，setTimeout/setlnterval,AJAX请求完成事件，用户交互事件等</li>
<li>2．什么是微任务?</li>
<li>JS引擎执行的异步代码</li>
<li>例如:Promise对象.then()的回调</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>//linux%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027214128.png" alt="image-20221027214128453"></p>
<ul>
<li><code>/</code>，根目录是最顶级的目录了</li>
<li>Linux只有一个顶级目录：<code>/</code></li>
<li>路径描述的层次关系同样适用<code>/</code>来表示</li>
<li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li>
</ul>
<h2 id="Linux命令基础格式"><a href="#Linux命令基础格式" class="headerlink" title="Linux命令基础格式"></a>Linux命令基础格式</h2><p><code>command [-options] [parameter]</code></p>
<ul>
<li>command：命令本身</li>
<li><p>-options：[可选，非可选]命令的一些选项，可以通过选项控制命令的行为细节</p>
</li>
<li><p>parameter:[可选，非必填]命令的参数，多数用于命令的指向目标等</p>
</li>
</ul>
<p>语法中的[ ],表示可选的意思</p>
<p>示例:</p>
<ul>
<li>ls -l /home/itheima，ls是命令本身，-l 是选项，/home/itheima是参数<ul>
<li>意思是以列表的形式，显示/home/itheima目录内的内容</li>
</ul>
</li>
<li>cp -r test1 test2，cp是命令本身，-r 是选项，test1和test2是参数<ul>
<li>意思是复制文件夹test1成为 test2</li>
</ul>
</li>
</ul>
<h1 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h1><ul>
<li><p><code>ctrl + c</code>：强制停止</p>
</li>
<li><p><code>ctrl + d</code>：退出或登出</p>
</li>
</ul>
<p>​    退出账户的登录或者退出特定程序的专属页面，python程序的页面ctrl + c没效果使用ctrl</p>
<p>​    ps：不能用于退出vi/vim</p>
<ul>
<li><p><code>history</code>命令，查看历史输入过的命令</p>
</li>
<li><p>!命令前缀，自动执行上一次匹配前缀的命令。</p>
</li>
</ul>
<p>​    例如：<code>!py</code>匹配以py开头匹配最近的一次命令并执行</p>
<ul>
<li><code>ctrl + r</code>：历史命令搜索</li>
</ul>
<p>​    输入内容去匹配历史指令</p>
<p>​        如果是需要的<br>​            1.回车键直接执行<br>​            2.键盘的左右键，可以直接得到此命令（不执行）</p>
<ul>
<li>光标移动快捷键</li>
</ul>
<p><code>ctrl+a</code>,跳到命令开头<br><code>ctrl+e</code>,跳到命令结尾<br><code>ctrl+键盘左键</code>，向左跳一个单词<br><code>ctrl+键盘右键</code>，向右跳一个单词</p>
<ul>
<li>清屏<code>ctrl + l</code>或者命令<code>clear</code></li>
</ul>
<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p>
<p>语法：<code>ls [-l -h -a] [参数]</code></p>
<ul>
<li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li>
<li>-l，以列表形式查看</li>
<li>-h，配合-l，以更加人性化的方式显示文件大小，加上单位</li>
<li>-a，显示隐藏文件</li>
</ul>
<h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p>
<p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p>
<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p>
<p>语法：<code>pwd</code></p>
<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录</p>
<p>语法：<code>cd [目标目录]</code></p>
<p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p>
<h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p>
<ul>
<li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p>
</li>
<li><p>root用户的HOME目录，在：<code>/root</code></p>
</li>
</ul>
<p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p>
<h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul>
<li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p>
<p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p>
</li>
<li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p>
<p>绝对路径从<code>根</code>开始描述路径</p>
</li>
</ul>
<h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul>
<li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li>
<li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li>
<li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li>
</ul>
<h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p>
<p>语法：<code>mkdir [-p] 参数</code></p>
<ul>
<li>参数：被创建文件夹的路径</li>
<li>选项：-p，可选，表示自动创建不存在的父目录，多路径<code>/home/itcast/good/666</code></li>
</ul>
<h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p>
<p>语法：<code>touch 参数</code></p>
<ul>
<li>参数：被创建的文件路径</li>
</ul>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p>
<p>语法：<code>cat 参数</code></p>
<ul>
<li>参数：被查看的文件路径</li>
</ul>
<h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p>
<p>语法：<code>more 参数</code></p>
<ul>
<li>参数：被查看的文件路径</li>
<li>在查看过程中：<ul>
<li><code>空格</code>键翻页</li>
<li><code>q</code>退出查看</li>
</ul>
</li>
</ul>
<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p>
<p>语法：<code>cp [-r] 参数1 参数2</code></p>
<ul>
<li>参数1，被复制的</li>
<li>参数2，要复制去的地方</li>
<li>选项：-r，可选，复制文件夹使用</li>
</ul>
<p>示例：</p>
<ul>
<li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li>
<li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li>
<li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li>
</ul>
<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p>
<p>语法：<code>mv 参数1 参数2</code></p>
<ul>
<li>参数1：被移动的</li>
<li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li>
</ul>
<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p>
<p>语法：<code>rm [-r -f] 参数...参数</code></p>
<ul>
<li>参数：支持多个，每一个表示被删除的，空格进行分隔</li>
<li>选项：-r，删除文件夹使用</li>
<li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li>
</ul>
<blockquote>
<p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p>
</blockquote>
<h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径</p>
<p>语法：<code>which 参数</code></p>
<ul>
<li>参数：被查看的命令</li>
</ul>
<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p>
<p>语法1：按文件名搜索：<code>find 路径 -name 参数</code></p>
<ul>
<li>路径，搜索的起始路径</li>
<li>参数，搜索的关键字，支持通配符<em>， 比如：`</em>`test表示搜索任意以test结尾的文件</li>
</ul>
<p>语法2：按文件大小查找文件：<code>find 起始路径 -size +/-n[kMG]</code></p>
<ul>
<li><p>+、- 表示大于和小于</p>
</li>
<li><p>n表示大小数字</p>
</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例:</p>
<ul>
<li>查找小于10KB的文件: <code>find / -size -10k</code></li>
<li>查找大于100MB的文件: <code>find / -size +100M</code></li>
<li>查找大于1GB的文件: <code>find / -size +1G</code></li>
</ul>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p>
<p>语法：<code>grep [-n] 关键字 文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<blockquote>
<p>参数文件路径，可以作为管道符的输入</p>
</blockquote>
<h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p>
<p>语法：<code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<blockquote>
<p>参数文件路径，可作为管道符的输入</p>
</blockquote>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p>
<p>功能：将符号左边的结果，作为符号右边的输入</p>
<p>示例：</p>
<p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p>
<p>可以支持嵌套：</p>
<p><code>cat a.txt | grep itheima | grep itcast</code></p>
<h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p>
<p>语法：<code>echo 参数</code></p>
<ul>
<li>参数：被输出的内容</li>
</ul>
<h2 id="反引号"><a href="#反引号" class="headerlink" title="`反引号"></a>`反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p>
<p>示例：</p>
<ul>
<li>echo `pwd`，会输出当前工作目录</li>
</ul>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p>
<p>语法：<code>tail [-f -num] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-f，持续跟踪文件修改</li>
<li>选项：-num，表示查看尾部多少行，不写默认查看10行</li>
</ul>
<h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p>
<p>语法：<code>head [-n] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-n，查看的行数</li>
</ul>
<h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p>
<ul>
<li><code>&gt;</code>，表示覆盖输出</li>
<li><code>&gt;&gt;</code>，表示追加输出</li>
</ul>
<h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027215841.png" alt="image-20221027215841573"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027215846.png" alt="image-20221027215846581"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027215849.png" alt="image-20221027215849668"></p>
<h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027215858.png" alt="image-20221027215858967"></p>
<h2 id="命令的选项"><a href="#命令的选项" class="headerlink" title="命令的选项"></a>命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p>
<p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p>
<p>课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p>
<p>课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</p>
<h3 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220005.png" alt="image-20221027220005610"></p>
<h3 id="查看命令的详细手册"><a href="#查看命令的详细手册" class="headerlink" title="查看命令的详细手册"></a>查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220010.png" alt="image-20221027220009949"></p>
<h1 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul>
<li>CentOS系统使用：<ul>
<li>yum [install remove search] [-y] 软件名称<ul>
<li>install 安装</li>
<li>remove 卸载</li>
<li>search 搜索</li>
<li>-y，自动确认</li>
</ul>
</li>
<li>yum命令需要root权限，可以su切换到root，或使用sudo提权</li>
</ul>
</li>
<li>Ubuntu系统使用<ul>
<li>apt [install remove search] [-y] 软件名称<ul>
<li>install 安装</li>
<li>remove 卸载</li>
<li>search 搜索</li>
<li>-y，自动确认</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>yum 和 apt 均需要root权限</p>
</blockquote>
<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>功能：控制系统服务的启动关闭等</p>
<p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p>
<ul>
<li>start，启动</li>
<li>stop，停止</li>
<li>status，查看状态</li>
<li>disable，关闭开机自启</li>
<li>enable，开启开机自启</li>
<li>restart，重启</li>
</ul>
<p>系统内置的服务比较多，比如:</p>
<ul>
<li>NetworkManager,主网络服务</li>
<li>network,副网络服务</li>
<li>firewalld,防火墙服务</li>
<li>sshd,ssh服务(Finalshell远程登录Linux使用的就是这个服务)</li>
</ul>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p>
<p>语法：<code>ln -s 参数1 参数2</code></p>
<ul>
<li>-s选项，创建软链接</li>
<li>参数1：被链接的</li>
<li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li>
</ul>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p>
<ul>
<li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p>
<ul>
<li>%Y   年%y   年份后两位数字 (00..99)</li>
<li>%m   月份 (01..12)</li>
<li>%d   日 (01..31)</li>
<li>%H   小时 (00..23)</li>
<li>%M   分钟 (00..59)</li>
<li>%S   秒 (00..60)</li>
<li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li>
</ul>
</li>
</ul>
<p>示例：</p>
<ul>
<li><p>按照2022-01-01的格式显示日期</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220514.png" alt="image-20221027220514640"></p>
</li>
<li><p>按照2022-01-01 10:00:00的格式显示日期</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220525.png" alt="image-20221027220525625"></p>
</li>
<li><p>-d选项日期计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220429.png" alt="image-20221027220429831"></p>
<ul>
<li><p>支持的时间标记为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220449.png" alt="image-20221027220449312"></p>
</li>
</ul>
</li>
</ul>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>修改时区为中国时区</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027220554.png" alt="image-20221027220554654"></p>
<h2 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h2><p>功能：同步时间</p>
<p>安装：<code>yum install -y ntp</code></p>
<p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p>
<p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p>
<h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>格式：a.b.c.d</p>
<ul>
<li>abcd为0~255的数字</li>
</ul>
<h3 id="修改ip地址"><a href="#修改ip地址" class="headerlink" title="修改ip地址"></a>修改ip地址</h3><p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p>修改<code>BOOTPROTO=&quot;static&quot;</code></p>
<p>在文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPADDR=&quot;192.168.39.131&quot;</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;192.168.39.2&quot;</span><br><span class="line">DNS1=&quot;192.168.39.2&quot;</span><br></pre></td></tr></table></figure>
<p>特殊IP：</p>
<ul>
<li>127.0.0.1，表示本机</li>
<li>0.0.0.0<ul>
<li>可以表示本机</li>
<li>也可以表示任意IP（看使用场景）</li>
</ul>
</li>
</ul>
<p>查看ip：<code>ifconfig</code></p>
<h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>功能：Linux系统的名称</p>
<p>查看：<code>hostname</code></p>
<p>设置：<code>hostnamectl set-hostname 主机名</code></p>
<h2 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h2><ol>
<li><p>修改VMware网络，参阅PPT，图太多</p>
</li>
<li><p>设置Linux内部固定IP</p>
<p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p>示例文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;			# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;		# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;		# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;		# 网关，要和VMware中配置的一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;			# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>功能：查看进程信息</p>
<p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p>
<ul>
<li>选项：-e，显示出全部的进程</li>
<li>选项：-f，以完全格式化的形式展示信息（展示全部信息）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240124133209625.png" alt="image-20240124133209625"></p>
<h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221303.png" alt="image-20221027221303037"></p>
<h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221241.png" alt="image-20221027221241123"></p>
<h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>功能：查看端口占用</p>
<p>安装netstat：<code>yum -y install net-tools</code></p>
<p>用法：<code>netstat -anp | grep xxx</code> 过滤xxx端口信息</p>
<p>查看当前占用端口命令：<code>netstat -tanlp</code></p>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>测试网络是否联通</p>
<p>语法：<code>ping [-c num] 参数</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221129.png" alt="image-20221027221129782"></p>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221149.png" alt="image-20221027221148964"></p>
<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221201.png" alt="image-20221027221201079"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221210.png" alt="image-20221027221210518"></p>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>功能：查看主机运行状态</p>
<p>语法：<code>top</code>，查看基础信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240124135035027.png" alt="image-20240124135035027"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240124135133476.png" alt="image-20240124135133476"></p>
<p>可用选项：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221340.png" alt="image-20221027221340729"></p>
<p>交互式模式，可用快捷键：</p>
<p>当top以交互式运行（非 -b 选项启动，直接执行top命令）</p>
<p>f键按空格选择，空格取消</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221354.png" alt="image-20221027221354137"></p>
<h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>查看磁盘占用</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221413.png" alt="image-20221027221413787"></p>
<h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><p>查看CPU、磁盘的相关信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221440.png" alt="image-20221027221439990"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221514.png" alt="image-20221027221514237"></p>
<h2 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h2><p>查看网络统计</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221545.png" alt="image-20221027221545822"></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul>
<li>临时设置：export 变量名=变量值</li>
<li>永久设置：<ul>
<li>针对当前用户，设置用户HOME目录内：<code>vim ~/.bashrc</code>文件，添加<code>export 变量名=变量值</code></li>
<li>针对全局，所有用户，设置<code>/etc/profile</code></li>
<li>并通过语法：source配置文件，进行立刻生效，或者重新登录FinalShell生效</li>
</ul>
</li>
</ul>
<h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>记录了执行程序的搜索路径</p>
<p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p>
<p>环境变量PATH会记录一组目录,目录之间用:隔开。这里记录的是命令的搜索路径<br>当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行。<br>可以通过修改这个项目的值，加入自定义的命令搜索路径<br>如<code>export PATH=$PATH:自定义路径</code></p>
<h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>可以取出指定的环境变量的值</p>
<p>语法：<code>$变量名</code></p>
<p>示例：</p>
<p><code>echo $PATH</code>，输出PATH环境变量的值</p>
<p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p>
<p>如果变量名和其它内容混淆在一起，可以使用${}</p>
<h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>Linux和Mac系统常用有2种压缩格式，后缀名分别是:</p>
<ul>
<li>.tar，称之为tarball，归档文件，即简单的将文件组装到一个.tar的文件内，并没有太多文件体积的减少，仅仅是简单的封装</li>
<li>.gz，也常见为.tar.gz，gzip格式压缩文件,即使用gzip压缩算法将文件压缩到一个文件内,可以极大的减少压缩后的体积</li>
</ul>
<p>针对这两种格式，使用tar命令均可以进行压缩和解压缩的操作</p>
<p>语法: <code>tar [-c -v -x -f -z -C] 参数1 参数2 ... 参数N</code></p>
<ul>
<li>-c，创建压缩文件，用于压缩模式</li>
<li>-v，显示压缩、解压过程，用于查看进度</li>
<li>-x，解压模式</li>
<li>-f，要创建的文件，或要解压的文件，-f选项必须在所有选项中位置处于最后一个</li>
<li>-z，gzip模式，不使用-z就是普通的tarball格式</li>
<li>-C，选择解压的目的地，用于解压模式</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p>
<ul>
<li>-z表示使用gzip，可以不写，如果使用一般放到选项位的第一个</li>
<li>将被压缩1，2，3放到压缩包里</li>
</ul>
<p><code>zip [-r] 参数1 参数2 参数N</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221906.png" alt="image-20221027221906247"></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p>
<ul>
<li>-z表示使用gzip，可以省略</li>
<li>-C，单独使用，和解压所需的其他参数分开，可以省略，指定要解压去的地方，不写解压到当前目录</li>
</ul>
<p><code>unzip [-d] 参数</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027221939.png" alt="image-20221027221939899"></p>
<h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p>
<p>语法：<code>su [-] [用户]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222021.png" alt="image-20221027222021619"></p>
<h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222035.png" alt="image-20221027222035337"></p>
<p>比如：<code>visudo</code>/<code>vi etc/sudoers</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure>
<p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p>
<h1 id="Linux权限"><a href="#Linux权限" class="headerlink" title="Linux权限"></a>Linux权限</h1><h2 id="权限细节"><a href="#权限细节" class="headerlink" title="权限细节"></a>权限细节</h2><p>通过ll可以以列表形式查看内容，并显示权限细节</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240122191602163.png" alt="image-20240122191602163"></p>
<ul>
<li>序号1，表示文件、文件夹的权限控制信息</li>
<li>序号2，表示文件、文件夹所属用户</li>
<li>序号3，表示文件、文件夹所属用户组</li>
</ul>
<p>权限细节总分为10个槽位</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240122185715761.png" alt="image-20240122185715761"></p>
<ul>
<li>rwx</li>
</ul>
<p>r表示读权限<br>w表示写权限<br>x表示执行权限</p>
<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>
<p>r：针对文件可以查看文件内容<br>     针对文件夹，可以查看文件夹内容，如ls命令</p>
<p>w：针对文件表示可以修改此文件<br>      针对文件夹，可以在文件夹内:创建、删除、改名等操作</p>
<p>x，针对文件表示可以将文件作为程序执行<br>      针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</p>
<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>修改文件、文件夹权限</p>
<p>语法：<code>chmod [-R] 权限 参数</code></p>
<ul>
<li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222157.png" alt="image-20221027222157276"></p>
</li>
<li><p>参数，被修改的文件、文件夹</p>
</li>
<li><p>选项-R，设置文件夹和其内部全部内容一样生效</p>
</li>
</ul>
<p>示例：</p>
<ul>
<li><code>chmod u=rwx,g=rx,o=x hello.txt</code>，将文件权限修改为:rwxr-x—x<ul>
<li>其中:u表示user所属用户权限,g表示group组权限,o表示other其它用户权限</li>
</ul>
</li>
<li><code>chmod -R u=rwx,g=rx,o=x test</code>,将文件夹test以及文件夹内全部内容权限设置为: rwxr-x—x</li>
</ul>
<p>快捷写法：</p>
<p>权限可以用3位数字来代表，第一位数字表示用户权限，第二位表示用户组权限，第三位表示其它用户权限。</p>
<ul>
<li><code>chmod 751 hello.txt</code>,将文件权限修改为:rwxr-x—x</li>
</ul>
<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p>
<p>普通用户无法修改所属为其它用户或组,所以此命令只适用于root用户执行</p>
<p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222326.png" alt="image-20221027222326192"></p>
<h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222354.png" alt="image-20221027222354498"></p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222407.png" alt="image-20221027222407618"></p>
<h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul>
<li><p><code>getenv group</code>，查看系统全部的用户组</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222446.png" alt="image-20221027222446514"></p>
<p>共有3份信息，分别是：</p>
<p>​    组名称:组认证(显示为x):组ID</p>
</li>
<li><p><code>getenv passwd</code>，查看系统全部的用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/20221027222512.png" alt="image-20221027222512274"></p>
</li>
</ul>
<p>共有7份信息，分别是：</p>
<p>​    用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p>
<h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p>
<p>语法：<code>env</code></p>
<h1 id="linux项目部署"><a href="#linux项目部署" class="headerlink" title="linux项目部署"></a>linux项目部署</h1><h2 id="1-手动部署"><a href="#1-手动部署" class="headerlink" title="1.手动部署"></a>1.手动部署</h2><ol>
<li>在IDEA中开发springboot项目并打成jar包</li>
<li>将jar包上传到linux服务器</li>
<li><code>java -jar xxx.jar</code>启动springboot程序</li>
<li>关闭防火墙</li>
</ol>
<ul>
<li>注意：改为后台运行SpringBoot程序，并将日志输出到日志文件</li>
</ul>
<p>目前程序运行的问题<br>    线上程序不会采用控制台霸屏的形式运行程序，而是将程序在后台运行<br>    线上程序不会将日志输出到控制台，而是输出到日志文件，方便运维查阅信息</p>
<p><code>nohup</code> 命令: 英文全称 no hang up (不挂起) ，用于不挂断地运行指定命令，退出终端不会影响程序的运行</p>
<p>语法格式: <code>nohup Command [Arg ...] [&amp;]</code></p>
<p>参数说明:</p>
<ul>
<li>Command:要执行的命令</li>
<li>Arg:一些参数，可以指定输出文件</li>
<li>&amp;: 让命令在后台运行</li>
</ul>
<p>举例:</p>
<p><code>nohup java -jar boot工程.jar &amp;&gt; hello.log &amp;</code>： 后台运行iava -jar命令，并将日志输出到hello.log文件、、</p>
<p>停止springboot进程</p>
<p>1.<code>ps -ef | grep java -jar</code>：找出进程</p>
<p>2.<code>kill -9 35685</code>：杀死进程</p>
<h2 id="2-通过shell脚本自动部署项目"><a href="#2-通过shell脚本自动部署项目" class="headerlink" title="2.通过shell脚本自动部署项目"></a>2.通过shell脚本自动部署项目</h2><p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240218162325439.png" alt="image-20240218162325439"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus</title>
    <url>//MyBatisPlus.html</url>
    <content><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><h1 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h1><p>比如我们要实现User表的CRUD，只需要下面几步：</p>
<ul>
<li>引入MybatisPlus依赖</li>
<li>定义Mapper</li>
</ul>
<h2 id="1-1引入依赖"><a href="#1-1引入依赖" class="headerlink" title="1.1引入依赖"></a><strong>1.1引入依赖</strong></h2><p>MybatisPlus提供了starter，实现了自动Mybatis以及MybatisPlus的自动装配功能，坐标如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于这个starter包含对mybatis的自动装配，因此完全可以替换掉Mybatis的starter。 最终，项目的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-定义Mapper"><a href="#1-2-定义Mapper" class="headerlink" title="1.2.定义Mapper"></a><strong>1.2.定义Mapper</strong></h2><p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066927528932.png" alt="img"></p>
<p>因此我们自定义的Mapper只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。 修改mp-demo中的<code>com.itheima.mp.mapper</code>包下的<code>UserMapper</code>接口，让其继承<code>BaseMapper</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066927528921.png" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-常见注解"><a href="#1-3-常见注解" class="headerlink" title="1.3.常见注解"></a>1.3.常见注解</h2><p>MybatisPlus中比较常用的几个注解如下</p>
<ul>
<li>@TableName:用来指定表名</li>
<li>@Tableld:用来指定表中的主键字段信息</li>
<li>@TableField:用来指定表中的普通字段信息</li>
</ul>
<p>数据库表为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240130230037015.png" alt="image-20240130230037015"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId( value= &quot;id&quot;，type= IdType.AUTO )</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@TableField(&quot;is_married&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;`order`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer order;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span>  <span class="comment">//没有字段</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ldType枚举：</p>
<ul>
<li>AUTO : 数据库自增长</li>
<li>INPUT : 通过set方法自行输入</li>
<li>ASSIGN_ID:分配ID，接口ldentifierGenerator的方法nextld来生成id</li>
<li>默认实现类为DefaultldentifierGenerator雪花算法</li>
</ul>
<p>使用@TableField的常见场景 :</p>
<ul>
<li>成员变量名与数据库字段名不一致</li>
<li>成员变量名以is开头，且是布尔值</li>
<li>成员变量名与数据库关键字冲突</li>
<li>成员变量不是数据库字段</li>
</ul>
<h2 id="1-4-常见配置"><a href="#1-4-常见配置" class="headerlink" title="1.4.常见配置"></a><strong>1.4.常见配置</strong></h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：</p>
<p><a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE</a></p>
<p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p>
<ul>
<li>实体类的别名扫描包</li>
<li>全局id类型</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure>
<p>可以看到默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。</p>
<p>例如，我们新建一个<code>UserMapper.xml</code>文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068642581453.png" alt="img"></p>
<p>然后在其中定义一个方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mp.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在测试类<code>UserMapperTest</code>中测试该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.queryById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-核心功能"><a href="#2-核心功能" class="headerlink" title="2.核心功能"></a>2.核心功能</h1><h2 id="2-1-条件构造器"><a href="#2-1-条件构造器" class="headerlink" title="2.1.条件构造器"></a><strong>2.1.条件构造器</strong></h2><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066305900691.png" alt="img"></p>
<p>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066929044535.png" alt="img"></p>
<p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066929044536.png" alt="img"></p>
<p>而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066929044537.png" alt="img"></p>
<p>而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066929044538.png" alt="img"></p>
<p>接下来，我们就来看看如何利用<code>Wrapper</code>实现复杂查询。</p>
<h3 id="2-1-1-QueryWrapper"><a href="#2-1-1-QueryWrapper" class="headerlink" title="2.1.1.QueryWrapper"></a><strong>2.1.1.QueryWrapper</strong></h3><p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： <strong>查询</strong>：查询出名字中带<code>o</code>的，存款大于等于1000元的人。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">            .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更新</strong>：更新用户名为jack的用户的余额为2000，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.更新数据，user中非null字段都会作为set语句</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    userMapper.update(user, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-UpdateWrapper"><a href="#2-1-2-UpdateWrapper" class="headerlink" title="2.1.2.UpdateWrapper"></a><strong>2.1.2.UpdateWrapper</strong></h3><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对应的SQL应该是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UPDATE user <span class="type">SET</span> <span class="variable">balance</span> <span class="operator">=</span> balance - <span class="number">200</span> WHERE id <span class="title function_">in</span> <span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure>
<p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-LambdaQueryWrapper"><a href="#2-1-3-LambdaQueryWrapper" class="headerlink" title="2.1.3.LambdaQueryWrapper"></a><strong>2.1.3.LambdaQueryWrapper</strong></h3><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串<code>魔法值</code>。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？</p>
<p>其中一种办法是基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的<code>方法引用</code>和<code>Lambda</code>表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p>
<ul>
<li>LambdaQueryWrapper</li>
<li>LambdaUpdateWrapper</li>
</ul>
<p>分别对应QueryWrapper和UpdateWrapper</p>
<p>其使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-自定义-SQL"><a href="#2-2-自定义-SQL" class="headerlink" title="2.2.自定义**SQL**"></a><strong>2.2.自定义**</strong>SQL**</h2><p>在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066929044539.png" alt="img"></p>
<p>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。</p>
<p>所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL</p>
<h3 id="2-2-1-基本用法"><a href="#2-2-1-基本用法" class="headerlink" title="2.2.1.基本用法"></a><strong>2.2.1.基本用法</strong></h3><p>以当前案例来说，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义SQL，用Param注解声明Wrapper变量,必须是ew：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就省去了编写复杂查询条件的烦恼了。</p>
<h3 id="2-2-2-多表关联"><a href="#2-2-2-多表关联" class="headerlink" title="2.2.2.多表关联"></a><strong>2.2.2.多表关联</strong></h3><p>理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">      SELECT *</span><br><span class="line">      FROM user u</span><br><span class="line">      INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">      WHERE u.id</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      AND a.city = #&#123;city&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。</p>
<p>但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。</p>
<p>查询条件这样来构建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-Service接口"><a href="#2-3-Service接口" class="headerlink" title="2.3.Service接口"></a><strong>2.3.Service接口</strong></h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p>
<ul>
<li><code>save</code>：新增</li>
<li><code>remove</code>：删除</li>
<li><code>update</code>：更新</li>
<li><code>get</code>：查询单个结果</li>
<li><code>list</code>：查询集合结果</li>
<li><code>count</code>：计数</li>
<li><code>page</code>：分页查询</li>
</ul>
<h3 id="2-3-1-CRUD"><a href="#2-3-1-CRUD" class="headerlink" title="2.3.1.CRUD"></a>2.3.1.CRUD</h3><p>我们先俩看下基本的CRUD接口。 <strong>新增</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457677.png" alt="img"></p>
<ul>
<li><code>save</code>是新增单个元素</li>
<li><code>saveBatch</code>是批量新增</li>
<li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li>
<li><code>saveOrUpdateBatch</code>是批量的新增或修改</li>
</ul>
<p><strong>删除：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457661.png" alt="img"></p>
<ul>
<li><code>removeById</code>：根据id删除</li>
<li><code>removeByIds</code>：根据id批量删除</li>
<li><code>removeByMap</code>：根据Map中的键值对为条件删除</li>
<li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li>
<li><code>~~removeBatchByIds~~</code>：暂不支持</li>
</ul>
<p><strong>修改：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457662.png" alt="img"></p>
<ul>
<li><code>updateById</code>：根据id修改</li>
<li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li>
<li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li>
<li><code>updateBatchById</code>：根据id批量修改</li>
</ul>
<p><strong>Get：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457673.png" alt="img"></p>
<ul>
<li><code>getById</code>：根据id查询1条数据</li>
<li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li>
<li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li>
</ul>
<p><strong>List：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457674.png" alt="img"></p>
<ul>
<li><code>listByIds</code>：根据id批量查询</li>
<li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li>
<li><code>list()</code>：查询所有</li>
</ul>
<p><strong>Count</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457675.png" alt="img"></p>
<ul>
<li><code>count()</code>：统计所有数量</li>
<li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li>
</ul>
<p><strong>getBaseMapper</strong>： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17066946457676.png" alt="img"></p>
<h3 id="2-3-2-基本用法"><a href="#2-3-2-基本用法" class="headerlink" title="2.3.2.基本用法"></a>2.3.2.基本用法</h3><p>一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：</p>
<ul>
<li>根据id扣减用户余额</li>
</ul>
<p>这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：</p>
<ul>
<li>判断用户状态是否正常</li>
<li>判断用户余额是否充足</li>
</ul>
<p>这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。</p>
<p>首先在UserController中定义一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;扣减用户余额&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;money&quot;)</span>Integer money)</span>&#123;</span><br><span class="line">    userService.deductBalance(id, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是UserService接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是UserServiceImpl实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.判断用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断用户余额</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额</span></span><br><span class="line">        baseMapper.deductMoneyById(id, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是mapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deductMoneyById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-Lambda"><a href="#2-3-3-Lambda" class="headerlink" title="2.3.3.Lambda"></a><strong>2.3.3.Lambda</strong></h3><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。</p>
<p>案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：</p>
<ul>
<li>name：用户名关键字，可以为空</li>
<li>status：用户状态，可以为空</li>
<li>minBalance：最小余额，可以为空</li>
<li>maxBalance：最大余额，可以为空</li>
</ul>
<p>可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。</p>
<p>我们首先需要定义一个查询条件实体，UserQuery实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们在UserController中定义一个controller方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组织查询条件的时候，我们加入了 <code>username != null</code> 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<code>&lt;if&gt;</code>标签。这样就实现了动态查询条件效果了。</p>
<p>不过，上述条件构建的代码太麻烦了。 因此Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p>
<p>基于Lambda查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：</p>
<ul>
<li><code>.one()</code>：最多1个结果</li>
<li><code>.list()</code>：返回集合结果</li>
<li><code>.count()</code>：返回计数结果</li>
</ul>
<p>MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。</p>
<p>与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。</p>
<p>例如下面的需求：</p>
<blockquote>
<p>需求：改造根据id修改用户余额的接口，要求如下</p>
<ul>
<li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li>
</ul>
</blockquote>
<p>也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-批量新增"><a href="#2-3-4-批量新增" class="headerlink" title="2.3.4.批量新增"></a><strong>2.3.4.批量新增</strong></h3><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">buildUser</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;&quot;</span> + (<span class="number">18688190000L</span> + i));</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(user.getCreateTime());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17067950801264.png" alt="img"></p>
<p>可以看到速度非常慢。</p>
<p>然后再试试MybatisPlus的批处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备10万条数据</span></span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        list.add(buildUser(i));</span><br><span class="line">        <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行最终耗时如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17067950801241.png" alt="img"></p>
<p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p>
<p>不过，我们简单查看一下<code>MybatisPlus</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure>
<p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure>
<p>该怎么做呢？</p>
<p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p>
<p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p>
<p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure>
<p>再次测试插入10万条数据，可以发现速度有非常明显的提升：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17067950801242.png" alt="img"></p>
<p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：</p>
<p>最终，SQL被重写了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17067950801243.png" alt="img"></p>
<h1 id="3-扩展功能"><a href="#3-扩展功能" class="headerlink" title="3.扩展功能"></a><strong>3.扩展功能</strong></h1><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1.代码生成"></a><strong>3.1.代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p>
<p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p>
<h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392257.png" alt="img"></p>
<p>然后重启你的Idea即可使用。</p>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392171.png" alt="img"></p>
<p>在弹出的窗口中填写数据库连接的基本信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392172.png" alt="img"></p>
<p>点击OK保存。</p>
<p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392183.png" alt="img"></p>
<p>在弹出的表单中填写信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392184.png" alt="img"></p>
<p>最终，代码自动生成到指定的位置了：</p>
<h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392185.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Db.getById(<span class="number">1L</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 利用Db实现复杂条件查询</span></span><br><span class="line">    List&lt;User&gt; list = Db.lambdaQuery(User.class)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">            .list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表</p>
<p>首先，我们要添加一个收货地址的VO对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;收货地址VO&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressVO</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;省&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;市&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;县/区&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String town;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;详细地址&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;联系人&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否是默认 1默认 0否&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isDefault;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;备注&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String notes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，改造原来的UserVO，添加一个地址属性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068008392186.png" alt="img"></p>
<p>接下来，修改UserController中根据id查询用户的业务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">    <span class="comment">// 基于自定义service方法查询</span></span><br><span class="line">    <span class="keyword">return</span> userService.queryUserAndAddressById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在UserServiceImpl中实现该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询收货地址</span></span><br><span class="line">    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)</span><br><span class="line">            .eq(Address::getUserId, userId)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));</span><br><span class="line">    <span class="keyword">return</span> userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p>
<p>再来实现一个功能：</p>
<ul>
<li>根据id批量查询用户，并查询出用户对应的所有地址</li>
</ul>
<h2 id="3-3-逻辑删除"><a href="#3-3-逻辑删除" class="headerlink" title="3.3.逻辑删除"></a><strong>3.3.逻辑删除</strong></h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p>
<ul>
<li>在表中添加一个字段标记数据是否被删除</li>
<li>当删除数据时把标记置为true</li>
<li>查询时过滤掉标记为true的数据</li>
</ul>
<p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。</p>
<p>为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。</p>
<p><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。</p>
<p>例如，我们给<code>address</code>表添加一个逻辑删除字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address <span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后给<code>Address</code>实体添加<code>deleted</code>字段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068033996523.png" alt="img"></p>
<p>接下来，我们要在<code>application.yml</code>中配置逻辑删除字段：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure>
<p>测试： 首先，我们执行一个删除操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法与普通删除一模一样，但是底层的SQL逻辑变了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068033996511.png" alt="img"></p>
<p>查询一下试试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068033996512.png" alt="img"></p>
<p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p>
<p><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p>
<ul>
<li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li>
<li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li>
</ul>
<p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p>
<h2 id="3-3-通用枚举"><a href="#3-3-通用枚举" class="headerlink" title="3.3.通用枚举"></a><strong>3.3.通用枚举</strong></h2><p>User类中有一个用户状态字段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857915.png" alt="img"></p>
<p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p>
<p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p>
<h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685751.png" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把<code>User</code>类中的<code>status</code>字段改为<code>UserStatus</code> 类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685752.png" alt="img"></p>
<p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685753.png" alt="img"></p>
<h3 id="3-3-2-配置枚举处理器"><a href="#3-3-2-配置枚举处理器" class="headerlink" title="3.3.2.配置枚举处理器"></a><strong>3.3.2.配置枚举处理器</strong></h3><p>在application.yaml文件中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a><strong>3.3.3.测试</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = userService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685754.png" alt="img"></p>
<p>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685755.png" alt="img"></p>
<p>并且，在UserStatus枚举中通过<code>@JsonValue</code>注解标记JSON序列化时展示的字段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685756.png" alt="img"></p>
<p>最后，在页面查询，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685767.png" alt="img"></p>
<h2 id="3-4-JSON-类型处理器"><a href="#3-4-JSON-类型处理器" class="headerlink" title="3.4.**JSON**类型处理器"></a><strong>3.4.**</strong>JSON<strong>**类型处理器</strong></h2><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685768.png" alt="img"></p>
<p>格式像这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>而目前<code>User</code>实体类中却是<code>String</code>类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068640685769.png" alt="img"></p>
<p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p>
<p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p>
<p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p>
<p>接下来，我们就来看看这个处理器该如何使用。</p>
<h3 id="3-4-1-定义实体"><a href="#3-4-1-定义实体" class="headerlink" title="3.4.1.定义实体"></a><strong>3.4.1.定义实体</strong></h3><p>首先，我们定义一个单独实体类来与info字段的属性匹配：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857610.png" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-使用类型处理器"><a href="#3-4-2-使用类型处理器" class="headerlink" title="3.4.2.使用类型处理器"></a><strong>3.4.2.使用类型处理器</strong></h3><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857611.png" alt="img"></p>
<p>测试可以发现，所有数据都正确封装到UserInfo当中了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857612.png" alt="img"></p>
<p>同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857613.png" alt="img"></p>
<p>此时，在页面查询结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170686406857614.png" alt="img"></p>
<h1 id="4-插件功能"><a href="#4-插件功能" class="headerlink" title="4.插件功能"></a><strong>4.插件功能</strong></h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p>
<ul>
<li><code>PaginationInnerInterceptor</code>：自动分页</li>
<li><code>TenantLineInnerInterceptor</code>：多租户</li>
<li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li>
<li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li>
<li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li>
<li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li>
</ul>
<p><strong>注意：</strong> 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p>
<ul>
<li>多租户,动态表名</li>
<li>分页,乐观锁</li>
<li>sql 性能规范,防止全表更新与删除</li>
</ul>
<p>这里我们以分页插件为里来学习插件的用法。</p>
<h2 id="4-1-分页插件"><a href="#4-1-分页插件" class="headerlink" title="4.1.分页插件"></a><strong>4.1.分页插件</strong></h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。 所以，我们必须配置分页插件。</p>
<h3 id="4-1-1-配置分页插件"><a href="#4-1-1-配置分页插件" class="headerlink" title="4.1.1.配置分页插件"></a><strong>4.1.1.配置分页插件</strong></h3><p>在项目中新建一个配置类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147617.png" alt="img"></p>
<p>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-分页-API"><a href="#4-1-2-分页-API" class="headerlink" title="4.1.2.分页**API**"></a><strong>4.1.2.分页**</strong>API**</h3><p>编写一个分页查询的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的SQL如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147561.png" alt="img"></p>
<p>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure>
<h2 id="4-2-通用分页实体"><a href="#4-2-通用分页实体" class="headerlink" title="4.2.通用分页实体"></a><strong>4.2.通用分页实体</strong></h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>/users/page</td>
</tr>
<tr>
<td>请求参数</td>
<td><code>&#123;    &quot;pageNo&quot;: 1,    &quot;pageSize&quot;: 5,    &quot;sortBy&quot;: &quot;balance&quot;,    &quot;isAsc&quot;: false,    &quot;name&quot;: &quot;o&quot;,    &quot;status&quot;: 1 &#125;</code></td>
</tr>
<tr>
<td>返回值</td>
<td><code>&#123;    &quot;total&quot;: 100006,    &quot;pages&quot;: 50003,    &quot;list&quot;: [        &#123;            &quot;id&quot;: 1685100878975279298,            &quot;username&quot;: &quot;user_9****&quot;,            &quot;info&quot;: &#123;                &quot;age&quot;: 24,                &quot;intro&quot;: &quot;英文老师&quot;,                &quot;gender&quot;: &quot;female&quot;            &#125;,            &quot;status&quot;: &quot;正常&quot;,            &quot;balance&quot;: 2000        &#125;    ] &#125;</code></td>
</tr>
<tr>
<td>特殊说明</td>
<td>如果排序字段为空，默认按照更新时间排序排序字段不为空，则按照排序字段排序</td>
</tr>
</tbody>
</table>
</div>
<p>这里需要定义3个实体：</p>
<ul>
<li><code>UserQuery</code>：分页查询条件的实体，包含分页、排序参数、过滤条件</li>
<li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li>
<li><code>UserVO</code>：用户页面视图实体</li>
</ul>
<h3 id="4-2-1-实体"><a href="#4-2-1-实体" class="headerlink" title="4.2.1.实体"></a><strong>4.2.1.实体</strong></h3><p>由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个<code>PageQuery</code>实体：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147562.png" alt="img"></p>
<p><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p>
<ul>
<li><code>pageNo</code>：页码</li>
<li><code>pageSize</code>：每页数据条数</li>
<li><code>sortBy</code>：排序字段</li>
<li><code>isAsc</code>：是否升序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，让我们的UserQuery继承这个实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> <span class="keyword">extends</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值的用户实体沿用之前定一个<code>UserVO</code>实体：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147563.png" alt="img"></p>
<p>最后，则是分页实体PageDTO:</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147564.png" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页结果&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总页数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;集合&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-开发接口"><a href="#4-2-2-开发接口" class="headerlink" title="4.2.2.开发接口"></a><strong>4.2.2.开发接口</strong></h3><p>我们在<code>UserController</code>中定义分页查询用户的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.dto.PageDTO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.query.PageQuery;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryUsersPage(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 。。。 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>IUserService</code>中创建<code>queryUsersPage</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(PageQuery query)</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，在UserServiceImpl中实现该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    <span class="comment">// 1.1.分页条件</span></span><br><span class="line">    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">    <span class="comment">// 1.2.排序条件</span></span><br><span class="line">    <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.数据非空校验</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.有数据，转换</span></span><br><span class="line">    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">    <span class="comment">// 5.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动项目，在页面查看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147565.png" alt="img"></p>
<h3 id="4-2-3-改造PageQuery实体"><a href="#4-2-3-改造PageQuery实体" class="headerlink" title="4.2.3.改造PageQuery实体"></a><strong>4.2.3.改造PageQuery实体</strong></h3><p>在刚才的代码中，从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦的。</p>
<p>我们完全可以在<code>PageQuery</code>这个实体中定义一个工具方法，简化开发。 像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在开发也时就可以省去对从<code>PageQuery</code>到<code>Page</code>的的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建条件</span></span><br><span class="line">Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-改造PageDTO实体"><a href="#4-2-4-改造PageDTO实体" class="headerlink" title="4.2.4.改造PageDTO实体"></a><strong>4.2.4.改造PageDTO实体</strong></h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。</p>
<p>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，业务层的代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是希望自定义PO到VO的转换过程，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终查询的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17068679147566.png" alt="img"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MyBatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>//linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<h1 id="实战章节：在Linux上部署各类软件"><a href="#实战章节：在Linux上部署各类软件" class="headerlink" title="实战章节：在Linux上部署各类软件"></a>实战章节：在Linux上部署各类软件</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么学习各类软件在Linux上的部署"><a href="#为什么学习各类软件在Linux上的部署" class="headerlink" title="为什么学习各类软件在Linux上的部署"></a>为什么学习各类软件在Linux上的部署</h2><p>在前面，我们学习了许多的Linux命令和高级技巧，这些知识点比较零散，同学们跟随着课程的内容进行练习虽然可以基础掌握这些命令和技巧的使用，但是并没有一些具体的实操能够串联起来这些知识点。</p>
<p>所以，现在我们设计了各类软件在Linux上部署安装的实战章节，可以让同学们：</p>
<ul>
<li>对前面学习的各类操作命令进行复习和练习，从而深度掌握它们</li>
<li>本章节中演示部署的软件，包含了IT行业各类岗位中所必须使用的，如：Java后台、大数据开发、运维开发、测试、AI等。无论学习Linux后从事什么岗位，这些内容都会给你带来帮助</li>
</ul>
<blockquote>
<p>对于零基础学员，实战课程中所讲解的软件大概率多数大家并不了解。</p>
<p>所以，课程仅涉及到安装部署，不对软件的使用做详细说明。</p>
<p>同学们在这个过程中，可能会遇到各种各样的错误，<code>不要怕</code>，解决它，将会给你带来极大的提升。</p>
</blockquote>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>对于本部分的内容学习，我们设计两个目标：</p>
<ul>
<li><p>对于零基础或未从业的学员，不要求深入理解所安装部署的软件是什么，仅仅能够跟随课程成功的将其部署安装并运行成功即可</p>
<p>在这个过程中，主要锻炼大家对Linux操作系统的熟练度，此乃零基础未从业学员的第一学习目标</p>
</li>
<li><p>对于有基础或已从业的学员，本章节讲解的软件涵盖了大多数IT从业者所能接触到的，特别是大数据开发、后端开发两个主流方向，可以作为参考资料，以便在工作中有所帮助。</p>
</li>
</ul>
<p>本章节内的各类软件安装，==不强制要求全部学习==</p>
<ol>
<li>零基础学员，建议全部学习，作为前面学习内容的总结和实战</li>
<li>IT从业者、有经验学员，可以按需选择，选择工作中需要用到的进行学习</li>
</ol>
<blockquote>
<p>章节内包含的软件并非100%涵盖了IT开发领域中所需要的内容。</p>
<p>如果您对某些软件的安装有强烈需求，且课程中没有提供教程，可以私信B站：”黑马大数据曹老师”，老师会酌情根据时间安排补充上去哦。</p>
</blockquote>
<h2 id="为什么不使用PPT而是使用文档进行授课"><a href="#为什么不使用PPT而是使用文档进行授课" class="headerlink" title="为什么不使用PPT而是使用文档进行授课"></a>为什么不使用PPT而是使用文档进行授课</h2><p>从现在开始，将要进入到Linux的实操阶段，在这个阶段我们将会涉及到非常多的软件部署等操作，涉及到：</p>
<ul>
<li>各类命令的使用</li>
<li>各种过程的结果</li>
<li>复杂的流程步骤</li>
<li>等</li>
</ul>
<p>这些信息的展示，并不适合于使用PPT作为载体进行授课，所以从现在开始我们将使用操作文档的模式为大家进行讲解。</p>
<blockquote>
<p>使用文档模式还有一个好处，除了学习视频以外，拿到课程中使用的操作文档，同样可以作为重要的参考手册进行使用。</p>
<p>一举两得</p>
</blockquote>
<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><ol>
<li>实战章节要求同学们==务必全部学习前面的知识点==，即：初识Linux、Linux基础命令、Linux权限管理、Linux高阶技巧这4个章节，请勿跳过前面的章节学习实战章节。</li>
<li>实战章节中会开启多台虚拟机，请尽量确保电脑的内存在：8GB（包含8GB）以上。如内存不足可以扩充内存条或购买阿里云、UCloud等云服务器临时使用（1个月多台低配服务器几十块左右）</li>
</ol>
<blockquote>
<p>对于云平台上购买服务器，可以参阅最后的章节（云服务）</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>下面全部的软件安装的相关流程，90%都是取自软件自身的官方网站。</p>
<p>一个合格的程序员要有良好的信息收集能力哦</p>
<h1 id="MySQL数据库管理系统安装部署【简单】"><a href="#MySQL数据库管理系统安装部署【简单】" class="headerlink" title="MySQL数据库管理系统安装部署【简单】"></a>MySQL数据库管理系统安装部署【简单】</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL数据库管理系统（后续简称MySQL），是一款知名的数据库系统，其特点是：轻量、简单、功能丰富。</p>
<p>MySQL数据库可谓是软件行业的明星产品，无论是后端开发、大数据、AI、运维、测试等各类岗位，基本上都会和MySQL打交道。</p>
<p>让我们从MySQL开始，进行实战的Linux软件安装部署。</p>
<p>本次课程分为2个版本进行安装：</p>
<ul>
<li>MySQL 5.7版本安装</li>
<li>MySQL 8.x版本安装</li>
</ul>
<blockquote>
<p>由于MySQL5.x和8.x各自有许多使用者，所以这两个版本我们都演示安装一遍</p>
</blockquote>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>MySQL的安装过程中，除了会使用Linux命令外，还会使用到少量的数据库专用的：SQL语句</p>
<p>对于SQL语句我们并未涉及，所以可以跟随教程的内容，复制粘贴即可</p>
<p>如对MySQL感兴趣，可以学习BiliBili黑马程序员视频：<a href="https://www.bilibili.com/video/BV1iF411z7Pu">2022新版黑马程序员MySQL知识精讲+mysql实战案例_零基础mysql数据库入门到高级全套教程</a></p>
<blockquote>
<p>如有时间，建议可以在学习完Linux系统之后，学习一下MySQL数据库</p>
<p>无论从事什么方面的开发，Java后端、大数据、AI、前端、Linux运维等，都会要求掌握MySQL数据库的</p>
<p>可以说，MySQL是IT开发从业者必备的技能了。</p>
</blockquote>
<h2 id="MySQL5-7版本在CentOS系统安装"><a href="#MySQL5-7版本在CentOS系统安装" class="headerlink" title="MySQL5.7版本在CentOS系统安装"></a>MySQL5.7版本在CentOS系统安装</h2><blockquote>
<p>注意：安装操作需要root权限</p>
</blockquote>
<p>MySQL的安装我们可以通过前面学习的yum命令进行。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>配置yum仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新密钥</span></span><br><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装Mysql yum库</span></span><br><span class="line">rpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012182514.png" alt="image-20221012182514865"></p>
<blockquote>
<p>由于MySQL并不在CentOS的官方仓库中，所以我们通过上述rpm命令：</p>
<ul>
<li>导入MySQL仓库的密钥</li>
<li>配置MySQLQ的yum仓库</li>
</ul>
</blockquote>
</li>
<li><p>使用yum安装MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum安装Mysql</span></span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012182556.png" alt="image-20221012182555420"></p>
</li>
<li><p>安装完成后，启动MySQL并配置开机自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld		# 启动</span><br><span class="line">systemctl enable mysqld		# 开机自启</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL安装完成后，会自动配置为名称叫做：<code>mysqld</code>的服务，可以被systemctl所管理</p>
</blockquote>
</li>
<li><p>检查MySQL的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012182716.png" alt="image-20221012182716598"></p>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>主要配置管理员用户root的密码以及配置允许远程登录的权限。</p>
<ol>
<li><p>获取MySQL的初始密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过grep命令，在/var/log/mysqld.log文件中，过滤temporary password关键字，得到初始密码</span></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012182744.png" alt="image-20221012182744115"></p>
</li>
<li><p>登陆MySQL数据库系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u，登陆的用户，MySQL数据库的管理员用户同Linux一样，是root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p，表示使用密码登陆</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行完毕后输入刚刚得到的初始密码，即可进入MySQL数据库</span></span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012182806.png" alt="image-20221012182805966"></p>
</li>
<li><p>修改root用户密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在MySQL控制台内执行</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;	<span class="comment">-- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[扩展]，配置root的简单密码</p>
<blockquote>
<p>我们可以给root设置简单密码，如123456.</p>
<p>请注意，此配置仅仅是用于测试环境或学习环境的MySQL，如果是正式使用，请勿设置简单密码</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 如果你想设置简单密码，需要降低Mysql的密码安全级别</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span>LOW; # 密码安全级别低</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">4</span>;	 # 密码长度最低<span class="number">4</span>位即可</span><br><span class="line"></span><br><span class="line"># 然后就可以用简单密码了（课程中使用简单密码，为了方便，生产中不要这样）</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;简单密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[扩展]，配置root运行远程登录</p>
<blockquote>
<p>默认情况下，root用户是不运行远程登录的，只允许在MySQL所在的Linux服务器登陆MySQL系统</p>
<p>请注意，允许root远程登录会带来安全风险</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 授权root远程登录</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> root@&quot;IP地址&quot; identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;  </span><br><span class="line"># IP地址即允许登陆的IP地址，也可以填写<span class="operator">%</span>，表示允许任何地址</span><br><span class="line"># 密码表示给远程登录独立设置密码，和本地登陆的密码可以不同</span><br><span class="line"></span><br><span class="line"># 刷新权限，生效</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出MySQL控制台页面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 退出命令</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 或者通过快捷键退出：ctrl <span class="operator">+</span> d</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查端口</p>
<p>MySQL默认绑定了3306端口，可以通过端口占用检查MySQL的网络状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012183746.png" alt="image-20221012183746802"></p>
</li>
</ol>
<p>至此，MySQL就安装完成并可用了，请妥善保存好MySQL的root密码。</p>
<h2 id="MySQL8-0版本在CentOS系统安装"><a href="#MySQL8-0版本在CentOS系统安装" class="headerlink" title="MySQL8.0版本在CentOS系统安装"></a>MySQL8.0版本在CentOS系统安装</h2><blockquote>
<p>注意：安装操作需要root权限</p>
</blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>配置yum仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新密钥</span></span><br><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装Mysql8.x版本 yum库</span></span><br><span class="line">rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用yum安装MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum安装Mysql</span></span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，启动MySQL并配置开机自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld		# 启动</span><br><span class="line">systemctl enable mysqld		# 开机自启</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL安装完成后，会自动配置为名称叫做：<code>mysqld</code>的服务，可以被systemctl所管理</p>
</blockquote>
</li>
<li><p>检查MySQL的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>主要修改root密码和允许root远程登录</p>
<ol>
<li><p>获取MySQL的初始密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过grep命令，在/var/log/mysqld.log文件中，过滤temporary password关键字，得到初始密码</span></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录MySQL数据库系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u，登陆的用户，MySQL数据库的管理员用户同Linux一样，是root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p，表示使用密码登陆</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行完毕后输入刚刚得到的初始密码，即可进入MySQL数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改root密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;	<span class="comment">-- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[扩展]，配置root的简单密码</p>
<blockquote>
<p>我们可以给root设置简单密码，如123456.</p>
<p>请注意，此配置仅仅是用于测试环境或学习环境的MySQL，如果是正式使用，请勿设置简单密码</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy<span class="operator">=</span><span class="number">0</span>;		# 密码安全级别低</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.length<span class="operator">=</span><span class="number">4</span>;		# 密码长度最低<span class="number">4</span>位即可</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>允许root远程登录，并设置远程登录密码</p>
<blockquote>
<p>默认情况下，root用户是不运行远程登录的，只允许在MySQL所在的Linux服务器登陆MySQL系统</p>
<p>请注意，允许root远程登录会带来安全风险</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 第一次设置root远程登录，并配置远程密码使用如下<span class="keyword">SQL</span>命令</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;密码!&#x27;</span>;	<span class="comment">-- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc</span></span><br><span class="line"></span><br><span class="line"># 后续修改密码使用如下<span class="keyword">SQL</span>命令</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出MySQL控制台页面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 退出命令</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 或者通过快捷键退出：ctrl <span class="operator">+</span> d</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查端口</p>
<p>MySQL默认绑定了3306端口，可以通过端口占用检查MySQL的网络状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/12/20221012192303.png" alt="image-20221012192303607"></p>
</li>
</ol>
<p>至此，MySQL就安装完成并可用了，请妥善保存好MySQL的root密码。</p>
<h2 id="MySQL5-7版本在Ubuntu（WSL环境）系统安装"><a href="#MySQL5-7版本在Ubuntu（WSL环境）系统安装" class="headerlink" title="MySQL5.7版本在Ubuntu（WSL环境）系统安装"></a>MySQL5.7版本在Ubuntu（WSL环境）系统安装</h2><blockquote>
<p>课程中配置的WSL环境是最新的Ubuntu22.04版本，这个版本的软件商店内置的MySQL是8.0版本</p>
<p>所以我们需要额外的步骤才可以安装5.7版本的MySQL</p>
</blockquote>
<p>安装操作需root权限，你可以：</p>
<ol>
<li><p>通过 sudo su -，切换到root用户</p>
<blockquote>
<p>课程中选择这种方式操作</p>
</blockquote>
</li>
<li><p>或在每一个命令前，加上sudo，用来临时提升权限</p>
</li>
</ol>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>下载apt仓库文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载apt仓库的安装包，Ubuntu的安装包是.deb文件</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094103.png" alt="image-20221016094103315"></p>
</li>
<li><p>配置apt仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用dpkg命令安装仓库</span></span><br><span class="line">dpkg -i mysql-apt-config_0.8.12-1_all.deb</span><br></pre></td></tr></table></figure>
<p>弹出框中选择：<code>ubuntu bionic</code> （Ubuntu18.04系统的代号是bionic，选择18.04的版本库用来安装）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094142.png" alt="image-20221016094142343"></p>
<p>弹出框中选择：<code>MySQL Server &amp; Cluster</code></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094216.png" alt="image-20221016094216377"></p>
<p>弹出框中选择：<code>mysql-5.7</code></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094254.png" alt="image-20221016094254397"></p>
<p>最后选择：<code>ok</code></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094306.png" alt="image-20221016094306917"></p>
</li>
<li><p>更新apt仓库的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先导入仓库的密钥信息</span></span><br><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新仓库信息</span></span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查是否成功配置MySQL5.7的仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache policy mysql-server</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094546.png" alt="image-20221016094546943"></p>
<p>看到如图所示字样，即成功</p>
</li>
<li><p>安装MySQL5.7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用apt安装mysql客户端和mysql服务端</span></span><br><span class="line">apt install -f -y mysql-client=5.7* mysql-community-server=5.7*</span><br></pre></td></tr></table></figure>
<p>弹出框中输入root密码并选择ok，密码任意，课程中以123456代替</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094941.png" alt="image-20221016094941439"></p>
<p>再次输入root密码确认</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016094954.png" alt="image-20221016094954505"></p>
</li>
<li><p>启动MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql start			# 启动</span><br><span class="line">/etc/init.d/mysql stop			# 停止</span><br><span class="line">/etc/init.d/mysql status		# 查看状态</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095259.png" alt="image-20221016095259172"></p>
</li>
<li><p>对MySQL进行初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行如下命令，此命令是MySQL安装后自带的配置程序</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过<span class="built_in">which</span>命令查看到这个自带程序所在的位置</span></span><br><span class="line">root@DESKTOP-Q89USRE:~# which mysql_secure_installation</span><br><span class="line">/usr/bin/mysql_secure_installation</span><br></pre></td></tr></table></figure>
<ol>
<li><p>输入密码：</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095458.png" alt="image-20221016095458755"></p>
</li>
<li><p>是否开启密码验证插件，如果需要增强密码安全性，输入<code>y</code>并回车，不需要直接回车（课程中选择直接回车）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095537.png" alt="image-20221016095537716"></p>
</li>
<li><p>是否更改root密码，需要输入<code>y</code>回车，不需要直接回车（课程不更改）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095621.png" alt="image-20221016095621386"></p>
</li>
<li><p>是否移除匿名用户，移除输入<code>y</code>回车，不移除直接回车（课程选择移除）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101232.png" alt="image-20221016101232827"></p>
</li>
<li><p>是否进制root用户远程登录，禁止输入<code>y</code>回车，不禁止直接回车（课程选择不禁止）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101324.png" alt="image-20221016101324577"></p>
</li>
<li><p>是否移除自带的测试数据库，移除输入<code>y</code>回车，不移除直接回车（课程选择不移除）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101404.png" alt="image-20221016101404392"></p>
</li>
<li><p>是否刷新权限，刷新输入<code>y</code>回车，不刷新直接回车（课程选择刷新）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101442.png" alt="image-20221016101442459"></p>
</li>
</ol>
</li>
<li><p>登陆MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入密码即可登陆成功</span></span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101524.png" alt="image-20221016101524498"></p>
</li>
</ol>
<p>至此，在Ubuntu上安装MySQL5.7版本成功。</p>
<h2 id="MySQL8-0版本在Ubuntu（WSL环境）系统安装"><a href="#MySQL8-0版本在Ubuntu（WSL环境）系统安装" class="headerlink" title="MySQL8.0版本在Ubuntu（WSL环境）系统安装"></a>MySQL8.0版本在Ubuntu（WSL环境）系统安装</h2><blockquote>
<p>课程中配置的WSL环境是最新的Ubuntu22.04版本，这个版本的软件商店内置的MySQL是8.0版本</p>
<p>所以直接可以通过apt安装即可</p>
<p>注意，课程是以WSL获得的Ubuntu操作系统环境。</p>
<p>如果你通过VMware虚拟机的方式获得了Ubuntu操作系统环境，操作步骤不用担心，和课程中使用WSL环境是==完全一致的==</p>
</blockquote>
<p>安装操作需root权限，你可以：</p>
<ol>
<li><p>通过 sudo su -，切换到root用户</p>
<blockquote>
<p>课程中选择这种方式操作</p>
</blockquote>
</li>
<li><p>或在每一个命令前，加上sudo，用来临时提升权限</p>
</li>
</ol>
<h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>如果已经安装过MySQL5.7版本，需要卸载仓库信息哦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载MySQL5.7版本</span></span><br><span class="line">apt remove -y mysql-client=5.7* mysql-community-server=5.7*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载5.7的仓库信息</span></span><br><span class="line">dpkg -l | grep mysql | awk &#x27;&#123;print $2&#125;&#x27; | xargs dpkg -P</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新apt仓库信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install -y mysql-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql start			# 启动</span><br><span class="line">/etc/init.d/mysql stop			# 停止</span><br><span class="line">/etc/init.d/mysql status		# 查看状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>登陆MySQL设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接执行：mysql</span></span><br><span class="line">mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出MySQL控制台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>对MySQL进行初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行如下命令，此命令是MySQL安装后自带的配置程序</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过<span class="built_in">which</span>命令查看到这个自带程序所在的位置</span></span><br><span class="line">root@DESKTOP-Q89USRE:~# which mysql_secure_installation</span><br><span class="line">/usr/bin/mysql_secure_installation</span><br></pre></td></tr></table></figure>
<ol>
<li><p>输入密码：</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095458.png" alt="image-20221016095458755"></p>
</li>
<li><p>是否开启密码验证插件，如果需要增强密码安全性，输入<code>y</code>并回车，不需要直接回车（课程中选择直接回车）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095537.png" alt="image-20221016095537716"></p>
</li>
<li><p>是否更改root密码，需要输入<code>y</code>回车，不需要直接回车（课程不更改）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016095621.png" alt="image-20221016095621386"></p>
</li>
<li><p>是否移除匿名用户，移除输入<code>y</code>回车，不移除直接回车（课程选择移除）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101232.png" alt="image-20221016101232827"></p>
</li>
<li><p>是否进制root用户远程登录，禁止输入<code>y</code>回车，不禁止直接回车（课程选择不禁止）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101324.png" alt="image-20221016101324577"></p>
</li>
<li><p>是否移除自带的测试数据库，移除输入<code>y</code>回车，不移除直接回车（课程选择不移除）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101404.png" alt="image-20221016101404392"></p>
</li>
<li><p>是否刷新权限，刷新输入<code>y</code>回车，不刷新直接回车（课程选择刷新）</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016101442.png" alt="image-20221016101442459"></p>
</li>
</ol>
</li>
<li><p>重新登陆MySQL（用更改后的密码）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/16/20221016110414.png" alt="image-20221016110414182"></p>
</li>
</ol>
<p>至此，在Ubuntu上安装MySQL5.7版本成功。</p>
<h1 id="Tomcat安装部署【简单】"><a href="#Tomcat安装部署【简单】" class="headerlink" title="Tomcat安装部署【简单】"></a>Tomcat安装部署【简单】</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。</p>
<p>简单来说，Tomcat是一个WEB应用程序的托管平台，可以让用户编写的WEB应用程序，被Tomcat所托管，并提供网站服务。</p>
<blockquote>
<p>即让用户开发的WEB应用程序，变成可以被访问的网页。</p>
</blockquote>
<h2 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h2><p>Tomcat的安装非常简单，主要分为2部分：</p>
<ol>
<li>安装JDK环境</li>
<li>解压并安装Tomcat</li>
</ol>
<blockquote>
<p>本次安装使用Tomcat版本是：10.0.27版本，需要Java（JDK）版本最低为JDK8或更高版本</p>
<p>课程中使用的JDK版本是：JDK8u351版本</p>
</blockquote>
<h3 id="安装JDK环境"><a href="#安装JDK环境" class="headerlink" title="安装JDK环境"></a>安装JDK环境</h3><ol>
<li><p>下载JDK软件</p>
<p><a href="https://www.oracle.com/java/technologies/downloads">https://www.oracle.com/java/technologies/downloads</a></p>
<p>在页面下方找到：</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017163411.png" alt="image-20221017163411651" style="zoom: 67%;" /></p>
<p>下载<code>jdk-8u351-linux-x64.tar.gz</code></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017163440.png" alt="image-20221017163440491"></p>
<p>==在弹出的页面中输入Oracle的账户密码即可下载（如无账户，请自行注册，注册是免费的）==</p>
</li>
<li><p>登陆Linux系统，切换到root用户</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017163607.png" alt=""></p>
</li>
<li><p>通过FinalShell，上传下载好的JDK安装包</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017163706.png" alt="image-20221017163706026"></p>
</li>
<li><p>创建文件夹，用来部署JDK，将JDK和Tomcat都安装部署到：/export/server 内</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /export/server</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压缩JDK安装文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u351-linux-x64.tar.gz -C /export/server</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JDK的软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /export/server/jdk1.8.0_351 /export/server/jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JAVA_HOME环境变量，以及将$JAVA_HOME/bin文件夹加入PATH环境变量中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑/etc/profile文件</span></span><br><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>生效环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置java执行程序的软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除系统自带的java程序</span></span><br><span class="line">rm -f /usr/bin/java</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">软链接我们自己安装的java程序</span></span><br><span class="line">ln -s /export/server/jdk/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解压并部署Tomcat"><a href="#解压并部署Tomcat" class="headerlink" title="解压并部署Tomcat"></a>解压并部署Tomcat</h3><blockquote>
<p>Tomcat建议使用非Root用户安装并启动</p>
<p>可以创建一个用户：tomcat用以部署</p>
</blockquote>
<ol>
<li><p>首先，放行tomcat需要使用的8080端口的外部访问权限</p>
<blockquote>
<p>CentOS系统默认开启了防火墙，阻止外部网络流量访问系统内部</p>
<p>所以，如果想要Tomcat可以正常使用，需要对Tomcat默认使用的8080端口进行放行</p>
<p>放行有2种操作方式：</p>
<ol>
<li>关闭防火墙</li>
<li>配置防火墙规则，放行端口</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作2选一即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1：关闭防火墙</span></span><br><span class="line">systemctl stop firewalld		# 关闭防火墙</span><br><span class="line">systemctl disable firewalld		# 停止防火墙开机自启</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2：放行8080端口的外部访问</span></span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent		# --add-port=8080/tcp表示放行8080端口的tcp访问，--permanent表示永久生效</span><br><span class="line">firewall-cmd --reload								# 重新载入防火墙规则使其生效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方便起见，建议同学们选择方式1，直接关闭防火墙一劳永逸</p>
<p>防火墙的配置非常复杂，后面会视情况独立出一集防火墙配置规则的章节。</p>
</blockquote>
</li>
<li><p>以root用户操作，创建tomcat用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root用户操作</span></span><br><span class="line">useradd tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选，为tomcat用户配置密码</span></span><br><span class="line">passwd tomcat</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载Tomcat安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root用户操作</span></span><br><span class="line">wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现https相关错误，可以使用--no-check-certificate选项</span></span><br><span class="line">wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果Linux内下载过慢，可以复制下载链接在Windows系统中使用迅雷等软件加速下载然后上传到Linux内即可</p>
<p>或者使用课程资料中提供的安装包</p>
</blockquote>
</li>
<li><p>解压Tomcat安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root用户操作，否则无权限解压到/export/server内，除非修改此文件夹权限</span></span><br><span class="line">tar -zxvf apache-tomcat-10.0.27.tar.gz -C /export/server</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Tomcat软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root用户操作</span></span><br><span class="line">ln -s /export/server/apache-tomcat-10.0.27 /export/server/tomcat</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改tomcat安装目录权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root用户操作，同时对软链接和tomcat安装文件夹进行修改，使用通配符*进行匹配</span></span><br><span class="line">chown -R tomcat:tomcat /export/server/*tomcat*</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到tomcat用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - tomcat</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>tomcat启动在8080端口，可以检查是否正常启动成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 8080</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017223814.png" alt="image-20221017223814737"></p>
</li>
<li><p>打开浏览器，输入：</p>
<p><a href="http://centos:8080或http://192.168.88.130:8080">http://centos:8080或http://192.168.88.130:8080</a></p>
<p>使用主机名（需配置好本地的主机名映射）或IP地址访问Tomcat的WEB页面</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/17/20221017223915.png" alt="image-20221017223915498"></p>
</li>
</ol>
<p>至此，Tomcat安装配置完成。</p>
<h1 id="Nginx安装部署【简单】"><a href="#Nginx安装部署【简单】" class="headerlink" title="Nginx安装部署【简单】"></a>Nginx安装部署【简单】</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p>
<p>同Tomcat一样，Nginx可以托管用户编写的WEB应用程序成为可访问的网页服务，同时也可以作为流量代理服务器，控制流量的中转。</p>
<p>Nginx在WEB开发领域，基本上也是必备组件之一了。</p>
<h2 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h2><p>Nginx同样需要配置额外的yum仓库，才可以使用yum安装</p>
<blockquote>
<p>安装Nginx的操作需要root身份</p>
</blockquote>
<ol>
<li><p>安装yum依赖程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动添加，nginx的yum仓库</p>
<p>yum程序使用的仓库配置文件，存放在：<code>/etc/yum.repo.d</code>内。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件使用vim编辑</span></span><br><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填入如下内容并保存退出</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过如上操作，我们手动添加了nginx的yum仓库</p>
</blockquote>
</li>
<li><p>通过yum安装最新稳定版的nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx自动注册了systemctl系统服务</span></span><br><span class="line">systemctl start nginx		# 启动</span><br><span class="line">systemctl stop nginx		# 停止</span><br><span class="line">systemctl status nginx		# 运行状态</span><br><span class="line">systemctl enable nginx		# 开机自启</span><br><span class="line">systemctl disable nginx		# 关闭开机自启</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置防火墙放行</p>
<p>nginx默认绑定80端口，需要关闭防火墙或放行80端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1（推荐），关闭防火墙</span></span><br><span class="line">systemctl stop firewalld		# 关闭</span><br><span class="line">systemctl disable firewalld		# 关闭开机自启</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2，放行80端口</span></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent		# 放行tcp规则下的80端口，永久生效</span><br><span class="line">firewall-cmd --reload							# 重新加载防火墙规则</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动后浏览器输入Linux服务器的IP地址或主机名即可访问</p>
<p><a href="http://192.168.88.130">http://192.168.88.130</a> 或 <a href="http://centos">http://centos</a></p>
<blockquote>
<p>ps：80端口是访问网站的默认端口，所以后面无需跟随端口号</p>
<p>显示的指定端口也是可以的比如：</p>
<ul>
<li><a href="http://192.168.88.130:80">http://192.168.88.130:80</a></li>
<li><a href="http://centos:80">http://centos:80</a></li>
</ul>
</blockquote>
</li>
</ol>
<p>至此，Nginx安装配置完成。</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/18/20221018143113.png" alt="image-20221018143113053"></p>
<h1 id="RabbitMQ安装部署【简单】"><a href="#RabbitMQ安装部署【简单】" class="headerlink" title="RabbitMQ安装部署【简单】"></a>RabbitMQ安装部署【简单】</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ一款知名的开源消息队列系统，为企业提供消息的发布、订阅、点对点传输等消息服务。</p>
<p>RabbitMQ在企业开发中十分常见，课程为大家演示快速搭建RabbitMQ环境。</p>
<h2 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>rabbitmq在yum仓库中的版本比较老，所以我们需要手动构建yum仓库</p>
</blockquote>
<ol>
<li><p>准备yum仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 准备gpgkey密钥</span></span><br><span class="line">rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">rpm --import https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 准备仓库文件</span></span><br><span class="line">vim /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填入如下内容</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Zero dependency Erlang</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PackageCloud<span class="string">&#x27;s repository key and RabbitMQ package signing key</span></span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name=rabbitmq_erlang-source</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">PackageCloud&#x27;</span>s repository key and RabbitMQ package signing key</span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># RabbitMQ server</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line">[rabbitmq_server]</span><br><span class="line">name=rabbitmq_server</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PackageCloud<span class="string">&#x27;s repository key and RabbitMQ package signing key</span></span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line">[rabbitmq_server-source]</span><br><span class="line">name=rabbitmq_server-source</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装RabbitMQ</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line">yum install erlang rabbitmq-server -y</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Installed:</span><br><span class="line">  erlang.x86_64 0:23.3.4.11-1.el7           rabbitmq-server.noarch 0:3.10.0-1.el7</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用systemctl管控，服务名：rabbitmq-server</span></span><br><span class="line">systemctl enable rabbitmq-server		# 开机自启</span><br><span class="line">systemctl disable rabbitmq-server		# 关闭开机自启</span><br><span class="line">systemctl start rabbitmq-server			# 启动</span><br><span class="line">systemctl stop rabbitmq-server			# 关闭</span><br><span class="line">systemctl status rabbitmq-server		# 查看状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>放行防火墙，RabbitMQ使用5672、15672、25672 3个端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1（推荐），关闭防火墙</span></span><br><span class="line">systemctl stop firewalld		# 关闭</span><br><span class="line">systemctl disable firewalld		# 关闭开机自启</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2，放行5672 25672端口</span></span><br><span class="line">firewall-cmd --add-port=5672/tcp --permanent		# 放行tcp规则下的5672端口，永久生效</span><br><span class="line">firewall-cmd --add-port=15672/tcp --permanent		# 放行tcp规则下的15672端口，永久生效</span><br><span class="line">firewall-cmd --add-port=25672/tcp --permanent		# 放行tcp规则下的25672端口，永久生效</span><br><span class="line">firewall-cmd --reload								# 重新加载防火墙规则</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动RabbitMQ的WEB管理控制台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加admin用户，并赋予权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user admin &#x27;Itheima66^&#x27;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; &quot;admin&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>浏览器打开管理控制台</p>
<p><a href="http://192.168.88.130:15672">http://192.168.88.130:15672</a></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/18/20221018154824.png" alt="image-20221018154823983"></p>
</li>
</ol>
<p>至此，RabbitMQ已经安装完成了。</p>
<h1 id="Redis安装部署【简单】"><a href="#Redis安装部署【简单】" class="headerlink" title="Redis安装部署【简单】"></a>Redis安装部署【简单】</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p>
<p>redis的特点就是：<code>快</code>，可以基于内存存储数据并提供超低延迟、超快的检索速度</p>
<p>一般用于在系统中提供快速缓存的能力。</p>
<h2 id="安装-7"><a href="#安装-7" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>配置<code>EPEL</code>仓库</p>
<blockquote>
<p>EPEL 的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。EPEL则为服务器版本提供大量的rpm包(yum程序所使用的程序安装包，类似Windows的exe)，而且大多数rpm包在官方 repository 中是找不到的。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line">yum install -y redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用systemctl管控，服务名：redis</span></span><br><span class="line">systemctl enable redis		# 开机自启</span><br><span class="line">systemctl disable redis		# 关闭开机自启</span><br><span class="line">systemctl start redis		# 启动</span><br><span class="line">systemctl stop redis		# 关闭</span><br><span class="line">systemctl status redis		# 查看状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>放行防火墙，redis使用端口6379</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1（推荐），关闭防火墙</span></span><br><span class="line">systemctl stop firewalld		# 关闭</span><br><span class="line">systemctl disable firewalld		# 关闭开机自启</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2，放行6379端口</span></span><br><span class="line">firewall-cmd --add-port=6379/tcp --permanent		# 放行tcp规则下的6379端口，永久生效</span><br><span class="line">firewall-cmd --reload	</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入redis服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行redis-cli</span></span><br><span class="line">[root@centos ~]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set mykey hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，redis安装完成。</p>
<h1 id="ElasticSearch安装部署"><a href="#ElasticSearch安装部署" class="headerlink" title="ElasticSearch安装部署"></a>ElasticSearch安装部署</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p><a href="https://baike.baidu.com/item/全文搜索引擎">全文搜索</a>属于最常见的需求，开源的 <a href="https://www.elastic.co/">Elasticsearch</a> （以下简称 es）是目前全文搜索引擎的首选。</p>
<p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>
<p>Elasticsearch简称es，在企业内同样是一款应用非常广泛的搜索引擎服务。</p>
<p>很多服务中的搜索功能，都是基于es来实现的。</p>
<h2 id="安装-8"><a href="#安装-8" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>添加yum仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入仓库密钥</span></span><br><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加yum源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span> </span><br><span class="line">vim /etc/yum.repos.d/elasticsearch.repo</span><br><span class="line"></span><br><span class="line">[elasticsearch-7.x]</span><br><span class="line">name=Elasticsearch repository for 7.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/7.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新yum缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装es</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y elasticsearch</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置es</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/elasticsearch/elasticsearch.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">17行，设置集群名称</span></span><br><span class="line">cluster.name: my-cluster</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">23行，设置节点名称</span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">56行，允许外网访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">74行，配置集群master节点</span></span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动es</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start | stop | status | enable | disable elasticsearch</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>浏览器打开：<a href="http://ip:9200/?pretty">http://ip:9200/?pretty</a></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025085432.png" alt="image-20221025085432335"></p>
</li>
</ol>
<h1 id="集群化环境前置准备"><a href="#集群化环境前置准备" class="headerlink" title="集群化环境前置准备"></a>集群化环境前置准备</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在前面，我们所学习安装的软件，都是以单机模式运行的。</p>
<p>后续，我们将要学习大数据相关的软件部署，所以后续我们所安装的软件服务，大多数都是以集群化（多台服务器共同工作）模式运行的。</p>
<p>所以，在当前小节，我们需要完成集群化环境的前置准备，包括创建多台虚拟机，配置主机名映射，SSH免密登录等等。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="配置多台Linux虚拟机"><a href="#配置多台Linux虚拟机" class="headerlink" title="配置多台Linux虚拟机"></a>配置多台Linux虚拟机</h3><p>安装集群化软件，首要条件就是要有多台Linux服务器可用。</p>
<p>我们可以使用VMware提供的克隆功能，将我们的虚拟机额外克隆出3台来使用。</p>
<ol>
<li><p>首先，关机当前CentOS系统虚拟机（可以使用root用户执行<code>init 0</code>来快速关机）</p>
</li>
<li><p>新建文件夹</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104157.png" alt="image-20221025104157628"></p>
<p>文件夹起名为：<code>虚拟机集群</code></p>
</li>
<li><p>克隆</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104131.png" alt="image-20221025104131303"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104312.png" alt="image-20221025104312091"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104329.png" alt="image-20221025104329109"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104345.png" alt="image-20221025104345484"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104414.png" alt="image-20221025104414576"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104427.png" alt="image-20221025104427160"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104432.png" alt="image-20221025104432927"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104446.png" alt="image-20221025104446044"></p>
</li>
<li><p>同样的操作克隆出：node2和node3</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025104825.png" alt="image-20221025104825204"></p>
</li>
<li><p>开启node1，修改主机名为node1，并修改固定ip为：192.168.88.131</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl set-hostname node1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改IP地址</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启网卡</span></span><br><span class="line">systemctl stop network</span><br><span class="line">systemctl start network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者直接</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样的操作启动node2和node3,</p>
<p>修改node2主机名为node2，设置ip为192.168.88.132</p>
<p>修改node2主机名为node3，设置ip为192.168.88.133</p>
</li>
<li><p>配置FinalShell，配置连接到node1、node2、node3的连接</p>
<blockquote>
<p>为了简单起见，建议配置root用户登录</p>
</blockquote>
</li>
</ol>
<h3 id="准备主机名映射"><a href="#准备主机名映射" class="headerlink" title="准备主机名映射"></a>准备主机名映射</h3><ol>
<li><p>在Windows系统中修改hosts文件，填入如下内容：</p>
<blockquote>
<p>如果同学们使用MacOS系统，请：</p>
<ol>
<li>sudo su -，切换到root</li>
<li>修改/etc/hosts文件</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.88.131 node1</span><br><span class="line">192.168.88.132 node2</span><br><span class="line">192.168.88.133 node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在3台Linux的/etc/hosts文件中，填入如下内容（==3台都要添加==）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.88.131 node1</span><br><span class="line">192.168.88.132 node2</span><br><span class="line">192.168.88.133 node3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置SSH免密登录"><a href="#配置SSH免密登录" class="headerlink" title="配置SSH免密登录"></a>配置SSH免密登录</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>SSH服务是一种用于远程登录的安全认证协议。</p>
<p>我们通过FinalShell远程连接到Linux，就是使用的SSH服务。</p>
<p>SSH服务支持：</p>
<ol>
<li>通过账户+密码的认证方式来做用户认证</li>
<li>通过账户+秘钥文件的方式做用户认证</li>
</ol>
<p>SSH可以让我们通过SSH命令，远程的登陆到其它的主机上，比如：</p>
<p>在node1执行：ssh root@node2，将以root用户登录node2服务器，输入密码即可成功登陆</p>
<p>或者ssh node2，将以当前用户直接登陆到node2服务器。</p>
<h4 id="SSH免密配置"><a href="#SSH免密配置" class="headerlink" title="SSH免密配置"></a>SSH免密配置</h4><p>后续安装的集群化软件，多数需要远程登录以及远程执行命令，我们可以简单起见，配置三台Linux服务器之间的免密码互相SSH登陆</p>
<ol>
<li><p>在每一台机器都执行：<code>ssh-keygen -t rsa -b 4096</code>，一路回车到底即可</p>
</li>
<li><p>在每一台机器都执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id node1</span><br><span class="line">ssh-copy-id node2</span><br><span class="line">ssh-copy-id node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕后，node1、node2、node3之间将完成root用户之间的免密互通</p>
</li>
</ol>
<h3 id="配置JDK环境"><a href="#配置JDK环境" class="headerlink" title="配置JDK环境"></a>配置JDK环境</h3><p>后续的大数据集群软件，多数是需要Java运行环境的，所以我们为==每一台==机器都配置JDK环境。</p>
<p>JDK配置参阅：<code>Tomcat</code>安装部署环节。</p>
<h3 id="关闭防火墙和SELinux"><a href="#关闭防火墙和SELinux" class="headerlink" title="关闭防火墙和SELinux"></a>关闭防火墙和SELinux</h3><p>集群化软件之间需要通过端口互相通讯，为了避免出现网络不通的问题，我们可以简单的在集群内部关闭防火墙。</p>
<p>==在每一台机器都执行==</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<p>Linux有一个安全模块：SELinux，用以限制用户和程序的相关权限，来确保系统的安全稳定。</p>
<p>SELinux的配置同防火墙一样，非常复杂，课程中不多涉及，后续视情况可以出一章SELinux的配置课程。</p>
<p>在当前，我们只需要关闭SELinux功能，避免导致后面的软件运行出现问题即可，</p>
<p>==在每一台机器都执行==</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/selinux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将第七行，SELINUX=enforcing 改为</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出后，重启虚拟机即可，千万要注意disabled单词不要写错，不然无法启动系统</span></span><br></pre></td></tr></table></figure>
<h3 id="添加快照"><a href="#添加快照" class="headerlink" title="添加快照"></a>添加快照</h3><p>为了避免后续出现问题，在完成上述设置后，为==每一台虚拟机==都制作快照，留待使用。</p>
<h2 id="补充命令-scp"><a href="#补充命令-scp" class="headerlink" title="补充命令 - scp"></a>补充命令 - scp</h2><p>后续的安装部署操作，我们将会频繁的在多台服务器之间相互传输数据。</p>
<p>为了更加方面的互相传输，我们补充一个命令：scp</p>
<p>scp命令是cp命令的升级版，即：ssh cp，通过SSH协议完成文件的复制。</p>
<p>其主要的功能就是：在不同的Linux服务器之间，通过<code>SSH</code>协议互相传输文件。</p>
<p>只要知晓服务器的账户和密码（或密钥），即可通过SCP互传文件。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp [-r] 参数1 参数2</span><br><span class="line">- -r选项用于复制文件夹使用，如果复制文件夹，必须使用-r</span><br><span class="line">- 参数1：本机路径 或 远程目标路径</span><br><span class="line">- 参数2：远程目标路径 或 本机路径</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">scp -r /export/server/jdk root@node2:/export/server/</span><br><span class="line">将本机上的jdk文件夹， 以root的身份复制到node2的/export/server/内</span><br><span class="line">同SSH登陆一样，账户名可以省略（使用本机当前的同名账户登陆）</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">scp -r node2:/export/server/jdk /export/server/</span><br><span class="line">将远程node2的jdk文件夹，复制到本机的/export/server/内</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scp命令的高级用法</span></span><br><span class="line">cd /export/server</span><br><span class="line">scp -r jdk node2:`pwd`/    # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</span><br><span class="line">scp -r jdk node2:$PWD      # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</span><br></pre></td></tr></table></figure>
<h1 id="Zookeeper集群安装部署"><a href="#Zookeeper集群安装部署" class="headerlink" title="Zookeeper集群安装部署"></a>Zookeeper集群安装部署</h1><h2 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h2><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/分布式/19276232?fromModule=lemma_inlink">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/分布式应用程序/9854429?fromModule=lemma_inlink">分布式应用程序</a>协调服务，是Hadoop和<a href="https://baike.baidu.com/item/Hbase/7670213?fromModule=lemma_inlink">Hbase</a>的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p>除了为Hadoop和HBase提供协调服务外，Zookeeper也被其它许多软件采用作为其分布式状态一致性的依赖，比如Kafka，又或者一些软件项目中，也经常能见到Zookeeper作为一致性协调服务存在。</p>
<p>Zookeeper不论是大数据领域亦或是其它服务器开发领域，涉及到分布式状态一致性的场景，总有它的身影存在。</p>
<h2 id="安装-9"><a href="#安装-9" class="headerlink" title="安装"></a>安装</h2><p>Zookeeper是一款分布式的集群化软件，可以在多台服务器上部署，并协同组成分布式集群一起工作。</p>
<ol>
<li><p>首先，要确保已经完成了<code>集群化环境前置准备</code>环节的全部内容</p>
</li>
<li><p>【node1上操作】下载Zookeeper安装包，并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">wget http://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保如下目录存在，不存在就创建</span></span><br><span class="line">mkdir -p /export/server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz -C /export/server</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1上操作】创建软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1上操作】修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /export/server/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zookeeper数据存储目录</span></span><br><span class="line">dataDir=/export/server/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=node1:2888:3888</span><br><span class="line">server.2=node2:2888:3888</span><br><span class="line">server.3=node3:2888:3888</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1上操作】配置<code>myid</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建Zookeeper的数据目录</span></span><br><span class="line">mkdir /export/server/zookeeper/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 创建文件，并填入1</span></span><br><span class="line">vim /export/server/zookeeper/data/myid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件内填入1即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node2和node3上操作】，创建文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /export/server</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1上操作】将Zookeeper 复制到node2和node3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/server</span><br><span class="line"></span><br><span class="line">scp -r apache-zookeeper-3.5.9 node2:`pwd`/</span><br><span class="line">scp -r apache-zookeeper-3.5.9 node3:`pwd`/</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node2上操作】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建软链接</span></span><br><span class="line">ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 修改myid文件</span></span><br><span class="line">vim /export/server/zookeeper/data/myid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改内容为2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node3上操作】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建软链接</span></span><br><span class="line">ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 修改myid文件</span></span><br><span class="line">vim /export/server/zookeeper/data/myid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改内容为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node1、node2、node3上分别执行】启动Zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动命令</span></span><br><span class="line">/export/server/zookeeper/bin/zkServer.sh start		# 启动Zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node1、node2、node3上分别执行】检查Zookeeper进程是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果中找到有：QuorumPeerMain 进程即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1上操作】验证Zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/zookeeper/zkCli.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到Zookeeper控制台中后，执行</span></span><br><span class="line">ls /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如无报错即配置成功</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此Zookeeper安装完成</p>
<h1 id="Kafka集群安装部署"><a href="#Kafka集群安装部署" class="headerlink" title="Kafka集群安装部署"></a>Kafka集群安装部署</h1><h2 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h2><p>Kafka是一款<code>分布式的、去中心化的、高吞吐低延迟、订阅模式</code>的消息队列系统。</p>
<p>同RabbitMQ一样，Kafka也是消息队列。不过RabbitMQ多用于后端系统，因其更加专注于消息的延迟和容错。</p>
<p>Kafka多用于大数据体系，因其更加专注于数据的吞吐能力。</p>
<p>Kafka多数都是运行在分布式（集群化）模式下，所以课程将以3台服务器，来完成Kafka集群的安装部署。</p>
<h2 id="安装-10"><a href="#安装-10" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>确保已经跟随前面的视频，安装并部署了JDK和Zookeeper服务</p>
<blockquote>
<p>Kafka的运行依赖JDK环境和Zookeeper请确保已经有了JDK环境和Zookeeper</p>
</blockquote>
</li>
<li><p>【在node1操作】下载并上传Kafka的安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载安装包</span></span><br><span class="line">wget http://archive.apache.org/dist/kafka/2.4.1/kafka_2.12-2.4.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node1操作】解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /export/server			# 此文件夹如果不存在需先创建</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf kafka_2.12-2.4.1.tgz -C /export/server/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软链接</span></span><br><span class="line">ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafka</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node1操作】修改Kafka目录内的config目录内的<code>server.properties</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/server/kafka/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定broker的<span class="built_in">id</span></span></span><br><span class="line">broker.id=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 kafka的绑定监听的地址</span></span><br><span class="line">listeners=PLAINTEXT://node1:9092</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Kafka数据的位置</span></span><br><span class="line">log.dirs=/export/server/kafka/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Zookeeper的三个节点</span></span><br><span class="line">zookeeper.connect=node1:2181,node2:2181,node3:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node1操作】将node1的kafka复制到node2和node3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制到node2同名文件夹</span></span><br><span class="line">scp -r kafka_2.12-2.4.1 node2:`pwd`/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制到node3同名文件夹</span></span><br><span class="line">scp -r kafka_2.12-2.4.1 node3:$PWD</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node2操作】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软链接</span></span><br><span class="line">ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafka</span><br><span class="line"></span><br><span class="line">cd /export/server/kafka/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定broker的<span class="built_in">id</span></span></span><br><span class="line">broker.id=2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 kafka的绑定监听的地址</span></span><br><span class="line">listeners=PLAINTEXT://node2:9092</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Kafka数据的位置</span></span><br><span class="line">log.dirs=/export/server/kafka/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Zookeeper的三个节点</span></span><br><span class="line">zookeeper.connect=node1:2181,node2:2181,node3:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>【在node3操作】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软链接</span></span><br><span class="line">ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafka</span><br><span class="line"></span><br><span class="line">cd /export/server/kafka/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定broker的<span class="built_in">id</span></span></span><br><span class="line">broker.id=3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 kafka的绑定监听的地址</span></span><br><span class="line">listeners=PLAINTEXT://node3:9092</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Kafka数据的位置</span></span><br><span class="line">log.dirs=/export/server/kafka/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Zookeeper的三个节点</span></span><br><span class="line">zookeeper.connect=node1:2181,node2:2181,node3:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动kafka</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请先确保Zookeeper已经启动了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1：【前台启动】分别在node1、2、3上执行如下语句</span></span><br><span class="line">/export/server/kafka/bin/kafka-server-start.sh /export/server/kafka/config/server.properties</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2：【后台启动】分别在node1、2、3上执行如下语句</span></span><br><span class="line">nohup /export/server/kafka/bin/kafka-server-start.sh /export/server/kafka/config/server.properties 2&gt;&amp;1 &gt;&gt; /export/server/kafka/kafka-server.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证Kafka启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每一台服务器执行</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/25/20221025174522.png" alt="image-20221025174522487"></p>
</li>
</ol>
<h2 id="测试Kafka能否正常使用"><a href="#测试Kafka能否正常使用" class="headerlink" title="测试Kafka能否正常使用"></a>测试Kafka能否正常使用</h2><ol>
<li>创建测试主题</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node1执行，创建一个主题</span></span><br><span class="line">/export/server/kafka_2.12-2.4.1/bin/kafka-topics.sh --create --zookeeper node1:2181 --replication-factor 1 --partitions 3 --topic test</span><br></pre></td></tr></table></figure>
<ol>
<li>运行测试，请在FinalShell中打开2个node1的终端页面</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开一个终端页面，启动一个模拟的数据生产者</span></span><br><span class="line">/export/server/kafka_2.12-2.4.1/bin/kafka-console-producer.sh --broker-list node1:9092 --topic test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再打开一个新的终端页面，在启动一个模拟的数据消费者</span></span><br><span class="line">/export/server/kafka_2.12-2.4.1/bin/kafka-console-consumer.sh --bootstrap-server node1:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>
<h1 id="大数据集群（Hadoop生态）安装部署"><a href="#大数据集群（Hadoop生态）安装部署" class="headerlink" title="大数据集群（Hadoop生态）安装部署"></a>大数据集群（Hadoop生态）安装部署</h1><h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p>1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构。<br>2）主要解决，海量数据的存储和海量数据的分析计算问题。</p>
<p>Hadoop HDFS 提供分布式海量数据存储能力</p>
<p>Hadoop YARN 提供分布式集群资源管理能力</p>
<p>Hadoop MapReduce 提供分布式海量数据计算能力</p>
<h3 id="前置要求-1"><a href="#前置要求-1" class="headerlink" title="前置要求"></a>前置要求</h3><ul>
<li>请确保完成了集群化环境前置准备章节的内容</li>
<li>即：JDK、SSH免密、关闭防火墙、配置主机名映射等前置操作</li>
</ul>
<h3 id="Hadoop集群角色"><a href="#Hadoop集群角色" class="headerlink" title="Hadoop集群角色"></a>Hadoop集群角色</h3><p>Hadoop生态体系中总共会出现如下进程角色：</p>
<ol>
<li>Hadoop HDFS的管理角色：Namenode进程（<code>仅需1个即可（管理者一个就够）</code>）</li>
<li>Hadoop HDFS的工作角色：Datanode进程（<code>需要多个（工人，越多越好，一个机器启动一个）</code>）</li>
<li>Hadoop YARN的管理角色：ResourceManager进程（<code>仅需1个即可（管理者一个就够）</code>）</li>
<li>Hadoop YARN的工作角色：NodeManager进程（<code>需要多个（工人，越多越好，一个机器启动一个）</code>）</li>
<li>Hadoop 历史记录服务器角色：HistoryServer进程（<code>仅需1个即可（功能进程无需太多1个足够）</code>）</li>
<li>Hadoop 代理服务器角色：WebProxyServer进程（<code>仅需1个即可（功能进程无需太多1个足够）</code>）</li>
<li>Zookeeper的进程：QuorumPeerMain进程（<code>仅需1个即可（Zookeeper的工作者，越多越好）</code>）</li>
</ol>
<h3 id="角色和节点分配"><a href="#角色和节点分配" class="headerlink" title="角色和节点分配"></a>角色和节点分配</h3><p>角色分配如下：</p>
<ol>
<li>node1:Namenode、Datanode、ResourceManager、NodeManager、HistoryServer、WebProxyServer、QuorumPeerMain</li>
<li>node2:Datanode、NodeManager、QuorumPeerMain</li>
<li>node3:Datanode、NodeManager、QuorumPeerMain</li>
</ol>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026202935.png" alt="image-20221026202935745"></p>
<h2 id="安装-11"><a href="#安装-11" class="headerlink" title="安装"></a>安装</h2><h3 id="调整虚拟机内存"><a href="#调整虚拟机内存" class="headerlink" title="调整虚拟机内存"></a>调整虚拟机内存</h3><p>如上图，可以看出node1承载了太多的压力。同时node2和node3也同时运行了不少程序</p>
<p>为了确保集群的稳定，需要对虚拟机进行内存设置。</p>
<p>请在VMware中，对：</p>
<ol>
<li>node1设置4GB或以上内存</li>
<li>node2和node3设置2GB或以上内存</li>
</ol>
<blockquote>
<p>大数据的软件本身就是集群化（一堆服务器）一起运行的。</p>
<p>现在我们在一台电脑中以多台虚拟机来模拟集群，确实会有很大的内存压力哦。</p>
</blockquote>
<h3 id="Zookeeper集群部署"><a href="#Zookeeper集群部署" class="headerlink" title="Zookeeper集群部署"></a>Zookeeper集群部署</h3><p>略</p>
<h3 id="Hadoop集群部署"><a href="#Hadoop集群部署" class="headerlink" title="Hadoop集群部署"></a>Hadoop集群部署</h3><ol>
<li><p>下载Hadoop安装包、解压、配置软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 下载</span></span><br><span class="line">wget http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 解压</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请确保目录/export/server存在</span></span><br><span class="line">tar -zxvf hadoop-3.3.0.tar.gz -C /export/server/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 构建软链接</span></span><br><span class="line">ln -s /export/server/hadoop-3.3.0 /export/server/hadoop</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件：<code>hadoop-env.sh</code></p>
<blockquote>
<p>Hadoop的配置文件要修改的地方很多，请细心</p>
</blockquote>
<p>cd 进入到/export/server/hadoop/etc/hadoop，文件夹中，配置文件都在这里</p>
<p>修改hadoop-env.sh文件</p>
<blockquote>
<p>此文件是配置一些Hadoop用到的环境变量</p>
<p>这些是临时变量，在Hadoop运行时有用</p>
<p>如果要永久生效，需要写到/etc/profile中</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件开头加入：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Java安装路径</span></span><br><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Hadoop安装路径</span></span><br><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hadoop hdfs配置文件路径</span></span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hadoop YARN配置文件路径</span></span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hadoop YARN 日志文件夹</span></span><br><span class="line">export YARN_LOG_DIR=$HADOOP_HOME/logs/yarn</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hadoop hdfs 日志文件夹</span></span><br><span class="line">export HADOOP_LOG_DIR=$HADOOP_HOME/logs/hdfs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hadoop的使用启动用户配置</span></span><br><span class="line">export HDFS_NAMENODE_USER=root</span><br><span class="line">export HDFS_DATANODE_USER=root</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER=root</span><br><span class="line">export YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">export YARN_NODEMANAGER_USER=root</span><br><span class="line">export YARN_PROXYSERVER_USER=root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件：<code>core-site.xml</code></p>
<p>如下，清空文件，填入如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<code>hdfs-site.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir.perm<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>700<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/nn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Path on the local filesystem where the NameNode stores the namespace and transactions logs persistently.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node1,node2,node3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>List of permitted DataNodes.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.blocksize<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>268435456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/dn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<code>mapred-env.sh</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件的开头加入如下环境变量设置</span></span><br><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export HADOOP_JOB_HISTORYSERVER_HEAPSIZE=1000</span><br><span class="line">export HADOOP_MAPRED_ROOT_LOGGER=INFO,RFA</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<code>mapred-site.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node1:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node1:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.intermediate-done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/mr-history/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/mr-history/done<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<code>yarn-env.sh</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件的开头加入如下环境变量设置</span></span><br><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export YARN_LOG_DIR=$HADOOP_HOME/logs/yarn</span><br><span class="line">export HADOOP_LOG_DIR=$HADOOP_HOME/logs/hdfs</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<code>yarn-site.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>http://node1:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.web-proxy.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node1:8089<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>proxy server hostname and port<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Configuration to enable or disable log aggregation<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.remote-app-log-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Configuration to enable or disable log aggregation<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.local-dirs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/nm-local<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Comma-separated list of paths on the local filesystem where intermediate data is written.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.log-dirs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/nm-log<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Comma-separated list of paths on the local filesystem where logs are written.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.log.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>10800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Default time (in seconds) to retain log files on the NodeManager Only applicable if log-aggregation is disabled.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Shuffle service that needs to be set for Map Reduce applications.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改workers文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部内容如下</span></span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>分发hadoop到其它机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node1执行</span></span><br><span class="line">cd /export/server</span><br><span class="line"></span><br><span class="line">scp -r hadoop-3.3.0 node2:`pwd`/</span><br><span class="line">scp -r hadoop-3.3.0 node2:`pwd`/</span><br></pre></td></tr></table></figure>
</li>
<li><p>在node2、node3执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软链接</span></span><br><span class="line">ln -s /export/server/hadoop-3.3.0 /export/server/hadoop</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建所需目录</p>
<ul>
<li><p>在node1执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/nn</span><br><span class="line">mkdir -p /data/dn</span><br><span class="line">mkdir -p /data/nm-log</span><br><span class="line">mkdir -p /data/nm-local</span><br></pre></td></tr></table></figure>
</li>
<li><p>在node2执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/dn</span><br><span class="line">mkdir -p /data/nm-log</span><br><span class="line">mkdir -p /data/nm-local</span><br></pre></td></tr></table></figure>
</li>
<li><p>在node3执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/dn</span><br><span class="line">mkdir -p /data/nm-log</span><br><span class="line">mkdir -p /data/nm-local</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置环境变量</p>
<p>在node1、node2、node3修改/etc/profile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>
<p>执行<code>source /etc/profile</code>生效</p>
</li>
<li><p>格式化NameNode，在node1执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hadoop这个命令来自于：$HADOOP_HOME/bin中的程序</p>
<p>由于配置了环境变量PATH，所以可以在任意位置执行hadoop命令哦</p>
</blockquote>
</li>
<li><p>启动hadoop的hdfs集群，在node1执行即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止可以执行</span></span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>start-dfs.sh这个命令来自于：$HADOOP_HOME/sbin中的程序</p>
<p>由于配置了环境变量PATH，所以可以在任意位置执行start-dfs.sh命令哦</p>
</blockquote>
</li>
<li><p>启动hadoop的yarn集群，在node1执行即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止可以执行</span></span><br><span class="line">stop-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动历史服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mapred --daemon start historyserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止将start更换为stop</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动web代理服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start proxyserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止将start更换为stop</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="验证Hadoop集群运行情况"><a href="#验证Hadoop集群运行情况" class="headerlink" title="验证Hadoop集群运行情况"></a>验证Hadoop集群运行情况</h4><ol>
<li><p>在node1、node2、node3上通过jps验证进程是否都启动成功</p>
</li>
<li><p>验证HDFS，浏览器打开：<a href="http://node1:9870">http://node1:9870</a></p>
<p>创建文件test.txt，随意填入内容，并执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -put test.txt /test.txt</span><br><span class="line"></span><br><span class="line">hadoop fs -cat /test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证YARN，浏览器打开：<a href="http://node1:8088">http://node1:8088</a></p>
<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件words.txt，填入如下内容</span></span><br><span class="line">itheima itcast hadoop</span><br><span class="line">itheima hadoop hadoop</span><br><span class="line">itheima itcast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件上传到HDFS中</span></span><br><span class="line">hadoop fs -put words.txt /words.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行如下命令验证YARN是否正常</span></span><br><span class="line">hadoop jar /export/server/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.0.jar wordcount -Dmapred.job.queue.name=root.root /words.txt /output</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="大数据NoSQL数据库HBase集群部署"><a href="#大数据NoSQL数据库HBase集群部署" class="headerlink" title="大数据NoSQL数据库HBase集群部署"></a>大数据NoSQL数据库HBase集群部署</h1><h2 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h2><p>HBase 是一种<a href="https://so.csdn.net/so/search?q=分布式&amp;spm=1001.2101.3001.7020">分布式</a>、可扩展、支持海量数据存储的 NoSQL 数据库。</p>
<p>和Redis一样，HBase是一款KeyValue型存储的数据库。</p>
<p>不过和Redis设计方向不同</p>
<ul>
<li>Redis设计为少量数据，超快检索</li>
<li>HBase设计为海量数据，快速检索</li>
</ul>
<p>HBase在大数据领域应用十分广泛，现在我们来在node1、node2、node3上部署HBase集群。</p>
<h2 id="安装-12"><a href="#安装-12" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>HBase依赖Zookeeper、JDK、Hadoop（HDFS），请确保已经完成前面</p>
<ul>
<li>集群化软件前置准备（JDK）</li>
<li>Zookeeper</li>
<li>Hadoop</li>
<li>这些环节的软件安装</li>
</ul>
</li>
<li><p>【node1执行】下载HBase安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">wget http://archive.apache.org/dist/hbase/2.1.0/hbase-2.1.0-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf hbase-2.1.0-bin.tar.gz -C /export/server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置软链接</span></span><br><span class="line">ln -s /export/server/hbase-2.1.0 /export/server/hbase</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】，修改配置文件，修改<code>conf/hbase-env.sh</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在28行配置JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在126行配置：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意思表示，不使用HBase自带的Zookeeper，而是用独立Zookeeper</span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在任意行，比如26行，添加如下内容：</span></span><br><span class="line">export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=&quot;true&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】，修改配置文件，修改<code>conf/hbase-site.xml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件的全部内容替换成如下内容：</span></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;!-- HBase数据在HDFS中的存放的路径 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hdfs://node1:8020/hbase&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- Hbase的运行模式。false是单机模式，true是分布式模式。若为false,Hbase和Zookeeper会运行在同一个JVM里面 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper的地址 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;node1,node2,node3&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper快照的存储位置 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;/export/server/apache-zookeeper-3.6.0-bin/data&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--  V2.1版本，在分布式情况下, 设置为false --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】，修改配置文件，修改<code>conf/regionservers</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填入如下内容</span></span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】，分发hbase到其它机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /export/server/hbase-2.1.0 node2:/export/server/</span><br><span class="line">scp -r /export/server/hbase-2.1.0 node3:/export/server/</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node2、node3执行】，配置软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /export/server/hbase-2.1.0 /export/server/hbase</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1、node2、node3执行】，配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置在/etc/profile内，追加如下两行</span></span><br><span class="line">export HBASE_HOME=/export/server/hbase</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】启动HBase</p>
<blockquote>
<p>请确保：Hadoop HDFS、Zookeeper是已经启动了的</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止可使用</span></span><br><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于我们配置了环境变量export PATH=$PATH:$HBASE_HOME/bin</p>
<p>start-hbase.sh即在$HBASE_HOME/bin内，所以可以无论当前目录在哪，均可直接执行</p>
</blockquote>
</li>
<li><p>验证HBase</p>
<p>浏览器打开：<a href="http://node1:16010，即可看到HBase的WEB">http://node1:16010，即可看到HBase的WEB</a> UI页面</p>
</li>
<li><p>简单测试使用HBase</p>
<p>【node1执行】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase shell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建表</span></span><br><span class="line">create &#x27;test&#x27;, &#x27;cf&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入数据</span></span><br><span class="line">put &#x27;test&#x27;, &#x27;rk001&#x27;, &#x27;cf:info&#x27;, &#x27;itheima&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询数据</span></span><br><span class="line">get &#x27;test&#x27;, &#x27;rk001&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描表数据</span></span><br><span class="line">scan &#x27;test&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="分布式内存计算Spark环境部署"><a href="#分布式内存计算Spark环境部署" class="headerlink" title="分布式内存计算Spark环境部署"></a>分布式内存计算Spark环境部署</h1><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>本小节的操作，基于：<code>大数据集群（Hadoop生态）安装部署</code>环节中所构建的Hadoop集群</p>
<p>如果没有Hadoop集群，请参阅前置内容，部署好环境。</p>
<h2 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h2><p>Spark是一款分布式内存计算引擎，可以支撑海量数据的分布式计算。</p>
<p>Spark在大数据体系是明星产品，作为最新一代的综合计算引擎，支持离线计算和实时计算。</p>
<p>在大数据领域广泛应用，是目前世界上使用最多的大数据分布式计算引擎。</p>
<p>我们将基于前面构建的Hadoop集群，部署Spark Standalone集群。</p>
<h2 id="安装-13"><a href="#安装-13" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>【node1执行】下载并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/spark/spark-2.4.5/spark-2.4.5-bin-hadoop2.7.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf spark-2.4.5-bin-hadoop2.7.tgz -C /export/server/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">软链接</span></span><br><span class="line">ln -s /export/server/spark-2.4.5-bin-hadoop2.7 /export/server/spark</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】修改配置文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改名</span></span><br><span class="line">cd /export/server/spark/conf</span><br><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">mv slaves.template slaves</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】修改配置文件，<code>spark-env.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置JAVA安装目录</span></span></span><br><span class="line">JAVA_HOME=/export/server/jdk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># HADOOP软件配置文件目录，读取HDFS上文件和运行YARN集群</span></span></span><br><span class="line">HADOOP_CONF_DIR=/export/server/hadoop/etc/hadoop</span><br><span class="line">YARN_CONF_DIR=/export/server/hadoop/etc/hadoop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定spark老大Master的IP和提交任务的通信端口</span></span></span><br><span class="line">export SPARK_MASTER_HOST=node1</span><br><span class="line">export SPARK_MASTER_PORT=7077</span><br><span class="line"></span><br><span class="line">SPARK_MASTER_WEBUI_PORT=8080</span><br><span class="line">SPARK_WORKER_CORES=1</span><br><span class="line">SPARK_WORKER_MEMORY=1g</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】修改配置文件，<code>slaves</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】分发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r spark-2.4.5-bin-hadoop2.7 node2:$PWD</span><br><span class="line">scp -r spark-2.4.5-bin-hadoop2.7 node3:$PWD</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node2、node3执行】设置软链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /export/server/spark-2.4.5-bin-hadoop2.7 /export/server/spark</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1执行】启动Spark集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/spark/sbin/start-all.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如需停止，可以</span></span><br><span class="line">/export/server/spark/sbin/stop-all.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开Spark监控页面，浏览器打开：<a href="http://node1:8081">http://node1:8081</a></p>
</li>
<li><p>【node1执行】提交测试任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/spark/bin/spark-submit --master spark://node1:7077 --class org.apache.spark.examples.SparkPi /export/server/spark/examples/jars/spark-examples_2.11-2.4.5.jar</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="分布式内存计算Flink环境部署"><a href="#分布式内存计算Flink环境部署" class="headerlink" title="分布式内存计算Flink环境部署"></a>分布式内存计算Flink环境部署</h1><h2 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h2><p>本小节的操作，基于：<code>大数据集群（Hadoop生态）安装部署</code>环节中所构建的Hadoop集群</p>
<p>如果没有Hadoop集群，请参阅前置内容，部署好环境。</p>
<h2 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h2><p>Flink同Spark一样，是一款分布式内存计算引擎，可以支撑海量数据的分布式计算。</p>
<p>Flink在大数据体系同样是明星产品，作为最新一代的综合计算引擎，支持离线计算和实时计算。</p>
<p>在大数据领域广泛应用，是目前世界上除去Spark以外，应用最为广泛的分布式计算引擎。</p>
<p>我们将基于前面构建的Hadoop集群，部署Flink Standalone集群</p>
<p>Spark更加偏向于离线计算而Flink更加偏向于实时计算。</p>
<h2 id="安装-14"><a href="#安装-14" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>【node1操作】下载安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/flink/flink-1.10.0/flink-1.10.0-bin-scala_2.11.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf flink-1.10.0-bin-scala_2.11.tgz -C /export/server/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">软链接</span></span><br><span class="line">ln -s /export/server/flink-1.10.0 /export/server/flink</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1操作】修改配置文件，<code>conf/flink-conf.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jobManager 的IP地址</span></span><br><span class="line"><span class="attr">jobmanager.rpc.address:</span> <span class="string">node1</span></span><br><span class="line"><span class="comment"># JobManager 的端口号</span></span><br><span class="line"><span class="attr">jobmanager.rpc.port:</span> <span class="number">6123</span></span><br><span class="line"><span class="comment"># JobManager JVM heap 内存大小</span></span><br><span class="line"><span class="attr">jobmanager.heap.size:</span> <span class="string">1024m</span></span><br><span class="line"><span class="comment"># TaskManager JVM heap 内存大小</span></span><br><span class="line"><span class="attr">taskmanager.heap.size:</span> <span class="string">1024m</span></span><br><span class="line"><span class="comment"># 每个 TaskManager 提供的任务 slots 数量大小</span></span><br><span class="line"><span class="attr">taskmanager.numberOfTaskSlots:</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#是否进行预分配内存，默认不进行预分配，这样在我们不使用flink集群时候不会占用集群资源</span></span><br><span class="line"><span class="attr">taskmanager.memory.preallocate:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 程序默认并行计算的个数</span></span><br><span class="line"><span class="attr">parallelism.default:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#JobManager的Web界面的端口（默认：8081）</span></span><br><span class="line"><span class="attr">jobmanager.web.port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1操作】，修改配置文件，<code>conf/slaves</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1操作】分发Flink安装包到其它机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/server</span><br><span class="line">scp -r flink-1.10.0 node2:`pwd`/</span><br><span class="line">scp -r flink-1.10.0 node3:`pwd`/</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node2、node3操作】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置软链接</span></span><br><span class="line">ln -s /export/server/flink-1.10.0 /export/server/flink</span><br></pre></td></tr></table></figure>
</li>
<li><p>【node1操作】，启动Flink</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证Flink启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器打开</span></span><br><span class="line">http://node1:8081</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交测试任务</p>
<p>【node1执行】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/export/server/flink/bin/flink run /export/server/flink-1.10.0/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="运维监控Zabbix部署"><a href="#运维监控Zabbix部署" class="headerlink" title="运维监控Zabbix部署"></a>运维监控Zabbix部署</h1><h2 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h2><p>Zabbix 由 Alexei Vladishev 创建，目前由其成立的公司—— Zabbix SIA 积极的持续开发更新维护， 并为用户提供技术支持服务。</p>
<p>Zabbix 是一个==企业级分布式开源监控解决方案==。</p>
<p>Zabbix 软件能够==监控==众多网络参数和服务器的==健康度、完整性==。Zabbix 使用灵活的告警机制，允许用户为几乎任何事件配置基于邮件的告警。这样用户可以快速响应服务器问题。Zabbix 基于存储的数据提供出色的报表和数据可视化功能。这些功能使得 Zabbix 成为容量规划的理想选择。</p>
<h2 id="安装-15"><a href="#安装-15" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p> 安装整体步骤:</p>
</blockquote>
<ol>
<li>准备Linux 服务器(虚拟机)</li>
<li>安装Mysql</li>
<li>安装zabbix( 包含 server  agent  web)</li>
<li>配置 mysql, 为zabbix创建表结构</li>
<li>配置zabbix server</li>
<li>启动并开启开机自启动</li>
</ol>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175324.png" alt="1574338996145"></p>
<h3 id="安装前准备-Mysql"><a href="#安装前准备-Mysql" class="headerlink" title="安装前准备 - Mysql"></a>安装前准备 - Mysql</h3><p>安装ZabbixServer需要先安装好<code>Mysql</code>数据库</p>
<p>课程使用<code>Mysql 5.7</code></p>
<p>安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装Mysql yum库</span></span><br><span class="line">rpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum安装Mysql</span></span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Mysql设置开机启动</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查Mysql服务状态</span></span><br><span class="line">systemctl status mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次启动mysql，会在日志文件中生成root用户的一个随机密码，使用下面命令查看该密码</span></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root用户密码</span></span><br><span class="line">mysql -u root -p -h localhost</span><br><span class="line">Enter password:</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;Root!@#$&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你想设置简单密码，需要降低Mysql的密码安全级别</span></span><br><span class="line">set global validate_password_policy=LOW; # 密码安全级别低</span><br><span class="line">set global validate_password_length=4;	 # 密码长度最低4位即可</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后就可以用简单密码了（课程中使用简单密码，为了方便，生产中不要这样）</span></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27;;</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;root&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="安装Zabbix-Server-和-Zabbix-Agent"><a href="#安装Zabbix-Server-和-Zabbix-Agent" class="headerlink" title="安装Zabbix Server 和 Zabbix Agent"></a>安装Zabbix Server 和 Zabbix Agent</h3><blockquote>
<p>初始安装，我们先安装ZabbixServer以及在Server本机安装Agent。</p>
</blockquote>
<p>打开官网下载页面：<a href="https://www.zabbix.com/download?zabbix=4.0&amp;os_distribution=centos&amp;os_version=7&amp;db=mysql">https://www.zabbix.com/download?zabbix=4.0&amp;os_distribution=centos&amp;os_version=7&amp;db=mysql</a></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175330.png" alt="1571981197131"></p>
<p>选择对应的版本，然后再下面官网给出了具体的安装命令，使用<code>rpm</code>和<code>yum</code>来进行安装。</p>
<p>需要有网络。</p>
<p><code>以下内容来自官方页面</code></p>
<h4 id="a-安装Zabbix-yum库"><a href="#a-安装Zabbix-yum库" class="headerlink" title="a. 安装Zabbix yum库"></a>a. 安装Zabbix yum库</h4><p><a href="https://www.zabbix.com/documentation/4.0/manual/installation/install_from_packages">documentation</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh https://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-2.el7.noarch.rpm</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure>
<h4 id="b-安装Zabbix-Server、前端、Agent"><a href="#b-安装Zabbix-Server、前端、Agent" class="headerlink" title="b. 安装Zabbix Server、前端、Agent"></a>b. 安装Zabbix Server、前端、Agent</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果只需要安装Agent的话</span></span><br><span class="line">yum -y install zabbix-agent</span><br></pre></td></tr></table></figure>
<h4 id="c-初始化Mysql数据库"><a href="#c-初始化Mysql数据库" class="headerlink" title="c. 初始化Mysql数据库"></a>c. 初始化Mysql数据库</h4><p><a href="https://www.zabbix.com/documentation/4.0/manual/appendix/install/db_scripts">documentation</a></p>
<blockquote>
<p>在Mysql中操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录Mysql 数据库</span></span><br><span class="line">mysql -uroot -pYourPassword</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">grant all privileges on zabbix.* to zabbix@localhost identified by <span class="string">&#x27;zabbix&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者: grant all privileges on zabbix.* to zabbix@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zabbix&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">quit;</span></span><br></pre></td></tr></table></figure>
<p>测试在Zabbix Server服务器上能否远程登录Mysql，如果可以登录继续向下走。</p>
<p>Import initial schema and data. You will be prompted to enter your newly created password.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span></span><br></pre></td></tr></table></figure>
<h4 id="d-为Zabbix-Server配置数据库"><a href="#d-为Zabbix-Server配置数据库" class="headerlink" title="d. 为Zabbix Server配置数据库"></a>d. 为Zabbix Server配置数据库</h4><p>Edit file /etc/zabbix/zabbix_server.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DBPassword=password</span><br><span class="line">DBHost=mysql-host-ip-or-hostname</span><br></pre></td></tr></table></figure>
<h4 id="e-配置Zabbix的PHP前端"><a href="#e-配置Zabbix的PHP前端" class="headerlink" title="e. 配置Zabbix的PHP前端"></a>e. 配置Zabbix的PHP前端</h4><p>Edit file <code>/etc/httpd/conf.d/zabbix.conf</code>, uncomment and set the right timezone for you.<code># php_value date.timezone Asia/Shanghai</code></p>
<p>Start Zabbix server and agent processes and make it start at system boot:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart zabbix-server zabbix-agent httpd # 启动、重启</span><br><span class="line">systemctl enable zabbix-server zabbix-agent httpd  # 开机自启</span><br></pre></td></tr></table></figure>
<p>Now your Zabbix server is up and running!</p>
<h3 id="配置zabbix-前端（WEB-UI）"><a href="#配置zabbix-前端（WEB-UI）" class="headerlink" title="配置zabbix 前端（WEB UI）"></a>配置zabbix 前端（WEB UI）</h3><p><strong>打开:<code>http://192.168.88.131/zabbix</code></strong></p>
<p>即可进入Zabbix页面，在首次打开的时候，会进入设置页面，如图：</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175338.png" alt="1571993951841"></p>
<p><strong>点击下一步，会检查相应的设置是否都正常</strong></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175341.png" alt="1571994018126"></p>
<p>如果一切正常，点击下一步。</p>
<p><strong>配置DB连接</strong></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175344.png" alt="1571994069689"></p>
<p>按具体情况填写即可</p>
<p><strong>配置Server细节</strong></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175347.png" alt="1571994111921"></p>
<p>具体配置即可，Name表示这个Zabbix服务的名字，这里起名叫<code>ITHEIMA-TEST</code></p>
<p><strong>安装前总结预览</strong></p>
<p>检查确认没有问题就下一步</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175349.png" alt="1571994206902"></p>
<p><strong>配置完成</strong></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175351.png" alt="1571994221531"></p>
<p><strong>初始管理员账户Admin密码zabbix</strong></p>
<p>输入账户密码后，就能进入zabbix页面了。</p>
<p>如下图：</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175354.png" alt="1571994287036"></p>
<p>现在是一个崭新的zabbix等待我们去探索。</p>
<h1 id="运维监控Grafana部署"><a href="#运维监控Grafana部署" class="headerlink" title="运维监控Grafana部署"></a>运维监控Grafana部署</h1><h2 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h2><h2 id="安装-16"><a href="#安装-16" class="headerlink" title="安装"></a>安装</h2><h3 id="部署形式"><a href="#部署形式" class="headerlink" title="部署形式"></a>部署形式</h3><p><code>Grafana</code>支持两种部署形式</p>
<ol>
<li>自行部署, 可以部署在操作系统之上. 自行提供服务器, 域名等.</li>
<li><code>Grafana</code>官方托管. 无需安装, 在线注册即可得到一个专属于自己的<code>Grafana</code>, 但是要花钱的. 是一种<code>SaaS</code>服务</li>
</ol>
<p>我们课程选择方式1</p>
<h3 id="安装-17"><a href="#安装-17" class="headerlink" title="安装"></a>安装</h3><p><code>Grafana</code>支持常见的绝大多数操作系统, 如<code>windows</code> <code>mac</code> <code>linux</code> 同时也支持部署在<code>docker</code>中.</p>
<p>大多数情况下, <code>Grafana</code>都是部署在<code>linux</code>服务器之上. 所以本课程也是基于<code>Linux</code>系统来讲解.</p>
<p>对<code>windows</code> <code>mac</code>系统 或 <code>docker</code>部署有兴趣的同学, 请参考:  <a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p>
<p>我们部署<code>Grafana</code>可以使用<code>YUM</code>来进行部署.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个文件</span></span><br><span class="line">vim /etc/yum.repos.d/grafana.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将下面的内容复制进去</span></span><br><span class="line">[grafana]</span><br><span class="line">name=grafana</span><br><span class="line">baseurl=https://packages.grafana.com/oss/rpm</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.grafana.com/gpg.key</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后安装</span></span><br><span class="line">yum install grafana</span><br></pre></td></tr></table></figure>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p><code>grafana-server</code>具有许多配置选项，这些选项可以在<code>.ini</code>配置文件中指定，也可以使用环境变量指定。</p>
<blockquote>
<p> <strong>Note.</strong> <code>Grafana</code> needs to be restarted for any configuration changes to take effect. </p>
</blockquote>
<h4 id="配置文件注释"><a href="#配置文件注释" class="headerlink" title="配置文件注释"></a>配置文件注释</h4><p><code>;</code>符号在<code>.ini</code>文件中全局表示注释 ()</p>
<h4 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h4><p>如果是自己解压安装, 或者自行编译的方式安装, 配置文件在:</p>
<ul>
<li>默认: <code>$WORKING_DIR/conf/defaults.ini</code></li>
<li>自定义:<code>$WORKING_DIR/conf/custom.ini</code></li>
<li>自定义配置文件路径可以被参数<code>--config</code>覆盖</li>
</ul>
<blockquote>
<p>对于<code>YUM</code> <code>RPM</code> 安装的方式, 配置文件在: <code>/etc/grafana/grafana.ini</code></p>
</blockquote>
<h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h4><p>可以使用以下语法使用环境变量来覆盖配置文件中的所有选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GF_&lt;SectionName&gt;_&lt;KeyName&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>SectionName</code>是方括号内的文本。一切都应为大写，<code>.</code>应替换为<code>_</code> 例如，给定以下配置设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default section</span></span><br><span class="line">instance_name = <span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line"></span><br><span class="line">[security]</span><br><span class="line">admin_user = admin</span><br><span class="line"></span><br><span class="line">[auth.google]</span><br><span class="line">client_secret = 0ldS3cretKey</span><br></pre></td></tr></table></figure>
<p>Then you can override them using:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GF_DEFAULT_INSTANCE_NAME=my-instance</span><br><span class="line"><span class="built_in">export</span> GF_SECURITY_ADMIN_USER=<span class="literal">true</span>	<span class="comment"># GF_ 固定 SECURITY 是SectionName ADMIN_USER 是配置的key 转大写 . 转 _</span></span><br><span class="line"><span class="built_in">export</span> GF_AUTH_GOOGLE_CLIENT_SECRET=newS3cretKey</span><br></pre></td></tr></table></figure>
<h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p><code>Grafana</code>支持使用<code>Sqlite3</code> <code>Postgresql</code> <code>Mysql</code>这三种数据库作为其<code>元数据</code>的存储.</p>
<p>我们课程使用<code>Mysql</code>. 和<code>zabbix</code>的元数据mysql共用一个实例</p>
<p>只需要配置如下内容即可:</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/26/20221026175713.png" alt="1573635500521"></p>
<p>并登陆mysql, 执行:</p>
<p><code>create database grafana CHARACTER SET utf8 COLLATE utf8_general_ci;</code></p>
<p>创建<code>Grafana</code>使用的数据库作为元数据存储.</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start grafana-server</span><br><span class="line">systemctl <span class="built_in">enable</span> grafana-server</span><br></pre></td></tr></table></figure>
<p>浏览器打开：<a href="http://node1:3000">http://node1:3000</a></p>
<p>默认账户密码：admin/admin</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记</title>
    <url>//vue%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h2 id="1-Vue-是什么"><a href="#1-Vue-是什么" class="headerlink" title="1.Vue 是什么"></a>1.Vue 是什么</h2><h3 id="1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架"><a href="#1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架" class="headerlink" title="1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架"></a>1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架</h3><p>基于数据渲染出用户看到的页面</p>
<ul>
<li>Vue 的两种使用方式：</li>
</ul>
<p>​        ① Vue 核心包开发</p>
<p>​                场景：局部 模块改造</p>
<p>​        ② Vue 核心包 &amp; Vue 插件 工程化开发</p>
<p>​                场景：整站 开发</p>
<h3 id="1-2-创建-Vue-实例，初始化渲染的核心步骤："><a href="#1-2-创建-Vue-实例，初始化渲染的核心步骤：" class="headerlink" title="1.2.创建 Vue 实例，初始化渲染的核心步骤："></a>1.2.创建 Vue 实例，初始化渲染的核心步骤：</h3><ol>
<li><p>准备容器</p>
</li>
<li><p>引包 (官网) - 开发版本 / 生产版本</p>
</li>
<li><p>创建 Vue 实例 new Vue()</p>
</li>
<li><p>指定配置项 el data =&gt; 渲染数据</p>
</li>
</ol>
<ul>
<li>① 通过el配置选择器 ，指定vue管理的是哪个盒子，作用跟vue脚手架中的main.js中的</li>
<li>$mount()作用一致</li>
<li>② data 提供数</li>
</ul>
<h3 id="1-3-插值表达式"><a href="#1-3-插值表达式" class="headerlink" title="1.3.插值表达式"></a>1.3.插值表达式</h3><p>插值表达式是一种 Vue 的模板语法</p>
<ol>
<li><p>作用: 利用表达式进行插值，渲染到页面中</p>
<p>​    表达式：是可以被求值的代码，JS引擎会将其计算出一个结果</p>
</li>
<li><p>语法：</p>
</li>
<li><p>注意点：</p>
<p>（1）使用的数据必须存在 （data） </p>
<p>（2）支持的是表达式，而非语句，比如：if for ..</p>
<p>（3）不能在标签属性中使用插值表达式</p>
</li>
</ol>
<h3 id="1-4-Vue-核心特性：响应"><a href="#1-4-Vue-核心特性：响应" class="headerlink" title="1.4.Vue 核心特性：响应"></a>1.4.Vue 核心特性：响应</h3><ul>
<li><p>​    数据的响应式处理 → 响应式：数据变化，视图自动更新</p>
<p>​        使用 Vue 开发，关注业务的核心逻辑，根据业务修改数据即可</p>
</li>
<li><p>​    如何访问或修改数据呢？</p>
<p>​        data中的数据, 最终会被添加到实例上</p>
<p>​            ① 访问数据： “实例.属性名”</p>
<p>​            ② 修改数据： “实例.属性名” = “值”</p>
</li>
</ul>
<h3 id="1-5-Vue-指令"><a href="#1-5-Vue-指令" class="headerlink" title="1.5.Vue 指令"></a>1.5.Vue 指令</h3><p>Vue 会根据不同的【指令】，针对标签实现不同的【功能】</p>
<p>​    指令：带有 v- 前缀 的 特殊 标签属性，不同属性 对应 不同的功能</p>
<p>v-html:作用：设置元素的 innerHTML语法：v-html = “表达式”</p>
<ul>
<li>​    动态解析标签</li>
</ul>
<pre><code>  msg: `
    &lt;a href=&quot;http://douyin.com&quot;&gt;
        抖音    
     &lt;/a&gt;
   ` 
</code></pre><p>​    msg里面不是引号，是Tab上面的 `号</p>
<p>v-show and v-if</p>
<p>v-show</p>
<ol>
<li><p>作用： 控制元素显示隐藏</p>
</li>
<li><p>语法： v-show = “表达式” 表达式值 true 显示， false 隐藏</p>
</li>
<li><p>原理： 切换 display:none 控制显示隐藏</p>
</li>
<li><p>场景： 频繁切换显示隐藏的场景</p>
</li>
</ol>
<p>v-if</p>
<ol>
<li><p>作用： 控制元素显示隐藏（条件渲染）</p>
</li>
<li><p>语法： v-if = “表达式” 表达式值 true 显示， false 隐藏</p>
</li>
<li><p>原理： 基于条件判断，是否 创建 或 移除 元素节点</p>
</li>
<li><p>场景： 要么显示，要么隐藏，不频繁切换的场景</p>
</li>
</ol>
<p>v-else v-else-if</p>
<ol>
<li><p>作用： 辅助 v-if 进行判断渲染</p>
</li>
<li><p>语法： v-else v-else-if = “表达式”</p>
</li>
<li><p>注意： 需要紧挨着 v-if 一起使用</p>
</li>
</ol>
<p>v-on</p>
<ul>
<li><p>作用： 注册事件 = 添加监听 + 提供处理逻辑</p>
</li>
<li><p>语法：① v-on:事件名 = “内联语句”        @click=”count++”</p>
<p> ​           ② v-on:事件名 = “methods中的函数名”</p>
</li>
<li><p>简写：@事件名        v-on:click替换成@click</p>
</li>
<li>注意：methods函数内的 this 指向 Vue 实例 </li>
</ul>
<p>v-bind</p>
<ol>
<li><p>作用： 动态的设置html的标签属性 → src url title ..</p>
</li>
<li><p>语法： v-bind:属性名=”表达式”</p>
</li>
<li><p>注意： 简写形式  :属性名=”表达式”</p>
<p>v-for</p>
</li>
<li><p>作用： 基于数据循环， 多次渲染整个元素</p>
</li>
<li><p>遍历数组语法：</p>
<ul>
<li>v-for = “(item, index) in 数组”</li>
<li>item 数组中的每一项数据， index 下标</li>
<li>也可以省略 index: v-for = “item in 数组“</li>
</ul>
</li>
<li>v-for 中的 key<ul>
<li>语法： :key属性 = “唯一标识”</li>
<li>key前面加:表示动态的属性值</li>
<li>作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。</li>
<li>key 的值必须具有 唯一性</li>
<li>推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li>
</ul>
</li>
<li>v-for 的默认行为会尝试 原地修改元素 （就地复用）</li>
</ol>
<p>v-model</p>
<ol>
<li><p>作用: 给 表单元素 使用, 双向数据绑定 → 可以快速 获取 或 设置 表单元素内容 </p>
<p>① 数据变化 → 视图自动更新 </p>
<p>② 视图变化 → 数据自动更新 </p>
</li>
<li><p>语法: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-model = &#x27;变量&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong><code>v-model.trim()</code></strong> 方法从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串。此上下文中的空格是指所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）。</p>
<p><strong><code>v-model.number()</code></strong> 方法可以将输入的数据转换为Number类型，否则虽然你输入的是数字.但它的类型其实是String</p>
<p><strong><code>v-model.lazy()</code></strong>方法失去焦点更新，并不是实时改变，而是在失去焦点或者按回车时才会更新，类似懒加载</p>
<h3 id="1-6-指令修饰符"><a href="#1-6-指令修饰符" class="headerlink" title="1.6.指令修饰符"></a>1.6.指令修饰符</h3><ul>
<li>通过 “.” 指明一些指令 后缀，不同 后缀 封装了不同的处理操作 → 简化代码</li>
<li>① 按键修饰符<ul>
<li>@keyup.enter → 键盘回车监听</li>
</ul>
</li>
<li>② v-model修饰符<ul>
<li>v-model.trim → 去除首尾空格</li>
<li>v-model.number → 转数字</li>
</ul>
</li>
<li>③ 事件修饰符<ul>
<li>@事件名.stop → 阻止冒泡</li>
<li>@事件名.prevent → 阻止默认行为</li>
</ul>
</li>
</ul>
<h3 id="1-7-v-bind-对于样式控制的增强"><a href="#1-7-v-bind-对于样式控制的增强" class="headerlink" title="1.7.v-bind 对于样式控制的增强"></a>1.7.v-bind 对于样式控制的增强</h3><ul>
<li>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 class 类名 和 style 行内样式 进行控制 。</li>
</ul>
<ol>
<li><p>操作class</p>
<ul>
<li><p>语法 :class = “对象/数组” </p>
<p>① 对象 → 键就是类名，值是布尔值。如果值为 true，有这个类，否则没有这个类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>​        适用场景：一个类名，来回切换</p>
<p>​            ② 数组 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表 v-bind 对于样式控制的增强 - 操作class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;[ 类名1, 类名2, 类名3 ]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>​        适用场景：批量添加或删除类</p>
</li>
<li><p>操作style</p>
<ul>
<li>语法 :style = “样式对象”</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :style=&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>​        适用场景：某个具体属性的动态设置</p>
<h3 id="1-8-v-model-应用于其他表单元素"><a href="#1-8-v-model-应用于其他表单元素" class="headerlink" title="1.8.v-model 应用于其他表单元素"></a>1.8.v-model 应用于其他表单元素</h3><ul>
<li>​    常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值</li>
<li>​        v-model 应用于其他表单元素</li>
<li>​    它会根据 控件类型 自动选取 正确的方法 来更新元素</li>
</ul>
<h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9.计算属性"></a>1.9.计算属性</h3><ul>
<li>概念：基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。</li>
<li>语法：</li>
<li>① 声明在 computed 配置项中，一个计算属性对应一个函数</li>
<li>② 使用起来和普通属性一样使用 </li>
<li>计算属性 → 可以将一段 求值的代码 进行封装</li>
</ul>
<h3 id="1-10-computed-计算属性-vs-methods-方法"><a href="#1-10-computed-计算属性-vs-methods-方法" class="headerlink" title="1.10. computed 计算属性 vs methods 方法"></a>1.10. computed 计算属性 vs methods 方法</h3><ul>
<li>computed 计算属性：<ul>
<li>作用：封装了一段对于数据的处理，求得一个结果。</li>
<li>语法：<ul>
<li>① 写在方法的配置项中</li>
<li>② 作为属性，直接使用 → this.计算属性 </li>
</ul>
</li>
<li>缓存特性（提升性能）：<ul>
<li>计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 → 并再次缓存</li>
</ul>
</li>
</ul>
</li>
<li>methods 方法：<ul>
<li>作用：给实例提供一个方法，调用以处理业务逻辑。</li>
<li>语法：<ul>
<li>① 写在方法的配置项中</li>
<li>② 作为方法，需要调用 → this方法 /( ) </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>//SpringBoot.html</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="一：开发"><a href="#一：开发" class="headerlink" title="一：开发"></a>一：开发</h2><h3 id="1-RestController"><a href="#1-RestController" class="headerlink" title="1.@RestController"></a>1.@RestController</h3><p>@RestController指在Spring中@RestController的作用等同于@Controller + @ResponseBody。</p>
<h3 id="2-REST风格"><a href="#2-REST风格" class="headerlink" title="2.REST风格"></a>2.REST风格</h3><p>2.1简介</p>
<p>​    按照REST风格访问资源时使用行为动作区分对资源进行了何种操作</p>
<p>​    <a href="http://localhost/users">http://localhost/users</a>        查询全部用户信息GET(查询)</p>
<p>​    <a href="http://localhost/users/1">http://localhost/users/1</a>        查询指定用户信息GET(查询)</p>
<p>​    <a href="http://localhost/users">http://localhost/users</a>        添加用户信息POST(新增/保存)</p>
<p>​    <a href="http://localhost/users">http://localhost/users</a>        修改用户信息PUT(修改/更新)</p>
<p>​    <a href="http://localhost/users/1">http://localhost/users/1</a>        删除用户信息DELETE（删除)</p>
<p>​    根据REST风格对资源进行访问称为RESTful</p>
<p>注意事项</p>
<p>​    上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范</p>
<p>​    描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、account..</p>
<p>2.2@GetMapping        查询</p>
<p>@PostMapping        添加</p>
<p>@PutMapping            修改</p>
<p>@DeleteMapping        删除</p>
<p>@PatchMapping        对资源数据打补丁或局部更新 </p>
<p>即<em>@GetMapping用于处理请求方法的GET类型，@ PostMapping用于处理请求方法的POST</em>类型等。</p>
<p>如果我们想使用传统的<em>@RequestMapping</em>注释实现URL处理程序，那么它应该是这样的：        </p>
<p>​    @RequestMapping(value = “/get/{id}”, method = RequestMethod.GET)</p>
<p>新方法可以简化为：</p>
<p>​    @GetMapping(“/get/{id}”)</p>
<h3 id="3-SpringBoot默认配置文件"><a href="#3-SpringBoot默认配置文件" class="headerlink" title="3.SpringBoot默认配置文件"></a>3.SpringBoot默认配置文件</h3><p>application.properties</p>
<p>基础配置</p>
<p>属性配置</p>
<p>​    修改配置</p>
<p>​    修改服务器端口</p>
<p>​        server.port=80</p>
<p>​    关闭运行日志图标（banner）</p>
<p>​        spring.main.banner-mode=off</p>
<p>​    设置日志相关</p>
<p>​        logging.level.root=debug</p>
<p>SpringBoot内置属性查询</p>
<p>​    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p>
<p>​    官方文档中参考文档第一项：Application Properties</p>
<h3 id="4-SpringBoot提供了3种配置文件的格式"><a href="#4-SpringBoot提供了3种配置文件的格式" class="headerlink" title="4.SpringBoot提供了3种配置文件的格式"></a>4.SpringBoot提供了3种配置文件的格式</h3><p>​        properties（传统格式/默认格式）</p>
<p>​        yml（主流格式）</p>
<p>​        yaml</p>
<p>SpringBoot配置文件加载顺序</p>
<p>​    application.properties &gt; application.yml &gt; application.yaml</p>
<p>​    常用配置文件种类</p>
<p>​        application.yml</p>
<p>4.1 配置文件间的加载优先级</p>
<p>​    properties（最高）</p>
<p>​    yml</p>
<p>​    yaml（最低）</p>
<p>4.2 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p>
<p>4.3 YAML（YAML Ain’t Markup Language），一种数据序列化格式</p>
<p>​    优点：</p>
<p>​        容易阅读</p>
<p>​        容易与脚本语言交互</p>
<p>​        以数据为核心，重数据轻格式</p>
<p>​    YAML文件扩展名</p>
<p>​        .yml（主流）</p>
<p>​        .yaml</p>
<p>4.4. yaml语法规则</p>
<p>​    大小写敏感</p>
<p>​    属性层级关系使用多行描述，每行结尾使用冒号结束</p>
<p>​    使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</p>
<p>​    属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</p>
<p>​    # 表示注释</p>
<p>​    注意：属性名冒号后面与数据之间有一个空格</p>
<p>4.5 字面值、对象数据格式、数组数据格式（略）</p>
<p>4.6 使用@Value配合SpEL读取单个数据</p>
<p>​    如果数据存在多层级，依次书写层级名称即可</p>
<p>​    使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}</p>
<p>​    yaml数据读取</p>
<p>​        1. 在配置文件中可以使用${属性名}方式引用属性值</p>
<p>​        2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</p>
<p>4.7     1. 使用Environment对象封装全部配置信息</p>
<p>​        2. 使用@Autowired自动装配数据到Environment对象中</p>
<p>4.8     @Component</p>
<p>​         @ConfigurationProperties(prefix = “datasource”)</p>
<pre><code>     1. 使用@ConfigurationProperties注解绑定配置信息到封装类中

     2. 封装类需要定义为Spring管理的bean，否则无法进行属性注入
</code></pre><h3 id="5-整合第三方技术"><a href="#5-整合第三方技术" class="headerlink" title="5.整合第三方技术"></a>5.整合第三方技术</h3><h4 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h4><p>​    1. 导入测试对应的starter    </p>
<p>​    2. 测试类使用@SpringBootTest修饰</p>
<p>​    3. 使用自动装配的形式添加要测试的对象</p>
<p>​    如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定</p>
<p>​        classes：设置SpringBoot启动类</p>
<p>​    小结：</p>
<p>​        1. 测试类如果存在于引导类所在包或子包中无需指定引导类</p>
<p>​        2. 测试类在引导启动类的父类，测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p>
<h4 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h4><p>​    1. 勾选MyBatis技术，也就是导入MyBatis对应的starter</p>
<p>​    2. 数据库连接相关信息转换成配置</p>
<p>​    3. 数据库SQL映射需要添加@Mapper被容器识别到</p>
<p>​    1. MySQL 8.X驱动强制要求设置时区</p>
<p>​        修改url，添加serverTimezone设定</p>
<p>​        修改MySQL数据库配置（略）</p>
<p>​    2. 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p>
<h4 id="整合MyBatis-Plus"><a href="#整合MyBatis-Plus" class="headerlink" title="整合MyBatis-Plus"></a>整合MyBatis-Plus</h4><p>1：手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取</p>
<p>​        由于SpringBoot中未收录MyBatis-Plus的坐标版本，需要指定对应的Version</p>
<p>2.数据层接口使用BaseMapper简化开发</p>
<p>3.需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</p>
<h4 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h4><ol>
<li><p>整合Druid需要导入Druid对应的starter</p>
</li>
<li><p>根据Druid提供的配置方式进行配置</p>
</li>
<li><p>整合第三方技术通用方式</p>
</li>
</ol>
<p>​        导入对应的starter</p>
<p>​        根据提供的配置格式，配置非默认值对应的配置项</p>
<h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><p>一个Java类库，提供了一组注解，简化POJO实体类开发</p>
<p>Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或eques方法，同时可以自动化日志变量。</p>
<p>lombok版本由SpringBoot提供，无需指定版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用注解：@Data</p>
<h3 id="7-开启日志"><a href="#7-开启日志" class="headerlink" title="7.开启日志"></a>7.开启日志</h3><p>使用配置方式开启日志，设置日志输出方式为标准输出，打印到控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">	configuration:</span><br><span class="line">		log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>
<h3 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h3><ol>
<li>使用IPage封装分页数据</li>
</ol>
<p>​    IPage对象中封装了分页操作中的所有数据</p>
<p>​    数据</p>
<p>​    当前页码值</p>
<p>​    每页数据总量</p>
<p>​    最大页码值</p>
<p>​    数据总量</p>
<ol>
<li>分页操作依赖MyBatisPlus分页拦截器实现功能</li>
</ol>
<p>​        分页操作是在MyBatisPlus的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能，</p>
<p>​        使用MyBatisPlus拦截器MybatisPlusInterceptor实现</p>
<ol>
<li>借助MyBatisPlus日志查阅执行SQL语句</li>
</ol>
<h3 id="9-条件查询"><a href="#9-条件查询" class="headerlink" title="9.条件查询"></a>9.条件查询</h3><ol>
<li><p>使用QueryWrapper对象封装查询条件</p>
</li>
<li><p>推荐使用LambdaQueryWrapper对象</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lqw.like(name != null,Book::getName,name);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>所有查询操作封装成方法调用</p>
</li>
<li><p>查询条件支持动态条件拼装</p>
</li>
</ol>
<h3 id="10-业务层开发"><a href="#10-业务层开发" class="headerlink" title="10.业务层开发"></a>10.业务层开发</h3><p>Service层接口定义与数据层接口定义具有较大区别，不要混用</p>
<p>​    selectByUserNameAndPassword(String username,String password);</p>
<p>​    login(String username,String password);</p>
<p>快速开发：</p>
<p>​    1. 使用通用接口（ISerivce）快速开发Service</p>
<p>​    2. 使用通用实现类（ServiceImpl）快速开发ServiceImpl</p>
<p>​    3. 可以在通用接口基础上做功能重载或功能追加</p>
<p>​    4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失</p>
<h3 id="11-表现层开发"><a href="#11-表现层开发" class="headerlink" title="11.表现层开发"></a>11.表现层开发</h3><p>1.基于Restful进行表现层接口开发</p>
<p>​    新增：POST</p>
<p>​    删除：DELETE</p>
<p>​    修改：PUT</p>
<p>​    查询：GET</p>
<p>2.接收参数</p>
<p>​    实体数据：@RequestBody</p>
<p>​    路径变量：@PathVariable</p>
<p>3.使用Postman测试表现层接口功能</p>
<h3 id="12-表现层消息一致性处理"><a href="#12-表现层消息一致性处理" class="headerlink" title="12.表现层消息一致性处理"></a>12.表现层消息一致性处理</h3><ol>
<li><p>设计统一的返回值结果类型便于前端开发读取数据</p>
</li>
<li><p>返回值结果类型可以根据需求自行设定，没有固定格式</p>
</li>
<li><p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p>
</li>
</ol>
<p>​    前后端协议联调</p>
<p>​        前后端分离结构设计中页面归属前端服务器</p>
<p>​        单体工程中页面放置在resources目录下的static目录中（建议执行clean）</p>
<h3 id="13-业务消息一致性处理"><a href="#13-业务消息一致性处理" class="headerlink" title="13.业务消息一致性处理"></a>13.业务消息一致性处理</h3><p>修改表现层返回结果的模型类，封装出现异常后对应的信息</p>
<p>​    flag：false</p>
<p>​    Data: null</p>
<p>​    消息(msg): 要显示信息</p>
<h2 id="二：运维"><a href="#二：运维" class="headerlink" title="二：运维"></a>二：运维</h2><h3 id="1-命令行启动常见问题及解决方案"><a href="#1-命令行启动常见问题及解决方案" class="headerlink" title="1.命令行启动常见问题及解决方案"></a>1.命令行启动常见问题及解决方案</h3><p>Windonws端口被占用</p>
<p># 查询端口</p>
<p>​    netstat -ano</p>
<p># 查询指定端口</p>
<p>​    netstat -ano |findstr “端口号”</p>
<p># 根据进程PID查询进程名称</p>
<p>​    tasklist |findstr “进程PID号”</p>
<p># 根据PID杀死任务</p>
<p>​    taskkill /F /PID “进程PID号”</p>
<p># 根据进程名称杀死任务</p>
<p>​    taskkill -f -t -im “进程名称”</p>
<h3 id="2-临时属性设置"><a href="#2-临时属性设置" class="headerlink" title="2.临时属性设置"></a>2.临时属性设置</h3><ol>
<li><p>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</p>
</li>
<li><p>临时属性添加方式：java –jar 工程名.jar –-属性名=值</p>
</li>
<li><p>多个临时属性之间使用空格分隔</p>
</li>
<li><p>临时属性必须是当前boot工程支持的属性，否则设置无效</p>
</li>
</ol>
<h3 id="3-传递启动属性"><a href="#3-传递启动属性" class="headerlink" title="3.传递启动属性"></a>3.传递启动属性</h3><p>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</p>
<p>​        //不希望用户在外面用临时参数覆盖掉你的参数</p>
<p>​        //为了安全性</p>
<p>​        SpringApplication.run(SsmpApplication.class);</p>
<h3 id="4-配置文件分类"><a href="#4-配置文件分类" class="headerlink" title="4.配置文件分类"></a>4.配置文件分类</h3><ol>
<li>SpringBoot中4级配置文件</li>
</ol>
<p>1级： file ：config/application.yml 【最高】</p>
<p>​    工程路径config目录中配置文件：服务于运维经理整体调控</p>
<p>2级： file ：application.yml</p>
<p>​    工程路径配置文件：服务于运维人员配置涉密线上环境</p>
<p>3级：classpath：config/application.yml</p>
<p>​    项目类路径config目录中配置文件：服务于项目经理整体调控</p>
<p>4级：classpath：application.yml 【最低】</p>
<p>​    项目类路径配置文件：服务于开发人员本机开发与测试</p>
<ol>
<li>作用：</li>
</ol>
<p>​    1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p>
<p>​    3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p>
<ol>
<li>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</li>
</ol>
<h3 id="5-多环境开发"><a href="#5-多环境开发" class="headerlink" title="5.多环境开发"></a>5.多环境开发</h3><ul>
<li>配置文件书写技巧（一）</li>
</ul>
<p>主配置文件中设置公共配置（全局）</p>
<p>环境分类配置文件中常用于设置冲突属性（局部）</p>
<ol>
<li><p>可以使用独立配置文件定义环境属性</p>
</li>
<li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p>
</li>
</ol>
<p>​        但properties文件多环境配置仅支持多文件格式</p>
<ul>
<li>多环境开发独立配置文件书写技巧（二）</li>
</ul>
<p>根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p>
<p>​    application-devDB.yml</p>
<p>​    application-devRedis.yml</p>
<p>​    application-devMVC.yml</p>
<p>从Spring2.4版开始使用group属性替代include属性，降低了配置书写量</p>
<p>​    使用group属性定义多种主环境与子环境的包含关系</p>
<p>​    spring:</p>
<p>​        profiles:</p>
<p>​        active: dev</p>
<p>​        group:</p>
<p>​            “dev”: devDB,devRedis,devMVC</p>
<p>​            “pro”: proDB,proRedis,proMVC</p>
<p>​            “test”: testDB,testRedis,testMVC</p>
<p>​            dev先加载，然后devDB,devRedis,devMVC依次加载，相同属性时，最后加载的环境属性生效</p>
<p>​    多环境开发使用group属性设置配置文件分组，便于线上维护管理</p>
<p>​        1. 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</p>
<p>​        2. 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</p>
<h3 id="6-日志基础操作"><a href="#6-日志基础操作" class="headerlink" title="6.日志基础操作"></a>6.日志基础操作</h3><p>日志（log）作用</p>
<p>​    编程期调试代码</p>
<p>​    运营期记录信息</p>
<p>​        记录日常运营重要信息（峰值流量、平均响应时长……）</p>
<p>​        记录应用报错信息（错误堆栈）</p>
<p>​        记录运维过程数据（扩容、宕机、报警……）</p>
<p>日志级别</p>
<p>​    TRACE：运行堆栈信息，使用率低</p>
<p>​    DEBUG：程序员调试代码使用</p>
<p>​    INFO：记录运维过程数据</p>
<p>​    WARN：记录运维过程报警数据</p>
<p>​    ERROR：记录错误堆栈信息</p>
<p>​    FATAL：灾难信息，合并计入ERROR</p>
<p>基于lombok提供的@Slf4j注解为类快速添加日志对象</p>
<p>日志输出格式控制</p>
<p><img src="https://s2.loli.net/2023/10/18/xuSDGiNVK8EsqrX.png" alt="截图"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">	pattern:</span><br><span class="line">		console: &quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span><br><span class="line">		%d：日期	</span><br><span class="line">		%m：消息</span><br><span class="line">		%n：换行</span><br></pre></td></tr></table></figure>
<h2 id="三、开发实用篇"><a href="#三、开发实用篇" class="headerlink" title="三、开发实用篇"></a>三、开发实用篇</h2><h3 id="1-启动热部署"><a href="#1-启动热部署" class="headerlink" title="1.启动热部署"></a>1.启动热部署</h3><p>​    开启开发者工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">	&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>激活热部署：Ctrl + F9    重新构建项目</p>
<p>关于热部署：热部署仅仅加载当前开发者自定义开发的资源，不加载jar资源</p>
<p>​    重启（Restart）：自定义开发代码，包含类、页面、配置文件等，加载位置restart类加载器</p>
<p>​    重载（ReLoad）：jar包，加载位置base类加载器</p>
<p>自动启动热部署</p>
<p>​    激活方式：Idea失去焦点5秒后启动热部署</p>
<p>热部署范围配置</p>
<p>​    默认不触发重启的目录列表</p>
<p>​        /META-INF/maven</p>
<p>​        /META-INF/resources</p>
<p>​        /resources</p>
<p>​        /static</p>
<p>​        /public</p>
<p>​        /templates</p>
<p>自定义不参与重启排除项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devtools:</span><br><span class="line">	restart:</span><br><span class="line">		exclude: public/**,static/**</span><br></pre></td></tr></table></figure>
<p>禁用热部署：设置高优先级属性禁用热部署</p>
<h3 id="2-ConfigurationProperties"><a href="#2-ConfigurationProperties" class="headerlink" title="2.@ConfigurationProperties"></a>2.@ConfigurationProperties</h3><p>@ConfigurationProperties</p>
<p>​    使用@ConfigurationProperties为第三方bean绑定属性</p>
<p>@EnableConfigurationProperties</p>
<p>​    @EnableConfigurationProperties（<em>*</em>.class）可以使加载的类不用加载为bean,也就是可以不用@Component注解</p>
<p>​        App类不用扫描bean,直接@Import(<em>*</em>.class)Enable注解的类加载进去    //降低耦合度</p>
<p>​    @EnableConfigurationProperties注解可以将使用@ConfigurationProperties注解对应的类加入Spring容器</p>
<p>​    @EnableConfigurationProperties与@Component不能同时使用    </p>
<p>解除使用@ConfigurationProperties注释警告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-宽松绑定"><a href="#3-宽松绑定" class="headerlink" title="3.宽松绑定"></a>3.宽松绑定</h3><p>@ConfigurationProperties绑定属性支持属性名宽松绑定</p>
<p>​    驼峰模式:ipAddress: 192.168.1.1</p>
<p>​    下划线模式:ip_address: 192.168.1.2</p>
<p>​    中划线模式 :ip-address: 192.168.1.3</p>
<p>​    常量模式:IP_ADDRESS: 192.168.1.4</p>
<p>宽松绑定不支持注解@Value引用单个属性的方式</p>
<p>绑定前缀名命名规范：仅能使用纯小写字母、数字、下划线作为合法的字符</p>
<p>数据校验:开启数据校验有助于系统安全性，J2EE规范中JSR303规范定义了一组有关数据校验相关的API</p>
<p>​    导入JSR303与Hibernate校验框架坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用@Validated注解启用校验功能</p>
<p>使用具体校验规则规范数据校验格式</p>
<p>注意：yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</p>
<h3 id="4-加载测试专用属性"><a href="#4-加载测试专用属性" class="headerlink" title="4.加载测试专用属性"></a>4.加载测试专用属性</h3><p>在启动测试环境时可以通过properties参数设置测试环境专用的属性</p>
<p>​    @SpringBootTest(properties = {“test.prop=testValue1”})    </p>
<p>​    优势：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效</p>
<p>在启动测试环境时可以通过args参数设置测试环境专用的传入参数</p>
<p>​    @SpringBootTest(args = {“—test.arg=testValue2”})</p>
<p>使用@Import注解加载当前测试类专用的配置</p>
<p>模拟端口</p>
<p>​    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p>
<p>业务层测试事务回滚</p>
<p>​    为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚</p>
<p>​    如果想在测试用例中提交事务，可以通过@Rollback注解设置</p>
<p>​    @Transactional</p>
<p>​    @Rollback(false)</p>
<p>使用随机数据替换测试用例中书写固定的数据，使用SpringBoot提供的随机数为其赋值</p>
<p>​    ${random.int}表示随机整数</p>
<p>​    ${random.int(10)}表示10以内的随机数</p>
<p>​    ${random.int(10,20)}表示10到20的随机数</p>
<p>​    其中()可以是任意字符，例如[]，!!均可</p>
<h3 id="5-数据层解决方案"><a href="#5-数据层解决方案" class="headerlink" title="5.数据层解决方案"></a>5.数据层解决方案</h3><p>• SQL</p>
<p>• NoSQL</p>
<p>​    现有数据层解决方案技术选型</p>
<p>​    数据源：DruidDataSource</p>
<p>​    持久化技术：MyBatis-Plus / MyBatis</p>
<p>​    数据库：MySQL</p>
<p>数据源配置</p>
<p>​    SpringBoot提供了3种内嵌的数据源对象供开发者选择</p>
<p>​        HikariCP：默认内置数据源对象</p>
<p>​        Tomcat提供DataSource：HikariCP不可用的情况下，且在web环境中，将使用tomcat服务器配置的数据源对象</p>
<p>​        Commons DBCP：Hikari不可用，tomcat数据源也不可用，将使用dbcp数据源</p>
<p>通用配置无法设置具体的数据源配置信息，仅提供基本的连接相关配置，如需配置，在下一级配置中设置具体设定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql://localhost:3306/ssm_db</span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">        hikari:</span><br><span class="line">            maximum-pool-size: 50</span><br></pre></td></tr></table></figure>
<p>内置持久化解决方案——JdbcTemplate</p>
<p>​    JdbcTemplate配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    jdbc:</span><br><span class="line">    template:</span><br><span class="line">        query-timeout: -1 # 查询超时时间</span><br><span class="line">        max-rows: 500 # 最大行数</span><br><span class="line">        fetch-size: -1 # 缓存行数</span><br></pre></td></tr></table></figure>
<p>内嵌数据库</p>
<p>SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率</p>
<p>​    H2，HSQL，Derby</p>
<p>Redis</p>
<p>Redis是一款key-value存储结构的内存级NoSQL数据库</p>
<p>​    支持多种数据存储格式</p>
<p>​    支持持久化</p>
<p>​    支持集群</p>
<p>Redis下载（ Windows版）</p>
<p>​    <a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>​    Redis安装与启动（ Windows版）</p>
<p>​    Windows解压安装或一键式安装</p>
<p>​    服务端启动命令</p>
<p>​        redis-server.exe redis.windows.conf</p>
<p>​    客户端启动命令</p>
<p>​        redis-cli.exe</p>
<p>lettcus与jedis区别</p>
<p>​    jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响。</p>
<p>​    lettcus(默认)基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作。</p>
<h3 id="6-Mongodb"><a href="#6-Mongodb" class="headerlink" title="6.Mongodb"></a>6.Mongodb</h3><p>MongoDB是一个开源、高性能、无模式的文档型数据库。NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库</p>
<p>新增：db.集合名称.insert/save/insertOne(文档)</p>
<p>修改：db.集合名称.update(条件，{操作种类:{文档}})</p>
<p>删除：db.集合名称.remove(条件)</p>
<ol>
<li>基础查询</li>
</ol>
<p>​    查询全部：db.集合.find();</p>
<p>​    查第一条：db.集合.findOne()</p>
<p>​    查询指定数量文档：db.集合.find().limit(10)         //查10条文档</p>
<p>​    跳过指定数量文档：db.集合.find().skip(20)         //跳过20条文档</p>
<p>​    统计：db.集合.count()</p>
<p>​    排序：db.集合.sort({age:1})                     //按age升序排序</p>
<p>​    投影：db.集合名称.find(条件,{name:1,age:1})     //仅保留name与age域</p>
<ol>
<li>条件查询</li>
</ol>
<p>​    基本格式：db.集合.find({条件})</p>
<p>​    模糊查询：db.集合.find({域名:/正则表达式/})     //等同SQL中的like，比like强大，可以执行正则所有规则</p>
<p>​    条件比较运算：db.集合.find({域名:{$gt:值}})         //等同SQL中的数值比较操作，例如：name&gt;18</p>
<p>​    包含查询：db.集合.find({域名:{$in:[值1，值2]}})     //等同于SQL中的in</p>
<p>​    条件连接查询：db.集合.find({$and:[{条件1},{条件2}]})     //等同于SQL中的and、or</p>
<p>配置客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	data:</span><br><span class="line">		mongodb:</span><br><span class="line">			uri: mongodb://localhost/itheima</span><br></pre></td></tr></table></figure>
<h3 id="7-ElasticSearch（ES）"><a href="#7-ElasticSearch（ES）" class="headerlink" title="7.ElasticSearch（ES）"></a>7.ElasticSearch（ES）</h3><p>1.创建/查询/删除索引</p>
<p>​    PUT <a href="http://localhost:9200/books">http://localhost:9200/books</a></p>
<p>​    GET <a href="http://localhost:9200/books">http://localhost:9200/books</a></p>
<p>​    DELETE <a href="http://localhost:9200/books">http://localhost:9200/books</a></p>
<p>​    用Ik分词器创建索引并指定规则</p>
<p>2.创建文档（往里面加数据）</p>
<p>​    POST <a href="http://localhost:9200/books/_doc">http://localhost:9200/books/_doc</a> #使用系统生成id</p>
<p>​    POST <a href="http://localhost:9200/books/_create/1">http://localhost:9200/books/_create/1</a> #使用指定id，</p>
<p>​    POST <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a> #使用指定id，不存在创建，存在更新（版本递增）</p>
<p>3.查询文档</p>
<p>​    GET <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a> #查询单个文档</p>
<p>​    GET <a href="http://localhost:9200/books/_search">http://localhost:9200/books/_search</a> #查询全部文档</p>
<p>4.条件查询</p>
<p>​    GET <a href="http://localhost:9200/books/_search?q=name:springboot">http://localhost:9200/books/_search?q=name:springboot</a></p>
<p>5.删除文档</p>
<p>​    DELETE <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a></p>
<p>6.修改文档（全量修改）</p>
<p>​    PUT <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:&quot;springboot&quot;,</span><br><span class="line">	&quot;type&quot;:&quot;springboot&quot;,</span><br><span class="line">	&quot;description&quot;:&quot;springboot&quot;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>7.修改文档（部分修改）</p>
<p>​    POST <a href="http://localhost:9200/books/_update/1">http://localhost:9200/books/_update/1</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">		&quot;name&quot;:&quot;springboot&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.idea导入坐标高级的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-整合第三方技术"><a href="#8-整合第三方技术" class="headerlink" title="8.整合第三方技术"></a>8.整合第三方技术</h3><p>缓存是一种介于数据永久存储介质与数据应用之间的数据临时存储介质</p>
<p>​    使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能</p>
<p>缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间</p>
<p>SpringBoot提供了缓存技术，方便缓存使用</p>
<p>SpringBoot提供的缓存技术除了提供默认的缓存方案，还可以对其他缓存技术进行整合，统一接口，方便缓存技术的开发与管理</p>
<p>​    Generic</p>
<p>​    JCache</p>
<p>​    Ehcache</p>
<p>​    Hazelcast</p>
<p>​    Infinispan</p>
<p>​    Couchbase</p>
<p>​    Redis</p>
<p>​    Caffeine</p>
<p>​    Simple（默认）</p>
<p>缓存供应商变更:memcached</p>
<p>SpringBoot未提供对memcached的整合，需要使用硬编码方式实现客户端初始化管理</p>
<p>缓存供应商变更:jetcache</p>
<p>jetCache对SpringCache进行了封装，在原有功能基础上实现了多级缓存、缓存统计、自动刷新、异步调用、数据报表等功能</p>
<p>jetCache设定了本地缓存与远程缓存的多级缓存解决方案</p>
<p>本地缓存（local）</p>
<p>​    LinkedHashMap</p>
<p>​    Caffeine</p>
<p>远程缓存（remote）</p>
<p>​    Redis</p>
<p>​    Tair</p>
<p>缓存供应商变更:j2cache</p>
<p>j2cache是一个缓存整合框架，可以提供缓存的整合方案，使各种缓存搭配使用，自身不提供缓存功能</p>
<p>基于 ehcache + redis 进行整合</p>
<p>​    加入j2cache坐标，加入整合缓存的坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;j2cache-spring-boot2-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.0-release&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;j2cache-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.4-release&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置使用j2cache（application.yml）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">j2cache:</span><br><span class="line">	config-location: j2cache.properties</span><br></pre></td></tr></table></figure>
<p>配置一级缓存与二级缓存以及一级缓存数据到二级缓存的发送方式（j2cache.properties）</p>
<p>​    # 配置1级缓存</p>
<p>​        j2cache.L1.provider_class = ehcache</p>
<p>​        ehcache.configXml = ehcache.xml</p>
<p>​    # 配置1级缓存数据到2级缓存的广播方式：可以使用redis提供的消息订阅模式，也可以使用jgroups多播实现</p>
<p>​        j2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</p>
<p>​    # 配置2级缓存</p>
<p>​        j2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProvider</p>
<p>​        j2cache.L2.config_section = redis</p>
<p>​        redis.hosts = localhost:6379</p>
<h3 id="9-SpringBoot整合Quartz"><a href="#9-SpringBoot整合Quartz" class="headerlink" title="9.SpringBoot整合Quartz"></a>9.SpringBoot整合Quartz</h3><p>相关概念</p>
<p>​    工作（Job）：用于定义具体执行的工作</p>
<p>​    工作明细（JobDetail）：用于描述定时工作相关的信息</p>
<p>​    触发器（Trigger）：用于描述触发工作的规则，通常使用cron表达式定义调度规则</p>
<p>​    调度器（Scheduler）：描述了工作明细与触发器的对应关系</p>
<h3 id="10-SpringBoot整合JavaMail"><a href="#10-SpringBoot整合JavaMail" class="headerlink" title="10.SpringBoot整合JavaMail"></a>10.SpringBoot整合JavaMail</h3><p>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件的传输协议</p>
<p>POP3（Post Office Protocol - Version 3）：用于接收电子邮件的标准协议</p>
<p>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</p>
<p>配置JavaMail</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	mail:</span><br><span class="line">	host: </span><br><span class="line">		smtp.qq.com</span><br><span class="line">		username: *********@qq.com</span><br><span class="line">		password: *********	</span><br></pre></td></tr></table></figure>
<h3 id="11-消息"><a href="#11-消息" class="headerlink" title="11.消息"></a>11.消息</h3><p>消息发送方：生产者</p>
<p>消息接收方：消费者</p>
<p>​    同步消息</p>
<p>​    异步消息</p>
<p>企业级应用中广泛使用的三种异步消息传递技术 JMS AMQP MQTT</p>
<p>JMS</p>
<p>​    JMS（Java Message Service）：一个规范，等同于JDBC规范，提供了与消息服务相关的API接口</p>
<p>JMS消息模型</p>
<p>​    peer-2-peer：点对点模型，消息发送到一个队列中，队列保存消息。队列的消息只能被一个消费者消费，或超时</p>
<p>​    publish-subscribe：发布订阅模型，消息可以被多个消费者消费，生产者和消费者完全独立，不需要感知对方的存在JMS消息种类</p>
<p>​    TextMessage</p>
<p>​    MapMessage</p>
<p>​    BytesMessage</p>
<p>​    StreamMessage</p>
<p>​    ObjectMessage</p>
<p>​    Message （只有消息头和属性）</p>
<p>JMS实现：ActiveMQ、Redis、HornetMQ、RabbitMQ、RocketMQ（没有完全遵守JMS规范）</p>
<p>AMQP</p>
<p>​    AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS</p>
<p>​    优点：具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现</p>
<p>AMQP消息模型</p>
<p>​    direct exchange</p>
<p>​    fanout exchange</p>
<p>​    topic exchange</p>
<p>​    headers exchange</p>
<p>​    system exchange</p>
<p>AMQP消息种类：byte[]</p>
<p>AMQP实现：RabbitMQ、StormMQ、RocketMQ</p>
<p>MQTT</p>
<p>​    MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一</p>
<p>Kafka</p>
<p>​    Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。</p>
<p>ActiveMQ</p>
<p>启动服务</p>
<p>​    activemq.bat</p>
<p>访问服务器</p>
<p>​    <a href="http://127.0.0.1:8161/">http://127.0.0.1:8161/</a></p>
<p>服务端口：61616，管理后台端口：8161</p>
<p>用户名&amp;密码：admin</p>
<p>SpringBoot整合ActiveMQ</p>
<p>配置ActiveMQ（采用默认配置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    activemq:</span><br><span class="line">        broker-url: tcp://localhost:61616</span><br><span class="line">    jms:</span><br><span class="line">        //发布订阅模式，是否一对多</span><br><span class="line">        pub-sub-domain: true</span><br><span class="line">        template:</span><br><span class="line">            default-destination: itheima</span><br></pre></td></tr></table></figure>
<p>SpringBoot整合RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置RabbitMQ （采用默认配置）</span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        port: 5672</span><br></pre></td></tr></table></figure>
<p>绑定键匹配规则</p>
<p>​    * (星号)： 用来表示一个单词 ，且该单词是必须出现的</p>
<p>​    # (井号)： 用来表示任意数量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配键</th>
<th>topic.<em>.</em></th>
<th>topic.#</th>
</tr>
</thead>
<tbody>
<tr>
<td>ic.order.id</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>order.topic.id</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>topic.sm.order.id</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>topic.sm.id</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>topic.id.order</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>topic.id</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>topic.order</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
</div>
<p>RocketMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置RocketMQ （采用默认配置）</span><br><span class="line">rocketmq:</span><br><span class="line">    name-server: localhost:9876</span><br><span class="line">    producer:</span><br><span class="line">        group: group_rocketmq</span><br></pre></td></tr></table></figure>
<p>Kafka</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置Kafka （采用默认配置）</span><br><span class="line">spring:</span><br><span class="line">    kafka:</span><br><span class="line">        bootstrap-servers: localhost:9092</span><br><span class="line">        consumer:</span><br><span class="line">            group-id: order</span><br></pre></td></tr></table></figure>
<h3 id="12-监控"><a href="#12-监控" class="headerlink" title="12.监控"></a>12.监控</h3><p>监控的意义</p>
<p>​    监控服务状态是否宕机</p>
<p>​    监控服务运行指标（内存、虚拟机、线程、请求等）</p>
<p>​    监控日志</p>
<p>​    管理服务（服务下线）</p>
<p>监控的实施方式</p>
<p>​    显示监控信息的服务器：用于获取服务信息，并显示对应的信息</p>
<p>​    运行的服务：启动时主动上报，告知监控服务器自己需要受到监控</p>
<p>可视化监控平台</p>
<p>​    Spring Boot Admin，开源社区项目，用于管理和监控SpringBoot应用程序。 客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Admin服务端</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">Admin客户端</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Admin服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure>
<p>设置启用Spring-Admin</p>
<p>​    启动类上加@EnableAdminServer</p>
<p>Admin客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    boot:</span><br><span class="line">        admin:</span><br><span class="line">            client:</span><br><span class="line">                url: http://localhost:8080</span><br><span class="line">management:</span><br><span class="line">    endpoint:</span><br><span class="line">        health:</span><br><span class="line">            show-details: always</span><br><span class="line">    endpoints:</span><br><span class="line">        web:</span><br><span class="line">            exposure:</span><br><span class="line">                include: &quot;*&quot;</span><br></pre></td></tr></table></figure>
<p>监控原理</p>
<p>​    Actuator提供了SpringBoot生产就绪功能，通过端点的配置与访问，获取端点信息</p>
<p>​    端点描述了一组监控信息，SpringBoot提供了多个内置端点，也可以根据需要自定义端点信息</p>
<p>​    访问当前应用所有端点信息：/actuator</p>
<p>​    访问端点详细信息：/actuator/端点名称</p>
<p>health 显示应用程序健康信息</p>
<p>info     显示应用程序信息</p>
<p>liquibase 显示已应用的 Liquibase 数据库迁移</p>
<p>metrics 显示当前应用程序的指标度量信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用指定端点</span><br><span class="line">management:</span><br><span class="line">    endpoint:</span><br><span class="line">        health: # 端点名称</span><br><span class="line">            enabled: true</span><br><span class="line">            show-details: always</span><br><span class="line">        beans: # 端点名称</span><br><span class="line">            enabled: true</span><br><span class="line">启用所有端点</span><br><span class="line">management:</span><br><span class="line">    endpoints:</span><br><span class="line">        enabled-by-default: true</span><br></pre></td></tr></table></figure>
<p>暴露端点功能</p>
<p>端点中包含的信息存在敏感信息，需要对外暴露端点功能时手动设定指定端点信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>management.endpoints.jmx.exposure.exclude</td>
<td></td>
</tr>
<tr>
<td>management.endpoints.jmx.exposure.include</td>
<td>*</td>
</tr>
<tr>
<td>management.endpoints.web.exposure.exclude</td>
<td></td>
</tr>
<tr>
<td>management.endpoints.web.exposure.include</td>
<td>info, health</td>
</tr>
</tbody>
</table>
</div>
<p>自定义监控指标</p>
<p>为info端点添加自定义指标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info:</span><br><span class="line">	appName: @project.artifactId@</span><br><span class="line">	version: @project.version@</span><br><span class="line">	author: itheima</span><br></pre></td></tr></table></figure>
<p>自定义端点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Endpoint(id=&quot;pay&quot;)</span><br><span class="line">public class PayEndPoint &#123;</span><br><span class="line">    @ReadOperation</span><br><span class="line">    public Object getPay()&#123;</span><br><span class="line">        //调用业务操作，获取支付相关信息结果，最终return出去</span><br><span class="line">        Map payMap = new HashMap();</span><br><span class="line">        payMap.put(&quot;level 1&quot;,103);</span><br><span class="line">        payMap.put(&quot;level 2&quot;,315);</span><br><span class="line">        payMap.put(&quot;level 3&quot;,666);</span><br><span class="line">        return payMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Bean"><a href="#13-Bean" class="headerlink" title="13.Bean"></a>13.Bean</h3><p>—@Configuration(proxyBeanMethods = true)    //默认为true</p>
<p>​    使用proxyBeanMethods=true可以保障调用此方法得到的对象是从容器中获取的而不是重新创建的</p>
<p>​    proxyBeanMethods=false    //每次bean创建一个新的对象</p>
<p>—导入实现了ImportSelector接口的类，实现对导入源的编程式处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector&#123;</span><br><span class="line">    public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        boolean flag = metadata.hasAnnotation(&quot;org.springframework.context.annotation.Import&quot;);</span><br><span class="line">        //各种各样的判断，判定完毕后，决定是否装在指定的bean</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            return new String[]&#123;&quot;com.itheima.domain.Dog&quot;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String[]&#123;&quot;com.itheima.domain.Cat&quot;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Import(MyImportSelector.class)    //dog类导入ImportSelector，可以查dog类中的所有信息</span><br><span class="line">public class dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—导入实现了ImportBeanDefinitionRegistrar接口的类，通过BeanDefinition的注册器注册实名bean，实现对容器中bean的裁定例如对现有bean的覆盖，进而达成不修改源代码的情况下更换实现的效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可以自定义bean的名称</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(dog.class).getBeanDefinition();</span><br><span class="line">            registry.registerBeanDefinition(&quot;yellow&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—导入实现了BeanDefinitionRegistryPostProcessor接口的类，通过BeanDefinition的注册器注册实名bean，实现对容器中bean的最终裁定    后处理器，最后进行裁决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;bookService&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.bean的加载控制</p>
<p>使用@Conditional注解的派生注解设置各种组合条件控制bean的加载</p>
<p>匹配指定类</p>
<p>​    @ConditionalOnClass(Mouse.class)</p>
<p>​    @ConditionalOnMissingClass(“com.itheima.bean.Wolf”)</p>
<p>匹配指定类型的bean</p>
<p>​    @ConditionalOnBean(Mouse.class)</p>
<p>​    @ConditionalOnBean(name=”com.itheima.bean.Mouse”)</p>
<p>​    @ConditionalOnBean(name=”jerry”)</p>
<p>匹配指定环境</p>
<p>​    @ConditionalOnWebApplication</p>
<p>​    @ConditionalOnNotWebApplication</p>
<p>自动配置原理</p>
<ol>
<li><p>收集Spring开发者的编程习惯，整理开发过程使用的常用技术列表——&gt;(技术集A)</p>
</li>
<li><p>收集常用技术(技术集A)的使用参数，整理开发过程中每个技术的常用设置列表——&gt;(设置集B)</p>
</li>
<li><p>初始化SpringBoot基础环境，加载用户自定义的bean和导入的其他坐标，形成初始化环境</p>
</li>
<li><p>将技术集A包含的所有技术都定义出来，在Spring/SpringBoot启动时默认全部加载</p>
</li>
<li><p>将技术集A中具有使用条件的技术约定出来，设置成按条件加载，由开发者决定是否使用该技术（与初始化环境比对）</p>
</li>
<li><p>将设置集B作为默认配置加载（约定大于配置），减少开发者配置工作量</p>
</li>
<li><p>开放设置集B的配置覆盖接口，由开发者根据自身需要决定是否覆盖默认配置</p>
</li>
</ol>
<p>变更自动配置</p>
<p>自定义自动配置（META-INF/spring.factories）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itheima.bean.CartoonCatAndMouse</span><br></pre></td></tr></table></figure>
<p>控制SpringBoot内置自动配置类加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    autoconfigure:</span><br><span class="line">        exclude: </span><br><span class="line">            - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span><br><span class="line">            - org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAutoConfiguration(excludeName = &quot;org.springframework.boot.autoconfigure.context.LifecycleAutoConfigurati</span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过配置文件exclude属性排除自动配置</p>
</li>
<li><p>通过注解@EnableAutoConfiguration属性排除自动配置项</p>
</li>
<li><p>启用自动配置只需要满足自动配置条件即可</p>
</li>
<li><p>可以根据需求开发自定义自动配置项</p>
</li>
</ol>
<p>15.自定义starter</p>
<p>案例：记录系统访客独立IP访问次数</p>
<p>​    1. 每次访问网站行为均进行统计</p>
<p>​    2. 后台每10秒输出一次监控信息（格式：IP+访问次数）</p>
<p>业务功能开发</p>
<p>​    1. 使用自动配置加载业务功能</p>
<p>​    2. 切记使用之前先clean后install安装到maven仓库，确保资源更新</p>
<p>开启定时任务功能</p>
<p>​    @EnableScheduling</p>
<p>​    @Scheduled(cron = “0/10 <em> </em> <em> </em> ?”)</p>
<p>​        1. 完成业务功能定时显示报表</p>
<p>​        2. String.format()</p>
<p>定义属性类，加载对应属性</p>
<p>​    @ConfigurationProperties(prefix = “tools.ip”)</p>
<p>配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">    ip:</span><br><span class="line">        cycle: 2</span><br><span class="line">        cycle-reset: false</span><br><span class="line">        mode: detail</span><br></pre></td></tr></table></figure>
<p>设置加载IpProperties类为bean,自定义bean名称</p>
<p>​    @Component(“ipProperties”)</p>
<p>放弃配置属性创建bean方式，改为手工控制</p>
<p>​    @Import(IpProperties.class)</p>
<p>使用#{beanName.attrName}读取bean的属性</p>
<p>​    @Scheduled(cron = “0/#{ipProperties.cycle} <em> </em> <em> </em> ?”)    //有配置文件，用配置文件的，没配置文件用自己定义的5秒</p>
<p>自定义拦截器</p>
<p>​    统计功能的调用，不可能在源码中把要加载的统计功能一个方法一个方法的全部配置上去</p>
<p>​    在所有的方法调用之前把统计功能执行一遍    Aop思想    在web层用拦截器，放到starter里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IpInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IpCountService ipCountService;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置核心配置类，加载拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    //将拦截器加载为bean</span><br><span class="line">    @Bean</span><br><span class="line">    public IpInterceptor ipInterceptor()&#123;</span><br><span class="line">        return new IpInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //注册拦截器，填写拦截的路径</span><br><span class="line">        registry.addInterceptor(ipInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助功能开发：开启yml的提示功能</p>
<p>导入配置处理器坐标    </p>
<p>在starter项目中加载坐标，复制出来META-INF/spring-configuration-metadata.json，配置好了消除坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>进行自定义提示功能开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hints&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;tools.ip.model&quot;,</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;value&quot;: &quot;detail&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;详细模式.&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;value&quot;: &quot;simple&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;极简模式.&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7开放及查看端口</title>
    <url>//centos7%E5%BC%80%E6%94%BE%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3.html</url>
    <content><![CDATA[<h1 id="centos7开放及查看端口"><a href="#centos7开放及查看端口" class="headerlink" title="centos7开放及查看端口"></a>centos7开放及查看端口</h1><p>1、开放端口</p>
<p><strong>firewall-cmd —zone=public —add-port=5672/tcp —permanent</strong>  # 开放5672端口</p>
<p><strong>firewall-cmd —zone=public —remove-port=5672/tcp —permanent</strong> #关闭5672端口</p>
<p><strong>firewall-cmd —reload</strong>  # 配置立即生效</p>
<ul>
<li>解释上面命令</li>
</ul>
<p>—zone=public：表示作用域为公共的；</p>
<p>—add-port=8080/tcp：添加tcp协议的端口8080；</p>
<p>—permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；</p>
<p>2、查看防火墙所有开放的端口</p>
<p><strong>firewall-cmd —zone=public —list-ports</strong></p>
<p>3.、关闭防火墙</p>
<p>如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估</p>
<p><strong>systemctl stop firewalld.service</strong></p>
<p>4、查看防火墙状态</p>
<p> <strong>firewall-cmd —state</strong></p>
<p>5、查看监听的端口</p>
<p><strong>netstat -lnpt</strong></p>
<p><img src="https://s2.loli.net/2023/10/11/6zbD2mlQsS9v5J1.png" alt="img"></p>
<p><em>PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</em></p>
<p>6、检查端口被哪个进程占用</p>
<p><strong>netstat -lnpt |grep 5672</strong></p>
<p><img src="https://s2.loli.net/2023/10/11/hcFqVa3iBAodZ94.png" alt="img"></p>
<p>7、查看进程的详细信息</p>
<p><strong>ps 6832</strong></p>
<p><img src="https://s2.loli.net/2023/10/11/XWMqx6gLJrIjFSA.png" alt="img"></p>
<p>8、中止进程</p>
<p><strong>kill -9 6832</strong></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>anaconda的默认位置修改pkgs以及默认创建环境踩坑</title>
    <url>//anaconda%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9pkgs%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%B8%A9%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="anaconda的默认位置修改pkgs以及默认创建环境踩坑"><a href="#anaconda的默认位置修改pkgs以及默认创建环境踩坑" class="headerlink" title="anaconda的默认位置修改pkgs以及默认创建环境踩坑"></a>anaconda的默认位置修改pkgs以及默认创建环境踩坑</h1><p>即可anaconda 的默认pkgs缓存位置以及创建环境位置 使用conda info 打印出来默认位置确实使你安装在d盘的位置但是由于d盘你没有给用户设置完全控制所以无法使用 即系统自动顺应到c盘去 所以只需要去你要修改的文件及右键属性点击安全选项给用户设置完全控制即可如图</p>
<p><img src="https://s2.loli.net/2023/11/22/UsHFv6NgJbzonGc.png" alt="image-20231122175804082"></p>
<p><img src="https://s2.loli.net/2023/11/22/FdO1I5GBismlxqz.png" alt="image-20231122175904116"></p>
<p><img src="https://s2.loli.net/2023/11/22/FCgtScvIyG5R4uN.png" alt="img"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud01</title>
    <url>//SpringCloud01.html</url>
    <content><![CDATA[<h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p>
<h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p>
<h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p><img src="https://s2.loli.net/2024/01/17/92LHaWx1PKo3EmR.png" alt=""></p>
<p>单体架构的优缺点如下：</p>
<p><strong>优点：</strong></p>
<ul>
<li>架构简单</li>
<li>部署成本低</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>耦合度高（维护困难、升级困难）</li>
</ul>
<h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<p><img src="https://s2.loli.net/2024/01/17/SmMNx476kbfwnKi.png" alt="image-20210713203124797"></p>
<p>分布式架构的优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低服务耦合</li>
<li>有利于服务升级和拓展</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务调用关系错综复杂</li>
</ul>
<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p>
<ul>
<li>服务拆分的粒度如何界定？</li>
<li>服务之间如何调用？</li>
<li>服务的调用关系如何管理？</li>
</ul>
<p>人们需要制定一套行之有效的标准来约束分布式架构。</p>
<h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/17/DvcdEMKtuSweNnB.png" alt="image-20210713203753373"></p>
<p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>
<p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p>
<p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p>
<p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p>
<h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud。">https://spring.io/projects/spring-cloud。</a></p>
<p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<p>其中常见的组件包括：</p>
<p><img src="https://s2.loli.net/2024/01/17/ZRNAn96IB8jF4as.png" alt="image-20210713204155887"></p>
<p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/3ud1fBUsvZIKF4S.png" alt="image-20210713205003790"></p>
<p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul>
<li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p>
</li>
<li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p>
</li>
<li><p>微服务：一种良好的分布式架构方案</p>
<p>①优点：拆分粒度更小、服务更独立、耦合度更低</p>
<p>②缺点：架构非常复杂，运维、监控、部署难度提高</p>
</li>
<li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p>
</li>
</ul>
<h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p>
<h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p>
<ul>
<li>不同微服务，不要重复开发相同业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/17/vTYUVJrPghGpM89.png" alt="image-20210713210800950"></p>
<h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/I3hzjZmEfabw7qn.png" alt="image-20210713211009593"></p>
<p>cloud-demo：父工程，管理依赖</p>
<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
</ul>
<p>要求：</p>
<ul>
<li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li>
<li>订单服务和用户服务都对外暴露Restful的接口</li>
<li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li>
</ul>
<h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p>
<p><img src="https://s2.loli.net/2024/01/17/627IG9rnNc4QuJV.png" alt="image-20210713211417049"></p>
<p>cloud-user表中初始数据如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/cEI4wmZrOMnbjCq.png" alt="image-20210713211550169"></p>
<p>cloud-order表中初始数据如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/lTRQxAeH9h5myu8.png" alt="image-20210713211657319"></p>
<p>cloud-order表中持有cloud-user表中的id字段。</p>
<h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p>
<p><img src="https://s2.loli.net/2024/01/17/ixRdUo98A7GKusj.png" alt="image-20210713211814094"></p>
<p>项目结构如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/7g291avCM6wuSsh.png" alt="image-20210713212656887"></p>
<p>导入后，会在IDEA右下角出现弹窗：</p>
<p><img src="https://s2.loli.net/2024/01/17/xKGXvycIsCa5B3O.png" alt="image-20210713212349272"></p>
<p>点击弹窗，然后按下图选择：</p>
<p><img src="https://s2.loli.net/2024/01/17/QvneG9blhqrDz1M.png" alt="image-20210713212336185"></p>
<p>会出现这样的菜单：</p>
<p><img src="https://s2.loli.net/2024/01/17/7Yr4BhxDCgleWaQ.png" alt="image-20210713212513324"></p>
<p>配置下项目使用的JDK：</p>
<p><img src="https://s2.loli.net/2024/01/17/r5bcDat2eIMEovF.png" alt="image-20210713220736408"></p>
<h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p>
<p><img src="https://s2.loli.net/2024/01/17/kTtFried9UIcZSY.png" alt="image-20210713212749575"></p>
<p>根据id查询订单，返回值是Order对象，如图：</p>
<p><img src="https://s2.loli.net/2024/01/17/UpHX2l7owMN5z9c.png" alt="image-20210713212901725"></p>
<p>其中的user为null</p>
<p>在user-service中有一个根据id查询用户的接口：</p>
<p><img src="https://s2.loli.net/2024/01/17/wRKIS78D2mpUNTO.png" alt="image-20210713213146089"></p>
<p>查询的结果如图：</p>
<p><img src="https://s2.loli.net/2024/01/17/aqxvBZjRkhsl3L8.png" alt="image-20210713213213075"></p>
<h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p>
<p><img src="https://s2.loli.net/2024/01/17/RWVf3eJ21zncbPY.png" alt="image-20210713213312278"></p>
<p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/{userId}这个接口。">http://localhost:8081/user/{userId}这个接口。</a></p>
<p>大概的步骤是这样的：</p>
<ul>
<li>注册一个RestTemplate的实例到Spring容器</li>
<li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li>
<li>将查询的User填充到Order对象，一起返回</li>
</ul>
<h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p>
<p><img src="https://s2.loli.net/2024/01/17/TNqfsYCvpJ8b2zr.png" alt="image-20210713213959569"></p>
<h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p>
<p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p>
<p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>
<p><img src="https://s2.loli.net/2024/01/17/5UmeKzBCIlDdX2q.png" alt="image-20210713214404481"></p>
<p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p>
<p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p>
<ul>
<li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li>
<li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li>
</ul>
<p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p>
<h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p>
<p><img src="https://s2.loli.net/2024/01/17/1njUicMVCvRKmGF.png" alt="image-20210713214925388"></p>
<p>大家思考几个问题：</p>
<ul>
<li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li>
<li>有多个user-service实例地址，order-service调用时该如何选择？</li>
<li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li>
</ul>
<h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/1yJkVR3WmjIhZfb.png" alt="image-20210713220104956"></p>
<p>回答之前的各个问题。</p>
<p>问题1：order-service如何得知user-service实例地址？</p>
<p>获取地址信息的流程如下：</p>
<ul>
<li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li>
<li>eureka-server保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li>
</ul>
<p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p>
<ul>
<li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
<p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p>
<ul>
<li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li>
<li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service拉取服务时，就能将故障实例排除了</li>
</ul>
<blockquote>
<p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p>
</blockquote>
<p>因此，接下来我们动手实践的步骤包括：</p>
<p><img src="https://s2.loli.net/2024/01/17/djzulJ3b2eUOFPK.png" alt="image-20210713220509769"></p>
<h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p>
<h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p>
<p><img src="https://s2.loli.net/2024/01/17/OlpHe7k6EoCZUtq.png" alt="image-20210713220605881"></p>
<p>填写模块信息：</p>
<p><img src="https://s2.loli.net/2024/01/17/wBNptDUIP8G4Eg3.png" alt="image-20210713220857396"></p>
<p>然后填写服务信息：</p>
<p><img src="https://s2.loli.net/2024/01/17/haABi2GQwRsXY4c.png" alt="image-20210713221339022"></p>
<h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086">http://127.0.0.1:10086</a></p>
<p>看到下面结果应该是成功了：</p>
<p><img src="https://s2.loli.net/2024/01/17/9rzCUHeGJ2WnyRl.png" alt="image-20210713222157190"></p>
<h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p>
<h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>
<h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p>
<p>首先，复制原来的user-service启动配置：</p>
<p><img src="https://s2.loli.net/2024/01/17/6hJG4qPlZ2kFcQX.png" alt="image-20210713222656562"></p>
<p>然后，在弹出的窗口中，填写信息：</p>
<p><img src="https://s2.loli.net/2024/01/17/TXHZJrhAKCocEV4.png" alt="image-20210713222757702"></p>
<p>现在，SpringBoot窗口会出现两个user-service启动配置：</p>
<p><img src="https://s2.loli.net/2024/01/17/5pCnOiXaxdBkv9c.png" alt="image-20210713222841951"></p>
<p>不过，第一个是8081端口，第二个是8082端口。</p>
<p>启动两个user-service实例：</p>
<p><img src="https://s2.loli.net/2024/01/17/vsHC6zDWZgPGcl2.png" alt="image-20210713223041491"></p>
<p>查看eureka-server管理页面：</p>
<p><img src="https://s2.loli.net/2024/01/17/nRczFH2bCP6KkNE.png" alt="image-20210713223150650"></p>
<h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p>
<h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p>
<p>在order-service的pom文件中，引入下面的eureka-client依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p>
<p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>
<h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p>
<p>不过这些动作不用我们去做，只需要添加一些注解即可。</p>
<p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p>
<p><img src="https://s2.loli.net/2024/01/17/U2kIdu9m7gqxPwe.png" alt="image-20210713224049419"></p>
<p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p>
<p><img src="https://s2.loli.net/2024/01/17/kMl7pdOytr5qi4g.png" alt="image-20210713224245731"></p>
<p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p>
<h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p>
<h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p>
<p><img src="https://s2.loli.net/2024/01/17/65njkPFGIeY4bJ1.png" alt="image-20210713224517686"></p>
<p>那么我们发出的请求明明是<a href="http://userservice/user/1，怎么变成了http://localhost:8081的呢？">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p>
<h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p>
<p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>
<p>我们进行源码跟踪：</p>
<h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://s2.loli.net/2024/01/17/eHqCOK5jAyg1sNR.png" alt="1525620483637"></p>
<p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li>
</ul>
<p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p>
<h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p>
<p><img src="https://s2.loli.net/2024/01/17/JLPZpVeIqAMW6FR.png" alt="1525620787090"></p>
<p>代码是这样的：</p>
<ul>
<li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li>
<li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li>
</ul>
<p>放行后，再次访问并跟踪，发现获取的是8081：</p>
<p> <img src="https://s2.loli.net/2024/01/17/ZGl7HLwrpbhieXo.png" alt="1525620835911"></p>
<p>果然实现了负载均衡。</p>
<h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p>
<p> <img src="D:/BaiduNetdiskDownload/1%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SpringCloud+RabbitMQ+Docker+Redis+%E6%90%9C%E7%B4%A2+%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AF%BE%E7%A8%8B/%E5%AE%9E%E7%94%A8%E7%AF%87/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/day01-SpringCloud01/%E8%AE%B2%E4%B9%89/assets/1525620835911.png" alt="1525620835911"></p>
<p>我们继续跟入：</p>
<p><img src="https://s2.loli.net/2024/01/17/IzOKLjQkR3SmpUx.png" alt="1544361421671"></p>
<p>继续跟踪源码chooseServer方法，发现这么一段代码：</p>
<p> <img src="https://s2.loli.net/2024/01/17/nmvc8jHuGqi6SFz.png" alt="1525622652849"></p>
<p>我们看看这个rule是谁：</p>
<p> <img src="https://s2.loli.net/2024/01/17/w8vmYcftKEgXzVh.png" alt="1525622699666"></p>
<p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p>
<p> <img src="https://s2.loli.net/2024/01/17/VyNSAYoJmvukjd4.png" alt="1525622754316"></p>
<p>这不就是轮询的意思嘛。</p>
<p>到这里，整个负载均衡的流程我们就清楚了。</p>
<h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p>
<p><img src="https://s2.loli.net/2024/01/17/OuSN5cFs1gGaRhb.png" alt="image-20210713224724673"></p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1，发起真实请求">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p>
<p><img src="https://s2.loli.net/2024/01/17/6jVQO4BYWP9K2I1.png" alt="image-20210713225653000"></p>
<p>不同规则的含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody>
</table>
</div>
<p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p>
<h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p>
</blockquote>
<h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure>
<h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p>
<h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p>
<p><img src="https://s2.loli.net/2024/01/17/gu2HFPRb6AqEZCc.png" alt="image-20210713230444308"></p>
<p>安装方式可以参考课前资料《Nacos安装指南.md》</p>
<h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p>
<p>主要差异在于：</p>
<ul>
<li>依赖不同</li>
<li>服务地址不同</li>
</ul>
<h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p>
</blockquote>
<h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：不要忘了注释掉eureka的地址</p>
</blockquote>
<h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p>
<p><img src="https://s2.loli.net/2024/01/17/Fdv1Vc3b89SJqaW.png" alt="image-20210713231439607"></p>
<h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p>
<p><img src="https://s2.loli.net/2024/01/17/D8219YpFItCx63o.png" alt="image-20210713232522531"></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p>
<p><img src="https://s2.loli.net/2024/01/17/t9XqINFYVzM6sAB.png" alt="image-20210713232658928"></p>
<p>杭州机房内的order-service应该优先访问同机房的user-service。</p>
<h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>
<p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p>
<p><img src="https://s2.loli.net/2024/01/17/Sa68mFCu4dh2MLO.png" alt="image-20210713232916215"></p>
<p>我们再次复制一个user-service启动配置，添加属性：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure>
<p>配置如图所示：</p>
<p><img src="https://s2.loli.net/2024/01/17/I4BmWLaTiPFgOw5.png" alt="image-20210713233528982"></p>
<p>启动UserApplication3后再次查看nacos控制台：</p>
<p><img src="https://s2.loli.net/2024/01/17/Xib1lqHjfkNp8y2.png" alt="image-20210713233727923"></p>
<h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>
<p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>
<p>1）给order-service配置集群信息</p>
<p>修改order-service的application.yml文件，添加集群配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>
<p>2）修改负载均衡规则</p>
<p>修改order-service的application.yml文件，修改负载均衡规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>
<p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p>
<p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p>
<p><img src="https://s2.loli.net/2024/01/17/tiv8RMpbFIodTmW.png" alt="image-20210713235133225"></p>
<p>在弹出的编辑窗口，修改权重：</p>
<p><img src="https://s2.loli.net/2024/01/17/mGw1TLoWQt36IuP.png" alt="image-20210713235235219"></p>
<blockquote>
<p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p>
</blockquote>
<h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/17/FiljC12XNyWzQhT.png" alt="image-20210714000101516"></p>
<h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p>
<p><img src="https://s2.loli.net/2024/01/17/UFPV7hEKL5Rw69e.png" alt="image-20210714000414781"></p>
<p>我们可以点击页面新增按钮，添加一个namespace：</p>
<p><img src="https://s2.loli.net/2024/01/17/BXq5TlOsw1xHctn.png" alt="image-20210714000440143"></p>
<p>然后，填写表单：</p>
<p><img src="https://s2.loli.net/2024/01/17/dGPY18zaA2FbHmu.png" alt="image-20210714000505928"></p>
<p>就能在页面看到一个新的namespace：</p>
<p><img src="https://s2.loli.net/2024/01/17/S2C5DMksPXyux7b.png" alt="image-20210714000522913"></p>
<h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p>
<p>例如，修改order-service的application.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>
<p>重启order-service后，访问控制台，可以看到下面的结果：</p>
<p><img src="https://s2.loli.net/2024/01/17/QYNd6xRo3fsGrtZ.png" alt="image-20210714000830703"></p>
<p><img src="https://s2.loli.net/2024/01/17/n4QW2CRHiS3r7xm.png" alt="image-20210714000837140"></p>
<p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p>
<p><img src="https://s2.loli.net/2024/01/17/wS1ZYKW8ntgqR9o.png" alt="image-20210714000941256"></p>
<h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p>
<ul>
<li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p>
</li>
<li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p>
</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure>
<p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<p><img src="https://s2.loli.net/2024/01/17/Y9eb81wyuXUKFZJ.png" alt="image-20210714001728017"></p>
<ul>
<li><p>Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li><p>Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud02</title>
    <url>//SpringCloud02.html</url>
    <content><![CDATA[<h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p>
<p><img src="https://s2.loli.net/2024/01/17/3CAHf7cwLtluOoZ.png" alt="image-20210714164426792"></p>
<p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>
<h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p>
<p><img src="https://s2.loli.net/2024/01/17/ZRyrqQXTk4MP8V2.png" alt="image-20210714164742924"></p>
<p>然后在弹出的表单中，填写配置信息：</p>
<p><img src="https://s2.loli.net/2024/01/17/erjiYf2vNoD8Kz6.png" alt="image-20210714164856664"></p>
<blockquote>
<p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
<h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p>
<p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p>
<p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p>
<p><img src="https://s2.loli.net/2024/01/17/MDvz9Ab5g6Zyxje.png" alt="img"></p>
<p>1）引入nacos-config依赖</p>
<p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）添加bootstrap.yaml</p>
<p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>
<p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p>
<p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>
<p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p>
<p><img src="https://s2.loli.net/2024/01/17/a71jnliMTYgKJzu.png" alt="image-20210714170845901"></p>
<p>3）读取nacos配置</p>
<p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p>
<p><img src="https://s2.loli.net/2024/01/17/ukVhC1Sm8lNeUpX.png" alt="image-20210714170337448"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在页面访问，可以看到效果：</p>
<p><img src="https://s2.loli.net/2024/01/17/2dJ9vgNcobmaCOQ.png" alt="image-20210714170449612"></p>
<h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>
<p>要实现配置热更新，可以使用两种方式：</p>
<h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p>
<p><img src="https://s2.loli.net/2024/01/17/THhsDOvnkC4odRL.png" alt="image-20210714171036335"></p>
<h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p>
<p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UserController中使用这个类代替@Value：</p>
<p><img src="https://s2.loli.net/2024/01/17/kHB6FJbPRCwUtpr.png" alt="image-20210714171316124"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p>
<ul>
<li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p>
</li>
<li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p>
</li>
</ul>
<p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p>
<p>下面我们通过案例来测试配置共享</p>
<h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p>
<p><img src="https://s2.loli.net/2024/01/17/mdhlncrL34OEA61.png" alt="image-20210714173233650"></p>
<h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p>
<p><img src="https://s2.loli.net/2024/01/17/li1oQT5mhjGZYMJ.png" alt="image-20210714173324231"></p>
<p>在user-service服务中，修改UserController，添加一个方法：</p>
<p><img src="https://s2.loli.net/2024/01/17/6OT9eSFmPqvjZHY.png" alt="image-20210714173721309"></p>
<h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p>
<p><img src="https://s2.loli.net/2024/01/17/eR6bhPCKAz15cwn.png" alt="image-20210714173538538"></p>
<p><img src="https://s2.loli.net/2024/01/17/e4yDgZPaEWO58wQ.png" alt="image-20210714173519963"></p>
<p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p>
<p>启动UserApplication和UserApplication2</p>
<p>访问<a href="http://localhost:8081/user/prop，结果：">http://localhost:8081/user/prop，结果：</a></p>
<p><img src="https://s2.loli.net/2024/01/17/dRnzXCVLP2BFKal.png" alt="image-20210714174313344"></p>
<p>访问<a href="http://localhost:8082/user/prop，结果：">http://localhost:8082/user/prop，结果：</a></p>
<p><img src="https://s2.loli.net/2024/01/17/WzRBIq2Emh5brSO.png" alt="image-20210714174424818"></p>
<p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p>
<h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p>
<p><img src="https://s2.loli.net/2024/01/17/8Yf6VUrEX9eRLaq.png" alt="image-20210714174623557"></p>
<h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p>
<p><img src="https://s2.loli.net/2024/01/17/zqjbXtsPvonpVEi.png" alt="image-20210714174728042"></p>
<h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p>
<p><img src="https://s2.loli.net/2024/01/17/MnHlKtViz3daF8g.png" alt="image-20210714174814204"></p>
<p>存在下面的问题：</p>
<p>•代码可读性差，编程体验不统一</p>
<p>•参数复杂URL难以维护</p>
<p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p>
<p><img src="https://s2.loli.net/2024/01/17/BFifqN2KX81Uwe7.png" alt="image-20210714174918088"></p>
<h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p>
<h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p>
<p><img src="https://s2.loli.net/2024/01/17/Y8Kg793PhvwedQb.png" alt="image-20210714175102524"></p>
<h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li>请求路径：/user/{id}</li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p>
<h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p>
<p><img src="https://s2.loli.net/2024/01/17/pQAS3XLbH2DdTiI.png" alt="image-20210714175415087"></p>
<p>是不是看起来优雅多了。</p>
<h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p>
<p>① 引入依赖</p>
<p>② 添加@EnableFeignClients注解</p>
<p>③ 编写FeignClient接口</p>
<p>④ 使用FeignClient中定义的方法代替RestTemplate</p>
<h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注解</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody>
</table>
</div>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p>
<p>下面以日志为例来演示如何自定义配置。</p>
<h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>
<p>也可以针对所有服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>
<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>
<p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>
<h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p>
<p>•URLConnection：默认实现，不支持连接池</p>
<p>•Apache HttpClient ：支持连接池</p>
<p>•OKHttp：支持连接池</p>
<p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p>
<p>这里我们用Apache的HttpClient来演示。</p>
<p>1）引入依赖</p>
<p>在order-service的pom文件中引入Apache的HttpClient依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）配置连接池</p>
<p>在order-service的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>
<p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p>
<p><img src="https://s2.loli.net/2024/01/17/Fph1wn85IDTkzim.png" alt="image-20210714185925910"></p>
<p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p>
<p><img src="https://s2.loli.net/2024/01/17/6RrPgE1HzYQbZXL.png" alt="image-20210714190041542"></p>
<p>总结，Feign的优化：</p>
<p>1.日志级别尽量用basic</p>
<p>2.使用HttpClient或OKHttp代替URLConnection</p>
<p>①  引入feign-httpClient依赖</p>
<p>②  配置文件开启httpClient功能，设置连接池参数</p>
<h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p>
<p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p>
<p>feign客户端：</p>
<p><img src="https://s2.loli.net/2024/01/17/PLgvIzVWkfRr4he.png" alt="image-20210714190542730"></p>
<p>UserController：</p>
<p><img src="https://s2.loli.net/2024/01/17/69QAy4Ots7nx2PT.png" alt="image-20210714190528450"></p>
<p>有没有一种办法简化这种重复的代码编写呢？</p>
<h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p>
<p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p>
<p>2）Feign客户端和Controller都集成改接口</p>
<p><img src="https://s2.loli.net/2024/01/17/1le63WxNRGu8mfP.png" alt="image-20210714190640857"></p>
<p>优点：</p>
<ul>
<li>简单</li>
<li>实现了代码共享</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>服务提供方、服务消费方紧耦合</p>
</li>
<li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p>
</li>
</ul>
<h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p>
<p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><img src="https://s2.loli.net/2024/01/17/UGEnDf4sJaVWz12.png" alt="image-20210714214041796"></p>
<h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p>
<p><img src="https://s2.loli.net/2024/01/17/OZhc9z5P8YKjiAt.png" alt="image-20210714204557771"></p>
<p>项目结构：</p>
<p><img src="https://s2.loli.net/2024/01/17/FKWYr9DtsRzBek2.png" alt="image-20210714204656214"></p>
<p>在feign-api中然后引入feign的starter依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p>
<p><img src="https://s2.loli.net/2024/01/17/nBkiDSwUXRrVpf7.png" alt="image-20210714205221970"></p>
<h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p>
<p>在order-service的pom文件中中引入feign-api的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p>
<h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714205623048.png" alt="image-20210714205623048"></p>
<p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p>
<p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p>
<h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p>
<p>指定Feign应该扫描的包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<p>指定需要加载的Client接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure>
<h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li>请求路由</li>
<li>权限控制</li>
<li>限流</li>
</ul>
<p>架构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714210131152.png" alt="image-20210714210131152"></p>
<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p>
<ol>
<li>创建SpringBoot工程gateway，引入网关依赖</li>
<li>编写启动类</li>
<li>编写基础配置和路由规则</li>
<li>启动网关服务进行测试</li>
</ol>
<h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714210919458.png" alt="image-20210714210919458"></p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure>
<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>
<h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714211908341.png" alt="image-20210714211908341"></p>
<h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714211742956.png" alt="image-20210714211742956"></p>
<p>总结：</p>
<p>网关搭建步骤：</p>
<ol>
<li><p>创建项目，引入nacos服务发现和gateway依赖</p>
</li>
<li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p>
</li>
</ol>
<p>路由配置包括：</p>
<ol>
<li><p>路由id：路由的唯一标示</p>
</li>
<li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p>
</li>
<li><p>路由断言（predicates）：判断路由的规则，</p>
</li>
<li><p>路由过滤器（filters）：对请求或响应做处理</p>
</li>
</ol>
<p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p>
<h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p>
<p>例如Path=/user/**是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p>
<p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method=GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query=name, Jack或者-  Query=name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
</tr>
</tbody>
</table>
</div>
<p>我们只需要掌握Path这种路由工程就可以了。</p>
<h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714212312871.png" alt="image-20210714212312871"></p>
<h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p>
<blockquote>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p>
</blockquote>
<p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>
<p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p>
<h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p>
<p>① 对路由的请求或响应做加工处理，比如添加请求头</p>
<p>② 配置在路由下的过滤器只对当前路由的请求生效</p>
<p>defaultFilters的作用是什么？</p>
<p>① 对所有路由都生效的过滤器</p>
<h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p>
<h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p>
<p>定义方式是实现GlobalFilter接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在filter中编写自定义逻辑，可以实现下列功能：</p>
<ul>
<li>登录状态判断</li>
<li>权限校验</li>
<li>请求限流等</li>
</ul>
<h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p>
<ul>
<li><p>参数中是否有authorization，</p>
</li>
<li><p>authorization参数值是否为admin</p>
</li>
</ul>
<p>如果同时满足则放行，否则拦截</p>
<p>实现：</p>
<p>在gateway中定义一个过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p>
<p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714214228409.png" alt="image-20210714214228409"></p>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li>
</ul>
<p>详细内容，可以查看源码：</p>
<p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p>
<p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p>
<h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p>
<ul>
<li><p>域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com</p>
</li>
<li><p>域名相同，端口不同：localhost:8080和localhost8081</p>
</li>
</ul>
<p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p>
<p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714215713563.png" alt="image-20210714215713563"></p>
<p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p>
<p>可以在浏览器控制台看到下面的错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20210714215832675.png" alt="image-20210714215832675"></p>
<p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p>
<h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>//git.html</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1．什么是-Git-仓库"><a href="#1．什么是-Git-仓库" class="headerlink" title="1．什么是 Git 仓库?"></a>1．什么是 Git 仓库?</h2><p>记录文件状态内容和历史记录的地方(.git文件夹)</p>
<h2 id="2．如何创建Git仓库"><a href="#2．如何创建Git仓库" class="headerlink" title="2．如何创建Git仓库?"></a>2．如何创建Git仓库?</h2><p>1.把本地文件夹转换成Git仓库:命令git init</p>
<p>2.从其他服务器上克隆Git仓库</p>
<h2 id="3-Git的三个区域"><a href="#3-Git的三个区域" class="headerlink" title="3 .    Git的三个区域"></a>3 .    Git的三个区域</h2><p>Git 使用时:</p>
<p>工作区:实际开发时操作的文件夹</p>
<p>暂存区:保存之前的准备区域（暂存改动过的文件)</p>
<p>版本库:提交并保存暂存区中的内容，产生一个版本快照</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git add 文件名</td>
<td>暂存指定文件</td>
</tr>
<tr>
<td>git add .</td>
<td>保存到暂存区，暂存所有改动的文件</td>
</tr>
<tr>
<td>git commit -m “注释说明”</td>
<td>保存到版本库，提交并保存，产生版本快照</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://s2.loli.net/2023/08/27/SpN3vhQYbmdnBt9.png" alt="img"></p>
<h2 id="4-Git文件状态"><a href="#4-Git文件状态" class="headerlink" title="4 .    Git文件状态"></a>4 .    Git文件状态</h2><p>Git文件2种状态:</p>
<p>未跟踪:新文件，从未被Git管理过</p>
<p>已跟踪:Git已经知道和管理的文件（新添加，未修改，已修改）</p>
<p>使用:修改文件，暂存，提交保存记录，如此反复</p>
<ul>
<li>使用git status -s查看文件状态</li>
<li>第一列是暂存区状态</li>
<li>第二列是工作区状态</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件状态</th>
<th>概念</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>未跟踪（U）</td>
<td>从未被Git管理过</td>
<td>新文件</td>
</tr>
<tr>
<td>新添加（A）</td>
<td>第一次被Git暂存</td>
<td>之前版本记录无此文件</td>
</tr>
<tr>
<td>未修改（’’）</td>
<td>三个区域统一</td>
<td>提交后保存</td>
</tr>
<tr>
<td>已修改（M）</td>
<td>工作区内容无变化</td>
<td>修改了内容产生</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-Git暂存区使用"><a href="#5-Git暂存区使用" class="headerlink" title="5 .    Git暂存区使用"></a>5 .    Git暂存区使用</h2><p>暂存区:暂时存储，可以临时恢复代码内容，与版本库解耦</p>
<p>暂存区-&gt;覆盖-&gt;工作区，命令: git restore目标文件（注意∶完全确认覆盖时使用)</p>
<p>从暂存区移除文件，命令: git rm —cached目标文件</p>
<p>查看暂存区的内容，命令：git ls-files</p>
<p>查看之前所有的提交历史，命令：git log —oneline</p>
<p><img src="https://s2.loli.net/2023/08/27/8ys6h3CiZSFlkgf.png" alt="image-20230827133555585"></p>
<h2 id="6-Git回退版本"><a href="#6-Git回退版本" class="headerlink" title="6 .    Git回退版本"></a>6 .    Git回退版本</h2><p>概念:把版本库某个版本对应的内容快照，恢复到工作区/暂存区查看</p>
<p>提交历史:git log —oneline</p>
<p>查看所有的历史:git reflog —oneline</p>
<p>回退命令:</p>
<p>git reset —soft 版本号（其他文件未跟踪)    css，js暂存区工作区全部保留</p>
<p>git reset —hard 版本号    css，js暂存区工作区不保留直接删除，先恢复暂存区，再恢复工作区</p>
<p>git reset —mixed版本号(与git reset等价)    暂存区不保留，工作区保留</p>
<p>注意1:只有记录在版本库的提交记录才能恢复<br>注意2:回退后，继续修改-&gt;暂存-&gt;提交操作即可（产生新的提交记录过程)</p>
<h2 id="7-分支"><a href="#7-分支" class="headerlink" title="7 .    分支"></a>7 .    分支</h2><p>概念:本质上是指向提交节点的可变指针，默认名字是master</p>
<p>注意:HEAD指针影响工作区/暂存区的代码状态，指向哪个分支使用哪个分支</p>
<p>场景:开发新需求/修复Bug，保证主线代码随时可用，多人协同开发提高效率</p>
<h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1 . 创建分支"></a>1 . 创建分支</h3><p>1.创建分支命令:git branch 分支名，以HEAD指针指向的分支作为起点来创建分支</p>
<p>2.切换分支命令:git checkout 分支名，使HEAD指向这个分支，就能来操控这个分支</p>
<h3 id="2-合并并删除"><a href="#2-合并并删除" class="headerlink" title="2 .  合并并删除"></a>2 .  合并并删除</h3><p>1．切回到要合入的分支上: git checkout master</p>
<p>2．合并其他分支过来:git merge login-bug</p>
<p>3．删除合并后的分支指针: git branch -d login-bug</p>
<ul>
<li>合并的时候出现合并冲突，两个分支都修改了这个文件</li>
</ul>
<ol>
<li>先将合并文件修改成想要的，然后add，提交上去</li>
<li>提交的时候，加个-i参数，如<code>git commit -m &quot;手动处理文件合并问题&quot; b1.txt -i</code></li>
</ol>
<p>第二个分支合并：合并提交，发生于原分支产生了新的提交记录后，再合并回去时发生，自动使用多个快照记录合并后产生一次新的提交</p>
<p><img src="https://s2.loli.net/2023/08/27/39qTPKuyeYSEJsf.png" alt="QQ图片20230827202417"></p>
<p>注意:提交记录的顺序按照产生的先后顺序排列，而非合并的先后顺序</p>
<p><img src="https://s2.loli.net/2023/08/27/GJaUh5bkmH2xVnv.png" alt="image-20230827202532657"></p>
<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><img src="https://s2.loli.net/2023/08/27/V1HzftLTnRh9dcF.png" alt="QQ图片20230827211901"></p>
<p><img src="https://s2.loli.net/2023/08/27/d1i3QAqLgbVNo79.png" alt="QQ图片20230827211907"></p>
<p><img src="https://s2.loli.net/2023/08/31/YKAMmq1GZoaVCe7.png" alt="QQ图片20230831120423"></p>
<h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>git tag</th>
<th>列出已有的标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>git tag [name]</td>
<td>创建标签</td>
</tr>
<tr>
<td>git push [shortName] [name]</td>
<td>将标签推送到远程仓库</td>
</tr>
<tr>
<td>git checkout -b [branch] [name]</td>
<td>检出标签</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>//nginx.html</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="1-Nginx介绍"><a href="#1-Nginx介绍" class="headerlink" title="1. Nginx介绍"></a>1. Nginx介绍</h2><p>Nginx是一款轻量级的web 服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有: 百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h2 id="2-Nginx下载和安装"><a href="#2-Nginx下载和安装" class="headerlink" title="2. Nginx下载和安装"></a>2. Nginx下载和安装</h2><p>安装过程:</p>
<p>1、安装依赖包 <code>yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</code><br>2、下载Nginx安装包<code>wget https://nginx.org/download/nginx-1.16.1.tar.gz</code><br>3、解压 <code>tar -zxvf nginx-1.16.1.tar.gz</code><br>4、<code>cd nginx-1.16.1</code><br>5、<code>./configure --prefix=/usr/local/nginx</code><br>6、<code>make &amp;&amp; make install</code></p>
<h2 id="3-nginx命令"><a href="#3-nginx命令" class="headerlink" title="3. nginx命令"></a>3. nginx命令</h2><p><code>./nginx -v</code>：查看nginx版本</p>
<p><code>./nginx -t</code>：检查配置文件的正确性</p>
<p><code>./nginx</code>：启动nginx</p>
<p><code>./nginx -s stop</code>：停止nginx</p>
<p><code>ps -ef | grep nginx</code>：查看nginx进程</p>
<p><code>./nginx -s reload</code>：重启nginx</p>
<h2 id="4-配置文件结构"><a href="#4-配置文件结构" class="headerlink" title="4. 配置文件结构"></a>4. 配置文件结构</h2><p>Nginx配置文件(conf/nginx.conf)整体分为三部分</p>
<ul>
<li>全局块        和Nginx运行相关的全局配置</li>
<li>events块    和网络连接相关的配置</li>
<li>http块        代理、缓存、日志记录、虚拟主机配置<ul>
<li>http全局块</li>
<li>Server块<ul>
<li>Server全局块</li>
<li>location块</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意: http块中可以配置多个Server块，每个Server块中可以配置多个location块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240221174139896.png" alt="image-20240221174139896"></p>
<h2 id="5-nginx应用"><a href="#5-nginx应用" class="headerlink" title="5. nginx应用"></a>5. nginx应用</h2><h3 id="1-部署静态资源"><a href="#1-部署静态资源" class="headerlink" title="1.部署静态资源"></a>1.部署静态资源</h3><p>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。<br>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中<br>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;	#监听端口</span><br><span class="line">	server_name localhost;	#服务器名称</span><br><span class="line">    location / &#123;		#匹配客户端请求url</span><br><span class="line">        root html:	#指定静态资源根目录</span><br><span class="line">        index index.html;	#指定默认首页</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h3><ul>
<li>正向代理</li>
</ul>
<p>是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。<br>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。<br>正向代理一般是在客户端设置代理服务器，通过代理服务器转发请求，最终访问到目标服务器，俗称梯子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240221175906908.png" alt="image-20240221175906908"></p>
<ul>
<li>反向代理</li>
</ul>
<p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。<br>用户不需要知道目标服务器的地址，也无须在用户端作任何设定</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240221183425739.png" alt="image-20240221183425739"></p>
<ul>
<li>配置反向代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen 82;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://192.168.138.101:8080;		#反向代理配置，将请求转发到指定服务</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240221193302357.png" alt="image-20240221193302357"></p>
<h3 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h3><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群进行性能的水平扩展以及避免单点故障出现。</p>
<ul>
<li>应用集群:将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</li>
<li>负载均衡器:将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240221193910268.png" alt="image-20240221193910268"></p>
<p>配置负载均衡:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream targetserver&#123;		#upstream指令可以定义一组服务器</span><br><span class="line">	server 192.168.138.101:8080 weight=10;</span><br><span class="line">	server 192.168.138.101:8081 weight=5;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 8080;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://targetserver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负载均衡策略：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>//Python%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h1 id="1-python基础"><a href="#1-python基础" class="headerlink" title="1 . python基础"></a>1 . python基础</h1><p>print()可以输出多份内容，多份内容可以用”,”隔开</p>
<h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1 . 注释"></a>1 . 注释</h2><p>单行注释：以 # 开头，# 右边的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用</p>
<p>注意,#号和注释内容一般建议以一个空格隔开</p>
<p>多行注释： 以 一对三个双引号 引起来 (“”” “””)来解释说明一段代码的作用使用方法</p>
<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2 . 类型转换"></a>2 . 类型转换</h2><p>type()查看数据的类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语句（函数）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象x转换为一个字符数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3 . 字符串格式化"></a>3 . 字符串格式化</h2><div class="table-container">
<table>
<thead>
<tr>
<th>格式符号</th>
<th>转化</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>将内容转化为字符串，放入占位位置</td>
</tr>
<tr>
<td>%d</td>
<td>将内容转化为整数，放入占位位置</td>
</tr>
<tr>
<td>%f</td>
<td>将内容转化为浮点型，放入占位位置</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>数字精度控制</li>
</ul>
<p>我们可以使用辅助符号”m.n”来控制数据的宽度和精度</p>
<ul>
<li><p>m，控制宽度，要求是数字（很少使用),设置的宽度小于数字自身，不生效</p>
</li>
<li><p>.n，控制小数点精度，要求是数字，会进行小数的四舍五入</p>
<p>示例:</p>
</li>
<li><p>%5d:表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成   11，用三个空格补足宽度。</p>
</li>
<li><p>.%5.2f:表示将宽度控制为5，将小数点精度设置为2</p>
</li>
<li><p>小数点和小数部分也算入宽度计算。</p>
</li>
</ul>
<p>快速格式化</p>
<ul>
<li>f”内容{变量}”</li>
</ul>
<p>例子</p>
<ul>
<li>print(f”我是{name}”)</li>
</ul>
<h2 id="4-if语句"><a href="#4-if语句" class="headerlink" title="4 . if语句"></a>4 . if语句</h2><ol>
<li>if elif else语句的作用是?<br>可以完成多个条件的判断</li>
<li>使用if elif else的注意点有:<br>elif可以写多个<br>判断是互斥且有序的，上一个满足后面的就不会判断了<br>可以在条件判断中，直接写input语句，节省代码量</li>
</ol>
<h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5 . 循环语句"></a>5 . 循环语句</h2><ol>
<li><p>whlie循环</p>
<p>while 条件：</p>
<p>​        条件满足时，做的事情</p>
</li>
<li><p>for循环</p>
<p>语法格式是:<br>for 临时变量 in 待处理数据集(序列）:</p>
<pre><code>    循环满足条件时执行的代码
</code></pre></li>
<li><p>while循环和for循环，都是循环语句，但细节不同:。</p>
<ul>
<li>在循环控制上:</li>
</ul>
<p>while循环可以自定循环条件﹐并自行控制<br>for循环不可以自定循环条件，只可以一个个从容器内取出数据。</p>
<ul>
<li>在无限循环上:</li>
</ul>
<p>while循环可以通过条件控制做到无限循环<br>for循环理论上不可以，因为被遍历的容器容量不是无限的</p>
<ul>
<li>在使用场景上:</li>
</ul>
<p>while循环适用于任何想要循环的场景<br>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</p>
</li>
</ol>
<h2 id="6-range语句"><a href="#6-range语句" class="headerlink" title="6 . range语句"></a>6 . range语句</h2><ul>
<li><p>语法1:</p>
</li>
<li><p>range(num)</p>
</li>
</ul>
<p>获取一个从0开始，到num结束的数字序列（不含num本身)</p>
<p>如range(5)取得的数据是:[0,1,2,3,4]</p>
<ul>
<li><p>语法2:</p>
</li>
<li><p>range(num1,num2)</p>
</li>
</ul>
<p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p>
<p>如,range(5,10)取得的数据是:[5,6,7,8,9]</p>
<ul>
<li><p>语法3:</p>
</li>
<li><p>range(num1, num2, step)</p>
</li>
</ul>
<p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p>
<p>数字之间的步长，以step为准(step默认为1)</p>
<p>如，range(5,10,2)取得的数据是:[5,7,9]</p>
<h2 id="7-循环中断"><a href="#7-循环中断" class="headerlink" title="7 . 循环中断"></a>7 . 循环中断</h2><ul>
<li>continue：中断本次循环，直接进入下一次循环</li>
<li>break：直接结束整个循环</li>
</ul>
<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8 . 函数"></a>8 . 函数</h2><ul>
<li>函数的定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">	函数名</span><br><span class="line">	<span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的返回值：函数执行完之后，返回给调用者的结果</li>
</ul>
<p>函数体遇到return后就结束了，卸载return后面的代码不执行</p>
<p>1.什么是None</p>
<p>None是类型’NoneType’的字面量，用于表示:空的、无意义的</p>
<p>2.函数如何返回None</p>
<p>不使用return语句即返回None</p>
<p>主动return None</p>
<p>3.使用场景<br>函数返回值<br>if判断<br>变量定义(赋值为None，表示暂时不提供值)</p>
<h2 id="9-变量"><a href="#9-变量" class="headerlink" title="9 . 变量"></a>9 . 变量</h2><p>1.什么是局部变量<br>    作用范围在函数内部，在函数外部无法使用<br>2.什么是全局变量<br>    在函数内部和外部均可使用<br>3.如何将函数内定义的变量声明为全局变量<br>    使用global关键字，global变量</p>
<h2 id="10-数据容器"><a href="#10-数据容器" class="headerlink" title="10 . 数据容器"></a>10 . 数据容器</h2><h3 id="1-列表list"><a href="#1-列表list" class="headerlink" title="1 . 列表list"></a>1 . 列表list</h3><ul>
<li>list() 空列表</li>
<li>列表排序<ul>
<li>列表.sort(key=选择排序依据的函数，reverse=True l False)<ul>
<li>参数key，是要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排序的依据。</li>
<li>参数reverse，是否反转排序结果，True表示降序，False表示升序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/06/uPUwFhj6o5lM1ds.png" alt="QQ图片20230906211908"></p>
<h3 id="2-元组tuple"><a href="#2-元组tuple" class="headerlink" title="2 . 元组tuple"></a>2 . 元组tuple</h3><ul>
<li>空元组( )，tuple()</li>
<li>注意：不可修改内容（可以修改内部list的内部元素）</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/06/ezOmdgCiJI2XH3D.png" alt="QQ图片20230906215231"></p>
<ul>
<li>zip(列表1, 列表2, …..)将多个列表对应的位置的元素组合成元组，并返回这个zip对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">b = [<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">c = [<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line"><span class="built_in">print</span>(d)		 //&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000026C1B719300</span>&gt;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d))   //[(<span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>), (<span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>), (<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="3-字符串str"><a href="#3-字符串str" class="headerlink" title="3 . 字符串str"></a>3 . 字符串str</h3><ul>
<li><p>“ “</p>
</li>
<li><p>字符串的比较大小，基于数字的ASCII码表的码值来进行比较</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/06/DJMGCRn1gNdcjBH.png" alt="QQ图片20230906221041"></p>
<h3 id="4-序列的切片"><a href="#4-序列的切片" class="headerlink" title="4 . 序列的切片"></a>4 . 序列的切片</h3><ul>
<li><p>序列：列表，元组，字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列[起始:结束:步长]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​    起始可以省略，省略从头开始<br>​    结束可以省略，省略到尾结束（不包含尾）<br>​    步长可以省略，省略步长为1（可以为负数，表示倒序执行，负一表示反转)</p>
<h3 id="5-集合str"><a href="#5-集合str" class="headerlink" title="5 . 集合str"></a>5 . 集合str</h3><ul>
<li>set( )，定义空集合</li>
<li>无序，去重</li>
<li>不支持下标索引访问</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/07/dCvGrIDVcf2A1QF.png" alt="QQ图片20230907103350"></p>
<h3 id="6-字典dict"><a href="#6-字典dict" class="headerlink" title="6 . 字典dict"></a>6 . 字典dict</h3><ul>
<li><p>字典{key:value,key:value}</p>
</li>
<li><p>空字典{}，dict()</p>
</li>
<li>不可以使用下标索引</li>
<li>获取value：字典[key]</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/07/s89whRZQWfMGYtN.png" alt="QQ图片20230907115521"></p>
<p>直接对字典进行遍历，每一次循环得到的是key</p>
<p><img src="https://s2.loli.net/2023/09/07/t5ZQukl1ymvacRg.png" alt="QQ图片20230907191822"></p>
<ul>
<li>容器的通用操作</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/07/nHgRM8pNySkIYja.png" alt="QQ图片20230907193354"></p>
<h2 id="11-函数进阶"><a href="#11-函数进阶" class="headerlink" title="11 . 函数进阶"></a>11 . 函数进阶</h2><ul>
<li>一个函数有多个返回值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">x,y,z = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>
<ul>
<li>函数多种传参方式</li>
</ul>
<p>1.掌握位置参数<br>    根据参数位置来传递参数<br>2.掌握关键字参数<br>    通过“键=值”形式传递参数,可以不限参数顺序·可以和位置参数混用，位置参数需在前<br>3.掌握缺省参数<br>    不传递参数值时会使用默认的参数值-默认值的参数必须定义在最后<br>4.掌握不定长参数<br>    位置不定长传递以<em>号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args<br>    关键字不定长传递以*</em>号标记一个形式参数，以字典的形式接受参数,形式参数一般命名为kwargs</p>
<ul>
<li>函数作为参数传递</li>
</ul>
<ol>
<li>函数本身是可以作为参数，传入另一个函数中进行使用</li>
<li>将函数传入的作用在于：传入计算逻辑，而非传入数据</li>
</ol>
<ul>
<li>lambda匿名函数</li>
</ul>
<p>函数的定义中</p>
<ul>
<li><p>def关键字，可以定义带有名称的函数</p>
</li>
<li><p>lambda关键字，可以定义匿名函数（无名称)</p>
</li>
</ul>
<p>有名称的函数，可以基于名称重复使用。</p>
<p>无名称的匿名函数，只可临时使用一次。</p>
<ul>
<li>匿名函数定义语法:</li>
<li>lambda传入参数:函数体(一行代码)</li>
</ul>
<p>lambda是关键字，表示定义匿名函数</p>
<p>传入参数表示匿名函数的形式参数，如:x, y表示接收2个形式参数</p>
<p>函数体，就是函数的执行逻辑，要注意:只能写一行，无法写多行代码</p>
<h2 id="12-python文件操作"><a href="#12-python文件操作" class="headerlink" title="12 . python文件操作"></a>12 . python文件操作</h2><h3 id="1-文件的读取操作"><a href="#1-文件的读取操作" class="headerlink" title="1 . 文件的读取操作"></a>1 . 文件的读取操作</h3><p><img src="https://s2.loli.net/2023/09/08/OoH3e9LfnGXuQCY.png" alt="QQ图片20230908194004"></p>
<ul>
<li>open中的encoding是“编码格式”</li>
<li>encoding顺序不是第三位，所以不能用位置参数，使用关键字参数直接指定</li>
<li>mode有三种访问文件模式</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/08/LgqxHhYFp1leCN6.png" alt="QQ图片20230908194729"></p>
<h3 id="2-文件的写入操作"><a href="#2-文件的写入操作" class="headerlink" title="2 . 文件的写入操作"></a>2 . 文件的写入操作</h3><ul>
<li>w和a都可以进行写入操作</li>
<li>flush()，刷新内容到硬盘</li>
<li>close()，带有flush()的功能</li>
<li>可以用”\n”来写出换行符</li>
</ul>
<h2 id="13-异常，模块，包"><a href="#13-异常，模块，包" class="headerlink" title="13 . 异常，模块，包"></a>13 . 异常，模块，包</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1 . 异常"></a>1 . 异常</h3><p>1.为什么要捕获异常?</p>
<p>在可能发生异常的地方，进行捕获。当异常出现的时候，提供解决方式，而不是任由其导致程序无法运行。</p>
<p>2.捕获异常的语法?</p>
<p>[ ]表示可选</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">	可能要发生异常的语句</span><br><span class="line"><span class="keyword">except</span>[异常 <span class="keyword">as</span> 别名:]</span><br><span class="line">	出现异常的准备手段</span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">	未出现异常时应做的事情</span><br><span class="line">[<span class="keyword">finally</span>:]</span><br><span class="line">	不管出不出现异常都会做的事情</span><br></pre></td></tr></table></figure>
<p>3.如何捕获所有异常?</p>
<p>异常的种类多种多样，如果想要不管什么类型的异常都能捕获到，那么<br>使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">except</span>:</span><br><span class="line"><span class="number">2.</span><span class="keyword">except</span> Exception:</span><br></pre></td></tr></table></figure>
<p>4.异常的传递性</p>
<p>想要捕获异常，并不需要真正的深入的最底层的代码中进行捕获，只有你的函数有调用关系，我们在最顶级的可以调用直接捕获异常，因为会传递</p>
<h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2 . 模块"></a>2 . 模块</h3><ul>
<li><p>模块就是一个Python代码文件，内含类、函数、变量等，我们可以导入进行使用。</p>
</li>
<li><p>模块的导入</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块 | 类 | 变量 | 函数 | *] [<span class="keyword">as</span> 别名]</span><br></pre></td></tr></table></figure>
<p>常用的组合形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类、变量、方法等</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义模块</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/09/Hg7KDxnuBieq29r.png" alt="QQ图片20230909144743"></p>
<h3 id="3-包"><a href="#3-包" class="headerlink" title="3 . 包"></a>3 . 包</h3><p><img src="https://s2.loli.net/2023/09/09/KqxtFfP3z96Gl7o.png" alt="QQ图片20230909144743"></p>
<ul>
<li>导入包的方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">import</span> 包名.模块名</span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure>
<h2 id="14-json"><a href="#14-json" class="headerlink" title="14 . json"></a>14 . json</h2><ol>
<li><p>json:是一种轻量级的数据交互格式,采用完全独立于编程语言的文本格式来存储和表示数据（就是字符串)<br> Python语言使用JSON有很大优势，因为:JSON无非就是python的一个单独的字典或一个内部元素都是字典的列表<br> 所以JSON可以直接和Python的字典或列表进行无缝转换。</p>
</li>
<li><p>json格式数据转化<br> 通过json. dumps (data)方法把python数据转化为了json数据</p>
<p>​    data = json. dumps (data)</p>
<p>​    如果有中文可以带上: ensure_ascii=False参数来确保中文正常转换</p>
<p>通过json.loads (data)方法把josn数据转化为了python列表或字典</p>
</li>
<li><p><code>loads</code>操作的是字符串</p>
</li>
<li><p><code>load</code>操作的是文件流</p>
<p>​    data = json.loads(data)</p>
</li>
</ol>
<h1 id="2-python面向对象"><a href="#2-python面向对象" class="headerlink" title="2 . python面向对象"></a>2 . python面向对象</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 . 对象"></a>1 . 对象</h2><ul>
<li>函数：类外面的函数叫函数</li>
<li>方法：类内部的函数叫方法</li>
</ul>
<p>1.在程序中设计表格，我们称之为:设计类(class)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:		<span class="comment">#class是关键字，表示要定义类了</span></span><br><span class="line">	name = <span class="literal">None</span>		<span class="comment">#记录学生姓名	</span></span><br><span class="line">    				<span class="comment">#类的属性，即在类中定义的成员变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hi大家好,我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    				<span class="comment">#类的行为，即定义在类中的成员方法</span></span><br></pre></td></tr></table></figure>
<p>2.在程序中打印生产表格，我们称之为:创建对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于类创建对象的语法</span></span><br><span class="line">对象 = 类名称()</span><br><span class="line"></span><br><span class="line">stu_1 = Student()</span><br><span class="line">stu_2 = Student()</span><br></pre></td></tr></table></figure>
<p>3.在程序中填写表格，我们称之为:对象属性赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_1.name = <span class="string">&quot;周杰轮&quot;</span>		<span class="comment"># 为学生1对象赋予名称属性值</span></span><br><span class="line">stu_2.name = <span class="string">&quot;林军杰&quot;</span>		<span class="comment"># 为学生2对象赋予名称属性值</span></span><br><span class="line">stu_1.name.say_hi()		<span class="comment"># 输出：Hi大家好,我是周杰轮</span></span><br></pre></td></tr></table></figure>
<p>4.类和对象的关系是什么?</p>
<p>类是程序中的“设计图纸”<br>对象是基于图纸生产的具体实体</p>
<p>5.什么是面向对象编程?</p>
<p>面向对象编程就是,使用对象进行编程。<br>即，设计一个类，基于类创建对象，并使用对象来完成具体的工作</p>
<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 . 构造方法"></a>2 . 构造方法</h2><p>1．构造方法的名称是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__init__，注意init前后的2个下划线符号</span><br></pre></td></tr></table></figure>
<p>2.构造方法的作用:</p>
<p>构建类对象的时候，会自动运行<br>构建类对象的传参，会传递给构造方法，借此特性可以给成员变量赋值</p>
<p>3.注意事项:</p>
<p>构造方法不要忘记self关键字<br>在方法内使用成员变量需要使用self</p>
<ul>
<li>魔术方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__str__		用于实现类对象转字符串的行为</span><br><span class="line">__lt__		用于2个类对象进行小于或大于比较</span><br><span class="line">__le__		用于2个类对象进行小于等于或大于等于比较</span><br><span class="line">__eq__		用于2个类对象进行相等比较</span><br></pre></td></tr></table></figure>
<h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3 . 封装"></a>3 . 封装</h2><p>1.封装的概念是指?</p>
<p>​    将现实世界事物在类中描述为属性和方法，即为封装。</p>
<p>2.什么是私有成员?为什么需要私有成员?</p>
<p>​    现实事物有部分属性和行为是不公开对使用者开放的。同样在类中描述属性和方法的时候也需要达到这个要求，就需要定义私有成员了</p>
<p>3.如何定义私有成员?</p>
<p>​    成员变量和成员方法的命名均以__(两个下划线)作为开头即可</p>
<p>4.私有成员的访问限制?</p>
<p>​    类对象无法访问私有成员<br>​    类中的其它成员可以访问私有成员</p>
<p>5.封装的实际的意义</p>
<p>​    在类中提供仅供内部使用的属性和方法，而不对外开放（类对象无法使用)</p>
<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4 . 继承"></a>4 . 继承</h2><h3 id="1-继承的基础语法"><a href="#1-继承的基础语法" class="headerlink" title="1 . 继承的基础语法"></a>1 . 继承的基础语法</h3><ul>
<li><p>继承表示:将从父类那里继承(复制)来成员变量和成员方法(不含私有)</p>
</li>
<li><p>单继承——一个子类继承一个父类</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>)∶</span><br><span class="line">	类内容体</span><br></pre></td></tr></table></figure>
<ul>
<li>多继承——一个子类继承多个父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>,父类<span class="number">2</span>,....., 父类N)∶</span><br><span class="line">	类内容体</span><br><span class="line">    <span class="keyword">pass</span> 		<span class="comment"># 空	占位语句，类功能够用了，不想再添加新功能了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果多继承中，父类有同名的方法或属性，先继承的优先级高于后继承</li>
</ul>
<h3 id="2-复写和使用父类成员"><a href="#2-复写和使用父类成员" class="headerlink" title="2 . 复写和使用父类成员"></a>2 . 复写和使用父类成员</h3><p>1.复写表示:</p>
<p>对父类的成员属性或成员方法进行重新定义</p>
<p>2.复写的语法:</p>
<p>在子类中重新实现同名成员方法或成员属性即可</p>
<p>3.在子类中，如何调用父类成员</p>
<ul>
<li>方式1:调用父类成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用成员变量:父类名.成员变量</span><br><span class="line">使用成员方法:父类名.成员方法(self)</span><br></pre></td></tr></table></figure>
<ul>
<li>方式2:使用super()调用父类成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用成员变量: super().成员变量</span><br><span class="line">使用成员方法: super().成员方法()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意:只可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的</li>
</ul>
<h2 id="5-类型注解"><a href="#5-类型注解" class="headerlink" title="5 . 类型注解"></a>5 . 类型注解</h2><p>1.什么是类型注解，有什么作用?</p>
<p>​    在代码中涉及数据交互之时，对数据类型进行显式的说明，可以帮助:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl+p	查看类型</span><br></pre></td></tr></table></figure>
<p>​        PyCharm等开发工具对代码做类型推断协助做代码提示</p>
<p>​        开发者自身做类型的备注</p>
<p>2.类型注解支持:</p>
<p>​    变量的类型注解</p>
<p>​    函数（方法）的形参和返回值的类型注解</p>
<p>3.变量的类型注解</p>
<p>类对象也行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法1:变量:类型</span><br><span class="line">语法2:在注释中，# type:类型</span><br></pre></td></tr></table></figure>
<ul>
<li>容器类型的详细注解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量:容器类型[类型1，类型2....]</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>元组类型设置类型详细注解，需要将每一个元素都标记出来</li>
<li>字典类型设置类型详细注解，需要两个类型，第一个是key第二个是value</li>
</ul>
<p>4.函数(方法)的注解</p>
<ul>
<li>形参的类型注解</li>
<li>返回值的类型注解</li>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>(<span class="params">形参: 类型 , ...... , 形参: 类型</span>) -&gt; 返回值类型:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>5.注意事项</p>
<p>类型注解只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致错误</p>
<p>6.Union类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">导包: <span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line">使用: <span class="built_in">dict</span> [<span class="built_in">str</span>,<span class="type">Union</span>[类型, ..... , 类型]]</span><br><span class="line">可以定义联合类型注解</span><br></pre></td></tr></table></figure>
<h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6 . 多态"></a>6 . 多态</h2><ul>
<li><p>多态，指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态</p>
</li>
<li><p>抽象类（接口)</p>
<ul>
<li>包含抽象方法的类，称之为抽象类。</li>
<li>抽象方法是指:没有具体实现的方法(只有pass)称之为抽象方法</li>
</ul>
</li>
<li><p>抽象类的作用</p>
<ul>
<li>多用于做顶层设计（设计标准)，以便子类做具体实现。<br>也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法<br>并配合多态使用，获得不同的工作状态。</li>
</ul>
</li>
</ul>
<h2 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7 . 数据库"></a>7 . 数据库</h2><ul>
<li>导入数据库pymysql</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line">Connection(主机,端口,账户,密码)即可得到连接对象</span><br><span class="line">连接对象.close()关闭和MySQL数据库的连接</span><br></pre></td></tr></table></figure>
<ul>
<li>执行sql</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">通过连接对象调用cursor()方法，得到游标对象</span><br><span class="line">游标对象.execute()	执行sql语句</span><br><span class="line">游标对象.fetchall()	可以得到全部的查询结果封装进元组</span><br></pre></td></tr></table></figure>
<ul>
<li>确认代码提交</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法1：手动提交：连接对象.commit()</span><br><span class="line">方法2：自动提交：在Connection()中加入autocommit=True</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-Python进阶"><a href="#3-Python进阶" class="headerlink" title="3 . Python进阶"></a>3 . Python进阶</h1><h2 id="1-PySpark"><a href="#1-PySpark" class="headerlink" title="1.PySpark"></a>1.PySpark</h2><p>1.什么是Spark、什么是PySpark</p>
<p>​    Spark是Apache基金会旗下的顶级开源项目，用于对海量数据进行大规模分布式计算。</p>
<p>​    PySpark是Spark的Python实现，是Spark为Python开发者提供的编程入口，用于以Python代码完成Spark任务的开发</p>
<p>​    PySpark不仅可以作为Python第三方库使用，也可以将程序提交的Spark集群环境中,调度大规模集群进行执行。</p>
<p>2.为什么要学习PySpark?</p>
<p>​    大数据开发是Python众多就业方向中的明星赛道,薪资高岗位多，Spark(PySpark)又是大数据开发中的核心技术</p>
<ul>
<li>PySpark的功能都是从SparkContext对象作为执行入口</li>
</ul>
<h3 id="1-数据输入"><a href="#1-数据输入" class="headerlink" title="1.数据输入"></a>1.数据输入</h3><p>1.RDD对象是什么?为什么要使用它?</p>
<p>​    RDD对象称之为分布式弹性数据集，是PySpark中数据计算的载体，它可以:<br>​        提供数据存储<br>​        提供数据计算的各类方法<br>​        数据计算的方法,返回值依旧是RDD (RDD迭代计算)<br>​    后续对数据进行各类计算,都是基于RDD对象进行</p>
<p>2.如何输入数据到Spark(即得到RDD对象)1</p>
<p>​    通过SparkContext的parallelize()成员方法，将Python数据容器转换为RDD对象<br>​    通过SparkContext的textFile()成员方法，读取文本文件得到RDD对象</p>
<h3 id="2-数据计算"><a href="#2-数据计算" class="headerlink" title="2.数据计算"></a>2.数据计算</h3><p>1.map算子(成员方法)</p>
<ul>
<li>​    接受一个处理函数，可用lambda表达式快速编写</li>
<li>​    对RDD内的元素逐个处理，并返回一个新的RDD</li>
</ul>
<p>2.链式调用</p>
<p>​    对于返回值是新RDD的算子，可以通过链式调用的方式多次调用算子。</p>
<p>3.flatMap算子</p>
<ul>
<li>计算逻辑和map一样</li>
<li>可以比map多出“解除一层嵌套”的功能</li>
</ul>
<p>4.reduceByKey算子</p>
<ul>
<li>接收一个处理函数，对数据进行两两计算</li>
<li>自动对key分组，然后对value进行聚合逻辑计算</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/13/WYBhn923zEK8Svx.png" alt="QQ图片20230913193510"></p>
<p>5.filter()算子</p>
<p>功能：过滤想要的数据进行保留</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdd.filter(func)</span><br><span class="line">func返回时True保留，False丢弃</span><br></pre></td></tr></table></figure>
<p>6.distinct算子</p>
<p>功能:对RDD数据进行去重,返回新RDD</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdd.distinct()	无需传参</span><br></pre></td></tr></table></figure>
<p>7.sortBy算子</p>
<p>功能:对RDD数据进行排序,基于你指定的排序依据.</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdd.sortBy(func, ascending=<span class="literal">False</span>,numPartitions=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func: (T) →U:告知按照rdd中的哪个数据进行排序，比如lambda x: x[1] 表示按照rdd中的第二列元素进行排序</span></span><br><span class="line"><span class="comment"># ascending True升序 False降序</span></span><br><span class="line"><span class="comment"># numPartitions:用多少分区排序</span></span><br></pre></td></tr></table></figure>
<h3 id="3-数据输出"><a href="#3-数据输出" class="headerlink" title="3.数据输出"></a>3.数据输出</h3><ul>
<li>输出为Python对象</li>
</ul>
<p>1.collect算子</p>
<p>功能:将RDD各个分区内的数据,统一收集到Driver中,形成一个List对象</p>
<p>用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdd.collect()		<span class="comment"># 返回值是一个list</span></span><br></pre></td></tr></table></figure>
<p>2.reduce算子</p>
<p>功能:对RDD数据集按照你传入的逻辑进行聚合</p>
<p>语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdd .reduce(func)</span><br><span class="line"><span class="comment"># func: (T,T) →T</span></span><br><span class="line"><span class="comment"># 2参数传入1个返回值,返回值和参数要求类型一致</span></span><br><span class="line"><span class="comment"># 返回值等同于计算函数的返回值</span></span><br></pre></td></tr></table></figure>
<p>3.take算子</p>
<p>功能：取RDD的前N个元素，组成list返回给你</p>
<p>4.count算子</p>
<p>功能：计算RDD有多少条数据，返回值是一个数字</p>
<ul>
<li>输出到文件</li>
</ul>
<p>1.saveAsTextFile算子</p>
<p>功能:将RDD的数据写入文本文件中</p>
<p>支持本地写出, hdfs等文件系统</p>
<p>2.修改rdd分区为1</p>
<p>方法1：SparkConf对象设置属性全局并行度为1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conf = SparkConf().setNaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;test_spark&quot;</span>)</span><br><span class="line">conf.<span class="built_in">set</span>(<span class="string">&#x27;spark.default.parallelism&quot;, 1)</span></span><br><span class="line"><span class="string">sc = SparkContext(conf=conf)</span></span><br></pre></td></tr></table></figure>
<p>方式2：创建RDD的时候设置(parallelize方法传入numSlices参数为1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdd1 = sc.parallelize([<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>], numSlices=<span class="number">1</span>)</span><br><span class="line">rdd1 = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>]，<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h2><p>1.什么是闭包</p>
<p>​    定义双层嵌套函数，内层函数可以访问外层函数的变量<br>​    将内存函数作为外层函数的返回，此内层函数就是闭包函数</p>
<p>2.闭包的好处和缺点</p>
<ul>
<li>优点:不定义全局变量,也可以让函数持续访问和修改一个外部变量</li>
<li>优点:闭包函数引用的外部变量,是外层函数的内部变量。作用域封闭难以被误操作修改</li>
<li>缺点:额外的内存占用</li>
</ul>
<p>3.nonlocal关键字的作用</p>
<p>​    在闭包函数(内部函数中)想要修改外部函数的变量值<br>​    需要用nonlocal声明这个外部变量</p>
<h2 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3.装饰器"></a>3.装饰器</h2><ul>
<li>装饰器就是使用创建一个闭包函数,在闭包函数内调用目标函数，可以达到不改动目标函数的同时，增加额外的功能。</li>
</ul>
<p>装饰器的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span> (func):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要睡觉了&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我起床了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@Outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>():</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;睡觉中......&quot;</span>)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">sleep()</span><br></pre></td></tr></table></figure>
<h2 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4.设计模式"></a>4.设计模式</h2><p>1.什么是设计模式</p>
<p>设计模式就是一种编程套路。<br>使用特定的套路得到特定的效果</p>
<p>2.单例设计模式</p>
<p>单例模式就是对一个类，只获取其唯一的类实例对象，持续复用它</p>
<ul>
<li>节省内存</li>
<li>节省创建对象的开销中</li>
</ul>
<p>3.工厂模式</p>
<p>将对象的创建由使用原生类本身创建<br>转换到由特定的工厂方法来创建</p>
<p>好处：</p>
<p>大批量创建对象的时候有统一的入口,易于代码维护</p>
<p>当发生修改,仅修改工厂类的创建方法即可</p>
<p>符合现实世界的模式,即由工厂来制作产品(对象)</p>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5.多线程"></a>5.多线程</h2><h3 id="1-进程、线程"><a href="#1-进程、线程" class="headerlink" title="1.进程、线程"></a>1.进程、线程</h3><p>进程:就是一个程序，运行在系统之上，那么便称之这个程序为一个运行进程，并分配进程ID方便系统管理。</p>
<p>线程:线程是归属于进程的，一个进程可以开启多个线程,执行不同的工作,是进程的实际工作最小单位。</p>
<ul>
<li>进程就好比一家公司，是操作系统对程序进行运行管理的单位</li>
<li>线程就好比公司的员工,进程可以有多个线程(员工)，是进程实际的工作者</li>
</ul>
<p>操作系统中可以运行多个进程，即多任务运行</p>
<p>一个进程内可以运行多个线程，即多线程运行</p>
<ul>
<li>注意点：</li>
</ul>
<p>进程之间是内存隔离的，即不同的进程拥有各自的内存空间。这就类似于不同的公司拥有不同的办公场所。</p>
<p>线程之间是内存共享的,线程是属于进程的，一个进程内的多个线程之间是共享这个进程所拥有的内存空间的。这就好比,公司员工之间是共享公司的办公场所。</p>
<ul>
<li>并行执行</li>
</ul>
<p>并行执行的意思指的是同一时间做不同的工作。</p>
<p>进程之间就是并行执行的,操作系统可以同时运行好多程序,这些程序都是在并行执行。我们就称之为:多任务并行执行</p>
<p>除了进程外，线程其实也是可以并行执行的。</p>
<p>也就是比如一个Python程序,其实是完全可以做到:</p>
<blockquote>
<p>一个线程在输出:你好<br>一个线程在输出: Hello</p>
</blockquote>
<p>像这样一个程序在同一时间做两件乃至多件不同的事情，我们就称之为:多线程并行执行</p>
<h3 id="2-多线程编程"><a href="#2-多线程编程" class="headerlink" title="2.多线程编程"></a>2.多线程编程</h3><p>绝大多数编程语言,都允许多线程编程,Pyhton也不例外。</p>
<p>Python的多线程可以通过threading模块来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">thread_obj = threading.Thread([group [, target [， name [, args [，kwargs]]]]])</span><br><span class="line">- group:暂时无用，未来功能的预留参数</span><br><span class="line">- target:执行的目标任务名</span><br><span class="line">- args:以元组的方式给执行任务传参</span><br><span class="line">- kwargs:以字典方式给执行任务传参</span><br><span class="line">- name:线程名，一般不用设置</span><br></pre></td></tr></table></figure>
<ul>
<li>threading模块的使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">threading_obj = threading.Thread(target=func) 创建线程对象</span><br><span class="line">threading_obj.start()	启动线程执行</span><br></pre></td></tr></table></figure>
<ul>
<li>如何传参</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;多线程运行模式&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 方式1：元组</span></span><br><span class="line">sing_thread = threading.Thread(target=sing)</span><br><span class="line">dance_thread = threading.Thread(target=dance，args=(<span class="string">&quot;我在跳舞，哈哈哈&quot;</span>，)</span><br><span class="line">sing_thread.start()</span><br><span class="line">dance_thread.start()</span><br><span class="line"><span class="comment"># 方式2：字典   </span></span><br><span class="line">sing_thread = threading.Thread(target=sing)</span><br><span class="line">dance_thread = threading.Thread(target=dance， kwangs=&#123;<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;我在跳舞，哈哈哈&quot;</span>&#125;)</span><br><span class="line">sing_thread.start()</span><br><span class="line">dance_thread.start()</span><br></pre></td></tr></table></figure>
<h2 id="6-网络编程"><a href="#6-网络编程" class="headerlink" title="6.网络编程"></a>6.网络编程</h2><p>Socket</p>
<p>Socket (简称套接字)是进程之间通信一个工具,好比现实生活中的插座,所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要Socket。</p>
<p>客户端和服务端</p>
<p>2个进程之间通过Socket进行相互通讯,就必须有服务端和客户端</p>
<p>Socket服务端:等待其它进程的连接、可接受发来的消息、可以回复消息Socket</p>
<p>客户端:主动连接服务端、可以发送消息、可以接收回复</p>
<p><img src="https://s2.loli.net/2023/09/14/HWkuKZUiGO7fbxg.png" alt="QQ图片20230914211103"></p>
<h2 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式"></a>7.正则表达式</h2><p>正则表达式，又称规则表达式(Regular Expression)，是使用单个字符串来描述、匹配某个句法规则的字符准，常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<p>简单来说，正则表达式就是一种字符串验证的规则，通过特殊的字符串组合来确立规则,用规则去匹配字符串是否满足</p>
<p>比如,验证一个字符串是否是符合条件的电子邮箱地址，只需要配置好正则规则,即可匹配任意邮箱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如通过正则规则:(^[\w-]+(\.[w-]+)*@[\w-]+(\.[\w-]+)+$)即可匹配一个字符串是否是标准邮箱格式</span><br></pre></td></tr></table></figure>
<p>但如果不使用正则,使用if else来对字符串做判断就非常困难了。</p>
<ul>
<li>使用re模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<p>分别是: match、search、findall三个基础方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 从被匹配字符串开头进行匹配，匹配成功返回匹配对象（包含匹配的信息)，匹配不成功返回空None</span></span><br><span class="line">re.search(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 搜索整个字符串，找出匹配的。从前向后,找到第一个后，就停止,不会继续向后，整个字符串都找不到，返回None</span></span><br><span class="line">re.findall(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 匹配整个字符串，找出全部的匹配项，找不到返回空list:[]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元字符匹配</li>
<li>字符串前面带上 r 的标记，表示当前字符串是原始字符串，即内部的转义字符无效而是普通字符</li>
</ul>
<p>单字符匹配</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配任意1个字符(除了\n), \ . 匹配点本身</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配[ ]中列举的字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字，即0-9</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白，即空格、tab键</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白</td>
</tr>
<tr>
<td>\w</td>
<td>匹配单词字符，即a-z、A-Z、0-9、_</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非单词字符</td>
</tr>
</tbody>
</table>
</div>
<p>数量匹配</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前一个规则的字符出现0至无数次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个规则的字符出现1至无数次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一个规则的字符出现0次或1次</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一个规则的字符出现m次</td>
</tr>
<tr>
<td>{m, }</td>
<td>匹配前一个规则的字符出现最少m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配前一个规则的字符出现m到n次</td>
</tr>
</tbody>
</table>
</div>
<p>边界匹配</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
</tr>
</tbody>
</table>
</div>
<p>分组匹配</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td></td>
<td>匹配左右任意一个表达式</td>
</tr>
<tr>
<td>( )</td>
<td>将括号中字符作为一个分组</td>
</tr>
</tbody>
</table>
</div>
<h2 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h2><p>递归在编程中是一种非常重要的算法</p>
<p>递归:即方法(函数)自己调用自己的一种特殊编程写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	<span class="keyword">if</span> ...:</span><br><span class="line">		func()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/09/14/7TE8Rpx4IJyOkAe.png" alt="QQ图片20230914221426"></p>
<p>递归需要注意什么?</p>
<ul>
<li>注意退出的条件，否则容易变成无限递归</li>
<li>注意返回值的传递，确保从最内层，层层传递到最外层，例如+=，将下一层函数的递归加到上面的一层函数</li>
</ul>
<p>递归需要调用os模块的3个方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.listdir,列出指定目录下的内容</span><br><span class="line">os.path.isdir,判断给定路径是否是文件夹，是返回<span class="literal">True</span>,否返回<span class="literal">False</span></span><br><span class="line">os.path.exists,判断给定路径是否存在，存在返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>//Docker.html</url>
    <content><![CDATA[<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h2 id="1-卸载旧版"><a href="#1-卸载旧版" class="headerlink" title="1.卸载旧版"></a>1.卸载旧版</h2><p>首先如果系统中已经存在旧的Docker，则先卸载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure>
<h2 id="2-配置Docker的yum库"><a href="#2-配置Docker的yum库" class="headerlink" title="2.配置Docker的yum库"></a>2.配置Docker的yum库</h2><p>首先要安装一个yum工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
<p>安装成功后，执行命令，配置Docker的yum源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3.安装Docker"></a>3.安装Docker</h2><p>最后，执行命令，安装Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>
<h2 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4.启动和校验"></a>4.启动和校验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<h2 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5.配置镜像加速"></a>5.配置镜像加速</h2><p>这里以阿里云镜像加速为例。</p>
<h3 id="5-1-注册阿里云账号"><a href="#5-1-注册阿里云账号" class="headerlink" title="5.1.注册阿里云账号"></a>5.1.注册阿里云账号</h3><p>首先访问阿里云网站:</p>
<p><a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p>
<p>注册一个账号。</p>
<h3 id="5-2-开通镜像服务"><a href="#5-2-开通镜像服务" class="headerlink" title="5.2.开通镜像服务"></a>5.2.开通镜像服务</h3><p>在首页的产品中，找到阿里云的<strong>容器镜像服务</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17090339504684.png" alt="img"></p>
<p>点击后进入控制台：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17090339504671.png" alt="img"></p>
<p>首次可能需要选择立刻开通，然后进入控制台。</p>
<h3 id="5-3-配置镜像加速"><a href="#5-3-配置镜像加速" class="headerlink" title="5.3.配置镜像加速"></a>5.3.配置镜像加速</h3><p>找到<strong>镜像工具</strong>下的<strong>镜像**</strong>加速器**：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17090339504682.png" alt="img"></p>
<p>页面向下滚动，即可找到配置的文档说明：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17090339504683.png" alt="img"></p>
<p>具体命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制内容，注意把其中的镜像加速地址改成你自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h1><p>要想让Docker帮我们安装和部署软件，肯定要保证你的机器上有Docker. 由于大家的操作系统各不相同，安装方式也不同。为了便于大家学习，我们统一在CentOS的虚拟机中安装Docker，统一学习环境。</p>
<p>注意：使用MacBook的同学也请利用 VMwareFusion来安装虚拟机，并在虚拟机中学习Docker使用。</p>
<h2 id="1-1-部署MySQL"><a href="#1-1-部署MySQL" class="headerlink" title="1.1.部署MySQL"></a>1.1.部署MySQL</h2><p>首先，我们利用Docker来安装一个MySQL软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p>
<p>如果是利用传统方式部署MySQL，大概的步骤有：</p>
<ul>
<li>搜索并下载MySQL安装包</li>
<li>上传至Linux环境</li>
<li>编译和配置环境</li>
<li>安装</li>
</ul>
<p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用CV大法）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>
<p>运行效果如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913519.png" alt="img"></p>
<p>MySQL安装完毕！通过任意客户端工具即可连接到MySQL.</p>
<p>大家可以发现，当我们执行命令后，Docker做的第一件事情，是去自动搜索并下载了MySQL，然后会自动运行MySQL，我们完全不用插手，是不是非常方便。</p>
<p>而且，这种安装方式你完全不用考虑运行的操作系统环境，它不仅仅在CentOS系统是这样，在Ubuntu系统、macOS系统、甚至是装了WSL的Windows下，都可以使用这条命令来安装MySQL。</p>
<p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p>
<p>而使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL。注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p>
<p>说明：</p>
<ul>
<li>镜像：英文是image</li>
<li>容器：英文是container</li>
</ul>
<blockquote>
<p>因此，Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程。</p>
</blockquote>
<p>Docker会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p>
<p>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：</p>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p>
<p>像这种提供存储、管理Docker镜像的服务器，被称为DockerRegistry，可以翻译为镜像仓库。DockerHub网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库。</p>
<p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。而企业内部的机密项目，往往会采用私有镜像仓库。</p>
<p>总之，镜像的来源有两种：</p>
<ul>
<li>基于官方基础镜像自己制作</li>
<li>直接去DockerRegistry下载</li>
</ul>
<p><strong>总结一下</strong>：</p>
<p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p>
<p>用一幅图标示如下：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<h2 id="1-2-命令解读"><a href="#1-2-命令解读" class="headerlink" title="1.2.命令解读"></a>1.2.命令解读</h2><p>利用Docker快速的安装了MySQL，非常的方便，不过我们执行的命令到底是什么意思呢？</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解读：</p>
<ul>
<li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li>
<li><code>--name mysql</code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li>
<li><code>-p 3306:3306</code> : 设置端口映射。<ul>
<li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将**</strong>宿主机<strong><strong>端口</strong></strong>映射容器内到端口**，当访问宿主机指定端口时，就是在访问容器内的端口了。</li>
<li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li>
<li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li>
</ul>
</li>
<li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul>
<li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li>
<li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li>
</ul>
</li>
<li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul>
<li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li>
<li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p>
<p>如果我们要安装其它软件，也可以到DockerRegistry中寻找对应的镜像名称和版本，阅读相关配置即可。</p>
<h1 id="2-Docker基础"><a href="#2-Docker基础" class="headerlink" title="2.Docker基础"></a>2.Docker基础</h1><p>接下来，我们一起来学习Docker使用的一些基础知识，为将来部署项目打下基础。具体用法可以参考Docker官方文档：</p>
<p><a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<h2 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1.常见命令"></a>2.1.常见命令</h2><p>首先我们来学习Docker中的常见命令，可以参考官方文档：</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/cli/">https://docs.docker.com/engine/reference/commandline/cli/</a></p>
<h3 id="2-1-1-命令介绍"><a href="#2-1-1-命令介绍" class="headerlink" title="2.1.1.命令介绍"></a>2.1.1.命令介绍</h3><p>其中，比较常见的命令有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>命令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
<th style="text-align:left"><strong>文档地址</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">docker pull</td>
<td style="text-align:left">拉取镜像</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td>
</tr>
<tr>
<td style="text-align:left">docker push</td>
<td style="text-align:left">推送镜像到DockerRegistry</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td>
</tr>
<tr>
<td style="text-align:left">docker images</td>
<td style="text-align:left">查看本地镜像</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td>
</tr>
<tr>
<td style="text-align:left">docker rmi</td>
<td style="text-align:left">删除本地镜像</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td>
</tr>
<tr>
<td style="text-align:left">docker run</td>
<td style="text-align:left">创建并运行容器（不能重复创建）</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td>
</tr>
<tr>
<td style="text-align:left">docker stop</td>
<td style="text-align:left">停止指定容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td>
</tr>
<tr>
<td style="text-align:left">docker start</td>
<td style="text-align:left">启动指定容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td>
</tr>
<tr>
<td style="text-align:left">docker restart</td>
<td style="text-align:left">重新启动容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td>
</tr>
<tr>
<td style="text-align:left">docker rm</td>
<td style="text-align:left">删除指定容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker ps</td>
<td style="text-align:left">查看容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td>
</tr>
<tr>
<td style="text-align:left">docker logs</td>
<td style="text-align:left">查看容器运行日志</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td>
</tr>
<tr>
<td style="text-align:left">docker exec</td>
<td style="text-align:left">进入容器</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td>
</tr>
<tr>
<td style="text-align:left">docker save</td>
<td style="text-align:left">保存镜像到本地压缩文件</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td>
</tr>
<tr>
<td style="text-align:left">docker load</td>
<td style="text-align:left">加载本地压缩文件到镜像</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td>
</tr>
<tr>
<td style="text-align:left">docker inspect</td>
<td style="text-align:left">查看容器详细信息</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td>
</tr>
</tbody>
</table>
</div>
<p>用一副图来表示这些命令的关系：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>补充：</p>
<p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-演示"><a href="#2-1-2-演示" class="headerlink" title="2.1.2.演示"></a>2.1.2.演示</h3><p>教学环节说明：我们以Nginx为例给大家演示上述命令。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line">mysql        latest    <span class="number">3218</span>b38490ce   <span class="number">17</span> months ago   <span class="number">516</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-命令别名"><a href="#2-1-3-命令别名" class="headerlink" title="2.1.3.命令别名"></a>2.1.3.命令别名</h3><p>给常用Docker命令起别名，方便我们访问：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后，执行命令使别名生效</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure>
<p>接下来，试试看新的命令吧。</p>
<h2 id="2-2-数据卷"><a href="#2-2-数据卷" class="headerlink" title="2.2.数据卷"></a>2.2.数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p>
<ul>
<li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li>
<li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li>
<li>我想要让Nginx代理我的静态资源怎么办？</li>
</ul>
<p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器**</strong>解耦**。</p>
<h3 id="2-2-1-什么是数据卷"><a href="#2-2-1-什么是数据卷" class="headerlink" title="2.2.1.什么是数据卷"></a>2.2.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机**</strong>目录**之间映射的桥梁。</p>
<p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p>
<ul>
<li><code>html</code>：放置一些静态资源</li>
<li><code>conf</code>：放置配置文件</li>
</ul>
<p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p>
<p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/image-20240229094403077.png" alt="image-20240229094403077"></p>
<p>在上图中：</p>
<ul>
<li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li>
<li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li>
<li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li>
</ul>
<p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p>
<p><strong>小提示</strong>：</p>
<p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p>
<p><strong>为什么不让容器目录直接指向**</strong>宿主机<strong>**目录呢</strong>？</p>
<ul>
<li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li>
<li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li>
</ul>
<p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与**</strong>宿主机<strong>**目录挂载而不使用数据卷</strong>，具体参考2.2.3小节。</p>
<h3 id="2-2-2-数据卷命令"><a href="#2-2-2-数据卷命令" class="headerlink" title="2.2.2.数据卷命令"></a>2.2.2.数据卷命令</h3><p>数据卷的相关命令有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>命令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
<th style="text-align:left"><strong>文档地址</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">docker volume create</td>
<td style="text-align:left">创建数据卷</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td>
</tr>
<tr>
<td style="text-align:left">docker volume ls</td>
<td style="text-align:left">查看所有数据卷</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker volume rm</td>
<td style="text-align:left">删除指定数据卷</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker volume inspect</td>
<td style="text-align:left">查看某个数据卷的详情</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker volume prune</td>
<td style="text-align:left">清除未使用的数据卷</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td>
</tr>
</tbody>
</table>
</div>
<p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p>
<p>教学<strong>演示环节</strong>：演示一下nginx的html目录挂载</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure>
<p>教学<strong>演示环节</strong>：演示一下MySQL的匿名数据卷</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.查看MySQL容器详细信息</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 关注其中.Config.Volumes部分和.Mounts部分</span></span><br></pre></td></tr></table></figure>
<p>我们关注两部分内容，第一是<code>.Config.Volumes</code>部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/var/lib/mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p>
<p>然后，我们再看结果中的<code>.Mounts</code>部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以发现，其中有几个关键属性：</p>
<ul>
<li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li>
<li>Source：宿主机目录</li>
<li>Destination : 容器内的目录</li>
</ul>
<p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p>
<p>接下来，可以查看该目录下的MySQL的data文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</span><br></pre></td></tr></table></figure>
<p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考DockerHub对应的页面</p>
<h3 id="2-2-3-挂载本地目录或文件"><a href="#2-2-3-挂载本地目录或文件" class="headerlink" title="2.2.3.挂载本地目录或文件"></a>2.2.3.挂载本地目录或文件</h3><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure>
<p><strong>教学演示</strong>，删除并重新创建mysql容器，并完成本地目录挂载：</p>
<ul>
<li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li>
<li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li>
<li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li>
</ul>
<p>在课前资料中已经准备好了mysql的<code>init</code>目录和<code>conf</code>目录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991301.png" alt="img"></p>
<p>以及对应的初始化SQL脚本和配置文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991312.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991313.png" alt="img"></p>
<p>其中，hm.cnf主要是配置了MySQL的默认编码，改为utf8mb4；而hmall.sql则是后面我们要用到的黑马商城项目的初始化SQL脚本。</p>
<p>我们直接将整个mysql目录上传至虚拟机的<code>/root</code>目录下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991314.png" alt="img"></p>
<p>接下来，我们演示本地目录挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf</span><br><span class="line">drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data</span><br><span class="line">drwxr-xr-x. 2 root    root   23 5月  19 15:11 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看MySQL容器内数据</span></span><br><span class="line"><span class="comment"># 5.1.进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123</span><br><span class="line"><span class="comment"># 5.2.查看编码表</span></span><br><span class="line">show variables like <span class="string">&quot;%char%&quot;</span>;</span><br><span class="line"><span class="comment"># 5.3.结果，发现编码是utf8mb4没有问题</span></span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| Variable_name            | Value                          |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                        |</span><br><span class="line">| character_set_connection | utf8mb4                        |</span><br><span class="line">| character_set_database   | utf8mb4                        |</span><br><span class="line">| character_set_filesystem | binary                         |</span><br><span class="line">| character_set_results    | utf8mb4                        |</span><br><span class="line">| character_set_server     | utf8mb4                        |</span><br><span class="line">| character_set_system     | utf8mb3                        |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看数据</span></span><br><span class="line"><span class="comment"># 6.1.查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment"># 结果，hmall是黑马商城数据库</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| hmall              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 6.2.切换到hmall数据库</span></span><br><span class="line">use hmall;</span><br><span class="line"><span class="comment"># 6.3.查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_hmall |</span><br><span class="line">+-----------------+</span><br><span class="line">| address         |</span><br><span class="line">| cart            |</span><br><span class="line">| item            |</span><br><span class="line">| order           |</span><br><span class="line">| order_detail    |</span><br><span class="line">| order_logistics |</span><br><span class="line">| pay_order       |</span><br><span class="line">| user            |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="comment"># 6.4.查看address表数据</span></span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| <span class="built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |</span><br><span class="line">| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |</span><br><span class="line">| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |</span><br><span class="line">| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="2-3-镜像"><a href="#2-3-镜像" class="headerlink" title="2.3.镜像"></a>2.3.镜像</h2><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p>
<h3 id="2-3-1-镜像结构"><a href="#2-3-1-镜像结构" class="headerlink" title="2.3.1.镜像结构"></a>2.3.1.镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p>
<p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p>
<p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p>
<p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p>
<ul>
<li>准备一个linux服务（CentOS或者Ubuntu均可）</li>
<li>安装并配置JDK</li>
<li>上传Jar包</li>
<li>运行jar包</li>
</ul>
<p>那因此，我们打包镜像也是分成这么几步：</p>
<ul>
<li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li>
<li>安装并配置JDK</li>
<li>拷贝jar包</li>
<li>配置启动脚本</li>
</ul>
<p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p>
<p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p>
<p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991315.png" alt="img"></p>
<h3 id="2-3-2-Dockerfile"><a href="#2-3-2-Dockerfile" class="headerlink" title="2.3.2.Dockerfile"></a>2.3.2.Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p>
<p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p>
<p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<p>其中的语法比较多，比较常用的有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
<th style="text-align:left"><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FROM</strong></td>
<td style="text-align:left">指定基础镜像</td>
<td style="text-align:left"><code>FROM centos:6</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>ENV</strong></td>
<td style="text-align:left">设置环境变量，可在后面指令使用</td>
<td style="text-align:left"><code>ENV key value</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>COPY</strong></td>
<td style="text-align:left">拷贝本地文件到镜像的指定目录</td>
<td style="text-align:left"><code>COPY ./xx.jar /tmp/app.jar</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>RUN</strong></td>
<td style="text-align:left">执行Linux的shell命令，一般是安装过程的命令</td>
<td style="text-align:left"><code>RUN yum install gcc</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>EXPOSE</strong></td>
<td style="text-align:left">指定容器运行时监听的端口，是给镜像使用者看的</td>
<td style="text-align:left">EXPOSE 8080</td>
</tr>
<tr>
<td style="text-align:left"><strong>ENTRYPOINT</strong></td>
<td style="text-align:left">镜像中应用的启动命令，容器运行时调用</td>
<td style="text-align:left">ENTRYPOINT java -jar xx.jar</td>
</tr>
</tbody>
</table>
</div>
<p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p>
<p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>是不是简单多了。</p>
<h3 id="2-3-3-构建镜像"><a href="#2-3-3-构建镜像" class="headerlink" title="2.3.3.构建镜像"></a>2.3.3.构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p>
<p>在课前资料中，我们准备好了一个demo项目及对应的Dockerfile：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991316.png" alt="img"></p>
<p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991317.png" alt="img"></p>
<p>然后，执行命令，构建镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<ul>
<li><code>docker build</code>: 就是构建一个docker镜像</li>
<li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li>
<li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul>
<li>```Bash<h1 id="直接指定Dockerfile目录"><a href="#直接指定Dockerfile目录" class="headerlink" title="直接指定Dockerfile目录"></a>直接指定Dockerfile目录</h1>docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991318.png)</span><br><span class="line"></span><br><span class="line">查看镜像列表：</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"># 查看镜像列表：</span><br><span class="line">docker images</span><br><span class="line"># 结果</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">docker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>然后尝试运行该镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8080:8080 docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">dps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES</span><br><span class="line">78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   <span class="built_in">dd</span></span><br><span class="line">f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">curl localhost:8080/hello/count</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-网络"><a href="#2-4-网络" class="headerlink" title="2.4.网络"></a>2.4.网络</h2><p>上节课我们创建了一个Java项目的容器，而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p>
<p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 也可以使用format过滤结果</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql</span><br><span class="line"><span class="comment"># 得到IP地址如下：</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后通过命令进入dd容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在容器内，通过ping命令测试网络</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</span><br></pre></td></tr></table></figure>
<p>发现可以互联，没有问题。</p>
<p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p>
<p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p>
<p>常见命令有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>命令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
<th style="text-align:left"><strong>文档地址</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">docker network create</td>
<td style="text-align:left">创建一个网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td>
</tr>
<tr>
<td style="text-align:left">docker network ls</td>
<td style="text-align:left">查看所有网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker network rm</td>
<td style="text-align:left">删除指定网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker network prune</td>
<td style="text-align:left">清除未使用的网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker network connect</td>
<td style="text-align:left">使指定容器连接加入某网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td>
</tr>
<tr>
<td style="text-align:left">docker network disconnect</td>
<td style="text-align:left">使指定容器连接离开某网络</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td>
</tr>
<tr>
<td style="text-align:left">docker network inspect</td>
<td style="text-align:left">查看网络详细信息</td>
<td style="text-align:left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td>
</tr>
</tbody>
</table>
</div>
<p>教学演示：自定义网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>
<p>OK，现在无需记住IP地址也可以实现容器互联了。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li>
<li>在同一个自定义网络中的容器，可以通过别名互相访问</li>
</ul>
<h1 id="3-项目部署"><a href="#3-项目部署" class="headerlink" title="3.项目部署"></a>3.项目部署</h1><p>好了，我们已经熟悉了Docker的基本用法，接下来可以尝试部署项目了。</p>
<p>在课前资料中已经提供了一个黑马商城项目给大家，如图：</p>
<p>项目说明：</p>
<ul>
<li>hmall：商城的后端代码</li>
<li>hmall-portal：商城用户端的前端代码</li>
<li>hmall-admin：商城管理端的前端代码</li>
</ul>
<p>部署的容器及端口说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>项目</strong></th>
<th style="text-align:left"><strong>容器名</strong></th>
<th style="text-align:left"><strong>端口</strong></th>
<th style="text-align:left"><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hmall</td>
<td style="text-align:left">hmall</td>
<td style="text-align:left">8080</td>
<td style="text-align:left">黑马商城后端API入口</td>
</tr>
<tr>
<td style="text-align:left">hmall-portal</td>
<td style="text-align:left">nginx</td>
<td style="text-align:left">18080</td>
<td style="text-align:left">黑马商城用户端入口</td>
</tr>
<tr>
<td style="text-align:left">hmall-admin</td>
<td style="text-align:left">18081</td>
<td style="text-align:left">黑马商城管理端入口</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">mysql</td>
<td style="text-align:left">mysql</td>
<td style="text-align:left">3306</td>
<td style="text-align:left">数据库</td>
</tr>
</tbody>
</table>
</div>
<p>在正式部署前，我们先删除之前的nginx、dd两个容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f nginx <span class="built_in">dd</span></span><br></pre></td></tr></table></figure>
<p>mysql容器中已经准备好了商城的数据，所以就不再删除了。</p>
<h2 id="3-1-部署Java项目"><a href="#3-1-部署Java项目" class="headerlink" title="3.1.部署Java项目"></a>3.1.部署Java项目</h2><p><code>hmall</code>项目是一个maven聚合项目，使用IDEA打开<code>hmall</code>项目，查看项目结构如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-17091258991319.png" alt="img"></p>
<p>我们要部署的就是其中的<code>hm-service</code>，其中的配置文件采用了多环境的方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913110.png" alt="img"></p>
<p>其中的<code>application-dev.yaml</code>是部署到开发环境的配置，<code>application-local.yaml</code>是本地运行时的配置。</p>
<p>查看application.yaml，你会发现其中的JDBC地址并未写死，而是读取变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913111.png" alt="img"></p>
<p>这两个变量在<code>application-dev.yaml</code>和<code>application-local.yaml</code>中并不相同：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913112.png" alt="img"></p>
<p>在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问。</p>
<p>我们将项目打包：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913113.png" alt="img"></p>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913214.png" alt="img"></p>
<p>将<code>hm-service</code>目录下的<code>Dockerfile</code>和<code>hm-service/target</code>目录下的<code>hm-service.jar</code>一起上传到虚拟机的<code>root</code>目录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913215.png" alt="img"></p>
<p>部署项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.构建项目镜像，不指定tag，则默认为latest</span></span><br><span class="line">docker build -t hmall .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">hmall         latest    0bb07b2c34b9   43 seconds ago   362MB</span><br><span class="line">docker-demo   1.0       49743484da68   24 hours ago     327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysql</span></span><br><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure>
<p>测试，通过浏览器访问：<a href="http://你的虚拟机地址:8080/search/list">http://你的虚拟机地址:8080/search/list</a></p>
<h2 id="3-2-部署前端"><a href="#3-2-部署前端" class="headerlink" title="3.2.部署前端"></a>3.2.部署前端</h2><p><code>hmall-portal</code>和<code>hmall-admin</code>是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913216.png" alt="img"></p>
<p>其中：</p>
<ul>
<li><code>html</code>是静态资源目录，我们需要把<code>hmall-portal</code>以及<code>hmall-admin</code>都复制进去</li>
<li><code>nginx.conf</code>是nginx的配置文件，主要是完成对<code>html</code>下的两个静态资源目录做代理</li>
</ul>
<p>我们现在要做的就是把整个nginx目录上传到虚拟机的<code>/root</code>目录下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913217.png" alt="img"></p>
<p>然后创建nginx容器并完成两个挂载：</p>
<ul>
<li>把<code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li>
<li>把<code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li>
</ul>
<p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口：</p>
<ul>
<li>18080：对应hmall-portal</li>
<li>18081：对应hmall-admin</li>
</ul>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network hmall \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>
<p>测试，通过浏览器访问：<a href="http://你的虚拟机ip:18080">http://你的虚拟机ip:18080</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/putongl/picgo/img/-170912589913218.png" alt="img"></p>
<h2 id="3-3-DockerCompose"><a href="#3-3-DockerCompose" class="headerlink" title="3.3.DockerCompose"></a>3.3.DockerCompose</h2><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p>
<ul>
<li>MySQL</li>
<li>Nginx</li>
<li>Java项目</li>
</ul>
<p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p>
<p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p>
<h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p>
<p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p>
<p>举例来说，用docker run部署MySQL的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>
<p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<p>对比如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>docker run 参数</strong></th>
<th style="text-align:left"><strong>docker compose 指令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">—name</td>
<td style="text-align:left">container_name</td>
<td style="text-align:left">容器名称</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">ports</td>
<td style="text-align:left">端口映射</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">environment</td>
<td style="text-align:left">环境变量</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">volumes</td>
<td style="text-align:left">数据卷配置</td>
</tr>
<tr>
<td style="text-align:left">—network</td>
<td style="text-align:left">networks</td>
<td style="text-align:left">网络</td>
</tr>
</tbody>
</table>
</div>
<p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p>
<p>黑马商城部署文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p>
<p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p>
<p>基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure>
<p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>参数或指令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Options</td>
<td style="text-align:left">-f</td>
<td style="text-align:left">指定compose文件的路径和名称</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Commands</td>
<td style="text-align:left">up</td>
<td style="text-align:left">创建并启动所有service容器</td>
</tr>
<tr>
<td style="text-align:left">down</td>
<td style="text-align:left">停止并移除所有容器、网络</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ps</td>
<td style="text-align:left">列出所有启动的容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">logs</td>
<td style="text-align:left">查看指定容器的日志</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:left">停止容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">start</td>
<td style="text-align:left">启动容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">restart</td>
<td style="text-align:left">重启容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">查看运行的进程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec</td>
<td style="text-align:left">在指定的运行中容器中执行命令</td>
</tr>
</tbody>
</table>
</div>
<p>教学演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>
<p>打开浏览器，访问：<a href="http://yourIp:8080">http://yourIp:8080</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>//VSCode.html</url>
    <content><![CDATA[<h2 id="Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？"><a href="#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？" class="headerlink" title="Visual Studio Code代码想要同时编辑多处，该怎么实现呢？"></a>Visual Studio Code代码想要同时编辑多处，该怎么实现呢？</h2><h3 id="1-重命名变量"><a href="#1-重命名变量" class="headerlink" title="1. 重命名变量"></a>1. 重命名变量</h3><p>首先看看自己需要同时修改多处的代码是不是要重命名一个变量，如果是的话，有现成的快捷键<code>f2</code></p>
<p>使用方法：</p>
<ul>
<li>选中一个变量，按<code>f2</code> 或者 按 <code>Fn + f2</code>，具体依据电脑品牌而定！</li>
<li>弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。</li>
</ul>
<p>注意:在<code>js文件</code>中，如果这个变量没有用<code>var或者const或者let</code>声明，会无法重命名</p>
<h3 id="2-多光标"><a href="#2-多光标" class="headerlink" title="2. 多光标"></a>2. 多光标</h3><blockquote>
<ol>
<li>按住<code>alt</code>，用鼠标<code>左键点击</code>，可以出现多个光标，输入的代码可以在光标处同时增加</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/x1Yai5TOJtr7VIG.png" alt="在这里插入图片描述"></p>
<ol>
<li>按住<code>Ctrl + Alt</code>，再按键盘上向上或者向下的键，可以使一列上出现多个光标。</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/fMbWCoecKLqyhA3.png" alt="在这里插入图片描述"></p>
<ol>
<li>选中一段文字，按<code>shift+alt+i</code>，可以在每行末尾出现光标</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/e3PyGSgTMtpbEHB.png" alt="在这里插入图片描述"></p>
<p><img src="https://s2.loli.net/2023/08/07/LcGv4XFP6iWn2dV.png" alt="在这里插入图片描述"></p>
<ol>
<li>光标放在一个地方，按<code>ctrl+shift+L</code>或者<code>ctrl+f2</code>，可以在页面中出现这个词的不同地方都出现光标。<code>有时候这个快捷键的作用和f2重命名变量类似</code>，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/Gz9gh8JyCFPAvcR.png" alt="在这里插入图片描述"></p>
<p><img src="https://s2.loli.net/2023/08/07/qWl2I3RTDKmhjsy.png" alt="在这里插入图片描述"></p>
<ol>
<li>按<code>shift+alt</code>，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/JQBkh5OagERo67y.png" alt="在这里插入图片描述"></p>
<ol>
<li>任何光标操作，可以按<code>Ctrl + U</code>取消</li>
</ol>
</blockquote>
<h3 id="3-替换字符串"><a href="#3-替换字符串" class="headerlink" title="3. 替换字符串"></a>3. 替换字符串</h3><blockquote>
<ol>
<li><p>按<code>ctrl+f</code>，可以搜索当前页面，然后按搜索框左边的小三角符号，<code>可以切换成替换模式</code>。</p>
<p>有时候使用字符串替换，比多光标方便，但是注意别不小心替换掉不想替换的内容。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/07/fEYHuMR4poLmb7n.png" alt="在这里插入图片描述"></p>
<p><img src="https://s2.loli.net/2023/08/07/dGwyr54Vso9ZT7C.png" alt="QQ图片20230807173855"></p>
<p>以上就是<code>vscode</code>同时编辑多处的三种方法，希望大家喜欢，谢谢！</p>
</blockquote>
<h3 id="4-全局替换某些单词"><a href="#4-全局替换某些单词" class="headerlink" title="4.全局替换某些单词"></a>4.全局替换某些单词</h3><ul>
<li>​        快捷键：ctrl + h </li>
</ul>
<h3 id="5-快速定位到某一行"><a href="#5-快速定位到某一行" class="headerlink" title="5.快速定位到某一行"></a>5.快速定位到某一行</h3><ul>
<li>​        快捷键：ctrl + g</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>将项目上传到gitee上面</title>
    <url>//%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0gitee%E4%B8%8A%E9%9D%A2.html</url>
    <content><![CDATA[<h2 id="将项目上传到gitee上"><a href="#将项目上传到gitee上" class="headerlink" title="将项目上传到gitee上"></a>将项目上传到gitee上</h2><p>1.新建仓库</p>
<p><img src="https://s2.loli.net/2023/11/09/45LPbOEIiAagoS3.webp" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/11/09/i51aHGPbW9tEVe2.webp" alt="image.png"></p>
<p>出现这样的界面就创建仓库成功了</p>
<p><img src="https://s2.loli.net/2023/11/09/1fZWhxG3A2TsYrU.webp" alt="image.png"></p>
<p>然后git全局设置（配置你的用户名及邮箱）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;木倾心&quot;</span><br><span class="line">$ git config --global user.email &quot;自己的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>在本地项目打开终端</p>
<p><img src="https://s2.loli.net/2023/11/09/sXazqONBI8t4Hdy.webp" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/11/09/luMAN3YRmUnyzIr.webp" alt="image.png"></p>
<p>然后初始化本地环境，把该项目变成可被git管理的仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://s2.loli.net/2023/11/09/5WBITKGatfZgFoC.webp" alt="image.png"></p>
<p>添加该项目下的所有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add . （不要忘记后面那个点）</span><br></pre></td></tr></table></figure>
<p>添加该项目所有文件到本地仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &#x27;本次提交的说明&#x27; (提交说明尽量写得有意义)</span><br></pre></td></tr></table></figure>
<p>将本地代码库与远程代码库相关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://gitee.com/mu-qingxin/自己gitee创建仓库地址</span><br></pre></td></tr></table></figure>
<p>将本地代码推送到指定远程的仓库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin &quot;master&quot; </span><br></pre></td></tr></table></figure>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="1-不用初始化ReadMe文件，造成本地和远程的不同步"><a href="#1-不用初始化ReadMe文件，造成本地和远程的不同步" class="headerlink" title="1.不用初始化ReadMe文件，造成本地和远程的不同步"></a>1.不用初始化ReadMe文件，造成本地和远程的不同步</h3><h3 id="2-报错：-git-push后出现错误-rejected-master-gt-master-non-fast-forward"><a href="#2-报错：-git-push后出现错误-rejected-master-gt-master-non-fast-forward" class="headerlink" title="2.报错：[git push后出现错误 ![rejected] master -&gt; master(non-fast-forward) ]"></a>2.报错：[git push后出现错误 ![rejected] master -&gt; master(non-fast-forward) ]</h3><p>我们提交代码<code>git push</code>后出现如下错误提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">To https://gitee.com/xxxxx/vue_shop.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;https://gitee.com/xxxxx/vue_shop.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/11/09/TijUrupa92fbXYZ.png" alt="img"></p>
<ul>
<li>原因</li>
</ul>
<p>Git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。<br>远程仓库和本地仓库存在差异。<br>一般都是因为你在码云创建的仓库有ReadMe文件，而本地没有，造成本地和远程的不同步</p>
<ul>
<li>解决方法：</li>
</ul>
<p>方法一、同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git pull origin master --allow-unrelated-histories //把远程仓库和本地同步，消除差异</span><br><span class="line">2、重新add和commit相应文件</span><br><span class="line">3、git push origin master</span><br><span class="line">4、此时就能够上传成功了</span><br></pre></td></tr></table></figure>
<p>如果只是因为本地没有ReadMe文件，那么就在本地生成一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin master  //本地生成ReadMe文件</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>方法二：强推</p>
<p>即利用强覆盖方式用你本地的代码替代git仓库内的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>
<p>该命令会强制上传覆盖远程文件，慎用</p>
<p>方法三、</p>
<p>先把git的东西fetch到你本地然后merge后再push</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM</title>
    <url>//SSM.html</url>
    <content><![CDATA[<h1 id="三大框架"><a href="#三大框架" class="headerlink" title="三大框架"></a>三大框架</h1><h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><h3 id="1-Spring是什么"><a href="#1-Spring是什么" class="headerlink" title="1. Spring是什么"></a>1. Spring是什么</h3><p>​    Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和AOP（Aspect OrientedProgramming：面向切面编程）为内核。提供了展现层 SpringMVC 和持久层 Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架</p>
<p>1.3 Spring的优势</p>
<p>​    1）方便解耦，简化开发</p>
<p>​        通过 Spring 提供的 IoC容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。</p>
<p>​        用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p>
<p>​    2）AOP 编程的支持</p>
<p>​        通过 Spring的 AOP 功能，方便进行面向切面编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松实现。</p>
<p>​    3）声明式事务的支持</p>
<p>​        可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。</p>
<p>​    4）方便程序的测试</p>
<p>​        可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情</p>
<h3 id="2-Spring快速入门"><a href="#2-Spring快速入门" class="headerlink" title="2.Spring快速入门"></a>2.Spring快速入门</h3><p>​        ① 导入 Spring 开发的基本包坐标</p>
<p>​        ② 编写 Dao 接口和实现类</p>
<p>​        ③ 创建 Spring 核心配置文件</p>
<p>​        ④ 在 Spring 配置文件中配置 UserDaoImpl</p>
<p>​        ⑤ 使用 Spring 的 API 获得 Bean 实例</p>
<p>Spring的开发步骤</p>
<p>​        ① 导入坐标</p>
<p>​        ② 创建Bean</p>
<p>​        ③ 创建applicationContext.xml</p>
<p>​        ④ 在配置文件中进行配置</p>
<p>​        ⑤ 创建ApplicationContext对象getBean</p>
<h3 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3.Spring配置文件"></a>3.Spring配置文件</h3><p>3.1 Bean标签基本配置</p>
<p>​    用于配置对象交由Spring 来创建。</p>
<p>​    默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p>
<p>​    基本属性：</p>
<p>​        id：Bean实例在Spring容器中的唯一标识</p>
<p>​        class：Bean的全限定名称</p>
<p>3.2 Bean标签范围配置</p>
<p>scope：指对象的作用范围，取值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>默认值，单例的</td>
</tr>
<tr>
<td>prototype</td>
<td>多例的</td>
</tr>
<tr>
<td>request</td>
<td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中</td>
</tr>
<tr>
<td>session</td>
<td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</td>
</tr>
<tr>
<td>global session</td>
<td>WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session</td>
</tr>
</tbody>
</table>
</div>
<p>1）当scope的取值为singleton时</p>
<p>​    Bean的实例化个数：1个</p>
<p>​    Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例        加载核心配置文件时创建</p>
<p>Bean的生命周期：</p>
<p>​    对象创建：当应用加载，创建容器时，对象就被创建了</p>
<p>​    对象运行：只要容器在，对象一直活着</p>
<p>​    对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p>
<p>2）当scope的取值为prototype时</p>
<p>​    Bean的实例化个数：多个</p>
<p>​    Bean的实例化时机：当调用getBean()方法时实例化Bean</p>
<p>​    对象创建：当使用对象时，创建新的对象实例</p>
<p>​    对象运行：只要对象在使用中，就一直活着</p>
<p>​    对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</p>
<p>3.3 Bean生命周期配置</p>
<p>​    init-method：指定类中的初始化方法名称</p>
<p>​    destroy-method：指定类中销毁方法名称</p>
<p>3.4 Bean实例化三种方式</p>
<p>​    无参构造方法实例化</p>
<p>​    工厂静态方法实例化</p>
<p>​        工厂实例方法实例化</p>
<p>3.7 Bean的依赖注入概念</p>
<p>​    依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p>
<p>​    在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p>
<p>​    IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>
<p>​    那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p>
<p>​    简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<p>Bean的依赖注入方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>构造方法</th>
<th>set方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造注入</td>
<td>name表示构造方法形参列表的参数名</td>
</tr>
<tr>
<td>set注入</td>
<td>name表示set方法的后缀名称</td>
</tr>
<tr>
<td>ref</td>
<td>引用容器中bean的id</td>
</tr>
</tbody>
</table>
</div>
<p>Spring的重点配置</p>
<p>标签</p>
<p>​    id属性:在容器中Bean实例的唯一标识，不允许重复</p>
<p>​    class属性:要实例化的Bean的全限定名</p>
<p>​    scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</p>
<p>标签：属性注入</p>
<p>​    name属性：属性名称</p>
<p>​    value属性：注入的普通属性值</p>
<p>​    ref属性：注入的对象引用值</p>
<p>​    <code>&lt;list&gt;</code>标签</p>
<p>​    <code>&lt;map&gt;</code>标签</p>
<p>​    <code>&lt;properties&gt;</code>标签</p>
<p>​    <code>&lt;constructor-arg&gt;</code>构造标签    相当于<code>&lt;bean&gt;</code>标签</p>
<p>​    <code>&lt;import&gt;</code>标签:导入其他的Spring的分文件</p>
<h3 id="4-Spring相关API"><a href="#4-Spring相关API" class="headerlink" title="4.Spring相关API"></a>4.Spring相关API</h3><p>4.2 ApplicationContext的实现类</p>
<p>​    1）ClassPathXmlApplicationContext</p>
<p>​        它是从类的根路径下加载配置文件 推荐使用这种</p>
<p>​    2）FileSystemXmlApplicationContext</p>
<p>​        它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>
<p>​    3）AnnotationConfigApplicationContext</p>
<p>​        当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<p>4.3 getBean()方法</p>
<p>​    1.传标签的id        适用于一个类型多个bean</p>
<p>​        使用当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p>
<p>​    2.传字节码对象类型        适用于一个类型一个bean，当存在一个类型多个bean时分辨不出来，不能使用</p>
<p>​        当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</p>
<h2 id="2-Spring配置数据源"><a href="#2-Spring配置数据源" class="headerlink" title="2.Spring配置数据源"></a>2.Spring配置数据源</h2><h3 id="1-数据源（连接池）的作用"><a href="#1-数据源（连接池）的作用" class="headerlink" title="1.数据源（连接池）的作用"></a>1.数据源（连接池）的作用</h3><p>​    常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p>
<p>1.2抽取jdbc配置文件</p>
<p>​    applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p>
<p>​    首先，需要引入context命名空间和约束路径：</p>
<p>​    命名空间：xmlns:context=”<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“</p>
<p>​    约束路径：</p>
<p>​        <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></p>
<p>​        <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p>
<p>1.5 知识要点</p>
<p>Spring容器加载properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-Spring注解开发"><a href="#2-Spring注解开发" class="headerlink" title="2.Spring注解开发"></a>2.Spring注解开发</h3><p>2.1 Spring原始注解</p>
<p>Spring原始注解主要是替代的配置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Controller</td>
<td>使用在web层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Service</td>
<td>使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Repository</td>
<td>使用在dao层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Resource</td>
<td>相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td>@Value</td>
<td>注入普通属性</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>使用在方法上标注该方法是Bean的初始化方法</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody>
</table>
</div>
<p>2.2 Spring新注解</p>
<p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p>
<p>​    非自定义的Bean的配置：<code>&lt;bean&gt;</code></p>
<p>​    加载properties文件的配置：<code>&lt;context:property-placeholder&gt;</code></p>
<p>​    组件扫描的配置：<code>&lt;context:component-scan&gt;</code></p>
<p>​    引入其他文件：<code>&lt;import&gt;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Configuration</td>
<td>Spring的核心配置类        总    -&gt;    分</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>扫描     跟xml中一样</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>用于加载.properties 文件中的配置</td>
</tr>
<tr>
<td>@Import</td>
<td>导入分类        用于导入其他配置类</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-Spring集成Junit"><a href="#3-Spring集成Junit" class="headerlink" title="3.Spring集成Junit"></a>3.Spring集成Junit</h3><p>3.1 原始Junit测试Spring的问题</p>
<p>​    在测试类中，每个测试方法都有以下两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure>
<p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<p>3.3 Spring集成Junit步骤</p>
<p>​    ① 导入spring集成Junit的坐标</p>
<p>​    ② 使用@Runwith注解替换原来的运行期</p>
<p>​    ③ 使用@ContextConfiguration指定配置文件或配置类</p>
<p>​    ④ 使用@Autowired注入需要测试的对象</p>
<p>​    ⑤ 创建测试方法进行测试</p>
<h2 id="3-SpringMVC入门"><a href="#3-SpringMVC入门" class="headerlink" title="3.SpringMVC入门"></a>3.SpringMVC入门</h2><h3 id="1-Spring集成web环境"><a href="#1-Spring集成web环境" class="headerlink" title="1.Spring集成web环境"></a>1.Spring集成web环境</h3><p>1.1 ApplicationContext应用上下文获取方式</p>
<p>​    应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p>​    在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了</p>
<p>1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</p>
<p>所以我们需要做的只有两件事：</p>
<p>​    ① 在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</p>
<p>​    ② 使用WebApplicationContextUtils获得应用上下文对象ApplicationContext</p>
<p>1.5 知识要点</p>
<p>Spring集成web环境步骤</p>
<p>​    ① 配置ContextLoaderListener监听器</p>
<p>​    ② 使用WebApplicationContextUtils获得应用上下文</p>
<h3 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2.SpringMVC 简介"></a>2.SpringMVC 简介</h3><p>2.1 SpringMVC概述</p>
<p>​    SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>​    SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<p>2.3 SpringMVC快速入门</p>
<p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p>
<p>开发步骤：</p>
<p>​    ① 导入SpringMVC相关坐标</p>
<p>​    ② 配置SpringMVC核心控制器DispathcerServlet</p>
<p>​    ③ 创建Controller类和视图页面</p>
<p>​    ④ 使用注解配置Controller类中业务方法的映射地址</p>
<p>​    ⑤ 配置SpringMVC核心文件 spring-mvc.xml</p>
<p>​    ⑥ 客户端发起请求测试</p>
<p>2.4 知识要点</p>
<p>​    SpringMVC的开发步骤</p>
<p>​    ① 导入SpringMVC相关坐标</p>
<p>​    ② 配置SpringMVC核心控制器DispathcerServlet</p>
<p>​    ③ 创建Controller类和视图页面</p>
<p>​    ④ 使用注解配置Controller类中业务方法的映射地址</p>
<p>​    ⑤ 配置SpringMVC核心文件 spring-mvc.xml</p>
<p>​    ⑥ 客户端发起请求测试</p>
<h3 id="3-SpringMVC组件解析"><a href="#3-SpringMVC组件解析" class="headerlink" title="3.SpringMVC组件解析"></a>3.SpringMVC组件解析</h3><ol>
<li>前端控制器：DispatcherServlet</li>
</ol>
<p>​    用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<ol>
<li>处理器映射器：HandlerMapping</li>
</ol>
<p>​    HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<ol>
<li>处理器适配器：HandlerAdapter</li>
</ol>
<p>​    通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<ol>
<li>处理器：Handler</li>
</ol>
<p>​    它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</p>
<ol>
<li>视图解析器：View Resolver</li>
</ol>
<p>​    View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
<ol>
<li>视图：View</li>
</ol>
<p>​    SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h3 id="4-SpringMVC注解解析"><a href="#4-SpringMVC注解解析" class="headerlink" title="4.SpringMVC注解解析"></a>4.SpringMVC注解解析</h3><p>@RequestMapping</p>
<p>​    作用：用于建立请求 URL 和处理请求方法之间的对应关系</p>
<p>​    位置：</p>
<p>​        类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录</p>
<p>​        方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p>
<p>​    属性：</p>
<p>​        value：用于指定请求的URL。它和path属性的作用是一样的</p>
<p>​        method：用于指定请求的方式</p>
<p>​        params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</p>
<p>​    例如：</p>
<p>​        params = {“accountName”}，表示请求参数必须有accountName</p>
<p>​        params = {“moeny!100”}，表示请求参数中money不能是100</p>
<ol>
<li><p>mvc命名空间引入</p>
</li>
<li><p>组件扫描</p>
</li>
</ol>
<p>​    SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用进行组件扫描。</p>
<p>3.4 SpringMVC的XML配置解析</p>
<p>​    视图解析器</p>
<p>​    SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</p>
<p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p>
<p>​    REDIRECT_URL_PREFIX = “redirect:”     —重定向前缀</p>
<p>​    FORWARD_URL_PREFIX = “forward:”         —转发前缀（默认值）</p>
<p>​    prefix = “”; —视图名称前缀</p>
<p>​    suffix = “”; —视图名称后缀</p>
<h3 id="5-pringMVC的请求和响应"><a href="#5-pringMVC的请求和响应" class="headerlink" title="5.pringMVC的请求和响应"></a>5.pringMVC的请求和响应</h3><ol>
<li>SpringMVC的数据响应</li>
</ol>
<p>1.1 SpringMVC的数据响应方式</p>
<p>1） 页面跳转</p>
<p>​    直接返回字符串</p>
<p>​    通过ModelAndView对象返回</p>
<p>2） 回写数据</p>
<p>​    直接返回字符串</p>
<p>​    返回对象或集合</p>
<p>1.3 回写数据</p>
<p>返回对象或集合</p>
<p>​    在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。</p>
<p>​    在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p>
<p>​    使用自动加载 RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用替代注解处理器和适配器的配置。</p>
<p>​    同时使用默认底层就会集成jackson进行对象或集合的json格式字符串的转换。</p>
<ol>
<li>SpringMVC 获得请求数据</li>
</ol>
<p>2.1 获得请求参数</p>
<p>​    客户端请求参数的格式是：name=value&amp;name=value… …</p>
<p>​    服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p>
<p>​        基本类型参数</p>
<p>​        POJO类型参数</p>
<p>​        数组类型参数</p>
<p>​        集合类型参数</p>
<p>2.2 获得基本类型参数</p>
<p>​    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。</p>
<p>2.3 获得POJO类型参数</p>
<p>​    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p>
<p>2.4 获得数组类型参数</p>
<p>​    Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p>
<p>2.5 获得集合类型参数</p>
<p>​    获得集合参数时，要将集合参数包装到一个POJO中才可以。</p>
<p>​    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。</p>
<p>​    注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p>
<p>​        1.在spring-mvc.xml配置文件中指定放行的资源 </p>
<p>​        2.使用标签</p>
<p>2.6 请求数据乱码问题</p>
<p>​    当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<p>2.7 参数绑定注解@requestParam</p>
<p>​    当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。</p>
<p>​    注解@RequestParam还有如下参数可以使用：</p>
<p>​        value：与请求参数名称</p>
<p>​        required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错</p>
<p>​        defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</p>
<p>2.8 获得Restful风格的参数</p>
<p>​    Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>​    Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p>
<p>​        GET：用于获取资源</p>
<p>​        POST：用于新建资源</p>
<p>​        PUT：用于更新资源</p>
<p>​        DELETE：用于删除资源</p>
<p>​    例如：</p>
<p>​        /user/1 GET ： 得到 id = 1 的 user</p>
<p>​        /user/1 DELETE： 删除 id = 1 的 user</p>
<p>​        /user/1 PUT： 更新 id = 1 的 user</p>
<p>​        /user POST： 新增 user</p>
<p>​    上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p>
<p>2.9 自定义类型转换器</p>
<p>​    • SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p>
<p>​    • 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p>
<p>自定义类型转换器的开发步骤：</p>
<p>​    ① 定义转换器类实现Converter接口</p>
<p>​    ② 在配置文件中声明转换器</p>
<p>​    ③ 在中引用转换器</p>
<p>2.10 获得Servlet相关API</p>
<p>​    SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p>
<p>​        HttpServletRequest</p>
<p>​        HttpServletResponse</p>
<p>​        HttpSession</p>
<p>2.11 获得请求头</p>
<ol>
<li>@RequestHeader</li>
</ol>
<p>​    使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p>
<p>@RequestHeader注解的属性如下：</p>
<p>​    value：请求头的名称</p>
<p>​    required：是否必须携带此请求头</p>
<ol>
<li>@CookieValue</li>
</ol>
<p>​        使用@CookieValue可以获得指定Cookie的值</p>
<p>​    @CookieValue注解的属性如下：</p>
<p>​        value：指定cookie的名称</p>
<p>​        required：是否必须携带此cookie</p>
<p>2.12 文件上传</p>
<ol>
<li>文件上传客户端三要素</li>
</ol>
<p>​        表单项type=“file”</p>
<p>​        表单的提交方式是post</p>
<p>​        表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data”</p>
<ol>
<li>文件上传原理</li>
</ol>
<p>​        当form表单修改为多部分表单时，request.getParameter()将失效。</p>
<p>​        enctype=“application/x-www-form-urlencoded”时，form表单的正文内容格式是：</p>
<p>​        key=value&amp;key=value&amp;key=value</p>
<p>​        当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：</p>
<p>2.13 单文件上传步骤</p>
<p>​    ① 导入fileupload和io坐标</p>
<p>​    ② 配置文件上传解析器</p>
<p>​    ③ 编写文件上传代码</p>
<p>2.15 多文件上传实现    同一个文件名</p>
<p>​    多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[ ]即可</p>
<ol>
<li>Spring JdbcTemplate基本使用</li>
</ol>
<p>1.1 JdbcTemplate概述</p>
<p>​    它是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p>
<p>1.2 JdbcTemplate开发步骤</p>
<p>​    ① 导入spring-jdbc和spring-tx坐标</p>
<p>​    ② 创建数据库表和实体</p>
<p>​    ③ 创建JdbcTemplate对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(dataSource);</span><br></pre></td></tr></table></figure>
<p>④ 执行数据库操作</p>
<p>更新操作：</p>
<p>​    jdbcTemplate.update (sql,params)</p>
<p>查询操作：</p>
<p>​    jdbcTemplate.query (sql,Mapper,params)</p>
<p>​    jdbcTemplate.queryForObject(sql,Mapper,params)</p>
<p>web层用注解  service层和dao层用配置文件</p>
<h3 id="6-SpringMVC拦截器"><a href="#6-SpringMVC拦截器" class="headerlink" title="6.SpringMVC拦截器"></a>6.SpringMVC拦截器</h3><p>1.1 拦截器（interceptor）的作用</p>
<p>​    Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p>
<p>1.2 拦截器和过滤器区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>过滤器（Filter）</th>
<th>拦截器（Interceptor）</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用范围</td>
<td>是 servlet 规范中的一部分，任何Java Web 工程都可以使用</td>
<td>是 SpringMVC 框架自己的，只有使用了SpringMVC 框架的工程才能用</td>
</tr>
<tr>
<td>拦截范围</td>
<td>在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截</td>
<td>在中配置了/**之后，也可以多所有资源进行拦截，但是可以通过标签排除不需要拦截的资源</td>
</tr>
</tbody>
</table>
</div>
<p>1.3 拦截器是快速入门</p>
<p>自定义拦截器很简单，只有如下三步：</p>
<p>​    ① 创建拦截器类实现HandlerInterceptor接口</p>
<p>​    ② 配置拦截器</p>
<p>​    ③ 测试拦截器的拦截效果</p>
<p>1.4 多拦截器操作同上，在编写一个MyHandlerInterceptor2操作，测试执行顺序</p>
<p>​    12    21    21        跟栈一样，先进后出，后进先出</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>preHandle()</td>
<td>方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法</td>
</tr>
<tr>
<td>postHandle()</td>
<td>该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作</td>
</tr>
<tr>
<td>afterCompletion()</td>
<td>该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是preHandle 方法的返回值为true 时才能被调用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-SpringMVC异常处理机制"><a href="#7-SpringMVC异常处理机制" class="headerlink" title="7.SpringMVC异常处理机制"></a>7.SpringMVC异常处理机制</h3><ol>
<li>SpringMVC异常处理</li>
</ol>
<p>1.1 异常处理的思路</p>
<p>​    系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<p>​    系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理</p>
<p>1.2 异常处理两种方式</p>
<p>​    使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</p>
<p>​    实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p>
<p>​        ① 创建异常处理器类实现HandlerExceptionResolver</p>
<p>​        ② 配置异常处理器</p>
<p>​        ③ 编写异常页面</p>
<p>​        ④ 测试异常跳转</p>
<h3 id="8-Spring-MVC-框架中常用的注解"><a href="#8-Spring-MVC-框架中常用的注解" class="headerlink" title="8. Spring MVC 框架中常用的注解"></a>8. Spring MVC 框架中常用的注解</h3><ol>
<li><code>@RequestBody</code>：<ul>
<li>用于从 HTTP 请求的 body 中获取数据。</li>
<li>通常用于 POST、PUT 等请求方法，用来接收请求体中的 JSON、XML 等格式的数据。</li>
<li>适用于传输较大的数据或结构化的数据。</li>
<li>用于将请求体的内容转换为指定的 Java 对象。</li>
</ul>
</li>
<li><code>@RequestParam</code>：<ul>
<li>用于从请求的 URL 查询字符串中获取参数。</li>
<li>可以获取单个或多个参数。</li>
<li>在方法的参数列表中使用，指定参数的名称，Spring MVC 会将 URL 中的对应参数值赋给该方法参数。</li>
<li>适用于获取简单的参数值，比如表单提交或者 URL 查询字符串中的参数。</li>
</ul>
</li>
<li><code>@PathVariable</code>：<ul>
<li>用于从 URL 中获取路径变量。</li>
<li>可以将 URL 中的某一部分作为方法的参数。</li>
<li>通常用于 RESTful 风格的 URL，例如 <code>/users/&#123;id&#125;</code>，其中 <code>&#123;id&#125;</code> 就是一个路径变量，可以通过 <code>@PathVariable</code> 注解获取。</li>
<li>适用于从 URL 中获取路径参数，比如资源的 ID。</li>
</ul>
</li>
<li><code>@ResponseBody</code>：<ul>
<li>用于将方法的返回值直接作为 HTTP 响应的 body 内容返回给客户端。</li>
<li>通常用于返回 JSON、XML 等格式的数据。</li>
</ul>
</li>
<li><code>@RestController</code>：<ul>
<li>是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合注解。</li>
<li>用于标记控制器类，表示该类的所有方法都会返回 JSON/XML 等数据，而不是视图页面。</li>
</ul>
</li>
<li><code>@RequestMapping</code>：<ul>
<li>用于映射请求路径和处理方法。</li>
<li>可以用在类级别或方法级别。</li>
<li>可以指定请求的 URL、请求方法、请求参数等条件，用于匹配具体的请求。</li>
</ul>
</li>
<li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code> 等：<ul>
<li>是 <code>@RequestMapping</code> 的快捷方式，用于指定不同 HTTP 方法的请求映射。</li>
<li>分别对应 HTTP 的 GET、POST、PUT、DELETE 方法。</li>
</ul>
</li>
<li><code>@ModelAttribute</code>：<ul>
<li>用于将请求参数绑定到方法的参数或控制器的属性上。</li>
<li>可以在方法的参数上使用，表示将请求参数绑定到该参数对象上。</li>
<li>也可以用在方法上，表示将返回的对象添加到模型中。</li>
</ul>
</li>
<li><code>@Valid</code>、<code>@Validated</code> 和相关的验证注解：<ul>
<li>用于数据验证和校验。</li>
<li>可以标记在方法参数或方法上，用于验证参数或对象的有效性。</li>
<li>配合 Hibernate Validator 或其他验证框架一起使用。</li>
</ul>
</li>
</ol>
<h2 id="4-面向切面编程AOP"><a href="#4-面向切面编程AOP" class="headerlink" title="4.面向切面编程AOP"></a>4.面向切面编程AOP</h2><h3 id="1-Spring-的-AOP-简介"><a href="#1-Spring-的-AOP-简介" class="headerlink" title="1. Spring 的 AOP 简介"></a>1. Spring 的 AOP 简介</h3><p>1.1 什么是 AOP</p>
<p>​    AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>​    动态代理：解耦合，不改变源码的同时，增强原方法的功能</p>
<p>​    AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
<p>1.2 AOP 的作用及其优势</p>
<p>​    作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p>
<p>​    优势：减少重复代码，提高开发效率，并且便于维护</p>
<p>1.3 AOP 的底层实现</p>
<p>​    实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<p>1.4 AOP 的动态代理技术</p>
<p>​    常用的动态代理技术</p>
<p>​    JDK 代理 : 基于接口的动态代理技术</p>
<p>​    cglib 代理：基于父类的动态代理技术</p>
<p>1.7 AOP 相关概念</p>
<p>​    Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p>
<p>​    在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Target（目标对象）</th>
<th>代理的目标对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Proxy （代理）</td>
<td>一个类被 AOP 织入增强后，就产生一个结果代理类</td>
</tr>
<tr>
<td>Joinpoint（连接点）</td>
<td>所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点<br />可以被增强的方法叫做连接点</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br />需要被增强的方法</td>
</tr>
<tr>
<td>Advice（通知/ 增强）</td>
<td>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br />增强的方法</td>
</tr>
<tr>
<td>Aspect（切面）</td>
<td>是切入点和通知（引介）的结合</td>
</tr>
<tr>
<td>Weaving（织入）</td>
<td>是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入<br />将切点和通知结合的过程</td>
</tr>
</tbody>
</table>
</div>
<p>1.8 AOP 开发明确的事项</p>
<ol>
<li>需要编写的内容</li>
</ol>
<p>​    编写核心业务代码（目标类的目标方法）</p>
<p>​    编写切面类，切面类中有通知(增强功能方法)</p>
<p>​    在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p>
<ol>
<li>AOP 技术实现的内容</li>
</ol>
<p>​    Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<ol>
<li>AOP 底层使用哪种代理方式</li>
</ol>
<p>​    在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式</p>
<p>1.9 知识要点</p>
<p>​    aop：面向切面编程</p>
<p>​    aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理</p>
<p>​    aop的重点概念：</p>
<p>​        Pointcut（切入点）：被增强的方法</p>
<p>​        Advice（通知/ 增强）：封装增强业务逻辑的方法</p>
<p>​        Aspect（切面）：切点+通知</p>
<p>​        Weaving（织入）：将切点与通知结合的过程</p>
<p>​    开发明确事项：</p>
<p>​        谁是切点（切点表达式配置）</p>
<p>​        谁是通知（切面类中的增强方法）</p>
<p>​        将切点和通知进行织入配置</p>
<h3 id="2-基于-XML-的-AOP-开发"><a href="#2-基于-XML-的-AOP-开发" class="headerlink" title="2.基于 XML 的 AOP 开发"></a>2.基于 XML 的 AOP 开发</h3><p>2.1 快速入门</p>
<p>​    ① 导入 AOP 相关坐标</p>
<p>​    ② 创建目标接口和目标类（内部有切点）</p>
<p>​    ③ 创建切面类（内部有增强方法）</p>
<p>​    ④ 将目标类和切面类的对象创建权交给 spring</p>
<p>​    ⑤ 在 applicationContext.xml 中配置织入关系</p>
<p>​    ⑥ 测试代码</p>
<p>2.2 XML 配置 AOP 详解</p>
<ol>
<li>切点表达式的写法</li>
</ol>
<p>表达式语法：</p>
<p>​    execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p>
<p>​    访问修饰符可以省略</p>
<p>​    返回值类型、包名、类名、方法名可以使用星号* 代表任意</p>
<p>​    包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p>
<p>​    参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br><span class="line">execution(public void com.itheima.aop.Target.method())</span><br><span class="line">execution(void com.itheima.aop.Target.*(..))</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure>
<ol>
<li>通知的类型</li>
</ol>
<p>通知的配置语法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置通知</td>
<td></td>
<td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td></td>
<td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td></td>
<td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td>
</tr>
<tr>
<td>异常抛出通知</td>
<td></td>
<td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td>
</tr>
<tr>
<td>最终通知</td>
<td></td>
<td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>切点表达式的抽取</li>
</ol>
<p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<p>2.3知识要点</p>
<p>aop的织入</p>
<p>​    通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知</p>
<p>​    切点表达式的写法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p>
<h3 id="3-基于注解的-AOP-开发"><a href="#3-基于注解的-AOP-开发" class="headerlink" title="3.基于注解的 AOP 开发"></a>3.基于注解的 AOP 开发</h3><p>3.1 快速入门</p>
<p>基于注解的aop开发步骤：</p>
<p>​    ① 创建目标接口和目标类（内部有切点）</p>
<p>​    ② 创建切面类（内部有增强方法）</p>
<p>​    ③ 将目标类和切面类的对象创建权交给 spring</p>
<p>​    ④ 在切面类中使用注解配置织入关系</p>
<p>​    ⑤ 在配置文件中开启组件扫描和 AOP 的自动代理</p>
<p>​    ⑥ 测试</p>
<p>3.2 注解配置 AOP 详解</p>
<ol>
<li>注解通知的类型</li>
</ol>
<p>通知的配置语法：@通知注解(“切点表达式”)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置通知</td>
<td>@Before</td>
<td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td>@AfterReturning</td>
<td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td>@Around</td>
<td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td>
</tr>
<tr>
<td>异常抛出通知</td>
<td>@AfterThrowing</td>
<td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td>
</tr>
<tr>
<td>最终通知</td>
<td>@After</td>
<td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>切点表达式的抽取</li>
</ol>
<p>​    同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@Component(&quot;myAspect&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">	@Before(&quot;MyAspect.myPoint()&quot;)</span><br><span class="line">	public void before()&#123;</span><br><span class="line">		System.out.println(&quot;前置代码增强.....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void myPoint()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解aop开发步骤</p>
<p>​    ① 使用@Aspect标注切面类</p>
<p>​    ② 使用@通知注解标注通知方法</p>
<p>​    ③ 在配置文件中配置aop自动代理</p>
<h2 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h2><h3 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1.编程式事务控制相关对象"></a>1.编程式事务控制相关对象</h3><p>1.1 PlatformTransactionManager </p>
<p>​    PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>TransactionStatus getTransaction(TransactionDefination defination)</td>
<td>获取事务的状态信息</td>
</tr>
<tr>
<td>void commit(TransactionStatus status)</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback(TransactionStatus status)</td>
<td>回滚事务</td>
</tr>
</tbody>
</table>
</div>
<p>注意：</p>
<p>​    PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：</p>
<p>​    Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager </p>
<p>​    Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p>
<p>1.2 TransactionDefinitionTransactionDefinition </p>
<p>是事务的定义信息对象，里面有如下方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int getIsolationLevel()</td>
<td>获得事务的隔离级别</td>
</tr>
<tr>
<td>int getPropogationBehavior()</td>
<td>获得事务的传播行为</td>
</tr>
<tr>
<td>int getTimeout()</td>
<td>获得超时时间</td>
</tr>
<tr>
<td>boolean isReadOnly()</td>
<td>是否只读</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>事务隔离级别</li>
</ol>
<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p>
<p>​    ISOLATION_DEFAULT</p>
<p>​    ISOLATION_READ_UNCOMMITTED</p>
<p>​    ISOLATION_READ_COMMITTED</p>
<p>​    ISOLATION_REPEATABLE_READ</p>
<p>​    ISOLATION_SERIALIZABLE</p>
<ol>
<li>事务传播行为</li>
</ol>
<p>​    REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</p>
<p>​    SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</p>
<p>​    MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p>
<p>​    REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p>
<p>​    NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p>
<p>​    NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p>
<p>​    NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p>
<p>​    超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p>
<p>​    是否只读：建议查询时设置为只读</p>
<p>1.3 TransactionStatus</p>
<p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean hasSavepoint()</td>
<td>是否存储回滚点</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>事务是否完成</td>
</tr>
<tr>
<td>boolean isNewTransaction()</td>
<td>是否是新事务</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>事务是否回滚</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-基于-XML-的声明式事务控制"><a href="#2-基于-XML-的声明式事务控制" class="headerlink" title="2.基于 XML 的声明式事务控制"></a>2.基于 XML 的声明式事务控制</h3><p>2.1 什么是声明式事务控制</p>
<p>​    Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p>
<p>声明式事务处理的作用</p>
<p>​    事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p>
<p>​    在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p>
<p>​    注意：Spring 声明式事务控制底层就是AOP。</p>
<p>2.2 声明式事务控制的实现</p>
<p>声明式事务控制明确事项：</p>
<p>​    谁是切点？</p>
<p>​    谁是通知？</p>
<p>​    配置切面？</p>
<p>2.3 切点方法的事务参数的配置</p>
<p>其中， 代表切点方法的事务参数的配置，例如：</p>
<p>​    name：切点方法名称</p>
<p>​    isolation:事务的隔离级别</p>
<p>​    propogation：事务的传播行为</p>
<p>​    timeout：超时时间</p>
<p>​    read-only：是否只读</p>
<p>2.4 知识要点</p>
<p>​    声明式事务控制的配置要点</p>
<p>​    平台事务管理器配置</p>
<p>​    事务通知的配置</p>
<p>​    事务aop织入的配置</p>
<h3 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3.基于注解的声明式事务控制"></a>3.基于注解的声明式事务控制</h3><p>3.2 注解配置声明式事务控制解析</p>
<p>​    ① 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p>
<p>​    ② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p>
<p>​    ③ 使用在方法上，不同的方法可以采用不同的事务参数配置。</p>
<p>​    ④ Xml配置文件中要开启事务的注解驱动</p>
<p>3.3 知识要点</p>
<p>​    注解声明式事务控制的配置要点</p>
<p>​    平台事务管理器配置（xml方式）</p>
<p>​    事务通知的配置（@Transactional注解配置）</p>
<p>​    事务注解驱动的配置 </p>
<h2 id="5-MyBatis入门操作"><a href="#5-MyBatis入门操作" class="headerlink" title="5.MyBatis入门操作"></a>5.MyBatis入门操作</h2><h3 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1.Mybatis简介"></a>1.Mybatis简介</h3><p>1.2 原始jdbc操作的分析</p>
<p>原始jdbc开发存在的问题如下：</p>
<p>​    ① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</p>
<p>​    ② sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。</p>
<p>​    ③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p>
<p>应对上述问题给出的解决方案：</p>
<p>​    ① 使用数据库连接池初始化连接资源</p>
<p>​    ② 将sql语句抽取到xml配置文件中</p>
<p>​    ③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>
<p>1.3 什么是Mybatis</p>
<p>​    mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​    mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>​    最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p>
<h3 id="2-MyBatis开发步骤"><a href="#2-MyBatis开发步骤" class="headerlink" title="2.MyBatis开发步骤"></a>2.MyBatis开发步骤</h3><p>MyBatis开发步骤：</p>
<p>​    ① 添加MyBatis的坐标</p>
<p>​    ② 创建user数据表</p>
<p>​    ③ 编写User实体类</p>
<p>​    ④ 编写映射文件UserMapper.xml</p>
<p>​    ⑤ 编写核心文件SqlMapConfig.xml</p>
<p>​    ⑥ 编写测试类</p>
<p>2.2 环境搭建</p>
<ol>
<li><p>导入MyBatis的坐标和其他相关坐标</p>
</li>
<li><p>MyBatis的增删改查操作</p>
</li>
</ol>
<p>知识小结</p>
<p>增删改查映射配置与API：</p>
<p>查询数据：List userList = sqlSession.selectList(“userMapper.findAll”);</p>
<p>​        select * from User</p>
<p>添加数据：sqlSession.insert(“userMapper.add”, user);</p>
<p>​        insert into user values(#{id},#{username},#{password})</p>
<p>修改数据：sqlSession.update(“userMapper.update”, user);</p>
<p>​        update user set username=#{username},password=#{password} where id=#{id}</p>
<p>删除数据：sqlSession.delete(“userMapper.delete”,3);</p>
<p>​        delete from user where id=#{id}</p>
<h3 id="5-MyBatis核心配置文件概述"><a href="#5-MyBatis核心配置文件概述" class="headerlink" title="5.MyBatis核心配置文件概述"></a>5.MyBatis核心配置文件概述</h3><p>5.1 MyBatis核心配置文件层级关系</p>
<p><img src="https://s2.loli.net/2023/10/17/JOETG5mYS7KMZNh.png" alt="image-20231017162302226"></p>
<p>5.2 MyBatis常用配置解析</p>
<ol>
<li>environments标签</li>
</ol>
<p>数据库环境的配置，支持多环境配置</p>
<p>​    其中，事务管理器（transactionManager）类型有两种：</p>
<p>​        • JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p>
<p>​        • MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>​    • UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
<p>​    • POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>​    • JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<ol>
<li>mapper标签</li>
</ol>
<p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<p>​    • 使用相对于类路径的资源引用，例如：<code>&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;</code></p>
<p>​    • 使用完全限定资源定位符（URL），例如：<code>&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</code></p>
<p>​    • 使用映射器接口实现类的完全限定类名，例如：<code>&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</code></p>
<p>​    • 将包内的映射器接口实现全部注册为映射器，例如：<code>&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</code></p>
<ol>
<li>Properties标签</li>
</ol>
<p>​    实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p>
<ol>
<li>typeAliases标签</li>
</ol>
<p>类型别名是为Java 类型设置一个短的名字。</p>
<p>配置typeAliases，为com.itheima.domain.User定义别名为user</p>
<p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>别名</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-MyBatis相应API"><a href="#6-MyBatis相应API" class="headerlink" title="6.MyBatis相应API"></a>6.MyBatis相应API</h3><p>6.1 SqlSession工厂构建器SqlSessionFactoryBuilder</p>
<p>​    常用API：SqlSessionFactory build(InputStream inputStream)</p>
<p>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br></pre></td></tr></table></figure>
<p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<p>6.2 SqlSession工厂对象SqlSessionFactory</p>
<p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>openSession()</td>
<td>会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中</td>
</tr>
<tr>
<td>openSession(boolean autoCommit)</td>
<td>参数为是否自动提交，如果设置为true，那么不需要手动提交事务</td>
</tr>
</tbody>
</table>
</div>
<p>6.3 SqlSession会话对象</p>
<p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</p>
<p>执行语句的方法主要有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T selectOne(String statement, Object parameter) </span><br><span class="line">List selectList(String statement, Object parameter) </span><br><span class="line">int insert(String statement, Object parameter) </span><br><span class="line">int update(String statement, Object parameter) </span><br><span class="line">int delete(String statement, Object parameter)</span><br></pre></td></tr></table></figure>
<p>操作事务的方法主要有：</p>
<p>​    void commit()</p>
<p>​    void rollback()</p>
<p>1.Mybatis的Dao层实现</p>
<p>代理开发方式</p>
<ol>
<li>代理开发方式介绍</li>
</ol>
<p>​    采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。</p>
<p>​    Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p>Mapper 接口开发需要遵循以下规范：</p>
<p>​    1、 Mapper.xml文件中的namespace与mapper接口的全限定名相同</p>
<p>​    2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p>
<p>​    3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</p>
<p>​    4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>
<p>MyBatis的Dao层实现的两种方式：</p>
<p>手动对Dao进行实现：传统开发方式</p>
<p>代理方式对Dao进行实现：</p>
<p>UserMapper userMapper = sqlSession.getMapper(UserMapper.class)</p>
<p><img src="https://s2.loli.net/2023/10/17/mWkVbga4nILj3MJ.png" alt="image-20231017162629569"></p>
<p>1.MyBatis映射文件深入</p>
<p>1.1 动态sql语句</p>
<ol>
<li>动态sql语句概述</li>
</ol>
<p>​    Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。‘</p>
<ol>
<li>动态 SQL 之 <code>&lt;if&gt;</code></li>
</ol>
<p>​    我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">	select * from User</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;if test=&quot;id!=0&quot;&gt;</span><br><span class="line">			and id=#&#123;id&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;username!=null&quot;&gt;</span><br><span class="line">			and username=#&#123;username&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;	</span><br></pre></td></tr></table></figure>
<ol>
<li>动态 SQL 之 <code>&lt;foreach&gt;</code></li>
</ol>
<p>​    循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">	select * from User</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">			#&#123;id&#125;</span><br><span class="line">		&lt;/foreach&gt;</span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>foreach标签的属性含义如下：</p>
<p>标签用于遍历集合，它的属性：</p>
<p>​    • collection：代表要遍历的集合元素，注意编写时不要写#{}</p>
<p>​    • open：代表语句的开始部分</p>
<p>​    • close：代表结束部分</p>
<p>​    • item：代表遍历集合的每个元素，生成的变量名</p>
<p>​    • sperator：代表分隔符</p>
<p>1.2 SQL片段抽取</p>
<p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<p>MyBatis映射文件配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;：查询</span><br><span class="line">&lt;insert&gt;：插入</span><br><span class="line">&lt;update&gt;：修改</span><br><span class="line">&lt;delete&gt;：删除</span><br><span class="line">&lt;where&gt;：where条件</span><br><span class="line">&lt;if&gt;：if判断</span><br><span class="line">&lt;foreach&gt;：循环</span><br><span class="line">&lt;sql&gt;：sql片段抽取</span><br></pre></td></tr></table></figure>
<ol>
<li>MyBatis核心配置文件深入</li>
</ol>
<p>1.1 typeHandlers标签</p>
<p>​    无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p>
<p>​    你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p>
<p>开发步骤：</p>
<p>​    ① 定义转换类继承类BaseTypeHandler</p>
<p>​    ② 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法</p>
<p>​    ③ 在MyBatis核心配置文件中进行注册</p>
<p>​    ④ 测试转换是否正确</p>
<p>1.2 plugins标签</p>
<p>​    MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据</p>
<p>开发步骤：</p>
<p>​    ① 导入通用PageHelper的坐标</p>
<p>​    ② 在mybatis核心配置文件中配置PageHelper插件</p>
<p>​    ③ 测试分页数据获取</p>
<p>MyBatis核心配置文件常用标签：</p>
<p>​    1、properties标签：该标签可以加载外部的properties文件</p>
<p>​    2、typeAliases标签：设置类型别名</p>
<p>​    3、environments标签：数据源环境配置标签</p>
<p>​    4、typeHandlers标签：配置自定义类型处理器</p>
<p>​    5、plugins标签：配置MyBatis的插件    </p>
<p>MyBatis多表配置方式：</p>
<p>​    一对一配置：使用做配置</p>
<p>​    一对多配置：使用+做配置</p>
<p>​    多对多配置：使用+做配置</p>
<p>1.Mybatis的注解开发</p>
<p>​    1.1 MyBatis的常用注解</p>
<p>​    这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。</p>
<p>​    @Insert：实现新增</p>
<p>​    @Update：实现更新</p>
<p>​    @Delete：实现删除</p>
<p>​    @Select：实现查询</p>
<p>​    @Result：实现结果集封装</p>
<p>​    @Results：可以与@Result 一起使用，封装多个结果集</p>
<p>​    @One：实现一对一结果集封装</p>
<p>​    @Many：实现一对多结果集封装</p>
<p>1.3 MyBatis的注解实现复杂映射开发</p>
<p>​    实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Results</td>
<td>代替的是标签该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（））</td>
</tr>
<tr>
<td>@Resut</td>
<td>代替了标签和标签@Result中属性介绍：column：数据库的列名property：需要装配的属性名one：需要使用的@One 注解（@Result（one=@One）（）））many：需要使用的@Many 注解（@Result（many=@many）（））</td>
</tr>
<tr>
<td>@One （一对一）</td>
<td>代替了 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One注解属性介绍：select: 指定用来多表查询的 sqlmapper使用格式：@Result(column=” “,property=””,one=@One(select=””))</td>
</tr>
<tr>
<td>@Many （多对一）</td>
<td>代替了标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。使用格式：@Result(property=””,column=””,many=@Many(select=””))</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解</title>
    <url>//%E6%A6%82%E5%BF%B5POJO%E3%80%81DTO%E3%80%81DAO%E3%80%81PO%E3%80%81BO%E3%80%81VO%E3%80%81QO%E3%80%81ENTITY%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<p>在java开发过程中，新手总是被DAO、PO、BO、VO等等概念弄得晕头转向。<br>下面我查找了很多资料，总结如下：</p>
<h1 id="一、POJO（Plain-Ordinary-Java-Object-简单Java对象）"><a href="#一、POJO（Plain-Ordinary-Java-Object-简单Java对象）" class="headerlink" title="一、POJO（Plain Ordinary Java Object 简单Java对象）"></a>一、POJO（Plain Ordinary Java Object 简单Java对象）</h1><p>实际就是普通JavaBeans，是为了避免和EJB（Enterprise Java Beans 企业级JavaBeans）混淆所创造的简称，也称为（Plain Old Java Object 又普通又老的对象）。</p>
<p>相比于EJB来说，的确是老的对象，因为ORM中间件的日趋流行，POJO又重新焕发了光彩。</p>
<p>POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。<br>它仅包含自身的属性以及自身属性的getter和setter方法，这意味者POJO可以方便的从一个框架迁移到另一个框架中，或者框架升级也会对代码毫无影响，因此而得到复用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如在该实体EJB中，实体包含业务逻辑，同时也包含自身的持久化逻辑</span></span><br><span class="line"><span class="comment">//当更换数据源，或改变中间件框架时，则需要修改大量代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">	<span class="comment">//省略业务逻辑</span></span><br><span class="line">	<span class="comment">//数据库访问方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//通过不同方式访问数据库，例如JDBC，Mybaits，JPA</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Customer <span class="title function_">load</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">	<span class="keyword">public</span> Customer <span class="title function_">create</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当改为POJO时，则可以运行在任一JAVA环境中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">	<span class="comment">//省略getter和setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般，当需要持久化对象时，人们喜欢将该对象放在名为xxxPOJO的目录中。当然，不建议这样命名。<br>POJO实际上是包括BO/VO/PO/DO等一系列对象的总称。有的团队规定禁止命名成xxxPOJO。</p>
<h1 id="二、PO-persistence-object-持久层对象"><a href="#二、PO-persistence-object-持久层对象" class="headerlink" title="二、PO(persistence object 持久层对象)"></a>二、PO(persistence object 持久层对象)</h1><p>对象字段持有的数据需要被持久化到数据表中，参与到持久化操作的对象就被称为持久化对象(persistence object，PO)。</p>
<p>通常，PO是在ORM（对象关系映射）中与数据表的一条记录相匹配，自身属性与数据表字段一一对应。可以将数据表中的一条记录作为一个对象处理，并可以转化为其它对象。</p>
<p>面对不同的数据源时，比如文档型数据库，对象型数据库等时，顾名思义PO是DAO层为进行持久化操作而准备的对象。</p>
<ul>
<li>包含getter、setter方法。</li>
<li>一般不包含业务逻辑与数据库的访问方法。因为数据库本身不包含业务逻辑。</li>
<li>PO平常不一定需要实现序列化，只是当采用分布式存储或者需要作为前端输出及远程调用使用时，应该实现序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//序列化版本，通过IDEA自动生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialiVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>；</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;    </span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>注意，持久化对象并不一定就是ORM机制（对象关系映射）的数据对象，相反，在领域驱动设计中，持久化对象往往指的就是领域模型对象。</p>
<p>在《阿里巴巴开发手册》中，PO也叫DO（Data Object）数据对象，与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p>
<h1 id="三、DAO-data-access-object-数据访问对象"><a href="#三、DAO-data-access-object-数据访问对象" class="headerlink" title="三、DAO(data access object 数据访问对象)"></a>三、DAO(data access object 数据访问对象)</h1><p>包含对数据的访问，负责持久层的操作 。通常需要结合PO来访问数据库，主要用来封装对数据的访问，并不转化成其它对象。<br>在基于“事务脚本”的业务设计时，它包含业务逻辑。否则，一般只包含持久化的封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、DTO（Data-Transfer-Object-数据传输对象）"><a href="#四、DTO（Data-Transfer-Object-数据传输对象）" class="headerlink" title="四、DTO（Data Transfer Object 数据传输对象）"></a>四、DTO（Data Transfer Object 数据传输对象）</h1><p>数据传输对象，是在应用网络层需要传输的对象，是一个为了减少方法调用次数而在进程间传输数据的对象。</p>
<p>在《阿里巴巴开发手册中》规定是Service 或 Manager 向外传输的对象。</p>
<blockquote>
<p>DTO模式诞生的背景是分布式通信。考虑到网络传输的损耗与不可靠性，设计分布式服务需遵循一个总体原则：尽可能设计粗粒度的服务，每个服务的方法应代表一个完整的功能，而不是功能的一个步骤。粗粒度服务可以减少服务调用的次数，从而减少不必要的网络通信，同时也能避免对分布式事务的支持。<br>某些人称这个为“值对象”，当然还是有稍许区别。值对象追求对象不可变，DTO的对象是可修改，可改变的。</p>
</blockquote>
<ol>
<li>什么是DTO?</li>
</ol>
<p>从输入来看，在进行请求时，应用在接口接收传入对象，然后又转换成实体进行持久化。在此过程中，传入的对象就是DTO。<br>它的命名方式可能是Param、Query 、Command、等。Param 为查询参数对象，适用于各层，一般用做接受前端参数对象。Param 和 Query 的出现是为了不使用 Map 做为接收参数的对象。<br>从输出来看，在进行返回响应时，若数据表有100个字段，那么PO中就有100个属性，而界面可能只需要其中10个属性，那么查询数据库后，对象就需要由PO转化成DTO。<br>DTO可能还需要组合多个表查询到的对象成为一个大对象，以便减少网络的调用，或者给前端传输一些不在数据库中查到的属性，所以需要添加属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码，继承实体类，从查询到的PO中添加属性返回给前端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//序列化版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialiVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>；</span><br><span class="line">    <span class="comment">//用户标识</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span>&#123;<span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;<span class="built_in">this</span>.username= username;&#125;</span><br><span class="line">    <span class="comment">//添加额外属性</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; extProperties;        </span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title function_">getExtProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExtProperties</span><span class="params">(HashMap&lt;String, Object&gt; extProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.extProperties = extProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>DTO里面有什么？</li>
</ol>
<p>一般不建议创建DTO，因为里面就一些属性和getter、setter方法，业务价值小，作用仅仅是在一次调用中传输几部分信息。<br>其中，属性必须为原始数据类型，因为DTO需要被序列化以便能在连接中传播。<br>它只包含自身数据的存储，而不包含业务逻辑。<br>在不同的客户端之间，通常需要DTO组装器完成领域对象和DTO之间的转化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DTOAssembler &#123;</span><br><span class="line">	public DTO createDTO(DO domainObject);</span><br><span class="line">	public void updateDO(DTO  dataTransferObject);</span><br><span class="line">	public DO createDO(DTO  dataTransferObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>DTO怎么使用？</li>
</ol>
<p>对于不同的客户端展现，可以选择一次封装所有可能的数据组成DTO，也可以为每种展现创建不同的DTO。各有利弊。</p>
<ul>
<li>单个大DTO，减少调用次数，只用创建一次，但是难以掌握传输的数据</li>
</ul>
<ul>
<li>不同的小DTO，要创建很多DTO，传输数据很清晰</li>
</ul>
<p>对于输入方和输出方，可以共用一个DTO，也可以各准备一个DTO，视情况而定。</p>
<p>有部分团队 RPC 的请求和响应参数都通过 DTO 来承载，通过 XXRequestDTO 和 XXResponseDTO 来表示。</p>
<h1 id="五、Entity（实体）"><a href="#五、Entity（实体）" class="headerlink" title="五、Entity（实体）"></a>五、Entity（实体）</h1><p>实体，顾名思义，实体需要给予一个唯一标识，以区分其它实体，而值对象VO不需要。<br>实体应该有一个生命周期，是有状态的，例如抽象订单有一个唯一识别号，订单有从下单创建到最后交货完成的生命周期，实体对象的状态可以变化。</p>
<ol>
<li>与VO(值对象)的区别：</li>
</ol>
<p>只要两个实体对象的唯一标识相等，就判断两个对象相等，即使其他属性不同。可以修改实体状态。<br>而VO(值对象）没有标识，所有属性相等，才判断两个对象相等。只能创建新的值对象，不能修改。</p>
<ol>
<li>与PO（持久化对象）的区别：</li>
</ol>
<p>PO与数据表的一条记录对应，通常为了方便存储，会给PO赋予了一个主键ID。<br>从而，PO也像实体一样具有了标识，Martin Flowler称之为委派标识，区别于实体标识。<br>例如身份证号作为身份证的实体标识，唯一区分其他身份证。但是存储在数据库中，依然可能分配自增主键ID(1,2,3,…)。若值对象需要持久化，也会被分配委派标识，方便查询，或与外键关联。<br>实体的标识与业务有关，PO的委派标识仅方便存储，与技术有关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、VO-value-object-值对象）"><a href="#六、VO-value-object-值对象）" class="headerlink" title="六、VO(value object 值对象）"></a>六、VO(value object 值对象）</h1><p>值对象，通常用于业务层之间的数据传递，仅仅包含自身的数据。<br>与实体的区别是，没有唯一标识，无生命周期，内部值是不变的。<br>与PO的区别是，PO只在数据层，作为存储。VO在商业逻辑层和表示层，作为一个概念整体。</p>
<ul>
<li>值对象通常是小而简单的对象，如货币、日期或地址这样的对象，判断相等时不根据标识ID。比如，年月日相同，就判断这两个对象相等。</li>
<li>值对象易于创建，参数传递时通常是传递值，而不是传递引用。</li>
<li>值对象不应被持久化，这个对象被创建后只能被引用，当没有引用时交给垃圾回收自动处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码,比如Address这样无唯一标识的就是值对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String country, String province, String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.country= country;</span><br><span class="line">        <span class="built_in">this</span>.province= province;</span><br><span class="line">        <span class="built_in">this</span>.city= city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略equals方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用值对象，若要修改值对象，值对象不用维护，直接创建一个全新的Address对象</span></span><br><span class="line"><span class="comment">//原对象直接被抛弃，而不是在原对象上进行修改</span></span><br><span class="line"><span class="keyword">public</span> Address <span class="title function_">changeAddress</span><span class="params">(String newCity, String newProvince, String newCity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Address</span>(newCity, newProvince, newCity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了VO的意思，也就明白了，某些DTO也是一种值对象。历史上，在Martin Flowler称“值对象”的术语，在J2EE社团中称为“数据传输对象”，这在设计模式界引起了一场混乱。</p>
<h1 id="七、VO（-View-Object-显示层对象）"><a href="#七、VO（-View-Object-显示层对象）" class="headerlink" title="七、VO（ View Object 显示层对象）"></a>七、VO（ View Object 显示层对象）</h1><p>Value Object和View Object的简写都是VO，可能容易弄混。View Object的含义是通常是Web向模板渲染引擎层传输的对象。《阿里巴巴开发手册》中建议把输出的显示层对象命名为VO。当然，也有人把这个对象命名为DTO作为传输。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller层</span></span><br><span class="line"><span class="keyword">public</span> HttpResult <span class="title function_">list</span><span class="params">(<span class="meta">@RequestBody</span> XXParam param)</span>&#123;</span><br><span class="line">    HttpResult vo=HttpResultUtils.convert(XXDTO);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于很多页面需要额外数据，比如错误码、提示信息、分页信息等，查询的DTO之后需要再封装成View Object 显示层对象再显示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	errcode: &quot;00000&quot;,</span><br><span class="line">	errmsg: &quot;ok&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		pageNum: 1, </span><br><span class="line">		pageSize: 10, </span><br><span class="line">		totalPage: 1, </span><br><span class="line">		total: 4, </span><br><span class="line">		list: [...]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、BO-business-object-业务对象"><a href="#八、BO-business-object-业务对象" class="headerlink" title="八、BO(business object 业务对象)"></a>八、BO(business object 业务对象)</h1><p>业务对象(business object，BO)是企业领域用来描述业务概念的语义对象。这是一个非常宽泛的定义。</p>
<p>业务对象，就是把业务逻辑封装为一个对象（注意是对象本身的业务逻辑，而不是协调其它对象的逻辑），这个业务对象可以包括一个或多个其它的对象。</p>
<p>一些业务建模方法使用了业务对象的概念，如SAP定义的公共事业模型，就将客户相关信息抽象为合作伙伴、合同账户、合同、连接对象等业务对象。它是站在一个高层次角度的表述，并形成了高度抽象的业务概念。</p>
<p>如果系统采用经典三层架构，可认为业务对象就是定义在业务逻辑层中封装了业务逻辑的对象。</p>
<p>一般，实现业务的通常方式之一，是包括数据而不包含行为的领域对象（所谓“贫血模型”）+Service类来实现的。其中，业务逻辑是包含在service层里，随着业务不断演进，service类里的逻辑越来越复杂，越来越重，不利于重用。</p>
<p>而在《面向领域驱动设计》中，将对象本身的逻辑也封装在对象中（所谓“充血模型”），而service类仅仅起协调作用，比如对领域对象的调用及其它工具的调用，不包含业务本身的逻辑，是轻量级的薄薄一层，名为应用服务层。当业务不断演进时，通常只需要关注业务对象（BO）即可，而应用层面较少变化。<br>因此，业务对象，也是领域对象（Domain Object）的另一说法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//对象自身的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setPassword(newPassword);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务对象（BO）通常是实体，或者是聚合根，包含多个实体或值对象，内部实现业务逻辑。</p>
<p>此对象在实际使用中有不一样的理解，有的团队将 BO 当作 Service 返回给上层的 “专用 DTO” 使用；而有的团队则当作 Service 层内保存中间信息数据的 “DTO” 或者上下文对象来使用（建议采用这种理解）。</p>
<h1 id="九、QO-query-object-查询对象）"><a href="#九、QO-query-object-查询对象）" class="headerlink" title="九、QO(query object 查询对象）"></a>九、QO(query object 查询对象）</h1><p>数据查询对象，各层接收上层的查询请求。注意，【强制】如果超过2个参数的查询封装，则禁止使用Map类传输。<br>查询对象用于 Controller 层方法接收客户端的请求参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQO</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String param1;</span><br><span class="line">  <span class="keyword">private</span> String param2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(<span class="meta">@RequestBody</span> MyQO qo)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以创建简历对象为例，简历可分为教育经历、工作经历、项目经历。先填写查询对象的信息，转换为业务对象，分成不同的表进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyBO</span> <span class="variable">bo</span> <span class="operator">=</span> service.createBO(qo);<span class="comment">//创建业务对象</span></span><br><span class="line">bo.dosomething();</span><br><span class="line"><span class="comment">//将业务对象存储在不同的表中</span></span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po1</span> <span class="operator">=</span> service.createPO1(bo);</span><br><span class="line">dao1.save(po1);</span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po2</span> <span class="operator">=</span> service.createPO2(bo);</span><br><span class="line">dao2.save(po2);</span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po3</span> <span class="operator">=</span> service.createPO3(bo);</span><br><span class="line">dao3.save(po3);</span><br></pre></td></tr></table></figure>
<h1 id="十、AO-Application-Object-应用对象"><a href="#十、AO-Application-Object-应用对象" class="headerlink" title="十、AO (Application Object 应用对象)"></a>十、AO (Application Object 应用对象)</h1><p>一般用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为 AO，如读取用户属性传给前端，用户在前端编辑了用户属性后传回后端。这种用法将 AO 用做 Param 和 VO 或 Param 和 DTO 的组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller层</span></span><br><span class="line"><span class="keyword">public</span> HttpResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> XXAO ao1)</span>&#123;</span><br><span class="line">	<span class="type">XXAO</span> <span class="variable">ao2</span> <span class="operator">=</span> XXService.update(ao1);</span><br><span class="line">    <span class="type">HttpResult</span> <span class="variable">vo</span> <span class="operator">=</span> HttpResultUtils.convert(ao2);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h1><p>POJO：简单Java对象，它没有任何限制和特定的约定，是一个普通的Java对象。<br>DTO：数据传输对象，它是一个数据传输结构，通常用于不同进程间的数据传输，在不同层之间传递数据的对象。<br>DAO：数据访问对象，是一个数据访问模式，在应用程序中它通常扮演着对数据库的访问。<br>PO：持久化对象，通常指ORM（对象关系映射）中映射的数据库表对应的实体类。<br>BO：业务对象，是应用程序中业务逻辑的实现。<br>VO：值对象，它是一个用于存储数据的对象，通常是与UI/界面模型相关的对象。<br>QO（Query）：查询对象，它主要用于定义查询条件和规则，用于接收前端传递的查询条件参数。<br>ENTITY：实体对象，是一个与业务相关的对象，通常是与应用程序领域模型相关的对象。<br>Param：表示请求参数，用于接收前端传递的参数<br>Command：表示命令，用于接收前端传递的命令参数</p>
<blockquote>
<p>各对象的命名习惯：</p>
<p>PO通常放在名为bean、entity、model目录中。<br>DAO本身就是一层，通常是DAO、mapper、repository目录。<br>BO通常在service、manager、business，domain，model目录中。<br>DTO通常在command、representation、DTO目录中。</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java对象</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖</title>
    <url>//ruijiwaimai.html</url>
    <content><![CDATA[<h1 id="瑞吉外卖项目难点"><a href="#瑞吉外卖项目难点" class="headerlink" title="瑞吉外卖项目难点"></a>瑞吉外卖项目难点</h1><ul>
<li>DTO，数据传输对象，一般用于展示层和服务层之间的数据传输</li>
<li>实体类命名：vo返回给前端，dto接受前端传入，用于封装页面提交的数据</li>
</ul>
<h2 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h2><p>实现步骤:<br>1、在实体类的属性上加入@TableField注解，指定自动填充的策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure>
<p>工具类BaseContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.ruiji.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户的id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个线程内</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置用户Id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;用户已登录，id为&#123;&#125;&quot;</span>, request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">    BaseContext.setCurrentId(empId);</span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaobjectHandler接口</p>
<p>获取用户id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.ruiji.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义元素数据对象处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"><span class="comment">//	  方法一：注入</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    HttpServletRequest request;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[insert]...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line"><span class="comment">//        metaObject.setValue(&quot;createUser&quot;, request.getSession().getAttribute(&quot;employee&quot;));</span></span><br><span class="line"><span class="comment">//        metaObject.setValue(&quot;updateUser&quot;, request.getSession().getAttribute(&quot;employee&quot;));</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[update]...&quot;</span>);</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line"><span class="comment">//        metaObject.setValue(&quot;updateUser&quot;, request.getSession().getAttribute(&quot;employee&quot;));</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><p>文件上传介绍</p>
<p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p>
<p>文件上传时，对页面的form表单有如下要求:</p>
<ul>
<li>method=”post”                        采用post方式提交数据</li>
<li>enctype=”multipart/form-data”    采用multipart格式上传文件</li>
<li>type=”file”        使用input的file控件上传</li>
</ul>
<p>举例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/common/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:</p>
<ul>
<li>commons-fileupload</li>
<li>commons-io</li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明<br>个MultipartFile类型的参数即可接收上传的文件</p>
<p>文件下载介绍</p>
<p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程</p>
<p>通过浏览器进行文件下载，通常有两种表现形式:</p>
<ul>
<li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li>
<li>直接在浏览器中打开</li>
</ul>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程,输入流，输出流</p>
<p>1.controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.ruiji.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itcast.ruiji.common.R;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件的上传和下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">commonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ruiji.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="comment">// 参数名file必须和前端发送的参数名name一致</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">// file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用UUID重新生成文件名，防止文件名重复造成文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">        <span class="comment">// 判断当前目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists())&#123;</span><br><span class="line">            <span class="comment">// 目录不存在，需要创建</span></span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将临时文件转存到指定位置,同名会覆盖</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 输入流，通过输入流读取文件内容</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line">            <span class="comment">// 输出流，通过输出流将文件写回给浏览器，在浏览器展示图片</span></span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">            response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ruiji:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">D:\img\</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><h3 id="Spring-Cache-介绍"><a href="#Spring-Cache-介绍" class="headerlink" title="Spring Cache 介绍"></a>Spring Cache 介绍</h3><p>Spring Cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。<br>Spring ache提供了一层抽象，底层可以切换不同的cache实现。具体就是通过CacheManager接口来统一不同的缓<br>存技术。<br>CacheManager是Spring提供的各种缓存技术抽象接口。</p>
<p>针对不同的缓存技术需要实现不同的CacheManager:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CacheManager</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EhCacheCacheManager</td>
<td>使用EhCache作为缓存技术</td>
</tr>
<tr>
<td>GuavaCacheManager</td>
<td>使用Google的GuavaCache作为缓存技术</td>
</tr>
<tr>
<td>RedisCacheManager</td>
<td>使用Redis作为缓存技术</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Spring-Cache-常用注解"><a href="#Spring-Cache-常用注解" class="headerlink" title="Spring Cache 常用注解"></a>Spring Cache 常用注解</h3><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@EnableCaching</td>
<td>开启缓存注解功能</td>
</tr>
<tr>
<td>@Cacheable  查询</td>
<td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td>@CachePut  新增</td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td>@CacheEvict  删除，修改</td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody>
</table>
</div>
<p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。<br>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可</p>
<ul>
<li><p><code>@CachePut(value = &quot;userCache&quot;, key = &quot;#result.id&quot;)</code>：</p>
</li>
<li><p><code>@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)</code>：</p>
</li>
<li><p><code>@CachePut(value = &quot;userCache&quot;, key = &quot;#p0.id&quot;)</code>：p0第一个参数</p>
</li>
<li><p><code>@CachePut(value = &quot;userCache&quot;, key = &quot;#root.args[0].id&quot;)</code>：</p>
</li>
</ul>
<p>当查询返回值不为null</p>
<ul>
<li><code>@Cacheable(value = &quot;userCache&quot;, key = &quot;#root.args[0].id&quot;, unless = &quot;#result == null&quot;)</code></li>
</ul>
<p>参数：</p>
<p>​    value指的是某一类的缓存，userCache指的是用户的缓存</p>
<p>​    key中的#reslut是方法的返回值</p>
<p>​    condition: 条件，满足指定条件时，才缓存数据</p>
<p>​    unless: 条件，满足指定条件时，不缓存数据</p>
]]></content>
      <categories>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>项目难点</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSE</title>
    <url>//javaSE.html</url>
    <content><![CDATA[<h2 id="javaSE"><a href="#javaSE" class="headerlink" title="javaSE"></a>javaSE</h2><h3 id="1-DOS命令："><a href="#1-DOS命令：" class="headerlink" title="1.DOS命令："></a>1.DOS命令：</h3><p>切换盘符    d：</p>
<p>dir              查看当前路径内容</p>
<p>cd 目录      进入当前目录   cd java</p>
<p>cd..            回到上级目录</p>
<p>cd 目录1\目录2..     进如多级目录</p>
<p>cd\             退回盘符目录</p>
<p>cls             清屏</p>
<p>exit            退出窗口</p>
<h3 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的执行从main开始</p>
<h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p>字符串常量“ “</p>
<p>字符常量‘ ’</p>
<p>空常量null</p>
<p>布尔常量ture false</p>
<h3 id="4-字节"><a href="#4-字节" class="headerlink" title="4.字节"></a>4.字节</h3><p>1B是1字节</p>
<p>1B=8bit</p>
<p>1KB=1024B</p>
<p>4.基本数据类型</p>
<p>整数  占位数</p>
<p>byte   1</p>
<p>short  2</p>
<p>int（默认）4</p>
<p>long   8</p>
<p>浮点（小数）float     4         1.4-3.4</p>
<p>double（默认）8        </p>
<p>字符 char        2</p>
<p>布尔 boolean    1</p>
<p>引用数据类型</p>
<p>类  class</p>
<p>接口 interface</p>
<p>数组  [ ]</p>
<p>小驼峰命名fristName</p>
<p>大驼峰命名GoodStudent</p>
<h3 id="5-报错"><a href="#5-报错" class="headerlink" title="5.报错"></a>5.报错</h3><p>​    非法字符  中英文符号问题</p>
<p>​    不存在    大小写写错了</p>
<h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>自动类型转换       </p>
<p>​    把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p>
<p>​        byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double    </p>
<p>​        char-&gt;int-&gt;long-&gt;float-&gt;double</p>
<p>​    强制类型转换相反        </p>
<p>​        把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
<p>​        目标数据类型 变量名=（目标数据类型）值或变量</p>
<p>​        int k=(int)88.88 double比int大 值的范围比目标数据类型大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println((a);		<span class="comment">//97</span></span><br><span class="line">System.out.println((<span class="type">char</span>) a);  <span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p>​    字符串+字符串         拼接</p>
<p>​    字符串+数字+数字         拼接</p>
<p>​    数字+数字+字符串        前面两个数字相加拼接字符串</p>
<h3 id="8-赋值运算符"><a href="#8-赋值运算符" class="headerlink" title="8.赋值运算符"></a>8.赋值运算符</h3><p>​    +=    a=a+b    把左边和右边相加赋值给左边</p>
<p>​    -=    *=    /=    a=a+b</p>
<p>​    %=将a%b的余数给a</p>
<h3 id="9-自增自减"><a href="#9-自增自减" class="headerlink" title="9.自增自减"></a>9.自增自减</h3><p>​    单独使用 相等    i++=i++    i—=—i</p>
<p>​    参与操作使用</p>
<p>（1）放在变量后，先参与操作再++ —</p>
<pre><code>  int j=i++;        i赋值给j后自增

 System.out.println(i);    i=11        i的值为i++

  System.out.println(j);    j=10        j的值为未自增的i
</code></pre><p>（2）放在变量前，先++ — 再参与操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int j=++i;		i自增后赋值给j</span><br><span class="line">System.out.println(i);	i=11		i的值为i++</span><br><span class="line">System.out.println(j);	j=11		j的值为自增后的i</span><br></pre></td></tr></table></figure>
<p>9.关系运算符</p>
<p>​    ==为等于     !=不等于</p>
<p>​    =为赋值        成立为ture，不成立false</p>
<p>9.逻辑运算符</p>
<p>​    &amp; 与     a&amp;b 有false则为false</p>
<p>​    | 或         a|b    有ture则ture</p>
<p>​    ^ 异或    a^b    结果不同为ture 结果相同为false</p>
<p>​    ! 非        !a  结果与a相反</p>
<p>短路运算符</p>
<p>​    &amp;&amp;    短路与    有false则为false</p>
<p>​    ||    短路或    有ture则ture</p>
<p>注意：&amp;无论左边真假，右边都执行</p>
<p>​    &amp;&amp;左边真，右边执行，左边假，右边不执行</p>
<p>​    |无论左边真假，右边都执行</p>
<p>​    ||左边真，右边不执行，左边假，右边执行</p>
<h3 id="10-三元运算符"><a href="#10-三元运算符" class="headerlink" title="10.三元运算符"></a>10.三元运算符</h3><p>​    格式：关系表达式?表达式1:表达式2；</p>
<p>范例：a&gt;b?a:b;</p>
<p>​    首先计算关系表达式a&gt;b</p>
<p>​    若值为ture，输出表达式1 a</p>
<p>​    若值为false，输出表达式2 b</p>
<h3 id="11-switch语句"><a href="#11-switch语句" class="headerlink" title="11.switch语句"></a>11.switch语句</h3><p>表达式和case值比较相等替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case 值1:语句体1; 		（春夏秋冬）case穿透	case 1;</span><br><span class="line"> 		break;								   case 2;</span><br><span class="line">	case 值2:语句体2;							 case 3;	</span><br><span class="line">		break;									春	</span><br><span class="line">...</span><br><span class="line">	default:</span><br><span class="line">		语句体n+1;</span><br><span class="line">		[break;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-循环语句"><a href="#12-循环语句" class="headerlink" title="12.循环语句"></a>12.循环语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(1.初始化语句;2.条件判断语句;4.条件控制语句)&#123;</span><br><span class="line">	3.循环体语句;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i &lt;= 5; i++)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意数字指定位上的数字咋求</p>
<p>先使用整除操作将要求书移动到各位上，再取余操作求最后一位值</p>
<p>123456789        先除10000，在对10取余得5</p>
<p>while循环        先判断后执行</p>
<p>初始化语句；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(条件判断语句)&#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">	条件控制语句；</span><br><span class="line">&#125;</span><br><span class="line">例.int i=1；</span><br><span class="line">while(i&lt;=5)&#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">	i++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do…while循环        先执行后判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句；</span><br><span class="line">do&#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">	条件控制语句；</span><br><span class="line">&#125;while（条件判断语句）；</span><br><span class="line">例.int j=1；</span><br><span class="line">do&#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">	j++；</span><br><span class="line">&#125;while（j&lt;=5）;</span><br></pre></td></tr></table></figure>
<p>死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for（；；）&#123;循环体；&#125;</span><br><span class="line">while（true）&#123;循环体；&#125;</span><br><span class="line">do&#123;&#125;while（true）；</span><br></pre></td></tr></table></figure>
<h3 id="13-跳转控制语句break句和continue语句"><a href="#13-跳转控制语句break句和continue语句" class="headerlink" title="13.跳转控制语句break句和continue语句"></a>13.跳转控制语句break句和continue语句</h3><p>​    1、break语句:用在switch条件语句和循环语句中，它的作用是终止某个case (或循环)并跳出switch结构（或跳出当前的循环)。</p>
<p>​    2、continue语句:用在循环语句中，它的作用是终止本次循环，执行下—次循环(首先返回到循环是否执行的判断处)</p>
<p>​    continue        跳过某次循环体内容；继续下一次执行</p>
<p>​    break        终止循环体进行</p>
<h3 id="14-数据输入Scanner"><a href="#14-数据输入Scanner" class="headerlink" title="14.数据输入Scanner"></a>14.数据输入Scanner</h3><p>随机值Random</p>
<p>（1）导包     import java.util.Scanner;（Random）</p>
<p>手动导包 import java.util.Scanner;</p>
<p>快捷键导包 Alt +回车</p>
<p>自动导包     Scanner</p>
<p>（2）创建对象Scanner sc = new Scanner(System.in);</p>
<pre><code>  Random r = new Random();
</code></pre><p>（3）接收数据 int hight1 = sc.nextInt();</p>
<pre><code>  获取随机数 int number=r.nextInt(10) + 1;    (从0到10获取随机数)包0不包括10
</code></pre><h3 id="15-数组"><a href="#15-数组" class="headerlink" title="15.数组"></a>15.数组</h3><p>（1）数组动态初始化  </p>
<p>int[ ] arr = new int[3];    </p>
<p>//左边：int：说明数组的元素类型是int类型</p>
<p>​      [ ]：说明这是一个数组</p>
<p>​      arr：数组的名称</p>
<p>//右边：new：为数组申请内存空间</p>
<p>​      int：说明数组的元素类型是int类型</p>
<p>​      [ ]：说明这是一个数组</p>
<p>3:数组长度，其实就是数组的元素个数</p>
<p>​    int[ ] arr 栈内存：储存局部变量 例如：arr；使用完毕立即消失</p>
<p>​    new int[3] 堆内存：储存new出来的内容</p>
<p>​    //只指定数组长度，由系统分配初始值</p>
<p>​    整数：0          浮点数：0.0        布尔：false    </p>
<p>​    字符：空字符    引用数据类型:null</p>
<p>​    每一个new出来的东西都有一个地址值    使用完毕会在垃圾回收器空闲的时被回收</p>
<p>（2）索引：是数组中数据的编号方式    index</p>
<p>​    数组名[索引]等同于变量名，是一种特殊的变量名</p>
<p>​    特征：从0开始连续增加每次加1</p>
<p>（3）静态初始化</p>
<p>​    格式：数组类型[ ] 变量名 = new 数组类型[ ]{数据1，数据2，….}；</p>
<p>​    int[ ] arr      = new int[ ]{1,2,3};</p>
<p>​    简化格式：数组类型[ ] 变量名 = {数据1，数据2，数据3，….}；</p>
<p>（4）数组遍历通用格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[ ] arr = &#123;11,22,33&#125;;</span><br><span class="line">for(int x=0;x&lt;=arr.length;x++)&#123;</span><br><span class="line">	System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）数组获取最值</p>
<p>​    int[] arr = {15,4164,4894,8434,8746};    int max = arr[0];    for(int i=1;i<arr.length;i++){        if(arr[i] > max){            max = arr[i];        }    }    System.out.println(max);</p>
<h3 id="16-方法"><a href="#16-方法" class="headerlink" title="16.方法"></a>16.方法</h3><p>两个明确：</p>
<p>返回值类型：void/int</p>
<p>参数：int[ ] arr    </p>
<p>(1).定义: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void getMax (int number1，int number2，.... )&#123;</span><br><span class="line">	方法内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)调用：方法名(变量名/常数);</p>
<p>int number1；</p>
<p>int number2；</p>
<p>getMax(number1/10，number2);</p>
<p>形参：方法定义中的参数    int number</p>
<p>实参：方法调用中的参数    10    number</p>
<p>带返回值方法的定义    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int（数据类型） getMAX（int a,int b）&#123;</span><br><span class="line">	return 100；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return后的返回值与方法定义类型上的数据类型要匹配</p>
<p>调用格式</p>
<p>int flag = getMax(10,20)</p>
<p>（3）方法不能嵌套</p>
<p>​    void表示无返回值可以省略return；也可以单独写return</p>
<p>（4）方法通用格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static 返回值类型 方法名（参数）&#123;</span><br><span class="line">	方法体；</span><br><span class="line">	return 数据；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public static        修饰符，记住这个格式</p>
<p>返回值类型        返回的数据的数据类型，没有数据返回填void，且一班不填return</p>
<p>方法名            调用方法时使用的标识</p>
<p>参数                由数据类型和变量名组成，多个参数之间用逗号隔开</p>
<p>方法体            完成功能的代码块</p>
<p>return            有数据返回，写相应的数据类型，把数据返回给调用者</p>
<ul>
<li>调用时</li>
</ul>
<p>void类型，直接调用</p>
<p>非void类型，推荐用变量接收调用（返回啥类型，用啥类型接收）sout（getMax（10））；</p>
<h3 id="17-方法重载"><a href="#17-方法重载" class="headerlink" title="17.方法重载"></a>17.方法重载</h3><p>多个方法在同一个类中</p>
<p>多个方法有相同方法名</p>
<p>多个方法参数不相同，类型不同或数量不同</p>
<p>（1）基本类型    int number = 100；</p>
<p>​    方法参数传递形参的改变不会改变实参的值</p>
<p>（2）引用类型    int arr [ ] = {10，20，30}；</p>
<p>​    形参的改变影响实参值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println();		输出内容换行</span><br><span class="line">System.out.print();			输出内容不换行</span><br></pre></td></tr></table></figure>
<h3 id="18-面向对象"><a href="#18-面向对象" class="headerlink" title="18.面向对象"></a>18.面向对象</h3><p>(1)类是有共同属性和行为的抽象</p>
<p>​    类是对象的抽象（数据类型）</p>
<p>​    对象是类的实体</p>
<p>(2)成员变量：类中方法外的变量（堆内存）有默认初始化值</p>
<p>​    局部变量：方法中的变量（栈内存）没有初始化值</p>
<p>(3)private  限制修饰符    //封装</p>
<p>​    作用：保护成员不被别的类使用，被private修饰的成员只能在本类中使用</p>
<p>​    set变量名(参数)    用于设置成员变量的名    用public修饰</p>
<p>​    get变量名()          用于获取成员变量的值    用public修饰</p>
<p>(4)this         //局部变量和成员变量同名时</p>
<p>​    被谁调用指的是谁的变量    this.name修饰成员变量</p>
<p>​    this.name = name            name修饰局部变量</p>
<p>(5)构造方法</p>
<p>无参构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Student()&#123;</span><br><span class="line">	System.out.println(&quot;默认的构造方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">	修饰符 类名(参数)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">例：</span><br><span class="line">public class Student&#123;</span><br><span class="line">	public Student()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若没有定义构造方法，系统自动给与一个无参数构造方法</p>
<p>如果定义了构造方法，系统将不再提供默认构造方法</p>
<p>如果定义了构造方法还要使用无参数构造方法就必须再写一个无参构造方法（手动给出）</p>
<h3 id="19-API"><a href="#19-API" class="headerlink" title="19.API"></a>19.API</h3><p>(1)String构造方法        //不可变</p>
<p>​    public String()                创建一个空白字符串对象，不含任何内容</p>
<p>​    public String(char[] chs)        根据字符数组的内容来创建字符串对象</p>
<p>​    public String(byte[] bys)        根据字节数组的内容来创建字符串对象</p>
<p>​    String s = “abc”；            直接赋值的方式创建字符串对象，内容是abc</p>
<p>(2)字符串的比较</p>
<pre><code> ==         基本类型：比较数值是否相等

 引用类型：比较地址是否相同        字符串String是类也是引用
</code></pre><p>​    public boolean equals(Object anObgect)    比较字符串内容，区分大小写</p>
<p>​    比较字符串的内容equals()</p>
<p>​    sout(s1.equals(s2));    字符串常量放前面不会造成空指针异常</p>
<p>​    public char charAt(int index)        返回指定索引处的char值</p>
<p>​    public lit length()                返回字符串长度</p>
<p>(3)StringBuilder            //可变字符串</p>
<p>​    public StringBuilder()            空白可变字符串</p>
<p>​    public StringBuilder(String str)    根据字符串内容创建可变字符串对象</p>
<p>​    sb.append(“任意数”)            添加数据</p>
<p>​    sb.reverse()                    返回相反数据</p>
<p>​    sb.toString()                    StringBuilder转化为String</p>
<h3 id="20-快捷键"><a href="#20-快捷键" class="headerlink" title="20.快捷键"></a>20.快捷键</h3><p>​    alt+insert    自动生成构造方法和get方法 多选shift</p>
<p>​    \t   等于tab键 </p>
<h3 id="21-面向对象三大特征：封装性，继承性，多态性"><a href="#21-面向对象三大特征：封装性，继承性，多态性" class="headerlink" title="21.面向对象三大特征：封装性，继承性，多态性"></a>21.面向对象三大特征：封装性，继承性，多态性</h3><p>​    继承：共性抽取</p>
<p>​    父类，基类，超类</p>
<p>​    子类，派生类</p>
<p>（1）父子继承关系中，成员变量重名，则创建对象时有两种访问方式：</p>
<p>直接通过子类对象访问成员变量：       new zi.numzi(成员变量)</p>
<p>​    等号左边是谁，则优先用谁，没药则向上找</p>
<p>通过成员方法访问成员变量：           调用方法</p>
<p>​    该方法属于谁则优先用谁，没有则向上找</p>
<p>（2）</p>
<p>局部变量：           直接写成员变量名</p>
<p>本类成员变量：       this.成员变量名</p>
<p>父类成员变量：       super.成员变量名</p>
<p>（3）</p>
<p>成员方法</p>
<p>创建对象是谁，优先用谁，没有则向上找</p>
<p>注意：</p>
<p>无论成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类</p>
<p>重写（Override）</p>
<p>概念：在继承关系中，方法名称一样，参数列表也一样</p>
<p>重写（Override）：方法名称一样，参数列表【也一样】。覆盖、覆写</p>
<p>重载（Overload）：方法名称一样，参数列表【不一样】。</p>
<p>方法覆盖重写的特点，创建的是子类对象，则优先用子类方法。new谁用谁</p>
<p>方法覆盖注意事项：</p>
<p>1.必须保证父子类之间方法名称相同，参数列表也相同</p>
<p>​    @Override：写在方法前面，用来检测是不是有效的正确覆盖重写</p>
<p>​    这个注释就算不写，只要满足要求，也是正确的方法覆盖重写</p>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
<p>​    小扩展提示：java.lang.Object类是是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>​    小扩展提示：public &gt; protected &gt; (default) &gt; private</p>
<p>​    备注：（default）不是关键字default，而是什么都不写留空</p>
<p>（4）构造方法：</p>
<p>​    构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有</p>
<p>​    不能被static、final、synchronized、abstract和native修饰</p>
<p>​    继承关系中，父子类构造方法的访问特点</p>
<p>​        1.子类构造方法中有一个默认隐含的”super()“调用，所以一定是先调用父类构造，后执行子类构造</p>
<p>​        2.子类构造可以通过super关键字调用父类重载构造    //方法名称一样，参数列表【不一样】</p>
<p>​        3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p>
<p>总结：</p>
<p>子类必须调用父类构造方法，不写则赠送super()，写了则用指定的super调用，super只能有一个还必须是第一个</p>
<p>super关键字用来访间父类内容，而this关键字用来访问本类内容。用法也有三种;</p>
<p>​    1.在本类的成员方法中,访间本类的成员变量。</p>
<p>​    2.在本类的成员方法中,访同本类的另一个成员方法。</p>
<p>​    3.在本类的构造法中,访间本类的另一个构造方法。</p>
<p>​        在第三种用法当中专注意:</p>
<p>​        A.this(…)调用也必须是构造方法的第一个语句，唯——个。   构造方法调用直接super(…) 或this(…)</p>
<p>​        B.super和this两种构造调用,不能同时使用。</p>
<h3 id="22-继承特点："><a href="#22-继承特点：" class="headerlink" title="22.继承特点："></a>22.继承特点：</h3><p>（1）Java语言是单维承的。</p>
<p>一个类的直接父类只能有唯——个。</p>
<p>class A{}</p>
<p>class B extends A {}     // 正确</p>
<p>class C{}</p>
<p>class D extends A.C{}    //错误</p>
<p>（2）Java语言可以多级继承。</p>
<p>我有一个父亲。我父亲还有一个父亲。也就是爷爷。</p>
<p>classA {}</p>
<p>class B extends A {}     //正确</p>
<p>class C extends B{}      //正确</p>
<p>（3）—个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。可以有很多个兄弟姐妹。生二胎。</p>
<p>class A {}</p>
<p>class B extends A {}    //正确</p>
<p>class C extends A {}    //正确</p>
<h3 id="23-抽象：子类就是父类，猫就是动物"><a href="#23-抽象：子类就是父类，猫就是动物" class="headerlink" title="23.抽象：子类就是父类，猫就是动物"></a>23.抽象：子类就是父类，猫就是动物</h3><p>抽象方法:就是加上abstract关键字,然后去掉大括号，直接分号结束。</p>
<p>抽象类。抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p>
<p>如何使用抽象类和抽象方法:</p>
<p>​    1.不能直接创建new抽象类对象。</p>
<p>​    2.必须用一个子类来继承抽象父类。</p>
<p>​    3.子类必须覆盖重写抽象父类当中所有的抽象方法。</p>
<p>​        覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</p>
<p>​    4.创建子类对象进行使用。</p>
<p>​        关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<p>1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<p>​    理解:假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>2抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<p>​    理解:子类的构造方法中,有默认的super)，需要访问父类构造方法。</p>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<p>​    理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<p>​    理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
<p>特点：</p>
<p>成员变量：可以是变量也可以是常量</p>
<p>构造方法：有构造方法，但是不能实例化</p>
<p>那么，构造方法的作用是什么呢?用于子类访问父类数据的初始化</p>
<p>成员方法：可以有抽象方法:限定子类必须完成某些动作也可以有非抽象方法:提高代码复用性</p>
<h3 id="24-多态"><a href="#24-多态" class="headerlink" title="24.多态"></a>24.多态</h3><p>多态的好处:提高了程序的扩展性</p>
<p>具体体现:定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作多态的弊端:不能使用子类的特有功能</p>
<h3 id="25-接口"><a href="#25-接口" class="headerlink" title="25.接口"></a>25.接口</h3><p>（1）接口的成员特点</p>
<p>成员变量</p>
<p>​    只能是常量        默认修饰符: public static final构造方法</p>
<p>​    接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在一个类如果没有父类，默认继承自Object类</p>
<p>成员方法</p>
<p>​    只能是抽象方法    默认修饰符: public abstract</p>
<p>特点：</p>
<p>​    接口用关键字interface修饰</p>
<p>​    public interface接口名{}</p>
<p>​    类实现接口用implements表示</p>
<p>​    public class类名implements接口名{}</p>
<p>​    接口不能实例化</p>
<p>​    接口如何实例化呢?参照多态的方式，通过实现类对象实例化，这叫接口多态。多态的形式:具体类多态，抽象类多态，接口多态。</p>
<p>​    多态的前提:有继承或者实现关系;有方法重写;有父(类/接口)引用指向(子/实现)类对象</p>
<p>​    接口的实现类</p>
<p>​    要么重写接口中的所有抽象方法要么是抽象类</p>
<p>（2）类和类的关系</p>
<p>继承关系，只能单继承，但是可以多层继承</p>
<p>类和接口的关系</p>
<p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口和接口的关系</p>
<p>继承关系，可以单继承，也可以多继承</p>
<p>1.类名作为形参和返回值</p>
<p>​    方法的形参是类名，其实需要的是该类的对象</p>
<p>​    方法的返回值是类名，其实返回的是该类的对象</p>
<p>2.抽象类名作为形参和返回值</p>
<p>​    方法的形参是抽象类名，其实需要的是该抽象类的子类对象</p>
<p>​    方法的返回值是抽象类名,其实返回的是该抽象类的子类对象</p>
<p>​    基本数据类型当做形式参数给的是值。           int String</p>
<p>​    引用数据类型当做形式参数给的是地址值。        引用类</p>
<p>3.接口名作为形参和返回值</p>
<p>​    方法的形参是接口名，其实需要的是该接口的实现类对象</p>
<p>​    方法的返回值是接口名，其实返回的是该接口的实现类对象</p>
<h3 id="26-内部类"><a href="#26-内部类" class="headerlink" title="26.内部类"></a>26.内部类</h3><p>(1).内部类的访问特点</p>
<p>​    内部类可以直接访问外部类的成员，包括私有</p>
<p>​    外部类要访问内部类的成员，必须创建对象</p>
<p>(2).局部内部类        class前无修饰词</p>
<p>​    局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>(3).匿名内部类        局部内部类的特殊形式</p>
<p>也要在方法里面写</p>
<p>前提：存在一个类或接口，类可以是具体类也可以是抽象类</p>
<p>本质：是一个继承了该类或实现了该接口的子类匿名对象</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 类名或接口名()&#123;</span><br><span class="line">	重写方法；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h3 id="27-Math无构造方法，如果是静态的直接用类名调用方法"><a href="#27-Math无构造方法，如果是静态的直接用类名调用方法" class="headerlink" title="27.Math无构造方法，如果是静态的直接用类名调用方法"></a>27.Math无构造方法，如果是静态的直接用类名调用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int abs (int a):返回参数的绝对值</span><br><span class="line"></span><br><span class="line">public static double ceil (double a):返回大于或等于参数的最小double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static double floor (double a)。返回小于或等于参数的最大double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static int round (fLoat a)。按照四舍五入返回最接近参数的int</span><br><span class="line"></span><br><span class="line">public static int max (int a,int b)。返回两个int值中的较大值</span><br><span class="line"></span><br><span class="line">public static int min (int a,int b)。返回两个int值中的较小值(自学)</span><br><span class="line"></span><br><span class="line">public static double pow (double a, double b)，返回a的b次幂的值</span><br><span class="line"></span><br><span class="line">public static double random ()。返回值为double的正值，[0.0,1.0]</span><br></pre></td></tr></table></figure>
<h3 id="28-System类"><a href="#28-System类" class="headerlink" title="28.System类"></a>28.System类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//public static void exit(int status):终止当前运行的java虚拟机，非零表示异常终止</span><br><span class="line"></span><br><span class="line">//public static  long currentTimeMillis():返回当前时间，以毫秒为单位 1970年1月1日</span><br></pre></td></tr></table></figure>
<h3 id="28-Object类"><a href="#28-Object类" class="headerlink" title="28.Object类"></a>28.Object类</h3><p>Object是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或者间接的继承自该类</p>
<p>构造方法: public Object()</p>
<p>回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法?因为它们的顶级父类只有无参构造方法</p>
<p>//看方法的源码，选中方法Ctrl+B</p>
<p>//建议所有子类重写toString方法    自动生成即可</p>
<p>​    public String toString()            返回对象的字符串表示形式。建议所有子类重写该方法，自动生成</p>
<p>​    public boolean equals(Object obj)    比较对象是否相等。默认比较地址，重写可以比较内容，自动生成</p>
<h3 id="29-Arrays"><a href="#29-Arrays" class="headerlink" title="29.Arrays"></a>29.Arrays</h3><p>1冒泡排序</p>
<p>​    如果有n个数据进行排序，总共需要比较n-1次</p>
<p>​    每一次比较完毕，下一次的比较就会少一个数据参与</p>
<p>2.public static String toString(int[]a) 返回指定数组的内容的字符串表示形式    打印数组的中的数据</p>
<p>​    public static void sort(int[] a)            按照数字顺序排列指定的数组</p>
<h3 id="30-基本数据类型包装类"><a href="#30-基本数据类型包装类" class="headerlink" title="30.基本数据类型包装类"></a>30.基本数据类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p>
<p>常用的操作之一:用于基本数据类型与字符串之间的转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>lnteger</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<p>1.int转换为String</p>
<p>​    public static String valueOf(int i):返回int参数的字符串表示形式。该方法是String类中的方法</p>
<p>2.String转换为int</p>
<p>​    public static int parseInt(Strings):将字符串解析为int类型。该方法是Integer类中的方法</p>
<p>3.自动装箱和拆箱</p>
<p>​    装箱:把基本数据类型转换为对应的包装类类型</p>
<p>​    拆箱:把包装类类型转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i = Integer.valueOf(100);</span><br><span class="line">Integer i = 100;		//自动装箱</span><br><span class="line">i = i.intValue() + 200;</span><br><span class="line">i += 200;				// i = i + 200; i + 200自动拆箱; i= i + 200;是自动装箱</span><br></pre></td></tr></table></figure>
<h3 id="31-Date类"><a href="#31-Date类" class="headerlink" title="31.Date类"></a>31.Date类</h3><p>构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Date()			分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</span><br><span class="line"></span><br><span class="line">public Date(long date)	分配一个Date对象，并将其初始化为表示从标准基准时间起指定的亳秒数</span><br></pre></td></tr></table></figure>
<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public long getTime()			获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值</span><br><span class="line"></span><br><span class="line">public void setTime(long time)	设置时间，给的是毫秒值</span><br></pre></td></tr></table></figure>
<h3 id="32-SimpleDateFormat-类"><a href="#32-SimpleDateFormat-类" class="headerlink" title="32.SimpleDateFormat 类"></a>32.SimpleDateFormat 类</h3><p>y    年；M     月；d    日；H    时；m    分；s    秒</p>
<p>构造方法;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public simpLeDateFormat() :构造一个SimpLeDateFormat，使用默认模式和日期格式</span><br><span class="line"></span><br><span class="line">public SimpleDateFormat (String pattern):构造一个SimpleDateFormat使用给定的模式和默认的日期格式格式化:</span><br></pre></td></tr></table></figure>
<p>从 Date到string</p>
<p>​    public final String format(Date date):将日期格式化成日期/时间字符串解析。</p>
<p>从 String到 Date</p>
<p>​    public Date parse (String source):从给定字符串的开始解析文本以生成日期</p>
<h3 id="33-Calendar类"><a href="#33-Calendar类" class="headerlink" title="33.Calendar类"></a>33.Calendar类</h3><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p>
<p>calendar提供了一个类方法 getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化:</p>
<p>Calendar rightNow = Calendar.getInstance();</p>
<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int get(int field)						返回给定日历字段的值 	年月日</span><br><span class="line"></span><br><span class="line">public abstract void add(int field, int amount)		根据日历的规则，将指定的时间量添加或减去给定的日历字段</span><br><span class="line"></span><br><span class="line">public final void set(int year,int month,int date)	设置当前日历的年月日</span><br></pre></td></tr></table></figure>
<h3 id="34-异常"><a href="#34-异常" class="headerlink" title="34.异常"></a>34.异常</h3><p>1.异常体系</p>
<p>​                Throwable</p>
<p>​    Error                            Exception</p>
<p>RuntimeException        非RuntimeException</p>
<p>Error:严重问题，不需要处理</p>
<p>Exception:称为异常类，它表示程序本身可以处理的问题</p>
<p>RuntimeException:在编译期是不检查的，出现问题后，需要我们回来修改代码</p>
<p>非RuntimeException:编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了</p>
<p>2.JVM的默认处理方案    java虚拟机</p>
<p>如果程序出现了问题，我们没有做任何处理，最终JⅣM会做默认的处理</p>
<p>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台.程序停止执行</p>
<p>3.异常处理之try…catch…</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch (异常类名 变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>执行流程:</p>
<p>程序从try里面的代码开始执行</p>
<p>出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统</p>
<p>当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理</p>
<p>执行完毕之后，程序还可以继续往下执行</p>
<ol>
<li>Throwable的成员方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名							说明</span><br><span class="line"></span><br><span class="line">public String getMessage()		返回此 throwable的详细消息字符串</span><br><span class="line"></span><br><span class="line">public String toString()		返回此可抛出的简短描述</span><br><span class="line"></span><br><span class="line">public void printStackTrace()	把异常的错误信息输出在控制台</span><br></pre></td></tr></table></figure>
<p>5.Java 中的异常被分为两大类:编译时异常和运行时异常，也被称为受检异常和非受检异常</p>
<p>所有的 RuntimeException类及其子类的实例被称为运行时异常，其他的异常都是编译时异常</p>
<p>编译时异常:必须显示处理，否则程序就会发生错误,无法通过编译</p>
<p>运行时异常:无需显示处理,也可以和编译时异常一样处理</p>
<p>6.异常处理之throws</p>
<p>虽然我们通过try…catch…可以对异常进行处理，但是并不是所有的情况我们都有权限进行异常的处理也就是说，有些时候可能出现的异常是我们处理不了的，这个时候该怎么办呢?</p>
<p>格式:throws 异常类名;</p>
<p>注意:这个格式是跟在方法的括号后面的</p>
<p>编译时异常必须要进行处理，两种处理方案: try..catch ..或者throws，如果采用throws这种方案，将来谁调用谁处理运行时异常可以不处理，出现问题后，需要我们回来修改代码</p>
<p>7.throws和throw的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throws										throw</span><br><span class="line"></span><br><span class="line">用在方法声明后面，跟的是异常类名			用在方法体内，跟的是异常对象名</span><br><span class="line"></span><br><span class="line">表示抛出异常，由该方法的调用者来处理		   表示抛出异常，由方法体内的语句处理</span><br></pre></td></tr></table></figure>
<p>表示出现异常的一种可能性，并不一定会发生这些异常    执行throw一定抛出了某种异常</p>
<h3 id="35-集合"><a href="#35-集合" class="headerlink" title="35.集合"></a>35.集合</h3><p>只能存储引用类型，不能存储基本类型，int类型的包装类lnteger是引用类型</p>
<p>集合类体系结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">								集合</span><br><span class="line">		collection单列													Map双列</span><br><span class="line"></span><br><span class="line">接口		List可重复		   			Set不可重复								HashMap</span><br><span class="line"></span><br><span class="line">实现类ArrayList  LinkedList     	HashSet  TreeSet LinkedHashSet</span><br></pre></td></tr></table></figure>
<p>(1)Collection集合概述    E是元素类型</p>
<p>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素JDK不提供此接口的任何直接实现，它提供更具体的子接口(如Set和List)实现</p>
<p>创建Collection集合的对象</p>
<p>多态的方式</p>
<p>具体的实现类ArrayList</p>
<p>(2)Collection集合常用方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中移除指定的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合中的元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
</div>
<p>(3)Collection集合的遍历</p>
<p>Iterator:迭代器，集合的专用遍历方式</p>
<p>Iterator iterator():返回此集合中元素的迭代器，通过集合的iterator)方法得到</p>
<p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p>
<p>Iterator中的常用方法</p>
<p>​    E next():返回迭代中的下一个元素</p>
<p>​    boolean hasNext():如果迭代具有更多元素，则返回true</p>
<p>(4)List集合概述</p>
<p>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</p>
<p>与Set集合不同，列表通常允许重复的元素</p>
<p>List集合特点</p>
<p>​    有序:存储和取出的元素顺序一致</p>
<p>​    可重复:存储的元素可以重复</p>
<p>List集合特有方法:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>void add(int index,E element)</th>
<th>在此集合中的指定位置插入指定的元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>E  remove( int index)</td>
<td>册除指定索引处的元素，返回被册除的元素</td>
</tr>
<tr>
<td>E set(int index,E element):</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E  get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody>
</table>
</div>
<p>并发修改异常</p>
<p>​    ConcurrentModificationException</p>
<p>产生原因</p>
<p>​    迭代器遍历的过程中，add通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p>
<p>解决方案</p>
<p>​    用for循环遍历，然后用集合对象做对应的操作即可</p>
<p>(5)Listlterator:列表迭代器</p>
<p>通过List集合的listlterator()方法得到，所以说它是List集合特有的迭代器</p>
<p>用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</p>
<p>Listlterator中的常用方法</p>
<p>​    E next():返回迭代中的下一个元素</p>
<p>​    boolean hasNext():如果迭代具有更多元素，则返回true </p>
<p>​    previous():返回列表中的上一个元素</p>
<p>​    boolean hasPrevious():如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</p>
<p>​    void add(E e):将指定的元素插入列表</p>
<p>(6)增强for循环</p>
<p>增强for:简化数组和Collection集合的遍历</p>
<p>实现lterable接口的类允许其对象成为增强型for语句的目标它是JDK5之后出现的，其内部原理是一个lterator迭代器</p>
<p>增强for的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(元素数据类型  变量名:数组或者Collection集合)&#123;</span><br><span class="line">	//在此处使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br><span class="line">范例:</span><br><span class="line">int[]arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(int i : arr) &#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(7)List集合常用子类:ArrayList，LinkedList</p>
<p>​    ArrayList:底层数据结构是数组，查询快，增删慢</p>
<p>​    LinkedList:底层数据结构是链表，查询慢，增删快</p>
<p>(8)LinkedList集合的特有功能</p>
<p>​    方法名                                    说明</p>
<p>public void addFirst(E e)            在该列表开头插入指定的元素</p>
<p>public void addLast(E e)            将指定的元索追加到此列表的末尾</p>
<p>public E getFirst()                    返回此列表中的第一个元素</p>
<p>public E getLast()                    返回此列表中的最后一个元素</p>
<p>public E removeFirst()            从此列表中删除并返回第一个元素</p>
<p>public E removeLast()            从此列表中删除并返回最后一个元素</p>
<p>(9)Set集合概述和特点Set集合特点</p>
<p>不包含重复元素的集合</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>(10)哈希值:是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<p>public int hashCode():返回对象的哈希码值</p>
<p>对象的哈希值特点</p>
<p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p>
<p>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</p>
<p>(11)HashSet集合特点</p>
<p>底层数据结构是哈希表</p>
<p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>由于是Set集合，所以是不包含重复元素的集合    保证元素唯一性，重写hashCode和equals方法</p>
<p>先比哈希值，再通过equals比较内容</p>
<p>(12)LinkedHashSet集合特点</p>
<p>哈希表和链表实现的Set接口，具有可预测的迭代次序</p>
<p>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</p>
<p>由哈希表保证元素唯一，也就是说没有重复的元素</p>
<p>(13)TreeSet集合特点</p>
<p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet():根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>由于是Set集合，所以不包含重复元素的集合</p>
<p>无参</p>
<p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</p>
<p>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</p>
<p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>比较器  带参</p>
<p>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</p>
<p>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法</p>
<p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>(14)泛型概述</p>
<p>泛型:是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢?顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型</p>
<p>这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口</p>
<p>泛型定义格式:</p>
<p>​    &lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是形参</p>
<p>​    &lt;类型1,类型2..&gt;︰指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</p>
<p>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</p>
<p>泛型的好处:</p>
<p>​    把运行时期的问题提前到了编译期间</p>
<p>​    避免了强制类型转换</p>
<p>泛型类的定义格式:</p>
<p>​    格式:修饰符class类名&lt;类型&gt;{}</p>
<p>​    范例: public class Generic{ }</p>
<p>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p>
<p>类型通配符</p>
<p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<p>类型通配符:</p>
<p>List:表示元素类型未知的List，它的元素可以匹配任何的类型</p>
<p>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</p>
<p>如果说我们不希望List是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<p>类型通配符上限: </p>
<p>List:它表示的类型是Number或者其子类型</p>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
<p>类型通配符下限:</p>
<p>List :它表示的类型是Number或者其父类型</p>
<p>(15)可变参数</p>
<p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p>
<p>格式:修饰符返回值类型方法名(数据类型…变量名){}</p>
<p>范例: public static int sum(int… a){}</p>
<p>可变参数注意事项</p>
<p>这里的变量其实是一个数组</p>
<p>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</p>
<p>可变参数的使用</p>
<p>Arrays工具类中有一个静态方法:</p>
<p>public static  List asList(T… a):返回由指定数组支持的固定大小的列表</p>
<p>返回的集合不能做增删操作，可以做修改操作</p>
<p>List接口中有一个静态方法:</p>
<p>public static  List of(E… elements):返回包含任意数量元素的不可变列表</p>
<p>返回的集合不能做增删改操作</p>
<p>Set接口中有一个静态方法:</p>
<p>public static  Set of(E… elements):返回一个包含任意数量元素的不可变集合</p>
<p>返回的集合不能做增删操作，没有修改的方法</p>
<p>(16)Map集合概述</p>
<p>lnterface MapK:键的类型;V:值的类型</p>
<p>将键映射到值的对象;不能包含重复的键;每个键可以映射到最多一个值</p>
<p>举例:学生的学号和姓名</p>
<p>itheima001    林青霞</p>
<p>itheima002    张曼玉</p>
<p>itheima003    王祖贤</p>
<p>创建Map集合的对象</p>
<p>多态的方式</p>
<p>具体的实现类HashMap</p>
<p>(17)Map集合的基本功能</p>
<p>方法名                                        说明</p>
<p>v put(K key,V value)                添加元素</p>
<p>v remove(Object key)                根据键删除健值对元素</p>
<p>void clear()                                移除所有的键值对元素</p>
<p>boolean containsKey(Object key)    判断集合是否包含指定的键</p>
<p>boolean containsValue(Object value)判断集合是否包含指定的值</p>
<p>boolean isEmpty()                    判断集合是否为空</p>
<p>int size()                                    集合的长度，也就是集合中键值对的个数</p>
<p>(18)Map集合的获取功能</p>
<p>方法名                                    说明</p>
<p>v get(Object key)                根据键获取值</p>
<p>Set keySet()                    获取所有键的集合</p>
<p>Collection values()            获取所有值的集合</p>
<p>Set &gt; entrySet()                获取所有键值对对象的集合</p>
<p>(19)Map集合的遍历1</p>
<p>获取所有键的集合。用keySet()方法实现</p>
<p>遍历键的集合，获取到每一个键。用增强for实现</p>
<p>根据键去找值。用get(Object key)方法实现</p>
<p>Map集合的遍历2</p>
<p>获取所有键值对对象的集合</p>
<p>Set &gt; entrySet():获取所有键值对对象的集合遍历键值对对象的集合，得到每一个键值对对象</p>
<p>用增强for实现，得到每一个Map.Entry根据键值对对象获取键和值</p>
<p>用getKey()得到键</p>
<p>用getValue()得到值</p>
<p>(20)Collections概述和使用Collections类的概述是针对集合操作的工具类</p>
<p>Collections类的常用方法</p>
<p>public static &gt; void sort(List list):将指定的列表按升序排序</p>
<p>public static void reverse(List list):反转指定列表中元素的顺序</p>
<p>public static void shuffle(List list):使用默认的随机源随机排列指定的列表</p>
<h3 id="36-数据结构"><a href="#36-数据结构" class="headerlink" title="36.数据结构"></a>36.数据结构</h3><p>栈：先进后出</p>
<p>队列：先进先出</p>
<p>数组是一种查询快，增删慢的模型</p>
<p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p>
<p>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低添加数据时，添加位置后的每个数据后移，再添加元素，添加效率极低</p>
<p>链表是一种增删快，查询慢的模型(对比数组)</p>
<h3 id="37-File"><a href="#37-File" class="headerlink" title="37.File"></a>37.File</h3><p>File类概述和构造方法</p>
<p>File:它是文件和目录路径名的抽象表示文件和目录是可以通过File封装成对象的</p>
<p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p>
<p>方法名                                说明</p>
<p>File(String pathname)        通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</p>
<p>File(String parent, String child)从父路径名字符串和子路径名字符串创建新的File实例</p>
<p>File(File parent, String child)    从父抽象路径名和子路径名字符串创建新的File实例</p>
<p>File类创建功能</p>
<p>方法名                        说明</p>
<p>public boolean createNewFile()    当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</p>
<p>public boolean mkdir()            创建由此抽象路径名命名的目录</p>
<p>public boolean mkdirs)            创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</p>
<p>FiLe类的判断和获取功能:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isDirectory():测试此抽象路径名表示的FiLe是否为目录</span><br><span class="line"></span><br><span class="line">public booLean isFile():测试此抽象路径名表示的FiLe是否为文件</span><br><span class="line"></span><br><span class="line">public boolean exists()。测试此抽象路径名表示的FiLe是否存在</span><br><span class="line"></span><br><span class="line">public String getAbsolutePath():返回此抽象路径名的绝对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getPath()。将此抽象路径名转换为相对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getName()。返回由此抽象路径名表示的文件或自录的名称</span><br><span class="line"></span><br><span class="line">public String[ ] list()，返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span><br><span class="line"></span><br><span class="line">public File[] listFiles()。返回此抽象路径名表示的目录中的文件和目录的File对象数组</span><br></pre></td></tr></table></figure>
<p>FiLe类删除功能:</p>
<p>public booLean delete( ):册除由此抽象路径名表示的文件或目录</p>
<p>绝对路径和相对路径的区别</p>
<p>绝对路径:完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如: E\itcast\ljava.txt</p>
<p>相对路径:必须使用取自其他路径名的信息进行解释。例如: myFile\Wava.txt</p>
<p>删除目录时的注意事项:</p>
<p>如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h3 id="38-递归"><a href="#38-递归" class="headerlink" title="38.递归"></a>38.递归</h3><p>递归概述:以编程的角度来看，递归指的是方法定义中调用方法本身的现象</p>
<p>递归解决问题的思路:</p>
<p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算</p>
<p>递归解决问题要找到两个内容:</p>
<p>递归出口:否则会出现内存溢出</p>
<p>递归规则:与原问题相似的规模较小的问题</p>
<h3 id="39-字节流写数据"><a href="#39-字节流写数据" class="headerlink" title="39.字节流写数据"></a>39.字节流写数据</h3><p>(1)字节流抽象基类</p>
<p>lnputStream:这个抽象类是表示字节输入流的所有类的超类</p>
<p>OutputStream:这个抽象类是表示字节输出流的所有类的超类</p>
<p>子类名特点:子类名称都是以其父类名作为子类名的后缀</p>
<p>FileOutputStream:文件输出流用于将数据写入File</p>
<p>构造方法:</p>
<p>​    FileOutputStream(String name):创建文件输出流以指定的名称写入文件</p>
<p>​    FileOutputStream (File file):创建文件输出流以写入由指定的 File对象表示的文件</p>
<p>使用字节输出流写数据的步骤:</p>
<p>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)</p>
<p>调用字节输出流对象的写数据方法</p>
<p>​        // void write (int b)。将指定的字节写入此文件输出流</p>
<p>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</p>
<p>​        //void close ()。关闭此文件输出流并释放与此流相关联的任何系统资源。</p>
<p>(2)IO流分类:</p>
<p>按照数据的流向</p>
<p>输入流:读数据</p>
<p>输出流:写数据</p>
<p>按照数据类型来分</p>
<p>字节流:字节输入流;字节输出流</p>
<p>字符流:字符输入流;字符输出流</p>
<p>如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流,否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流</p>
<p>(3)字节流写数据的3种方式</p>
<p>方法名                                                    说明</p>
<p>void write(int b)                            将指定的字节写入此文件输出流—次,写一个字节数据            </p>
<p>void write(byte[] b)将b.length        字节从指定的字节数组写入此文件输出流一次写一个字节数组数据</p>
<p>void write(byte[] b, int off, int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流一次写一个字节数组的部分数据</p>
<p>(4)字节流写数据的两个小问题</p>
<p>字节流写数据如何实现换行呢?</p>
<p>写完数据后，加换行符</p>
<p>windows:\r\n</p>
<p>linux:\n</p>
<p>mac\r</p>
<p>字节流写数据如何实现追加写入呢?</p>
<p>public FileOutputStream(String name,boolean append)</p>
<p>创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头</p>
<p>(5)字节流写数据加异常处理</p>
<p>finally:在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p>
<p>特点:被finally控制的语句一定会执行，除非JVM退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	执行所有清除操作;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>(6)字节缓冲流:</p>
<p>BufferOutputStream:该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</p>
<p>BufferedlnputStream:创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</p>
<p>构造方法:</p>
<p>字节缓冲输出流:BufferedOutputStream(OutputStream out)</p>
<p>字节缓冲输入流: BufferedInputStream(InputStream in)</p>
<p>为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?</p>
<p>字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</p>
<p>byte[] getBytes(String charsetName) 使用命名的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中。 </p>
<h3 id="40-1-字符流"><a href="#40-1-字符流" class="headerlink" title="40.(1)字符流"></a>40.(1)字符流</h3><p>为什么会出现字符流</p>
<p>由于字节流操作中文不是特别的方便，所以Java就提供字符流·</p>
<p>字符流=字节流＋编码表</p>
<p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢?</p>
<p>汉字在存储的时候，无论选择哪种编码存储,第一个字节都是负数</p>
<p>(2)编码表</p>
<p>基础知识:</p>
<p>计算机中储存的信息都是用二进制数表示的;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果</p>
<p>按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。这里强调一下:按照A编码存储，必须按照A编码解析，这样才能显示正确的文本符号。否则就会导致乱码现象</p>
<p>字符编码:就是一套自然语言的字符与二进制数之间的对应规则(A65)</p>
<p>字符集:</p>
<p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p>
<p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCIl字符集、GBXXX字符集. Unicode字符集等</p>
<p>ASCI字符集:</p>
<p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)∶是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)</p>
<p>基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p>
<p>GBXXX字符集:</p>
<p>GB2312:简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了</p>
<p>GBK:最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等</p>
<p>GB18030:最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等</p>
<p>Unicode字符集:</p>
<p>为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF32。最为常用的UTF-8编码</p>
<p>UTF-8编码:可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组(IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码</p>
<p>编码规则:</p>
<p>128个US-ASCI字符，只需一个字节编码拉丁文等字符，需要二个字节编码</p>
<p>大部分常用字(含中文)，使用三个字节编码</p>
<p>其他极少使用的Unicode辅助字符，使用四字节编码</p>
<p>小结:采用何种规则编码，就要采用对应规则解码，否则就会出现乱码</p>
<p>(3)字符串中的编码解码问题</p>
<p>编码:</p>
<p>bytel]getBytes():使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>bytelgetBytes(String charsetName):使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>解码:</p>
<p>String(byte[] bytes):通过使用平台的默认字符集解码指定的字节数组来构造新的String</p>
<p>String(byte[] bytes, String charsetName):通过指定的字符集解码指定的字节数组来构造新的String</p>
<p>字符流抽象基类</p>
<p>Reader:字符输入流的抽象类</p>
<p>Writer:字符输出流的抽象类</p>
<p>字符流中和编码解码问题相关的两个类:</p>
<p>lnputStreamReader:是从字节流到字符流的桥梁</p>
<p>它读取字节,并使用指定的编码将其解码为字符</p>
<p>它使用的字符集可以由名称指定，也可以被明码指定，或者可以接受平台的默认字符集</p>
<p>OutputStreamWriter是从字符流到字节流的桥梁</p>
<p>是从字符流到字节流的桥梁,使用指定的编码将写入的字符编码为字节</p>
<p>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集</p>
<p>构造方法:</p>
<p>OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter。  </p>
<p>OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 </p>
<p>InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader。  </p>
<p>InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader。 </p>
<p>字符流写数据的5种方式</p>
<p>方法名                                                    说明</p>
<p>void write(int c)                                    写一个字符</p>
<p>void write(char[]cbuf)                            写入一个字符数组</p>
<p>void write(char[]cbuf, int off, int len)    写入字符数组的一部分</p>
<p>void write(String str)                            写一个字符串</p>
<p>void write(String str, int off, int len)        写一个字符串的一部分</p>
<p>方法名        说明</p>
<p>flush()        刷新流，还可以继续写数据</p>
<p>close()        关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</p>
<p>字符流读数据</p>
<p>方法名            说明</p>
<p>int read()            —次读一个字符数据</p>
<p>int read(char[] cbuf)—次读一个字符数组数据</p>
<p>字节是byte  字符是char</p>
<p>转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化书写，转换流提供了对应的子类</p>
<p>FileReader:用于读取字符文件的便捷类</p>
<p>FileReader(String fileName)</p>
<p>FileWriter:用于写入字符文件的便捷类</p>
<p>FileWriter(String fileName)</p>
<p>数据源和目的地的分析</p>
<p>数据源: myCharStream)(ConversionStreamDemojava—-读数据——Reader —-InputStreamReader —-FileReader</p>
<p>目的地: myCharStreamll Copy.java —-写数据—-Writer —- OutputStreamWriter —- FileWriter</p>
<p>(4)字符缓冲流:</p>
<p>BufferedWriter:将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p>
<p>BufferedReader:从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p>
<p>构造方法:</p>
<p>​    BufferedWriter(Writer out)</p>
<p>​    BufferedReader(Reader in)</p>
<p>字符缓冲流特有功能</p>
<p>BufferedWriter:</p>
<p>void newLine():写一行行分隔符，行分隔符字符串由系统属性定义</p>
<p>BufferedReader:</p>
<p>public String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null     只读内容不读换行符号</p>
<p>String split(“,”);    //字符串中按逗号分割，分成字符串数组</p>
<p>String转换为int类型</p>
<p>Integer.parseInt（String）方法</p>
<p>parseInt（）是Integer包装类里的一个方法，可以将字符串解析为带符号的整数</p>
<p>TreeSet 比较排序 Student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Student s) &#123;</span><br><span class="line">    //return 0;   //s2和s1是同一个接口</span><br><span class="line">    //return 1;      //正序   升序</span><br><span class="line">    //return -1;      //倒叙    降序</span><br><span class="line">    //按年龄排序</span><br><span class="line">    int num = this.age-s.age;   //this是s1，s 是s2     this在前，s在后升序  反过来降序</span><br><span class="line">    int num2 = num == 0?this.name.compareTo(s.name):num; //如果年龄相同num=0则比较name，不等于直接输出num</span><br><span class="line">    return num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeSet比较器排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Student s1, Student s2) &#123;</span><br><span class="line">//                int num = (s2.getChinese()+s2.getMath())-(s1.getChinese()+s1.getMath());</span><br><span class="line">                //主要条件  s1-this   s2-s  s在前，this在后  s-this降序</span><br><span class="line">                int num = s2.getSum()-s1.getSum();</span><br><span class="line">                int num2 = num == 0?s1.getChinese()-s2.getChinese():num;    //s1-s2有啥讲究</span><br><span class="line">                int num3 = num2 == 0?s1.getName().compareTo(s2.getName()):num2;</span><br><span class="line">                return num3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>//s1-s2  升序  s1小    小减大 从小往大</p>
<p>//s2-s1  降序  s2大    大减小 从大往小</p>
<p>static修饰，类名可以直接访问</p>
<p>(5)复制文件的异常处理</p>
<p>try…catch…finally的做法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">	执行所有清除操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7改进方案:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try(定义流对象)&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>自动释放资源</p>
<p>JDK9改进方案:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line">try(输入流对象;输出流对象)&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动释放资源</p>
<h3 id="41-标准输入输出流"><a href="#41-标准输入输出流" class="headerlink" title="41.标准输入输出流"></a>41.标准输入输出流</h3><p>System类中有两个静态的成员变量:</p>
<p>public static final lnputStream in:标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源</p>
<p>public static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标</p>
<p>自己实现键盘录入数据:</p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in);</p>
<p>写起来太麻烦，Java就提供了一个类实现键盘录入</p>
<p>Scanner sc = new Scanner(System.in);</p>
<p>输出语句的本质:是一个标准的输出流</p>
<p>PrintStream ps = System.out;</p>
<p>PrintStream类有的方法，System.out都可以使用</p>
<p>打印流分类:</p>
<p>字节打印流:PrintStream</p>
<p>字符打印流:PrintWriter</p>
<p>打印流的特点:</p>
<p>只负责输出数据，不负责读取数据有自己的特有方法</p>
<p>字节打印流</p>
<p>PrintStream(String fileName):使用指定的文件名创建新的打印流</p>
<p>使用继承父类的方法写数据，查看的时候会转码;使用自己的特有方法写数据，查看的数据原样输出</p>
<p>字符打印流PrintWriter的构造方法:</p>
<p>方法名                        说明</p>
<p>PrintWriter(String fileName)        使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新</p>
<p>PrintWriter(Writer out,boolean autoFlush)创建一个新的PrintWriter</p>
<p>out:字符输出流</p>
<p>autoFlush:一个布尔值，如果为真，则println , printf ，或format方法将刷新输出缓冲区</p>
<h3 id="42-对象序列化"><a href="#42-对象序列化" class="headerlink" title="42.对象序列化"></a>42.对象序列化</h3><p>对象序列化:就是将对象保存到磁盘中，或者在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含:对象的类型、对象的数据和对象中存储的属性等信息字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p>
<p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流:</p>
<p>(1)对象序列化流:ObjectOutputStream</p>
<p>将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取(重构)对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象</p>
<p>构造方法:</p>
<p>ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</p>
<p>序列化对象的方法:</p>
<p>void writeObject(Object obj):将指定的对象写入ObjectOutputStream</p>
<p>注意:</p>
<p>一个对象要想被序列化，该对象所属的类必须必须实现Serializable接口</p>
<p>Serializable是一个标记接口，实现该接口，不需要重写任何方法</p>
<p>(2)对象反序列化流:ObiectlnoutStream</p>
<p>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</p>
<p>构造方法:</p>
<p>ObjectInputStream(InputStream in):创建从指定的InputStream读取的ObjectInputStream</p>
<p>反序列化对象的方法:</p>
<p>Object readObject():从ObjectInputStream读取一个对象</p>
<p>(3)对象序列化流问题</p>
<p>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢?</p>
<p>会出问题，抛出InvalidClassException异常</p>
<p>如果出问题了，如何解决呢?</p>
<p>给对象所属的类加一个serialVersionUID</p>
<p>private static final long serialVersionUID = 42L;</p>
<p>如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢?</p>
<p>给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
<p>(4) Properties概述:</p>
<p>是一个Map体系的集合类·</p>
<p>Properties可以保存到流中或从流中加载</p>
<p>练习: Properties作为Map集合的使用</p>
<p>Properties作为集合的特有方法:</p>
<p>方法名                                            说明</p>
<p>Object setProperty(String key, String value)    设置集合的键和值，都是String类型，底层调用Hashtable方法 put</p>
<p>String getProperty(String key)                使用此属性列表中指定的键搜索属性</p>
<p>Set stringPropertyNames()                    从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p>
<p>Properties和IO流结合的方法:</p>
<p>方法名                                    说明</p>
<p>void load(InputStream inStream)            从输入字节流读取属性列表（键和元素对)</p>
<p>void load(Reader reader)                    从输入字符流读取属性列表〔键和元素对)</p>
<p>void store(OutputStream out, Stringcomments)    将此属性列表〔键和元素对)写入此 Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</p>
<p>void store(Writer writer,String comments)    将此属性列表〔键和元素对)写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</p>
<h3 id="43-实现多线程"><a href="#43-实现多线程" class="headerlink" title="43.实现多线程"></a>43.实现多线程</h3><p>1.1进程</p>
<p>进程:是正在运行的程序</p>
<p>是系统进行资源分配和调用的独立单位</p>
<p>每一个进程都有它自己的内存空间和系统资源</p>
<p>1.2线程</p>
<p>线程:是进程中的单个顺序控制流，是一条执行路径</p>
<p>单线程:一个进程如果只有一条执行路径，则称为单线程程序</p>
<p>多线程:一个进程如果有多条执行路径，则称为多线程程序</p>
<p>1.3多线程的实现方式</p>
<p>方式1：继承Threac类</p>
<p>定义一个类MyThread继承Thread类</p>
<p>在MyThread类中重写run()方法</p>
<p>创建MyThread类的对象</p>
<p>启动线程</p>
<p>两个小问题:</p>
<p>为什么要重写run方法?</p>
<p>​    因为run()是用来封装被线程执行的代码</p>
<p>run()方法和start()方法的区别?</p>
<p>​    run():封装线程执行的代码，直接调用，相当于普通方法的调用</p>
<p>​    start():启动线程;然后由JVM调用此线程的run()方法.</p>
<p>1.4设置和获取线程名称Thread类中设置和获取线程名称的方法</p>
<p>void setName(String name):将此线程的名称更改为等于参数name</p>
<p>String getName():返回此线程的名称</p>
<p>通过构造方法也可以设置线程名称</p>
<p>如何获取main()方法所在的线程名称?</p>
<p>public static Thread currentThread():返回对当前正在执行的线程对象的引用</p>
<p>线程有两种调度模型</p>
<p>分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
<p>抢占式调度模型:优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程</p>
<p>获取的CPU时间片相对多一些</p>
<p>Java使用的是抢占式调度模型</p>
<p>假如计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</p>
<p>Thread类中设置和获取线程优先级的方法</p>
<p>public final int getPriority():返回此线程的优先级</p>
<p>public final void setPriority(int newPriority):更改此线程的优先级</p>
<p>线程默认优先级是5;线程优先级的范围是:1-10</p>
<p>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p>
<p>1.6线程控制</p>
<p>方法名                                说明</p>
<p>static void sleep(long millis)        使当前正在执行的线程停留(暂停执行)指定的亳秒数</p>
<p>sleep后没有执行权，会被其他线程抢走,其他线程执行后也sleep，接着等待sleep结束后重新抢执行权</p>
<p>void join()                        等待这个线程死亡</p>
<p>void setDaemon(boolean  on)    将此线程标记为守护线程，当运行的线程都是守护线程时（主线程执行完毕），Java虚拟机将退出        主线程死后，守护线程也会死</p>
<p>多线程的实现方案有两种</p>
<p>继承Thread类</p>
<p>实现Runnable接口</p>
<p>相比继承Thread类，实现Runnable接口的好处</p>
<p>避免了Java单继承的局限性</p>
<p>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p>
<p>2.3同步代码块</p>
<p>锁多条语句操作共享数据，可以使用同步代码块实现</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(任意对象)&#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁</p>
<p>同步的好处和弊端</p>
<p>好处:解决了多线程的数据安全问题</p>
<p>弊端:当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p>
<p>2.4同步方法</p>
<p>同步方法:就是把synchronized关键字加到方法上</p>
<p>格式:</p>
<p>修饰符 synchronized 返回值类型 方法名(方法参数){    }</p>
<p>同步方法的锁对象是什么呢?        this</p>
<p>同步静态方法:就是把synchronized关键字加到静态方法上</p>
<p>格式:</p>
<p>修饰符 static synchronized  返回值类型 方法名(方法参数){    }</p>
<p>同步静态方法的锁对象是什么呢?        类名.class</p>
<p>2.5 Lock锁</p>
<p>Lock中提供了获得锁和释放锁的方法</p>
<p>void lock():获得锁</p>
<p>void unlock():释放锁</p>
<p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法</p>
<p>ReentrantLock():创建一个ReentrantLock的实例</p>
<p>Object类的等待和唤醒方法:</p>
<p>方法名            说明</p>
<p>void wait()    导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</p>
<p>void notify()    唤醒正在等待对象监视器的单个线程</p>
<p>void notifyAll()    唤醒正在等待对象监视器的所有线程</p>
<h3 id="44-网络编程三要素"><a href="#44-网络编程三要素" class="headerlink" title="44.网络编程三要素"></a>44.网络编程三要素</h3><ul>
<li>(1)IP地址</li>
</ul>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而lP地址就是这个标识号。也就是设备的标识</p>
<p>常用命令:</p>
<p>ipconfig:查看本机IP地址</p>
<p>ping IP地址:检查网络是否连通</p>
<p>特殊IP地址:</p>
<p>127.0.0.1:是回送地址，可以代表本机地址，一般用来测试使用</p>
<p>lnetAddress:此类表示Internet协议(IP）地址</p>
<p>方法名                    说明</p>
<p>static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</p>
<p>String getHostName()        获取此lP地址的主机名</p>
<p>String getHostAddress()        返回文本显示中的IP地址字符串</p>
<ul>
<li>(2)端口</li>
</ul>
<p>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢?如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</p>
<p>端口:设备上应用程序的唯一标识</p>
<p>端口号:用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p>
<ul>
<li>(3)协议</li>
</ul>
<p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</p>
<p>协议:计算机网络中，连接和通信的规则被称为网络通信协议</p>
<p>UDP协议</p>
<p>用户数据报协议(User Datagram Protocol)</p>
<p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p>
<p>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时,由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</p>
<p>发送数据的步骤</p>
<p>创建发送端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket()</p>
<p>创建数据，并把数据打包</p>
<p>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</p>
<p>调用DatagramSocket对象的方法发送数据</p>
<p>void send(DatagramPacket p)</p>
<p>关闭发送端</p>
<p>void close()</p>
<p>接收数据的步骤</p>
<p>创建接收端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket(int port)</p>
<p>创建一个数据包。用于接收数据</p>
<p>DatagrarmPacket(byte[] buf, int length)</p>
<p>调用DatagramSocket对象的方法接收数据</p>
<p>void receive(DatagramPacketp)</p>
<p>解析数据包，并把数据在控制台显示</p>
<p>byte[] getData()</p>
<p>int getLength()</p>
<p>关闭接收端</p>
<p>void close()</p>
<p>TCP协议</p>
<p>传输控制协议(Transmission Control Protocol)</p>
<p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据,它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p>
<p>三次握手:TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p>
<p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p>
<p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求第三次握手，客户端再次向服务器端发送确认信息，确认连接</p>
<p>发送数据的步骤</p>
<p>创建客户端的Socket对象</p>
<p>(Socket)Socket(String host, int port)</p>
<p>获取输出流，写数据</p>
<p>OutputStreamgetOutputStream()</p>
<p>释放资源</p>
<p>void close()</p>
<p>接收数据的步骤</p>
<p>创建服务器端的Socket对象(ServerSocket)</p>
<p>ServerSocket(int port)</p>
<p>监听客户端连接。返回一个Socket对象</p>
<p>Socket accept()</p>
<p>获取输入流，读数据，并把数据显示在控制台</p>
<p>lnputStream getInputStream()</p>
<p>释放资源</p>
<p>void close()</p>
<p>//public void shutdownOutput()   关闭客户端的输出流。相当于给流中加入一个结束标记-1</p>
<h3 id="45-Lambda"><a href="#45-Lambda" class="headerlink" title="45.Lambda"></a>45.Lambda</h3><p>(1)Lambda表达式的格式</p>
<p>格式:(形式参数)-&gt;{代码块}</p>
<p>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空即可</p>
<p>箭头 -&gt;:由英文中画线和大于符号组成，固定写法。代表指向动作</p>
<p>代码块:是我们具体要做的事情，也就是以前我们写的方法体内容</p>
<p>(2)Lambda表达式的使用前提</p>
<p>有一个接口</p>
<p>接口中有且仅有一个抽象方法</p>
<p>(3)Lambda表达式的省略模式</p>
<p>省略规则:</p>
<p>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p>
<p>如果参数有且仅有一个，那么小括号可以省略</p>
<p>如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</p>
<p>(4)注意事项:</p>
<p>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p>
<p>必须有上下文环境，才能推导出Lambda对应的接口</p>
<p>根据局部变量的赋值得知Lambda对应的接口:Runnable r = () -&gt; System.out.printin(“Lambda表达式T);</p>
<p>根据调用方法的参数得知Lambda对应的接口: new Thread(()-&gt; System.out.printIn(“Lambda表达式”))start();</p>
<p>Lambda表达式和匿名内部类的区别</p>
<p>所需类型不同</p>
<p>匿名内部类:可以是接口，也可以是抽象类,还可以是具体类    new 接口</p>
<p>Lambda表达式:只能是接口</p>
<p>使用限制不同</p>
<p>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</p>
<p>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</p>
<p>实现原理不同</p>
<p>匿名内部类:编译之后，产生一个单独的.class字节码文件</p>
<p>Lambda表达式:编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</p>
<p>(5)接口的组成</p>
<p>常量public static final</p>
<p>抽象方法public abstract</p>
<p>默认方法(Java 8)</p>
<p>静态方法(Java 8)</p>
<p>私有方法(Java 9)</p>
<p>接口中默认方法</p>
<p>接口中默认方法的定义格式:</p>
<p>格式: public default返回值类型方法名(参数列表){}</p>
<p>范例: public default void show3( ){}</p>
<p>接口中默认方法的注意事项:</p>
<p>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字</p>
<p>public可以省略,default不能省略</p>
<p>接口中静态方法</p>
<p>接口中静态方法的定义格式:</p>
<p>格式: public static返回值类型方法名(参数列表){}</p>
<p>范例: public static void show(){}</p>
<p>接口中静态方法的注意事项:</p>
<p>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</p>
<p>public可以省略,static不能省略</p>
<p>接口中私有方法</p>
<p>当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java9增加私有方法的必然性</p>
<p>接口中私有方法的定义格式:</p>
<p>格式1: private返回值类型方法名(参数列表){}</p>
<p>范例1: private void show(){ }</p>
<p>格式2: private static返回值类型方法名(参数列表){}</p>
<p>范例2: private static void method0{}</p>
<p>接口中私有方法的注意事项:</p>
<p>默认方法可以调用私有的静态方法和非静态方法.</p>
<p>静态方法只能调用私有的静态方法</p>
<p>(6)方法引用符</p>
<p>::该符号为引用运算符，而它所在的表达式被称为方法引用</p>
<p>Lambda表达式: usePrintable(s-&gt; System.out.println(s));</p>
<p>分析:拿到参数s 之后通过Lambda表达式，传递合System.out.println方法去处理</p>
<p>方法引用:usePrintable(System.out:printIn);</p>
<p>分析:直接使用System.out中的printIn方法来取代Lambda，代码更加的简洁</p>
<p>推导与省略</p>
<p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导</p>
<p>如果使用方法引用，也是同样可以根据上下文进行推导</p>
<p>方法引用是Lambda的孪生兄弟</p>
<p>(7)引用对象的实例方法。其实就引用类中的成员方法</p>
<p>得先创建对象  new 对象</p>
<p>格式:对象::成员方法</p>
<p>范例:“HelloWorld”:toUpperCase</p>
<p>String类中的方法: public String toUpperCase()将此String所有字符转换为大写</p>
<p>(8)引用类的实例方法，其实就是引用类中的成员方法</p>
<p>格式:类名::成员方法</p>
<p>范例: String::substring</p>
<p>String类中的方法: public String substring(int beginIndex,int endIndex)</p>
<p>从beginIndex开始到endlndex结束，截取字符串。返回一个子串，子串的长度为endlndex-beginIndex</p>
<p>(9)引用构造器，其实就是引用构造方法</p>
<p>格式:类名::new</p>
<p>范例:Student::new</p>
<h3 id="46-1-函数式接口"><a href="#46-1-函数式接口" class="headerlink" title="46(1)函数式接口"></a>46(1)函数式接口</h3><p>:有且仅有一个抽象方法的接口</p>
<p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>
<p>如何检测一个接口是不是函数式接口呢?</p>
<p>@Functionallnterface</p>
<p>放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是，编译失败</p>
<p>注意</p>
<p>我们自己定义函数式接口的时候，@Functionallnterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</p>
<p>(2)如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</p>
<p>startThread( ()  -&gt;  System.out.println(Thread.currentThread().getName() +”线程启动了”));</p>
<p>(3)函数式接口作为方法的返回值</p>
<p>如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Comparator getComparator() &#123;</span><br><span class="line">	return (s1, s2) -&gt; s1.length( - s2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)Supplier接口</p>
<p>Supplier:包含一个无参的方法</p>
<p>T get():获得结果</p>
<p>该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</p>
<p>Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用</p>
<p>(5)Predicate接口</p>
<p>Predicate:常用的四个方法</p>
<p>​    boolean test(T t):对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值</p>
<p>​    default Predicate negate():返回一个逻辑的否定，对应逻辑非</p>
<p>​    default Predicate and(Predicate other):返回一个组合判断，对应短路与default </p>
<p>​    Predicate or(Predicate other):返回一个组合判断，对应短路或</p>
<p>Predicate接口通常用于判断参数是否满足指定的条件</p>
<p>(6)Function接口</p>
<p>Function:常用的两个方法  将T转换为R</p>
<p>R apply(T t):将此函数应用于给定的参数</p>
<p>default  Function andThen(Function after):返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</p>
<p>Function接口通常用于对参数讲行外理，转换(休理逻罗辑由Lambda表达式实现)，然后返回一个新的值</p>
<h3 id="47-使用Stream流的方式"><a href="#47-使用Stream流的方式" class="headerlink" title="47.使用Stream流的方式"></a>47.使用Stream流的方式</h3><p>(1)完成filter过滤操作</p>
<p>void forEach(Consumer action)：逐一处理流中的元素</p>
<p>list.stream().filter(s -&gt; s.startsWith(“张”)).filter(s-&gt; s.length()== 3).forEach(System.out::printIn);</p>
<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义:生成流、过滤姓张、过滤长度为3、逐一打印</p>
<p>Stream流把真正的函数式编程风格引入到ava中</p>
<p>Stream流的使用</p>
<p>生成流</p>
<p>通过数据源(集合,数组等)生成流    </p>
<p>list.stream()</p>
<p>中间操作</p>
<p>一个流后面可以跟随零个或多个中间操作，其目的主要是打开流，做出某种程度的数据过滤/映射，然后返回一个新的流,交给下一个操作使用</p>
<p>filter()</p>
<p>终结操作</p>
<p>一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作</p>
<p>forEach()</p>
<p>(2)Stream流的常见生成方式</p>
<p>1 : ColLection体系的集合可以使用默认方法stream()生成流</p>
<p>default Stream stream ()</p>
<p>2 : Map体系的集合间接的生成流</p>
<p>3∶数组可以通过stream接口的静态方法of (T… values )生成流</p>
<p>(3)Stream流的常见中间操作方法</p>
<p>Stream filter(Predicate predicate):用于对流中的数据进行过滤</p>
<p>Predicate接口中的方法        boolean test(T t):对给定的参数进行判断，返回—个布尔值</p>
<p>Stream limit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</p>
<p>Stream skip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流.</p>
<p>static  Stream concat(Stream a, Stream b):合并a和b两个流为一个流</p>
<p>Stream distinct():返回由该流的不同元素（根据Object equals(Object))组成的流，消除重复元素</p>
<p>Stream sorted():返回由此流的元素组成的流，根据自然顺序排序</p>
<p>Stream sorted(Comparator comparator):返回由该流的元素组成的流，根据提供的Comparator进行排序</p>
<p> Stream map(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</p>
<p>Function接口中的方法        R apply(Tt)</p>
<p>Intstream mapToInt(TolntFunction mapper):返回一个ntStream其中包含将给定函数应用于此流的元素的结果        sum()方法 求和  结束   流终止操作</p>
<p>lntStream:表示原始int流</p>
<p>TolntFunction接口中的方法    int applyAsInt(T value)</p>
<p>(4)Stream流的常见终结操作方法</p>
<p>void forEach(Consumer action):对此流的每个元素执行操作</p>
<p>Consumer接口中的方法            void accept(T t):对给定的参数执行此操作</p>
<p>long count():返回此流中的元素数</p>
<p>(5)Stream流的收集方法</p>
<p>R collect(Collector collector)        但是这个收集方法的参数是一个Collector接口</p>
<p>工具类Collectors提供了具体的收集方式</p>
<p>public static  Collector toList():把元素收集到List集合中</p>
<p>publicstatic  Collector toSet(:把元素收集到Set集合年</p>
<p>public static Collector toMap(Function keyMapper,Function valueMapper):把元素收集到Map集合中</p>
<h3 id="48-1-类加载类的初始化步骤"><a href="#48-1-类加载类的初始化步骤" class="headerlink" title="48.(1)类加载类的初始化步骤"></a>48.(1)类加载类的初始化步骤</h3><p>假如类还未被加载和连接，则程序先加载并连接该类</p>
<p>假如该类的直接父类还未被初始化。则先初始化其直接父类</p>
<p>假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>注意:在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3</p>
<p>类的初始化时机:</p>
<p>创建类的实例</p>
<p>调用类的类方法</p>
<p>访问类或者接口的类变量，或者为该类变量赋值</p>
<p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>初始化某个类的子类</p>
<p>直接使用java.exe命苓来运行某个主类</p>
<p>(2)类加载器</p>
<p>ClassLoader:是负责加载类的对象</p>
<p>Java运行时具有以下内置类加载器</p>
<p>Bootstrap class loader:它是虚拟机的内置类加载器，通常表示为null，并且没有父null</p>
<p>Platform class loader:平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</p>
<p>System class loader:它也被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径,模块路径和JDK特定工具上的类</p>
<p>类加载器的继承关系:System的父加载器为Platform，而Platform的父加载器为Bootstrap</p>
<p>ClassLoader中的两个方法</p>
<p>static ClassLoader getSystemClassLoader():返回用于委派的系统类加载器</p>
<p>ClassLoader getParent():返回父类加载器进行委派</p>
<p>(3)反射概述</p>
<p>Java反射机制:是指在运行时去获取一个类的变呈和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p>
<p>这里我们提供三种方式获取Class类型的对象</p>
<p>使用类的class属性来获取该类对应的Class对象。举例: Studentclass将会返回Student类对应的Class对象</p>
<p>调用对象的getClass()方法，返回该对象所属类对应的Class对象        该方法是Object类中的方法，所有的Java对象都可以调用该方法</p>
<p>使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</p>
<p>(4)反射获取构造方法并使用</p>
<p>Class类中用于获取构造方法的方法</p>
<p>Constructor[]getConstructors():返回所有公共构造方法对象的数组</p>
<p>Constructor[]getDeclaredConstructors():返回所有构造方法对象的数组</p>
<p>Constructor getConstructor(Class… parameterTypes):返回单个公共构造方法对象</p>
<p>Constructor getDeclaredConstructor(Class… parameterTypes):返回单个构造方法对象</p>
<p>Constructor类中用于创建对象的方法</p>
<p>T newInstance(Object… initargs):根据指定的构造方法创建对象</p>
<p>暴力反射：</p>
<p>public void setAccessible(boolean flag):值为true，取消访问检查</p>
<p>(5)Class类中用于获取成员变量的方法</p>
<p>Field[] getFields():返回所有公共成员变量对象的数组</p>
<p>Field[] getDeclaredFields():返回所有成员变量对象的数组</p>
<p>Field getField(String name):返回单个公共成员变量对象</p>
<p>Field getDeclaredField(String name):返回单个成员变呈对象</p>
<p>Field类中用于给成员变量赋值的方法</p>
<p>void set(Object obj, Object value):给obj对象的成员变量赋值为value</p>
<p>(6)Class类中用于获取成员方法的方法</p>
<p>Method getMethods(:返回所有公共成员方法对象的数组，包括继承的</p>
<p>Method[]getDeclaredMethods(:返回所有成员方法对象的数组，不包括继承的</p>
<p>Method getMethod(String name, Class… parameterTypes):返回单个公共成员方法对象</p>
<p>Method getDeclaredMethod(String name, Class… parameterTypes):返回单个成员方法对象</p>
<p>Method类中用于调用成员方法的方法    执行方法</p>
<p>Object invoke(Object obj, Object…args):调用obj对象的成员方法，参数是args,返回值是Object类型</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>//JavaWeb.html</url>
    <content><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-Junit使用-白盒测试"><a href="#1-Junit使用-白盒测试" class="headerlink" title="1.Junit使用:白盒测试"></a>1.Junit使用:白盒测试</h2><p>*步骤:</p>
<p>1．定义一个测试类(测试用例)</p>
<p>*建议∶</p>
<p>​    测试类名∶被测试的类名TestCalculatorTest</p>
<p>​    包名:xxx.xxx.xx.testcn.itcast.test</p>
<p>2．定义测试方法:可以独立运行</p>
<p>建议∶</p>
<p>​    *方法名: test测试的方法名testAdd()</p>
<p>​    *返回值: void</p>
<p>​    *参数列表:空参</p>
<p>3．给方法加@Test 独立运行 导包</p>
<p>4．导入junit依赖环境</p>
<p>​    *判定结果︰红色∶失败绿色∶成功</p>
<p>​    *—股我们会使用断言操作来处理结果</p>
<p>​    *Assert.assertEquals(期望的结果,运算的结果);</p>
<p>补充∶</p>
<p>​    @Before:修饰的方法会在测试方法之前被自动执行</p>
<p>​    @After:修饰的方法会在测试方法执行之后自动被执行。</p>
<h2 id="2-反射-框架设计的灵魂"><a href="#2-反射-框架设计的灵魂" class="headerlink" title="2.反射:框架设计的灵魂"></a>2.反射:框架设计的灵魂</h2><p>框架:半成品软件。可以在框架的基础上进行软件开发，简化编码</p>
<p>反射:将类的各个组成部分封装为其他对象，这就是反射机制</p>
<p>*好处:</p>
<p>​    1.可以在程序运行过程中，操作这些对象。</p>
<p>​    2.可以解耦,提高程序的可扩展性。</p>
<p>*获取class对象的方式:</p>
<p>​    1.Class.forName(“全类名”)∶将字节码文件加载进内存，返回class对象 全类名：包名.类名</p>
<p>​    *多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p>
<p>2.类名.class :通过类名的属性class获取</p>
<p>​    *多用于参数的传递</p>
<p>3，对象.getclass( : getclass()方法在object类中定义着。</p>
<p>​    *多用于对象的获取字节码的方式</p>
<p>​    结论:同一个字节码文件(* .class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。</p>
<p>class对象功能:</p>
<p>​    获取功能:</p>
<p>​        1,获取成员变量们</p>
<p>​        2,获取构造方法们</p>
<p>​        3,获取成员方法们</p>
<p>​        4.获取类名</p>
<p>Field:成员变量</p>
<p>操作:</p>
<p>​    1。设置值</p>
<p>​        void set(object obj, object value)</p>
<p>​    2．获取值</p>
<p>​        get(object obj)</p>
<p>​    3，忽略访问权限修饰符的安全检查</p>
<p>​        setAccessible(true):暴力反射</p>
<p>​        constructor:构造方法</p>
<p>​    创建对象∶</p>
<p>​        newInstance(object… initargs)</p>
<p>​    如果使用空参数构造方法创建对象，操作可以简化 : class对象的newInstance方法</p>
<h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h2><p>说明程序的，给计算机看的</p>
<p>作用分类:</p>
<p>​    编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</p>
<p>​    代码分析:通过代码里标识的注解对代码进行分析【使用反射】</p>
<p>​    编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】</p>
<p>(1).JDK中预定义的一些注解</p>
<p>​    @override:检测被该注解标注的方法是否是继承自父类(接口)的</p>
<p>​    @Deprecated :该注解标注的内容，表示已过时</p>
<p>​    @suppresswarnings :压制警告</p>
<p>​        —般传递参数all @suppresswarnings(“all”)</p>
<p>(2).自定义注解</p>
<p>格式∶</p>
<p>元注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line"></span><br><span class="line">	属性列表;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质:注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation {}</p>
<p>属性:接口中的抽象方法</p>
<p>要求∶</p>
<p>1．属性的返回值类型有下列取值</p>
<p>​    基本数据类型</p>
<p>​    String</p>
<p>​    枚举注解</p>
<p>​    以上类型的数组</p>
<p>2．定义了属性，在使用时需要给属性赋值</p>
<p>​    1，如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</p>
<p>​    2．如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</p>
<p>​    3．数组赋值时，值使用{ }包裹。如果数组中只有一个值，则省略</p>
<p>元注解:用于描述注解的注解</p>
<p>​    @Target :描述注解能够作用的位置</p>
<p>ElementType取值:</p>
<p>​    TYPE:可以作用于类上</p>
<p>​    METHOD:可以作用于方法上</p>
<p>​    FIELD:可以作用于成员变量上</p>
<p>@Retention:描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)︰当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</p>
<p>@Documented:描述注解是否被抽取到api文档中</p>
<p>@Inherited:描述注解是否被子类继承</p>
<p>(3).在程序使用(解析)注解:获取注解中定义的属性值</p>
<p>​    1，获取注解定义的位置的对象(class,Method,Field)</p>
<p>​    2．获取指定的注解</p>
<p>​        *getAnnotation(class)</p>
<p>​        //其实就是在内存中生成了一个该注解接口的子类实现对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProImpl</span> <span class="keyword">implements</span> <span class="title class_">Pro</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> string <span class="title function_">className</span><span class="params">(()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;cn.itcast.annotation.Demo1&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">methodName</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">        return <span class="string">&quot;show&quot;</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    3．调用注解中的抽象方法获取配置的属性值</p>
<h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h2><p>（1）数据库的基本概念</p>
<p>1，数据库的英文单词:DataBase简称: DB</p>
<p>2．什么数据库?</p>
<p>​    用于存储和管理数据的仓库。</p>
<p>3．数据库的特点:</p>
<p>​    1．持久化存储数据的。其实数据库就是一个文件系统</p>
<p>​    2．方便存储和管理数据</p>
<p>​    3．使用了统一的方式操作数据库— SQL</p>
<p>（2）MysQL服务启动</p>
<p>​    1. 手动。</p>
<p>​    2. cmd—&gt; services.msc打开服务的窗口</p>
<p>​    3. 使用管理员打开cmd</p>
<p>​        net start mysql :启动mysql的服务</p>
<p>​        net stop mysql:关闭mysql服务</p>
<p>MysQL登录</p>
<p>​    1.mysql -uroot -p密码</p>
<p>​    2.mysql -h IP地址 -uroot -p连接目标的密码</p>
<p>​    3.mysql —host=IP地址 —user=root —password=连接目标的密码</p>
<p>MysQL退出</p>
<p>​    1.exit</p>
<p>​    2.quit</p>
<p>Structured Query Language :结构化查询语言</p>
<p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”</p>
<p>（3）SQL通用语法</p>
<p>1.SQL语句可以单行或多行书写，以分号结尾。</p>
<p>2可使用空格和缩进来增强语句的可读性。</p>
<p>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p>
<ol>
<li>3种注释</li>
</ol>
<p><em>单行注释: — 注释内容 或 # 注释内容 (mysql特有)</em></p>
<p>多行注释:/<em> 注释 </em>/</p>
<p>（4）SQL分类</p>
<p>1.DDL(Data Definition Language)数据定义语言</p>
<p>​    用来定义数据库对象:数据库，表，列等。关键字: create，drop,alter等</p>
<p>2.DML(Data Manipulation Language)数据操作语言</p>
<p>​    用来对数据库中表的数据进行增删改。关键字:insert，delete，update等</p>
<p>3.DQL(Data Query Language)数据查询语言</p>
<p>​    用来查询数据库中表的记录(敬据)。关键字: select，where 等</p>
<p>4.DCL(Data control Language)数据控制语言(了解)</p>
<p>​    用来定义数据库的访问权限和安全级别，及创建用户。关键字:GRANT,REVOKE等</p>
<ul>
<li>DDL:操作数据库、表</li>
</ul>
<p>1．操作数据库:CRUD</p>
<p>1.1 C(Create):创建</p>
<p>创建数据库:</p>
<p>​    create database 数据库名称;</p>
<p>创建数据库，判断不存在，再创建:</p>
<p>​    create database if not exists数据库名称;</p>
<p>创建数据库，并指定字符集</p>
<p>​    create database数据库名称character set字符集名;</p>
<p>练习:创建db4数据库，判断是否存在，并制定字符集为gbk</p>
<p>​    create database if not exists db4 character set gbk;</p>
<p>2．R(Retrieve):查询</p>
<p>查询所有数据库的名称:</p>
<p>​    show databases;</p>
<p>查询某个数据库的字符集:查询某个数据库的创建语句</p>
<p>​    show create database 数据库名称;</p>
<ol>
<li>U(Update):修改</li>
</ol>
<p>修改数据库的字符集</p>
<p>​    alter database 数据库名称 character set字符集名称;</p>
<ol>
<li>D(Delete):删除</li>
</ol>
<p>删除数据库</p>
<p>​    drop database数据库名称;</p>
<p>判断数据库存在，存在再删除</p>
<p>​    drop database if exists 数据库名称;</p>
<p>5．使用数据库</p>
<p>查询当前正在使用的数据库名称</p>
<p>​    select database();</p>
<p>使用数据库</p>
<p>​    use 数据库名称;</p>
<p>2．操作表</p>
<p>1.c(create):创建</p>
<p>1.1.语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">	列名1数据类型1,</span><br><span class="line">	列名2数据类型2，</span><br><span class="line">	....</span><br><span class="line">	列名n数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意∶最后一列，不需要加逗号(,)</p>
<p>*数据库类型:</p>
<p>1.int :整数类型</p>
<p>age int,</p>
<ol>
<li>double:小数类型</li>
</ol>
<p>​    score double(5,2)</p>
<ol>
<li><p>date:日期，只包含年月日, yyyy-MM-dd</p>
</li>
<li><p>datetime :日期，包含年月日时分秒yyyy-Mm-dd HH: mm : ss</p>
</li>
<li><p>timestamp:时间错类型 包含年月日时分秒yyyy-Mm-ddHH: mm: ss</p>
</li>
</ol>
<p>​        如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</p>
<ol>
<li>varchar:字符串</li>
</ol>
<p>name varchar(20):姓名最大20个字符</p>
<p>zhangsan 8个字符，张三2个字符</p>
<p>*创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>( <span class="number">32</span>),</span><br><span class="line">	age <span class="type">int</span> ,</span><br><span class="line">	score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">	birthday <span class="type">date</span>,</span><br><span class="line">	insert_time <span class="type">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>*复制表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名 like 被复制的表名;</span><br></pre></td></tr></table></figure>
<ol>
<li>R(Retrieve):查询</li>
</ol>
<p>查询某个教据库中所有的表名称</p>
<p>​    show tables;</p>
<p>查询表结构</p>
<p>​    desc 表名;</p>
<ol>
<li>U(Update):修改</li>
</ol>
<p>3.1.修改表名</p>
<p>​    alter table 表名 rename to 新的表名;</p>
<p>3.2．修改表的字符集</p>
<p>​    alter table 表名 character set 字符集名称;</p>
<p>3.3．添加一列</p>
<p>​    alter tabie 表名 add 列名 数据类型;</p>
<p>3.4、修改列名称类型</p>
<p>​    alter table 表名 change 列名 新列名 新数据类型;</p>
<p>只改类型</p>
<p>​    alter table 表名 modify 列名 新数据类型;</p>
<p>3.5，删除列</p>
<p>​    alter tabie 表名 drop 列名;</p>
<p>DML:增制改表中数据</p>
<p>1．添加数据∶</p>
<p>语法︰</p>
<p>​    insert into 表名(列名1,列名2,…列名n) values(值1,值2,. ..值n);</p>
<p>*注意:</p>
<p>1.1.列名和值要一一对应。</p>
<p>1.2.如果表名后，不定义列名，则默认给所有列添加值</p>
<p>​    insert into 表名 values(值1,值2,…值n);</p>
<p>1.3．除了数字类型，其他类型需要使用引号(单双都可以)引起来</p>
<p>2．删除数据:|</p>
<p>语法∶[ ] 意思是可选可不选</p>
<p>​    delete from 表名 [where 条件];</p>
<p>*注意︰</p>
<p>​    1.如果不加冬件，则删除表中所有记录。</p>
<p>​    2.如果要删除所有记录</p>
<p>​        1.delete from 表名; —不推荐使用。有多少条记录就会执行多少次删除操作</p>
<p>​        2.TRUNCATE truncate table TABLE 表名; —推荐使用，效率更高先删除表，然后再创建一张一样的表。</p>
<p>​    3．修改数据︰</p>
<p>​        语法:</p>
<p>​        update 表名 set 列名1 =值1，列名2=值2,… [where条件];</p>
<p>​        *注意∶</p>
<p>​            1、如果不加任何条件，则会将表中所有记录全部修改。</p>
<ul>
<li>DQL:查询表中的记录</li>
</ul>
<p>select * from表名;</p>
<p>1．语法︰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by</span><br><span class="line">分组字段</span><br><span class="line">having</span><br><span class="line">分组之后的条件</span><br><span class="line">order by </span><br><span class="line">排序</span><br><span class="line">limit</span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure>
<p>2．基础查询</p>
<p>1，多个字段的查询</p>
<p>select 字段名1，字段名2… from表名;</p>
<p>*注意:</p>
<p>​    如果查询所有字段，则可以使用来替代字段列表。</p>
<p>2．去除重复:</p>
<p>​    distinct</p>
<p>3，计算列</p>
<p>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</p>
<p> ifnull(表达式1,表达式2) : null参与的运算，计算结果都为null</p>
<p>​    *表达式1:哪个字段需要判断是否为null</p>
<p>​    *表达式2:如果该字段为null后的替换值。</p>
<p>4．起别名︰</p>
<p>​    as : as也可以省咯</p>
<p>3．条件查询</p>
<p>​    3.1.where子句后跟条件</p>
<p>​    3.2．运算符 &gt;、&lt; 、 &lt;= 、 &gt;= 、= 、&lt;&gt;不等于</p>
<p>BETWEEN. ..AND</p>
<p>IN(集合)</p>
<p>LIKE模糊查询</p>
<p>占位符∶</p>
<p>_ 单个任意字符</p>
<p>% 多个任意字符</p>
<p>IS NULL</p>
<p>and或&amp;&amp;且</p>
<p>or 或 ||或</p>
<p>not 或 ！ </p>
<p>4.排序查询</p>
<p>*语法: order by 子句</p>
<p>order by 排序字段1 排序方式1 ，排序字段2 排序方式2.. .</p>
<p>*排序方式:</p>
<p>*ASC asc:升序，默认的。</p>
<p>*DESC desc:降序。</p>
<p>*注意︰</p>
<p>*如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p>
<p>2．聚合函数:将一列数据作为一个整体，进行纵向的计算。</p>
<p>count :计算个数</p>
<p> 1.一般选择非空的列:主键</p>
<p>  2.count(*) as total 设置列名为total计算个数与</p>
<p>max :计算最大值</p>
<p>min :计算最小值</p>
<p>sum :计算和</p>
<p>avg :计算平均值</p>
<p>*注意:聚合函数的计算，排除null值。</p>
<p>解决方案:</p>
<p>1.选择不包含非空的列进行计算</p>
<p>2.IF NULL if null函数</p>
<p>3.分组查询:</p>
<p>​    1.语法:group by 分组字段;</p>
<p>​    2．注意:</p>
<p>​        1.分组之后查询的字段:分组字段、聚合函数</p>
<p>​        2.where和having 的区别?</p>
<p>​            1.where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</p>
<p>​            2.where后不可以跟聚合函数，having可以进行聚合函数的判断。</p>
<p>4、分页查询</p>
<p>​    1．语法:limit开始的索引,每页查询的条数;</p>
<p>​    2．公式:开始的索引=(当前的页码-1)*每页显示的条数</p>
<p>—每页显示3条记录</p>
<p>SELECT *FROM student LIMIT 0,3;—第1页</p>
<p>SELECT * FROM student LIMIT 3,3; —第2页</p>
<p>SELECT * FROM student LIMIT 6,3; —第3页</p>
<p>3.limit是一个MySQL”方言”</p>
<p>约束</p>
<p>*概念:对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p>本分类:</p>
<p>1．主键约束:primary key</p>
<p>2．非空约束:not null</p>
<p>3．唯一约束: unique</p>
<p>4．外键约束:foreign key</p>
<p>*非空约束:not null某一列的值不能为null</p>
<p>1.创建表时添加约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	NAME VARCHAR( 20) NOT NULL -- name为非空</span><br><span class="line">	name varchar(20) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2．创建表完后，添加非空约束</p>
<p>​    ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</p>
<p>​    alter table stu modify name varchar(20) not null</p>
<p>3.删除name的非空约束</p>
<p>​    ALTER TABLE stu MODIFY NAME VARCHAR( 20);</p>
<p>​    *唯一约束:unique，某一列的值不能重复</p>
<p>1．注意:</p>
<p>唯一约束可以有NULL值，但是只能有一条记录为null</p>
<p>2．在创建表时，添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	phone_number VARCHAR(20) UNIQUE --手机号</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>3.删除唯一约束</p>
<p>​    ALTER TABLE stu DROP INDEX phone_number;</p>
<p>4．在表创建完后，添加唯一约束</p>
<p>​    ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</p>
<p>主键约束: primary key。</p>
<p>1.注意∶</p>
<p>​    1.含义:非空且唯一</p>
<p>​    2.一张表只能有一个字段为主键</p>
<p>​    3.主键就是表中记录的唯一标识</p>
<p>2.在创建表时，添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key ,--给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>3．删除主键</p>
<p>​    错误alter table stu modify id int ;</p>
<p>​    ALTER TABLE stu DROP PRIMARY KEY;  drop primary</p>
<p>4．创建完表后,添加主键</p>
<p>​    ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p>
<p>5，自动增长:</p>
<p>​    1.概念∶如桌某一列是数值类型的，使用auto_increment可以来完成值得自动增长</p>
<p>​    2．在创建表时，添加主键约束，并且完成主键自增长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key auto_increment,--给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>3．删除自动增长</p>
<p>​    ALTER TABLE stu MODIFY id INT;</p>
<p>4．添加自动增长</p>
<p>​    ALTER TABLE stu MODIFY id INT AUTO_INCRENENT;</p>
<p>*外键约束:foreign key,让表于表产生关系，从而保证数据的准确性。</p>
<p>1．在创建表时，可以添加外键</p>
<p>*语法∶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">	.....</span><br><span class="line">	外键列,</span><br><span class="line">	constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2．删除外键</p>
<p>​    ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; foreign key</p>
<p>3，创建表之后，添加外键</p>
<p>​    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称 (主表列名称);</p>
<p>​    alter table 表名 ADD constraint 外键名称 foreign key references主表名称 (主表列名称);</p>
<p>4.级联操作</p>
<p>1。添加级联操作</p>
<p>语法:ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p>
<p>FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</p>
<p>foreign key (外键字段名称) references 主表名称 (主表列名称) on update cascade on delete cascade</p>
<p>2．分类:</p>
<p>1．级联更新:ON UPDATE CASCADE</p>
<p>2．级联删除:ON DELETE CASCADE </p>
<p>数据库的设计</p>
<p>1.多表之间的关系</p>
<p>1.分类:</p>
<p>1.一对一(了解)∶</p>
<p>​    *如∶人和身份证</p>
<p>​    *分析:—个人只有一个身份证，一个身份证只能对应一个人</p>
<p>2.一对多(多对一）:</p>
<p>​    *如∶部门和员工</p>
<p>​    *分析:—个部门有多个员工，一个员工只能对应一个部门</p>
<p>3．多对多∶</p>
<p>​    *如:学生和课程</p>
<p>​    *分析:—个学生可以选择很多门课程，一个课程也可以被很多学生选择</p>
<p>2．实现关系∶</p>
<p>​    1.一对多(多对一) :</p>
<p>​        *如∶部门和员工</p>
<p>​        *实现方式:在多的一方建立外键，指向一的一方的主键。</p>
<p>2，多对多∶</p>
<p>​    *如:学生和课程</p>
<p>​    实现方式∶多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</p>
<p>3.一对一(了解)∶</p>
<p>​    *如:人和身份证</p>
<p>​    *实现方式:一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</p>
<p>2．数据库设计的范式</p>
<p>​    *概念∶设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p>
<p>​    设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p>​    目前关系数据库有六种范式∶第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。</p>
<p>*分类:</p>
<p>​    1，第一范式(1NF):每一列都是不可分割的原子数据项</p>
<p>​    2．第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖)</p>
<p>*几个概念:</p>
<p>​    1，函数依赖∶A—&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</p>
<p>​        例如:学号—&gt;姓名。(学号，课程名称)—&gt;分数</p>
<p>​    2．完全函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。例如:(学号，课程名称)—&gt;分数</p>
<p>​    3，部分函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。例如:(学号，课程名称)—&gt;姓名</p>
<p>​    4，传递函数依赖∶A—&gt;8,B — &gt;c，如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组)的值可以确定唯一C属性的值，则称C传递函数依赖于A</p>
<p>​        例如:学号—&gt;系名，系名—&gt;系主任</p>
<p>​    5，码;如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</p>
<p>​        例如:该表中码为︰(学号，课程名称)可以确定唯一的其他属性</p>
<p>*主属性:码属性组中的所有属性</p>
<p>*非主属性:除过码属性组的属性</p>
<p>3．第三范式(3NF)︰在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖)</p>
<p>数据库的备份和还原</p>
<p>1，命令行:</p>
<p>*语法∶</p>
<p>​    备份: mysqldump -u用户名 -p密码 数据库的名称 &gt; 保存的路径</p>
<p>还原:</p>
<p>​    1．登录数据库</p>
<p>​    2．创建数据库</p>
<p>​    3．使用数据库</p>
<p>​    4。执行文件。source 文件路径</p>
<p>2．图形化工具︰</p>
<p>多表查询∶</p>
<p>查询语法∶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">列名列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where.. .. 条件</span><br></pre></td></tr></table></figure>
<p>笛卡尔积∶</p>
<p>*有两个集合A,B .取这两个集合的所有组成情况。</p>
<p>*要完成多表查询，需要消除无用的数据</p>
<p>*多表查询的分类:</p>
<p>1.内连接查询:</p>
<p>1.隐式内连接:使用where条件消除无用数据</p>
<p>​    SELECT * FROM emp,dept WHERE emp. “ dept_id= dept. id ;</p>
<p>2．显式内连接:</p>
<p>​    语法: select 字段列表 from 表名1 [inner] join 表名2 on 条件</p>
<p>例如︰</p>
<p>SELECT * FROM emp INNER JOIN dept ON emp. dept_id = dept. id ;</p>
<p>SELECT * FROM emp JOIN dept ON emp. “ dept_id’= dept.’ id’;</p>
<p>3．内连接查询∶</p>
<p>​    1.从哪些表中查询数据</p>
<p>​    2.条件是什么</p>
<p>​    3.查询哪些字段</p>
<p>2.外链接查询:</p>
<p>1．左外连接:</p>
<p>​    *语法: select 字段列表 from 表1 left [outer] join 表2 on 条件;</p>
<p>​    *查询的是左表所有数据以及其交集部分。</p>
<p>2．右外连接:</p>
<p>​    语法: select 字段列表 from表1 right [outer] join 表2 on 条件;</p>
<p>​    *查询的是右表所有数据以及其交集部分。</p>
<p>3.子查询:</p>
<p>​    概念∶查询中嵌套查询，称嵌套查询为子查询。</p>
<p>​        —查询工资最高的员工信息</p>
<p>​        — 1查询最高的工资是多少 9000</p>
<p>​            SELECT MAX( salary) FROM emp;</p>
<p>​        —2查询员工信息，并且工资等于9008的</p>
<p>​            SELECT * FROM emp WHERE emp.”salary”= 9000;</p>
<p>​        —一条sql就完成这个操作。子查询</p>
<p>​            SELECT * FROM emp WHERE emp.’salary’ = (SELECT MAX( salary) FROM emp);</p>
<p>*子查询不同情况</p>
<p>1，子查询的结果是单行单列的∶</p>
<p>​    子查询可以作为条件，使用运算符去判断。运算符∶ &gt; &gt;= &lt; &lt;= =</p>
<p>​    —查询员工工资小于平均工资的人</p>
<p>​    SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</p>
<p>2．子查询的结果是多行单列的∶</p>
<p>​    子查询可以作为条件，使用运算符in来判断</p>
<p>​    —查询”财务部和’市场部”所有的员工信息</p>
<p>​    SELECT id FROM dept WHERE NAME =‘财务部’OR NAME = ‘巿场部”;</p>
<p>​    SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</p>
<p>—子查询</p>
<p>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept MHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</p>
<p>3，子查询的结果是多行多列的:</p>
<p>*子查询可以作为—张虚拟表参与查询</p>
<p>—查询员工入职日期是?2011-11-11日之后的员工信息和部门信息</p>
<p>—子查询</p>
<p>​    SELECT <em> FROM dept t1 ,(SELECT </em> FROM emp WHERE emp. join_date &gt; ‘2011-11-11’) t2 WHERE t1.id = t2.dept_id;</p>
<p>—普通内连接</p>
<p>​    SELECT FROM emp t1,dept t2 WHERE t1.’ dept_id’ = t2. id’ AND t1.” join_date’&gt; ‘2011-11-11’</p>
<p>事务</p>
<p>1，事务的基本介绍</p>
<p>​    1.概念∶</p>
<p>​        *如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p>
<p>​    2．操作:</p>
<p>​        1.开启事务:start transaction;</p>
<p>​        2.回滚:rollback;</p>
<p>​        3.提交:commit;</p>
<p>MysQL数据库中事务默认自动提交</p>
<p>*事务提交的两种方式:</p>
<p>自动提交∶</p>
<p>​    *mysql就是自动提交的</p>
<p>​    *一条DML(增删改语句会自动提交一次事务。</p>
<p>手动提交:</p>
<p>​    oracle数据库默认是手动提交事务需要先开后事务，再提交</p>
<p>*修改事务的默认提交方式∶</p>
<p>​    查看事务的默认提交方式:SELECT @autocommit; — 1代表自动提交0代表手动提交</p>
<p>​    修改默认提交方式:set @@autocommit = 0;</p>
<p>2．事务的四大特征:</p>
<p>​    1．原子性:是不可分割的最小操作单位，要么同时成功，要么同时失败。</p>
<p>​    2，持久性:当事务提交或回液后，数据库会持久化的保存数据。</p>
<p>​    3，隔离性:多个事务之间。相互独立。</p>
<p>​    4，一致性:事务操作前后，数据总量不变</p>
<p>3.事务的隔离级别(了解)</p>
<p>​    *概念∶多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题.</p>
<p>*存在问题:</p>
<p>​    1．脏读:一个事务，读取到另一个事务中没有提交的数据</p>
<p>​    2．不可重复读(虚读):在同一个事务中，两次读取到的数据不一样。</p>
<p>​    3．幻读:一个事务操作(DNL)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p>
<p>*隔离级别∶</p>
<p>​    1.read uncommitted : 读未提交</p>
<p>​        产生的问题:脏读、不可重复读．幻读</p>
<p>​    2.read committed :读已提交(oracle)</p>
<p>​        产生的问题:不可重复读、幻读</p>
<p>​    3.repeatable read:可重复读(rysQL默认)</p>
<p>​        产生的问题:幻读</p>
<p>​    4.serializable :串行化</p>
<p>​        可以解决所有的问题</p>
<p>注意:隔离级别从小到大安全性越来越高，但是效率越来越低</p>
<p>数据库查询隔离级别:</p>
<p>​    l select @atx_isolation;</p>
<p>​    l sellect @@transaction_isolation;</p>
<p>*数据库设置隔离级别:</p>
<p>​    l set global transaction isolation level 级别字符串;</p>
<p>DCL :</p>
<p>*SQL分类:</p>
<p>​    1.DDL:操作数据库和表</p>
<p>​    2.DML:增删改表中数据</p>
<p>​    3.DQL:查询表中数据</p>
<p>​    4.DCL:管理用户，授权</p>
<p>l DBA:数据库管理员</p>
<p>DCL:管理用户，授权</p>
<p>1．管理用户</p>
<p>​    1．添加用户:</p>
<p>​        *语法:CREATE USER ‘用户名”@’主机名’ IDENTIFIED identified BY ‘密码’;</p>
<p>​    2．删除用户:</p>
<p>​        *语法- DROP USER ‘用户名’@”主机名’;</p>
<p>​    3．修改用户密码:</p>
<p>​        UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’;</p>
<p>​        UPDATE USER SET PASSWORD = PASSWORD( ‘ abc ‘ ) WHERE USER = ‘lisi’;</p>
<p>​        SET PASSWORD FOR “用户名’@”主机名’= PASSWORD(“新密码”);</p>
<p>​        SET PASSWORD FOR “root’@’ localhost’ = PASSWORD( “123”);</p>
<p>mysq1中忘记了root用户的密码?</p>
<p>​    1.cmd — &gt;net stop mysql停止mysql服务</p>
<p>​        本需要管理员运行该cmd</p>
<p>​    2．使用无验证方式启动mysql服务: mysqld —skip-grant-tables</p>
<p>​    3．打开新的cmd窗口,直接输入mysql命今，敲回车。就可以登录成功</p>
<p>​    4.use mysql ;</p>
<p>​    5.update user set password = password(‘你的新密码’) where user = ‘root ‘;    </p>
<p>​    6.关闭两个窗口</p>
<p>​    7.打开任务管理器，手动结束mysqld.exe的进程</p>
<p>​    8.启动mysql服务</p>
<p>​    9.使用新密码登录。</p>
<p>4．查询用户:</p>
<p>​    — 1．切换到mysql数据库</p>
<p>​        USE myql;</p>
<p>​    — 2.查询user表</p>
<p>​        SELECT * FROM USER;</p>
<p>*通配符:%表示可以在任意主机使用用户登录数据库</p>
<p>2．权限管理:</p>
<p>1．查询权限:</p>
<p>—查询权限</p>
<p>​    SHOW GRANTS grants FOR “用户名’@”主机名”;</p>
<p>​    SHOW GRANTS FOR “lisi’@’ %”;</p>
<p>2．授予权限:</p>
<p>—授予权限</p>
<p>​    grant 权限列表 on 数据库名.表名 to ‘用户名”@’主机名”;</p>
<p>—给张三用户授予所有权限，在任意数据库任意表上</p>
<p>​    GRANT ALL ON <em>.</em> TO “ zhangsan’@” localhost “ ;</p>
<p>所以权限列表all所以数据库名和表名都是*</p>
<p>3．撤销权限:</p>
<p>—撤销权限:</p>
<p>​    revoke 权限列表 on 数据库名.表名 from `用户名’@”主机名’;</p>
<p>​    REVOKE UPDATE ON db3.” account“  FROM ‘lisi’@”%’;</p>
<h2 id="5-JDBC"><a href="#5-JDBC" class="headerlink" title="5.JDBC"></a>5.JDBC</h2><p>1．概念:Java DataBase Connectivity Java 数据库连接，Java语言操作数据库</p>
<p>JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我门可以使用这套接口(JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<p>2．快速入门:</p>
<p>*步骤:</p>
<p>1.导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p>
<p>​    1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</p>
<p>​    2.右键—&gt;add as Library</p>
<p>2．注册驱动</p>
<p>3。获取数据库连接对象connection</p>
<p>4．定义sql</p>
<p>5，获取执行sql语句的对象 statement</p>
<p>6．执行sql，接受返回结果</p>
<p>7．处理结果</p>
<p>8.释放资源</p>
<p>3．详解各个对象︰</p>
<p>1.DhiverManager :驱动管理对象</p>
<p>*功能∶</p>
<p>1。注册驱动:告诉程序该使用哪一个数据库驱动jar</p>
<p>static void registerDriver(Driver driver) :注册与给定的驱动程序DerverManger</p>
<p>写代码使用:class.forName( “ com.mysql .jdbc.Driver”);</p>
<p>通过查看源码发现:在com.mysqi.jdbc.Driver类中存在静态代码块 自动执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.sql. DriverMianager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;can&#x27;t register driver!&quot;);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
<p>2．获取数据库连接:</p>
<p>方法:static connection getConnection(string url，string user，string password)</p>
<p>*参数︰</p>
<p>ur1:指定连接的路径</p>
<p>语法:jdbc : mysql://ip地址(域名):端口号/数据库名称</p>
<p>例子:jdbc : mysql:// localhost: 3306/db3</p>
<p>细节∶如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则ur1可以简写为: jdbc:mysq1://数据库名称</p>
<p>​    user :用户名</p>
<p>​    password :密码</p>
<p>2.Connectibn :数据库连接对象</p>
<p>1.功能∶</p>
<p>1.获取执行sql的对象</p>
<p>​    statement createstatement(</p>
<p>​    Preparedstatement preparestatement(string sql)</p>
<p>2.管理事务︰开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开后事务</p>
<p>​    提交事务: commit( )</p>
<p>​    回滚事务: rollback()</p>
<p>3.Statement :执行sql的对象</p>
<p>1。执行sql</p>
<p>​    1.boolean execute(string sql) :可以执行任意的sql了解</p>
<p>​    2.int executeupdate(string sql)︰执行DML (insert、update、delete)语句、DDL(create,alter、drop)语句</p>
<p>​        *返回值:影响的行数，可以通过这个影响的行数判断DNL语句是否执行成功 返回值&gt;o的则执行成功，反之，则失败。</p>
<p>​    3.Resultset executeQuery(string sql):执行DQL (select)语句</p>
<p>​    4.Resultset :结果集对象,封装查询结果</p>
<p>​        boolean next():游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p>
<p>​        getXxx(参数):获取数据[</p>
<p>​    Xxx:代表数据类型―如: int getInt() , string getstring()</p>
<p>​    参数:int : 代表列的编号,从1开始如: getstring(1)</p>
<p>​    string :代表列名称。如:getDouble(“balance”)</p>
<p>​    *注意:</p>
<p>​    使用步骤:</p>
<p>​        1。游标向下移动一行</p>
<p>​        2．判断是否有数据</p>
<p>​        3．获取数据</p>
<p>​    5.PreparedStatement :执行sql的对象</p>
<p>1，SQL注入问题∶在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p>
<p>​    1．输人用户随便，输入密码:a’ or ‘a’ = ‘a</p>
<p>​    2.sql : select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</p>
<p>2．解决sql注入问题;使用Preparedstatement对象来解决</p>
<p>3。预编译的SQL:参数使用?作为占位符</p>
<p>4，步骤︰</p>
<p>​    1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar</p>
<p>​    2.注册驱动</p>
<p>​    3.获取数据库连接对象connection</p>
<p>​    4.定义sql</p>
<p>​        注意∶ sql的参数使用?作为占位符。</p>
<p>​        如: select * from user where username = ? and password = ?;</p>
<p>5．获取执行sql语句的对象Preparedstatement </p>
<p>​    Connection.preparestatement(string sql)</p>
<p>6．给?赋值</p>
<p>​    方法. setXxx(参数1，参数2)Xxx类型</p>
<p>​    参数1：?的位置编号 从1开始</p>
<p>​    参数2：?的值</p>
<p>7．执行sql，接受返回结果，不需要传递sql语句</p>
<p>8．处理结果</p>
<p>9．释放资源</p>
<p>注意︰后期都会使用Preparedstatement来完成增删改查的所有操作</p>
<p>1.可以防止SQL注入</p>
<p>2.效率更高:</p>
<p>​    抽取JDBC工具类:JDBCUtils</p>
<p>*目的:简化书写</p>
<p>*分析:</p>
<p>​    1.注册驱动也抽取</p>
<p>​    2.抽取一个方法获取连接对象</p>
<p>*需求:不想传递参数（麻烦)，还得保证工具类的通用性。</p>
<p>*解决:配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.properties</span><br><span class="line">url=</span><br><span class="line">user=</span><br><span class="line">password=</span><br></pre></td></tr></table></figure>
<p>3．抽取一个方法释放资源</p>
<p>JDBC控制事务:</p>
<p>1.事务:一个包含多个步骠的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
<p>2.操作:</p>
<p>​    1.开启事务</p>
<p>​    2.提交事务</p>
<p>​    3.回滚事务</p>
<p>3．使用connection对象来管理事务</p>
<p>开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</p>
<p>​    在执行sql之前开启事务</p>
<p>提交事务: commit()</p>
<p>​    当所有sql都执行完提交事务</p>
<p>回滚事务:roillback()</p>
<p>​    在catch中回滚事务</p>
<p>数据库连接池</p>
<p>1．概念:其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>​    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
<p>2．好处:</p>
<p>​    1.节约资源</p>
<p>​    2.用户访问高效</p>
<p>3．实现︰</p>
<p>​    1,标准接口:DataSource javax.sql包下的</p>
<p>​    1.方法︰</p>
<p>​        *获取连接:getConnection()</p>
<p>​        *归还连接:Connection.close()。如果连接对象connection是从连接池中获取的，那么调用connection.close()方法，则不会再关闭连接了。而是归还连接</p>
<p>​    2.—般我们不去实现它，有数据库厂商来实现</p>
<p>​        1.C3PO∶数据库连接池技术</p>
<p>​        2.Druid :数据库连接池实现技术，由阿里巴巴提供的</p>
<p>​        4.C3Pe:数据库连接池技术</p>
<p>*步骤∶</p>
<p>1．导入jar包（3个)c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ,</p>
<p>​    *不要忘记导入数据库驱动jar包</p>
<p>2．定义配置文件:</p>
<p>​    名称:c3po.properties或者c3pe-config.xml</p>
<p>​    路径︰直接将文件放在src目录下即可。</p>
<p>3．创建核心对象 数据库连接池对象ComboPooledDatasource</p>
<p>4．获取连接: getConnection</p>
<p>5.Druid :数据库连接池实现技术，由阿里巴巴提供的</p>
<p>本步骤∶</p>
<p>1.导入jar包druid-1.e.9.jar</p>
<p>2．定义配置文件;</p>
<p>​    是properties形式的</p>
<p>​    可以叫任意名称，可以放在任意目录下</p>
<p>3．加载配置文件。Properties</p>
<p>​     //获取src路径下的文件的方式—-&gt;ClassLoader类加载器，加载字节码文件进内存，获取src文件下资源的路径 类名.class.getClassLoader(); </p>
<p>​    ClassLoader classLoader = JDBCUtils.class.getClassLoader();</p>
<p>4．获取数据库连接池对象:通过工厂来来获取DruidDataSourceFactory</p>
<p>5．获取连接:getconnection</p>
<h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><p>spring框架对JDBC的简单封装。提供了一个DBCTemplate对象简化JDBC的开发步骤︰</p>
<p>1．导入jar包</p>
<p>2．创建JdbcTemplate对象。依赖于数据源Datasource</p>
<p>​    JdbcTemplate template = new JdbcTemplate(ds) ;</p>
<p>3．调用JdbcTemplate的方法来完成CRUD的操作</p>
<p>​    update():执行DML语句。增、删、改语句</p>
<p>​    queryForMap() :查询结果将结果集封装为map集合，将列名作为key，将值作为value将这条记录封装为一个map集合</p>
<p>​        注意:这个方法查询的结果集长度只能是1</p>
<p>​    queryForList():查询结果将结果集封装为list集合</p>
<p>​        注意:将每一条记录封装为一个Map集合，再好Map集合装载到List集合中query():查询结果，将结果封装为JavaBean对象</p>
<p>​        query的参数:RowMapper</p>
<p>​        一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p>
<p>​        *new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p>
<p>queryForObject :查询结果，将结果封装为对象</p>
<p>​        —般用于聚合函数的查询</p>
<p>web概念概述</p>
<p>Javaweb :</p>
<p>*使用ava语言开发基于互联网的项目</p>
<p>*软件架构:</p>
<p>1.C/S: client/server客户端/服务器端</p>
<p>*在用户本地有一个客户端程序，在远程有一个服务器端程序如:Qo，迅雷…</p>
<p>优点:T.1．用户体验好缺点∶</p>
<p>​    1.开发、安装，部署，维护麻烦</p>
<p>​    2.B/S: Browser/Server浏览器/服务器端</p>
<p>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序*优点:</p>
<p>1.开发、安装，部署，维护简单缺点︰</p>
<p>1，如果应用过大，用户的体验可能会受到影响2．对硬件要求过高</p>
<p>B/S架构详解</p>
<p>*资源分类:</p>
<p>1.静态资源:</p>
<p>​    本使用静态网页开发技术发布的资源。本特点:</p>
<p>​    所有用户访问，得到的结果是—样的。</p>
<p>​    本如:文本，图片，音频、视频,HTML ,css,javaScript</p>
<p>​    如果用户请求的是静态资源，那么服务器会直接将静右资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</p>
<p>2.动态资源:</p>
<p>​    使用动态网页及时发布的资源。*特点:</p>
<p>​    *所有用户访问，得到的结果可能不一样。如:jsp/servlet,php,asp…</p>
<p>​    *如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</p>
<p>​    *我们要学习动态资源，必须先学习静态资源!</p>
<p>​    *静态资源:</p>
<p>*HTML:用于搭建基础网页，展示页面的内容</p>
<p>CSS:用于美化页面，布局页面</p>
<p>JavaScript :控制页面的元素，让页面有一些动态的效果</p>
<h2 id="6-HTML"><a href="#6-HTML" class="headerlink" title="6.HTML"></a>6.HTML</h2><p>1、概念︰是最基础的网页开发语言</p>
<p>​    *Hyper Text Markup Language超文本标记语言</p>
<p>超文本:</p>
<p>​    *超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p>
<p>标记语言:</p>
<p>​    由标签构成的语言。&lt;标签名称&gt;如html, xml</p>
<p>​    标记语言不是编程语言</p>
<p>2．快速入门∶</p>
<p>​    *语法∶</p>
<p>​    1.html文档后缀名.html或者.htm</p>
<p>​    2．标签分为</p>
<p>​        1．围堵标签:有开始标签和结束标签。如<code>&lt;html&gt; &lt;/html&gt;</code></p>
<p>​        2。自闭和标签∶开始标签和结束标签在一起。如<code>&lt;br/&gt;</code> 换行标签</p>
<p>​        3．标签可以嵌套:</p>
<p>​            需要正确嵌套，不能你中有我，我中有你</p>
<p>​        错误∶<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></p>
<p>​        正确:<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></p>
<p>​        4．在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p>
<p>​        5.html的标签不区分大小写，但是建议使用小写。</p>
<p>​    3．标签学习:</p>
<p>​        1．文件标签:构成html最基本的标签</p>
<p>​        html : html文档的根标签</p>
<p>​        head :头标签。用于指定html文档的一些属性。引入外部的资源*</p>
<p>​        title:标题标签。</p>
<p>​        body :体标签</p>
<p>*&lt; I DOCTYPE html&gt; : html5中定义该文档是html文档.</p>
<p>2．文本标签:和文本有关的标签</p>
<p>注释:<l--注释内容-->*</p>
<p>标题标签</p>
<p>h1~h6:字体大小逐渐递减</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;:段落标签</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;:换行标签</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr&gt;:展示一条水平线 属性∶ color :颜色 width :宽度 size :高度</span><br></pre></td></tr></table></figure>
<p>align :对其方式center :居中 left :左对齐 right :右对齐</p>
<p>width :</p>
<p>​    1．数值: width=’20’,数值的单位，默认是px(像素)</p>
<p>​    2．数值%:占比相对于父元素的比例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;:字体加粗</span><br><span class="line">&lt;i&gt;:字体斜体</span><br><span class="line">&lt;font&gt;:字体标签</span><br><span class="line">&lt;center&gt; :文本居中</span><br></pre></td></tr></table></figure>
<p>属性:color :颜色<em> size :大小</em> face :字体</p>
<p>*属性定义∶color :</p>
<p>​    1.英文单词: red ,green, blue</p>
<p>​    2.rgb(值1，值2,值3):值的范国:0~255如rgb(0,0,255)</p>
<p>​    3.#值1值2值3:值的范国:00~FF之间。如:#FF00FF 16进制配比</p>
<p>3，图片标签:</p>
<p>img :展示图片</p>
<p>属性:</p>
<p>src :指定图片的位置</p>
<p>alt：加载不出来输出的 名字</p>
<p> 相对路径 </p>
<p>​    以.开头的路径 </p>
<p>​    ./ 代表当前目录 </p>
<p>​    ../ 后退 上一级目录</p>
<p>4.列表标签</p>
<p>有序列表</p>
<p>​    ol：列表<code>&lt;ol type=&quot;A&quot; start=&quot;5&quot;&gt;</code></p>
<p>​    li：列表的项</p>
<p>无序列表ul   li</p>
<p>5．链接标签∶</p>
<p>​    <code>&lt;a&gt;</code>:定义一个超链接</p>
<p>​    属性: href :指定访问资源的URL(统一资源定位符)为空在本页面跳转javascript:void(0);阻止他的返回</p>
<p>​    target :指定打开资源的方式</p>
<p>​    _self:默认值，在当前页面打开</p>
<p>​    _blank :在新建空白页面打开</p>
<p>6.div和span</p>
<p>​    div：每个div占满一整行，块级标签</p>
<p>​    span：文本信息在一行展示，行内标签 内联标签</p>
<p>7.语义化标签：html5中为了提高程序的可读性，提供的一些标签</p>
<p>1.<code>&lt;header&gt; &lt;/header&gt;</code>:定义一个文档的头部分</p>
<p>2.<code>&lt;footer&gt; &lt;/footer&gt;</code>：定义一个文章的低部</p>
<p>8.表格标签</p>
<p>​    table :定义表格</p>
<p>​    width :宽度</p>
<p>​    border :边框</p>
<p>​    cellpadding :定义内容和单元格的距离</p>
<p>​    cellspacing:定义单元格之间的距离。如果指定为0，则单元格的线会合为一条.</p>
<p>​    bgcolor :背景色</p>
<p>​    align :对齐方式</p>
<p>​    margin:指定外边距，auto水平居中</p>
<p>​    tr :定义行</p>
<p>​    bgcolor :背景色</p>
<p>​    align :对齐方式</p>
<p>​    td :定义单元格</p>
<p>​    colspan：合并列</p>
<p>​    rowspan：合并行</p>
<p>​    th :定义表头单元格</p>
<p>​    <code>&lt;caption&gt;</code> :表格标题</p>
<p>​    <code>&lt;thead&gt;</code> :表示表格的头部分</p>
<p>​    <code>&lt;tbody&gt;</code>:表示表格的体部分</p>
<p>​    <code>&lt;tfoot&gt;</code> :表示表格的脚部分</p>
<p>HTML标签∶</p>
<p>​    表单标签表单︰</p>
<p>​    *概念︰用于采集用户输入的数据的。用于和服务器进行交互。</p>
<p>​         form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p>
<p>属性:</p>
<p>​    action :指定提交数据的URL</p>
<p>​    method:指定提交方式</p>
<p>​    分类:—共7种，2种比较常用</p>
<p>get :</p>
<p>​    1，请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。</p>
<p>​    2，请求参数大小是有限制的。</p>
<p>​    3，不太安全。</p>
<p>post :</p>
<p>​    1．请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)</p>
<p>​    2．请求参数的大小没有限制。</p>
<p>​    3．较为安全。</p>
<p>​        *表单项中的数据要想被提交︰必须指定其name属性</p>
<p>​        *表单项标签︰</p>
<p>input :可以通过type属性值，改变元素展示的样式</p>
<p>type属性:</p>
<p>​    *text:文本输入框，默认值</p>
<p>​    *placeholder :指定输人框的提示信息，当输入框的内容发生变化，会自动清空提示信息</p>
<p>password :密码输入框隐藏密码 变成圆点</p>
<p>radio:单选框</p>
<p>注意︰</p>
<p>​    1.要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p>
<p>​    2.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
<p>​    3.checked属性，可以指定默认值</p>
<p>​        checkbox :复选框</p>
<p>注意︰</p>
<p>​    1.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
<p>​    2.checked属性，可以指定默认值 默认被选中</p>
<p>​    file:文件选择框</p>
<p>​    hidden :隐藏域,用于提交一些信息，虽然看不到，但值会被提交</p>
<p>按钮:</p>
<p>​    submit:提交按钮。可以提交表单</p>
<p>​    button:普通按钮</p>
<p>​    image :图片提交按钮</p>
<p>​    src属性指定图片的路径</p>
<p>​    label :指定输入项的文字描进信息</p>
<p>*注意∶</p>
<p>​    label的for属性一般会和input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p>
<p>​    select:下拉列表</p>
<p>*子元素: option，指定列表项</p>
<p>​    textarea :文本域</p>
<p>​    cols :指定列数，每一行有多少个字符</p>
<p>​    rows :默认多少行。</p>
<p>​    css:页面美化和布局控制</p>
<p>1．概念: cascading style sheets 层叠样式表</p>
<p>​    *层叠:多个样式可以作用在同一个html的元秦上，同时生效</p>
<p>2．好处∶</p>
<p>​    1．功能强大</p>
<p>​    2．将内容展示和样式控制分离</p>
<p>​        降低耦合度。解耦</p>
<p>​        让分工协作更容易提高开发效率</p>
<p>​    3.css的使用:css与html结合方式</p>
<p>​    1。内联样式</p>
<p>​        在标签内使用style属性指定css代码</p>
<p>*如: <code>&lt;div style=&quot;color : red;&quot;&gt;hello css&lt;/div&gt;</code></p>
<p>2．内部样式</p>
<p>在head标签内，定义style标签，style标签的标签体内容就是css代码</p>
<p>如∶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div&#123;</span><br><span class="line">	color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>3．外部样式</p>
<p>1．定义css资源文件。</p>
<p>2．在head标签内，定义link标签，引入外部的资源文件</p>
<p>如：</p>
<p>a.css文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">	color:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; herf=&quot;css/a.css&quot;&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>*注意:</p>
<p>1,2,3种方式css作用范围越来越大</p>
<p>1方式不常用，后期常用2,3</p>
<p>3种格式可以写为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@import &quot;css/a.css&quot;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>4.css语法∶</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">	属性名1:属性值1;</span><br><span class="line">	属性名2:属性值2;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择器:筛选具有相似特征的元素</p>
<p>注意︰</p>
<p>每—对属性需要使用;隔开，最后一对属性可以不加;</p>
<p>5．选择器︰筛选具有相似特征的元秦</p>
<p>​    *分类︰</p>
<p>​    1，基础选择器</p>
<p>​        1.id选择器∶选择具体的id属性值的元素.建议在一个html页面中id值唯一</p>
<p>​        语法: #id属性值{}</p>
<p>​        2．元素选择器:选择具有相同标签名称的元素</p>
<p>​        本语法︰标签名称{}</p>
<p>​        本注意:id选择器优先级高于元素选择器</p>
<p>​        3．类选择器:选择具有相同的class属性值的元素。</p>
<p>​        语法:.class属性值{}</p>
<p>​        本注意:类选择器选择器优先级高于元素选择器</p>
<p>​    2.扩展选择器</p>
<p>​        1.选择所有元秦:</p>
<p>​            语法︰*{}</p>
<p>​        2.并集选择器︰</p>
<p>​            语法：*选择器1,选择器2{}</p>
<p>​        3.子选择器∶筛选选择器1元素下的选择器2元素</p>
<p>​            语法;选择器1 选择器2{}</p>
<p>​        4.父选择器∵:筛选选择器2的父元素选择器1</p>
<p>​            语法:选择器1&gt;选择器2{}</p>
<p>​        5.属性选择器:选择元素名称，属性名-属性值的元素</p>
<p>​            多语法:元素名称[属性名=”属性值”]{ }</p>
<p>​        6.伪类选择器:选择一些元素具有的状态</p>
<p>​            *语法:元素:状态{ }</p>
<p>​    *如: <code>&lt;a&gt;</code></p>
<p>​        *状态︰</p>
<p>​            link :初始化的状态</p>
<p>​            visited :被访问过的状态</p>
<p>​            active : 正在访问状态</p>
<p>​            hover:鼠标悬浮状态</p>
<p>6．属性</p>
<p>1．字体、文本</p>
<p>​    font-size :字体大小</p>
<p>​    color :文本颜色</p>
<p>​    text-align :对其方式 </p>
<p>​    line-height :行高</p>
<p>2．背景</p>
<p>​    background :</p>
<p>3，边框</p>
<p>​    border :设置边框，符合属性</p>
<p>4．尺寸 width :宽度</p>
<p>​    height :高度</p>
<h2 id="7-Javascript"><a href="#7-Javascript" class="headerlink" title="7.Javascript"></a>7.Javascript</h2><p>概念:一门客户端本语营</p>
<p>​    运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p>
<p>​    脚本语言:不需要编译,直接就可以被浏览器解析执行了</p>
<p>功能:</p>
<p>​    可以来培强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</p>
<p>ECMAScript :客户端脚本语言的标准</p>
<p>1．基本语法:</p>
<p>1.与html结合方式</p>
<p>1．内部s :</p>
<p>*定义<code>&lt;script&gt;</code>，标签体内容就是js代码</p>
<p>2．外部s :</p>
<p>*定义<code>&lt;script&gt;</code>，通过src属性引入外部的js文件</p>
<p>*注意︰</p>
<p>1.<code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</p>
<p>2.<code>&lt;script&gt;</code>可以定义多个。</p>
<p>​    2．注释</p>
<p>​        1，单行注释://注释内容</p>
<p>​        2．多行注释∶/<em>注释内容</em>/</p>
<p>​        3．数据类型:</p>
<p>1．原始数据类型(基本数据类型):</p>
<p>​        1.number:数字。整数/小数/NaN(not a number 一个不是数字的数字类型)</p>
<p>​        2.string :字符串。字符串”abc” “a” “abc ‘ 无字符</p>
<p>2.boolean: true和false</p>
<p>3.null :一个对象为空的占位符</p>
<p>4.undefined :未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</p>
<p>2.引用数据类型:对象</p>
<p>4．变量</p>
<p>*变量:一小块存储数据的内存空间</p>
<p>Java语言是强类型语言，而Javascript是弱类型语言。</p>
<p>强类型︰在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p>
<p>弱类型:在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p>
<p>*语法∶</p>
<p>​    *var变量名=初始化值;</p>
<p>​    *typeof运算符:获取变量的类型。</p>
<p>注:null运算后得到的是object</p>
<p>5．运算符</p>
<p>1，—元运算符︰只有一个运算数的运算符</p>
<p>​    ++,— , +(正号),-(负号)</p>
<p>​    ++ —:自增(自减)++(—)在前，先自增(自减)，再运算++(—)在后，先运算，再自增(自减)</p>
<p>​    +(-):正负号</p>
<p>注意。在s中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p>
<p>其他类型转number:</p>
<p>​    string转number:按照字面值转换。如果字面值不是数字，则转为NaN(不是数字的数字)</p>
<p>​    boolean转number: true转为1,false转为-1</p>
<p>2．算数运算符</p>
<p>​    + - * / % …</p>
<p>3．赋值运算符</p>
<p>​    = += -+…</p>
<p>4．比较运算符</p>
<p>​    &lt; &gt; &gt;= &lt;= == ===(全等于)</p>
<p>比较方式</p>
<p>1．类型相同:直接比较</p>
<p>​    字符串,按照字典顺序比较。按位逐一比较，直到得出大小为止。</p>
<p>2．类型不同:先进行类型转换，再比较</p>
<p>​    *===:全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p>
<p>5．逻辑运算符</p>
<p>​     &amp;&amp; || !</p>
<p>​    逻辑运算符:&amp;&amp;:与（短路)</p>
<p>​    l|:或（短路)</p>
<p>​    !:非</p>
<p>*其他类型转boolean:</p>
<p>​    1.number:0或NaN为假，其他为真</p>
<p>​    2.string:除了空字符串(“”)，其他都是true</p>
<p>​    3.null&amp;undefined:都是false</p>
<p>​    4.对象:所有对象都为true</p>
<p>6．三元运算符</p>
<p>  ? : </p>
<p>6．流程控制语句</p>
<p>1.if…else. . .</p>
<p>2.switch:[</p>
<p>*在java中, switch语句可以接受的数据类型: byte int shor char,枚举(1.5) ,string(1.7)</p>
<p>​    switch(变量):</p>
<p>​    case 值:</p>
<p>​    *在JS中, switch语句可以接受任意的原始数据类型</p>
<p>​    3.while</p>
<p>​    4.do . ..while</p>
<p>​    5.for</p>
<p>7．特殊语法</p>
<p>1．语句以;结尾，如果一行只有一条语句则﹔可以省略(不建议)</p>
<p>2．变量的定义使用var关键字，也可以不使用</p>
<p>​    *用:定义的变量是局部变量</p>
<p>​    *不用:定义的变量是全局变量(不建议)</p>
<h3 id="1-Function-函数-方法-对象"><a href="#1-Function-函数-方法-对象" class="headerlink" title="1.Function:函数(方法)对象"></a>1.Function:函数(方法)对象</h3><p>1．创建:</p>
<p>1.var fun = new Function(形式参数列表,方法体);//忘掉吧</p>
<p>2.function 方法名称(形式参数列表){</p>
<p>​    方法体</p>
<p>}</p>
<p>3.var 方法名= function(形式参数列表){</p>
<p>​    方法体</p>
<p>}</p>
<p>2．方法:</p>
<p>3．属性:</p>
<p>​    length :代表形参的个数</p>
<p>4．特点:</p>
<p>​    1．方法定义是，形参的类型不用写,返回值类型也不写。</p>
<p>​    2．方法是一个对象，如果定义名称相同的方法，会覆盖</p>
<p>​    3．在JS中，方法的调用只与方法的名称有关，和参数列表无关</p>
<p>​    4．在方法声明中有一个隐藏的内置对象（数组）, arguments ,封装所有的实际参数</p>
<p>​    5．调用:</p>
<p>​        方法名称(实际参数列表);</p>
<p>​    Array:数组对象</p>
<p>1．创建:</p>
<p>​    1.var arr = new Array(元素列表);</p>
<p>​    2.var arr = new_Array(默认长度);</p>
<p>​    3.var arr =[元素列表];</p>
<p>2．方法</p>
<p>​    join(参数):将数组中的元素按照指定的分隔符拼接为字符串</p>
<p>​    push()向数组的末尾添加一或更多元素，并返回新的长度。</p>
<p>3．属性</p>
<p>​    length :数组的长度</p>
<p>4．特点:</p>
<p>​    1.Js中，数组元素的类型可变的。</p>
<p>​    2.Js中，数组长度可变的。</p>
<h3 id="2-Date-日期对象"><a href="#2-Date-日期对象" class="headerlink" title="2.Date:日期对象"></a>2.Date:日期对象</h3><p>​    1．创建:</p>
<p>​        var date =new Date( );</p>
<p>​    2．方法:</p>
<p>​        toLocalestring():返回当前date对象对应的时间本地字符串格式</p>
<p>​        getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p>
<p>​    Number</p>
<p>​    String</p>
<h3 id="3-RegExp-正则表达式对象"><a href="#3-RegExp-正则表达式对象" class="headerlink" title="3.RegExp:正则表达式对象"></a>3.RegExp:正则表达式对象</h3><p>1.正则表达式:定义字符串的组成规则。</p>
<p>1,单个字符:[ ]</p>
<p>​    如:[a][ab] [a-zA-Zo-9_]</p>
<p>​    特殊符号代表特殊含义的单个字符:</p>
<p>​        \d:单个数字字符[0-9]</p>
<p>​        \w:单个单词字符[a-zA-Z0-9_]</p>
<p>2．量词符号:</p>
<p>​    ?:表示出现0次或1次</p>
<p>​    *:表示出现0次或多次</p>
<p>​    +:出现1次或多次</p>
<p>​    {m,n}:表示m&lt;=数量&lt;=n</p>
<p>​    m如果缺省:{,n}:最多n次</p>
<p>​    n如果缺省:{m,}最少m次</p>
<p>3.开始结束符号</p>
<p>​    ^：开始</p>
<p>​    $：结束</p>
<p>2．正则对象:</p>
<p>1．创建</p>
<p>​    1.var reg =new_RegExp(”正则表达式”);</p>
<p>​    \2. var reg =/正则表达式/;</p>
<p>2．方法</p>
<p>​    1.test(参数):验证指定的字符串是否符合正则定义的规范</p>
<h3 id="4-Global"><a href="#4-Global" class="headerlink" title="4.Global"></a>4.Global</h3><p>1．特点:全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</p>
<p>2．方法:</p>
<p>​    encodeURI( ) : url编码</p>
<p>​    decodeURI(() : url解码</p>
<p>​    encodeURIComponent() : url编码,编码的字符更多</p>
<p>​    decodeURIComponent() : url解码</p>
<p>​    parseInt():将字符串转为数字</p>
<p>*逐—判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</p>
<p>isNaN():判断一个值是否是NaN</p>
<p>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false</p>
<p>eval():讲JavaScript字符串，并把它作为脚本代码来执行。</p>
<p> 3.URL编码</p>
<p>​    传智播客=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p>
<h2 id="8-BOM"><a href="#8-BOM" class="headerlink" title="8.BOM"></a>8.BOM</h2><p>1．概念︰Browser object Model 浏览器对象模型</p>
<p>​    将浏览器的各个组成部分封装成对象。</p>
<p>2．组成:window :窗口对象</p>
<p>​    Navigator :浏览器对象</p>
<p>​    screen :显示器屏幕对象</p>
<p>​    History : 历史记录对象</p>
<p>​    Location :地址栏对象</p>
<p>​    DOM简单学习:为了满足案例要求</p>
<p>*功能:控制html文档的内容</p>
<p>*代码∶获取页面标签(元秦)对象 Element</p>
<p>​    *document.getElementById(“id值”):通过元素的id获取元素对象</p>
<p>*操作Element对象︰</p>
<p>​    1.修改属性值∶</p>
<p>​        1.明确获取的对象是哪一个?</p>
<p>​        2.查看API文档，找其中有哪些属性可以设置</p>
<p>​    2．修改标签体内容︰</p>
<p>​    属性:innerHTML</p>
<p>​    事件简单学习</p>
<p>​    *功能:某些组件被执行了某些操作后，触发某些代码的执行。</p>
<p>​    *如何绑定事件</p>
<p>1．直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p>
<p>​    1.事件:onclickl—单击事件</p>
<p>2．通过js获取元素对象，指定事件属性，设置一个函数</p>
<p>​    window:窗口对象</p>
<p>​    1、创建</p>
<p>​    2．方法</p>
<p>​        1．与弹出框有关的方法:</p>
<p>​        alert(）显示带有一段消,息和一个确认按钮的警告框。</p>
<p>​        confirm()  显示带有一段消息以及确认按钮和取消按钮的对话框。</p>
<p>​    如果用户点击确定按钮,则方法返回true</p>
<p>​    如果用户点击取消按钮，则方法返回false</p>
<p>​    prompt() 显示可提示用户输入的对话框。</p>
<p>​    返回值:获取用户输入的值</p>
<p>2．与打开关闭有关的方法:</p>
<p>​    close()关闭浏览器窗口。</p>
<p>​        谁调用我，我关谁</p>
<p>​    open()打开一个新的浏览器窗口</p>
<p>​        返回新的window对象</p>
<p>3．与定时器有关的方式</p>
<p>​    setTimeout()在指定的毫秒数后调用函数或计算表达式。</p>
<p>*参数:</p>
<p>​    1.js代码或者方法对象</p>
<p>​    2．毫秒值</p>
<p>​    *返回值:唯—标识，用于取消定时器</p>
<p>​        clearTimeout()取消由setTimeout()方法设置的 timeout。</p>
<p>​        setInterval()</p>
<p>​    按照指定的周期（以毫秒计）来调用函数或计算表达式。</p>
<p>​        clearInterval()取消由setInterval()设置的timeout。</p>
<p>3．属性</p>
<p>4．特点</p>
<p>Window对象不需要创建可以直接使用window使用。window .方法名();</p>
<p>window引用可以省略。方法名();</p>
<p>Location对象 :地址栏对象</p>
<p>1．创建(获取)∶</p>
<p>1.window. location</p>
<p>\2. location</p>
<p>2．方法︰</p>
<p>​    reload(重新加载当前文档。刷新)</p>
<p>3。属性</p>
<p>​    href设置或返回完整的URL。跳转页面</p>
<p>​    History :历史记录对象</p>
<p>1．创建(获取)∶</p>
<p>​    1.window.history</p>
<p>​    2.history</p>
<p>2．方法:</p>
<p>​    back() 加载history列表中的前一个URL。</p>
<p>​    forward() 加载history列表中的下一个URL。</p>
<p>​    go(参数) 加载history列表中的某个具体页面。</p>
<p>参数:正数∶前进几个历史记录</p>
<p>​     负数:后退几个历史记录</p>
<p>3．属性∶</p>
<p>​    *length返回当前窗口历史列表中的URL数量。</p>
<h2 id="9-DOM"><a href="#9-DOM" class="headerlink" title="9.DOM"></a>9.DOM</h2><p>*概念: Document object Model文档对象模型</p>
<p>*将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p>
<p>W3C DOM 标准被分为3个不同的部分∶</p>
<p>核心DOM -针对任何结构化文档的标准模型</p>
<p>​    Document :文档对象</p>
<p>​    Eiement:元素对象</p>
<p>​    Attfibute :属性对象</p>
<p>​    Text :文本对象</p>
<p>​    Comment:注释对象</p>
<p>​    Node :节点对象，其他5个的父对象</p>
<p>​    XML DOM -针对XML文档的标准模型</p>
<p>​    HTML DOM -针对HTML文档的标准模型</p>
<p>核心DOM模型:</p>
<p>*Document :文档对象</p>
<p>1.创建(获取):在html dom模型中可以使用window对象来获取</p>
<p>​    1.window. document</p>
<p>​    2.document</p>
<p>2。方法:</p>
<p>​    1．获取Element对象︰ </p>
<p>​        1.getElementById() :根据id属性值获取元素对象。id属性值一般唯</p>
<p>​        2.getElementsByTagName():根据元素名称获取元素对象们。返回值是一个数组</p>
<p>​        3.getElementsByclassName( ) :根据class属性值获取元素对象们。返回值是一个数组</p>
<p>​        4.getElementsByName():根据name属性值获取元素对象们。返回值是一个数组</p>
<p>2．创建其他DOM对象:</p>
<p>​    createAttribute( name)：创建指定名称的属性节点，并返回新的attr对象</p>
<p>​    createcomment()：创建注释节点</p>
<p>​    createElement()：创建元素节点</p>
<p>​    createTextNode( )：创建文本节点</p>
<p>3．属性</p>
<p>Element :元素对象</p>
<p>1，获取/创建:通过document来获取和创建</p>
<p>2．方法:</p>
<p>​    1.removeAttribute() :删除属性</p>
<p>​    2.setAttribute(): 设置属性</p>
<p>Node :节点对象，其他5个的父对象</p>
<p>特点:所有dom对象都可以被认为是一个节点</p>
<p>方法:</p>
<p>CRUD dom树:︰</p>
<p>​    appendchild():向节点的子节点列表的结尾添加新的子节点。</p>
<p>​    removechild():删除(并返回)当前节点的指定子节点。</p>
<p>​    replacechild():用新节点替换一个子节点。</p>
<p>属性:</p>
<p>​    *parentNode返回节点的父节点。</p>
<p>HTML DOM</p>
<p>​    1．标签体的设置和获取: innerHTML</p>
<p>​    2．使用html元秦对象的属性</p>
<p>​    3．控制元素样式</p>
<p>1。使用元素的style属性来设置</p>
<p>如:</p>
<p>//修改样式方式1</p>
<p>​    div1.style.border = “1px solid red” ;</p>
<p>​    div1.style.width = “200px”;</p>
<p>​    font-size—&gt; fontsize//字体大小</p>
<p>​    div1.style.fontsize = “20px”;</p>
<p>2．提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p>
<h2 id="10-Bootstrap"><a href="#10-Bootstrap" class="headerlink" title="10.Bootstrap"></a>10.Bootstrap</h2><p>​    1．概念︰一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap是基于 HTML、JS、 Javascript 的，它简洁灵活，使得web开发更加快捷。</p>
<p><em>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</em>好处:</p>
<p>​        1，定义了很多的css毕式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</p>
<p>​        2．响应式布局。</p>
<p>​        同一套页面可以兼容不同分辨率的设备。</p>
<p>​    2．快速入门</p>
<p>​        1.下载Bootstrap</p>
<p>​        2．在项目中将这三个文件夹复制</p>
<p>​        3、创建html页面，引入必要的资源文件</p>
<p>响应式布局:</p>
<p>​    同一套页面可以兼容不同分辨率的设备。</p>
<p>​    实现∶依赖于棚格系统:将一行平均分成12个格子，可以指定元素占几个格子步骤∶</p>
<p>1，定义容器。相当于之前的table.</p>
<p>容器分类∶</p>
<p>​    1.container :两边留白  固定宽度</p>
<p>​    2.container-fluid :每一种设备都是100%的宽度</p>
<p>2．定义行。相当于之前的tr样式: row</p>
<p>3．定义元素。相当于之前的td样式指定该元素在不同的设备上，所占的格子数目。样式: col-设备代号-格子数目</p>
<p>设备代号︰</p>
<p>1.xs :超小屏幕手机(&lt;768px) : col-xs-12</p>
<p>2.sm :小屏蒂平板(≥768px)</p>
<p>3.md : 中等屏蒂桌面显示器(≥992px)</p>
<p>4.lg :大屏蒂大桌面显示器(≥1200px)</p>
<p>注意︰</p>
<p>​    1.一行中如果格子数目超过12，则超出部分自动换行。</p>
<p>​    2．栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</p>
<p>​    3．如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</p>
<p>css样式和js插件</p>
<p>1.全局CSS样式:</p>
<p>​    按钮:class=”btn btn-default”</p>
<p>图片:</p>
<p>​    class=”img-responsive”:图片在任意尺寸都占100%</p>
<p>图片形状:</p>
<pre><code> class=&quot;img-rounded&quot;:方形: 
</code></pre><p>​    class=”img-circle”:圆形 </p>
<p>​    class=”img-thumbnail”相框</p>
<p>表格</p>
<p>​    table 添加表格</p>
<p>​    table’- bordered 表格边框 </p>
<p>​    table- hover 鼠标悬停效果</p>
<p>表单</p>
<p>​    *给表单项添加: class=”form-control”</p>
<p>2.组件:</p>
<p>​    导航条</p>
<p>​    分页条</p>
<p>3.插件︰</p>
<p>​    轮播图</p>
<p>​    事件监听机制:</p>
<p>*概念:某些组件被执行了某些操作后，触发某些代码的执行。</p>
<p>​    事件:某些操作。如:单击，双击，键盘按下了，鼠标移动了</p>
<p>​    事件源:组件。如:按钮文本输入框…</p>
<p>​    监听器∶代码。</p>
<p>​    注册监听∶将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</p>
<p>*常见的事件︰</p>
<p>1．点击事件∶</p>
<p>​    1.onclick:单击事件</p>
<p>​    2.ondblclick :双击事件</p>
<p>2．焦点事件</p>
<p>​    1.onblur :失去焦点</p>
<p>​        一般用于表单校验</p>
<p>​    2.onfocus:元素获得焦点。</p>
<p>​    3．加载事件:</p>
<p>​        1.onload : —张页面或─幅图像完成加载。</p>
<p>​    4．鼠标事件︰</p>
<p>​        1.onmousedown 鼠标按钮被按下。</p>
<p>​            定义方法时，定义一个形参，接受event对象。</p>
<p>​            event对象的button属性可以获取鼠标哪个键被点击了 </p>
<p>​        2.onmouseup鼠标按键被松开。</p>
<p>​        3.onmousemove鼠标被移动。</p>
<p>​        4.onmouseover鼠标移到某元素之上。</p>
<p>​        5.onmouseout鼠标从某元素移开。</p>
<p>​    5.键盘事件:</p>
<p>​        1.onkeydown某个键盘按键被按下。</p>
<p>​        2.onkeyup某个键盘按键被松开。</p>
<p>​        3.onkeypress某个键盘按键被按下并松开。</p>
<p>​    6．选择和改变</p>
<p>​        1.onchange 域的内容被改变。</p>
<p>​        2.onselect文本被选中。</p>
<p>​    7.表单事件:</p>
<p>​        1.onsubmit确认按钮被点击。</p>
<p>​            可以阻止表单的提交</p>
<p>​        2.onreset重置按钮被点击。</p>
<h2 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h2><p>1。概念︰Extensible Markup Language 可扩展标记语言</p>
<p>*可扩展︰标签都是自定义的。<code>&lt;user&gt; &lt;student&gt;</code></p>
<p>*功能</p>
<p>*存储数据</p>
<p>1．配置文件</p>
<p>2．在网络中传输</p>
<p>xml与html的区别</p>
<p>​    1.xml标签都是自定义的，html标签是预定义。</p>
<p>​    2.xml的语法严格，html语法松散</p>
<p>​    3.xml是存储数据的，html是展示数据</p>
<p>2．语法︰</p>
<p>*基本语法︰</p>
<p>​    1.xml文档的后缀名.xml</p>
<p>​    2.xml第一行必须定义为文档声明</p>
<p>​    3.xml文档中有且仅有一个根标签</p>
<p>​    4.属性值必须使用引号(单双都可)引起来</p>
<p>​    5.标签必须正确关闭</p>
<p>​    6.xml标签名称区分大小写</p>
<p>*快速人门:</p>
<p>*组成部分∶</p>
<p>1，文档声明</p>
<p>​    1．格式:<code>&lt;?xml 属性列表 ?&gt;</code></p>
<p>2．属性列表:</p>
<p>​    version :版本号，必须的属性</p>
<p>​    encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值:ISO-8859-1</p>
<p>​    standalone :是否独立</p>
<p>取值:</p>
<p>​    yes :不依赖其他文件</p>
<p>​    no:依赖其他文件</p>
<p>2．指令(了解)∶结合css的</p>
<p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=fa.css&quot; ?&gt;</code></p>
<p>3．标签︰标签名称自定义的</p>
<p>规则: 名称可以包含字母、数字以及其他的字符名称</p>
<p>​     不能以数字或者标点符号开始</p>
<p>​     名称不能以字母xml(或者XML、 xml等等)开始</p>
<p>​     名称不能包含空格</p>
<p>4.属性:</p>
<p>​    id属性值唯一</p>
<p>5，文本:</p>
<p>CDATA区:在该区域中的数据会被原样展示</p>
<p>格式:&lt; ![CDATA[ 数据 ]]&gt;</p>
<p>约束:规定xml文档的书写规则</p>
<p>*作为框架的使用者(程序员)∶</p>
<p>​    1．能够在xml中引入约束文档</p>
<p>​    2．能够简单的读懂约束文档</p>
<p>*分类︰</p>
<p>​    1.DTD:—种简单的约束技术</p>
<p>​    2.schema :—种复杂的约束技术</p>
<p>DTD :</p>
<p>*引人dtd文档到xml文档中</p>
<p>*内部dtd :将约束规则定义在xml文档中I</p>
<p>*外部dtd:将约束的规则定义在外部的dtd文件中</p>
<p>*本地:<code>&lt;! DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></p>
<p>*网络:<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></p>
<p>schema :</p>
<p>引入:</p>
<p>​    1.填写xml文档的根元秦</p>
<p>​    2.引入xsi前缀， xmlns :xsi=”http: / /www . w3. org/2001/xNLSchema-instance”</p>
<p>​    3.引入xsd文件命名空间.  xsi:schemaLocation=”http : / / ww.itcast.cn/xml student.xsd”</p>
<p>​    4.为每一个xsd约束声明一个前缀,作为标识 xmlns=”http: / / www.itcast.cn/xml”</p>
<p>3．解析∶操作xml文档，将文档中的数据读取到内存中</p>
<p>*操作xml文档</p>
<p>1．解析(读取)∶将文档中的数据读取到内存中</p>
<p>2．写入:将内存中的数据保存到xml文档中。持久化的存储</p>
<p>*解析xml的方式:</p>
<p>1.DOM∶将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p>
<p>​    *优点:操作方便，可以对文档进行CRUD的所有操作</p>
<p>​    *缺点∶占内存</p>
<p>2.SAX:逐行读取，基于事件驱动的。</p>
<p>​    *优点:不占内存。</p>
<p>​    *缺点:只能读取，不能增删改</p>
<p>xml常见的解析器∶</p>
<p>​    1.JAXP : sun公司提供的解析器，支持dom和sax两种思想</p>
<p>​    2.DOM43 :一款非常优秀的解析器</p>
<p>​    3.Jsoup : jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容它提供了一套非常省力的API，可通过DOM,cSs以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>​    4.PULL : Android操作系统内置的解析器，sax方式的。</p>
<p>对象的使用:</p>
<p>1.Jsoup :工具类，可以解析html或xml文档，返回Document</p>
<p>​    parse :解析html或xml文档，返回Document</p>
<p>​    parse(File in，string charsetName ):解析xml或html文件的。</p>
<p>​    parse(string html):解析xml或html字符出</p>
<p>​    parse(URL_url,int timeoutNillis):通过网络路径获取指定的html或xml的文档对象</p>
<p>2.Document :文档对象。代表内存中的dom树</p>
<h2 id="12-获取Element对象"><a href="#12-获取Element对象" class="headerlink" title="12.获取Element对象"></a>12.获取Element对象</h2><p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p>
<p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p>
<p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p>
<p>3.Elements :元素Element对象的集合。可以当做ArrayList<Element>来使用</p>
<p>4.Element :元素对象</p>
<p>1.获取子元素对象</p>
<p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p>
<p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p>
<p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p>
<p>2.获取属性值</p>
<p>​    string attr( string key):根据属性名称获取属性值</p>
<p>3.获取文本内容</p>
<p>​    string text():获取标签的纯文本内容</p>
<p>​    string html():获取标签体的所有内容(包括子标签的标签和文本内容)</p>
<p>5.Node :节点对象</p>
<p>是Document和Element的父类</p>
<p>快捷查询方式:</p>
<p>1.selector:选择器</p>
<p>​    使用的方法:Elementsselect(string cssQuery)</p>
<p>​    语法:参考selector类中定义的语法</p>
<p>2.XPath : XPath即为ML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p>
<p>​    *使用Jsoup的xpath需要额外导入jar包。</p>
<p>​    *查询w3cshool参考手册xml中，使用xpath的语法完成查询</p>
<p>web服务器软件∶</p>
<p>​    服务器︰安装了服务器软件的计算机</p>
<p>​    服务器软件∶接收用户的请求，处理请求，做出响应</p>
<p>​    web服务器软件:接收用户的请求，处理请求，做出响应。</p>
<p>​    在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 </p>
<p>web容器</p>
<p>常见的java相关的web服务器软件</p>
<p>​     webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​     websphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​    JBOSS :JBOSs公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​    Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的javaEE规范servlet/jsp。开源的，免费的。</p>
<p>​    JavaEE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p>
<p>​    Tomcat:web服务器软件</p>
<p>启动︰</p>
<p>bin/startup.bat ,双击运行该文件即可</p>
<p>​    访问:浏览器输入:localhost:8080回车访问自己</p>
<p><a href="http://别人的ip:8o80访问别人">http://别人的ip:8o80访问别人</a></p>
<p>​    可能遇到的问题: 1.黑窗口一闪而过: 原因:没有正确配置AVA_HOME环境变量</p>
<p>解决方案:正确配置JAvA_HOME环境变量</p>
<p>2．启动报错:</p>
<p>1．暴力∶找到占用的端口号，并目找到对应的进程，杀死该进程</p>
<p>   cmdnetstat -ano</p>
<p>2．温柔∶修效自身的端口号</p>
<p>​    conflserver.xml</p>
<p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p>
<p>好处∶在访问时，就不用输入端口号</p>
<p>5．关闭:</p>
<p>1．正常关闭:</p>
<p>​    bin/shutdown.bat</p>
<p>​    进入程序ctrl+c</p>
<p>2．强制关闭∶</p>
<p>​    点击启动窗口的×</p>
<p>6.配置:</p>
<p>部署项目的方式:</p>
<p>1.直接将项目放到webapps目录下即可。</p>
<p>​    localhost:8080/hello/hello.html</p>
<p>​    hello:项目的访问路径—&gt;虚拟目录</p>
<p>简化部署:将项目打成一个war包，再将war包放置到webapps目录下。</p>
<p>war包会自动解压缩</p>
<p>2.配置conf/server.xml文件在<code>&lt;Host&gt;</code>标签体中配置&lt;context docBase=”D: \hello” path=” /hehe” / &gt;</p>
<p>​    docBase:项目存放的路径</p>
<p>​    path :虚拟目录</p>
<p>3.在conf\catalina\localhost创建任意名称的xml文件。在文件中编写</p>
<p>&lt;context docBase=”D: \hello”/&gt;</p>
<p>虚拟目录:xml文件的名称</p>
<p>静态项目和动态项目:</p>
<p>​    目录结构</p>
<p>java动态项目的目录结构∶</p>
<p>​    —项目的根目录</p>
<p>​    — WEB-INF目录∶</p>
<p>​    — web.xml : web项目的核心配置文件</p>
<p>​    — classes目录:放置字节码文件的目录</p>
<p>​    — lib目录∶放置依赖的jar包</p>
<p>将Tomcat集成到IDEA中，并且创建avaEE的项目，部署项目。</p>
<h2 id="13-Servlet-server-applet"><a href="#13-Servlet-server-applet" class="headerlink" title="13.Servlet : server applet"></a>13.Servlet : server applet</h2><p>*概念:运行在服务器端的小程序</p>
<p>servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p>
<p>将来我们自定义一个类，实现servlet接口，复写方法。</p>
<p>快速入门:</p>
<p>1．创建JavaEE项目</p>
<p>2．定义一个类，实现servlet接口</p>
<p>*public class servletDemo1 implements servlet</p>
<p>3．实现接中的抽象方法</p>
<p>4．配置servlet</p>
<p>在web.xml中配置∶</p>
<p><code>&lt;!--配置servlet --&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;cn.itcast.web.servlet.servletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;demo1&lt;/ servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>执行原理:</p>
<p>1，当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的servlet的资源路径</p>
<p>2．查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</p>
<p>3．如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</p>
<p>4 . tomcat会将字节码文件加载进内存，并且创建其对象</p>
<p>5．调用其方法</p>
<p>servlet中的生命周期方法:</p>
<p>1．被创建:执行init方法，只执行一次</p>
<p>servlet什么时候被创建?</p>
<p>​    默认情况下，第一次被访问时，servlet被创建</p>
<p>​    可以配置执行servlet的创建时机。</p>
<p>在<code>&lt;servlet&gt;</code>标签下配置</p>
<p>1．第一次被访问时，创建</p>
<p>*<code>&lt;load-on-startup&gt;</code>的值为负数</p>
<p>2．在服务器启动时，创建</p>
<p>*<code>&lt;load-on-startup&gt;</code>的值为0或正整数</p>
<p>​    Servlet的init方法，只执行一次，说明一个servlet在内存中只存在一个对象，Servlet是单例的</p>
<p>*多个用户同时访问时，可能存在线程安全问题。</p>
<p>*解决∶尽量不要在servlet中定义成员变量。应使用局部变量，即使定义了成员变量，也不要对修改值</p>
<p>2．提供服务:执行service方法，执行多次</p>
<p>​    每次访问servlet时, service方法都会被调用一次。</p>
<p>3．被销毁:执行destroy方法，只执行一次</p>
<p>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p>
<p>​    只有服务器正常关闭时，才会执行destroy方法。</p>
<p>destroy方法在servlet被销毁之前执行，一般用于释放资源</p>
<p>servlet3.0 :</p>
<p>*好处:</p>
<p>​    *支持注解配置。可以不需要web.xml了。</p>
<p>*步骤：</p>
<p>​    1．创建JavaEE项目，选择servlet的版本3.0以上，可以不创建web.xml</p>
<p>​    2．定义一个类，实现servlet接口</p>
<p>​    3，复写方法</p>
<p>​    4、在类上使用@WebServlet注解，进行配置</p>
<p>@WebServlet(”/资源路径”)  千万别少 / 不然服务器打不开</p>
<p>IDEA和tomcat的相关配置</p>
<p>1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件</p>
<p>​    查看控制台的log : using CATALINA_BASE: “C:\Users\liu.IntelliJIdea2019.3\system\tomcat_JavaWeb”</p>
<p>2．工作空间项目和tomcat部署的web项目tomcat真正访问的是“tomcat部署的web项目””，”tomcat部署的web项目””对应着”工作空间项目”的web目录下的所有资源</p>
<p>​    WEB-INF目录下的资源不能被浏览器百接访问。</p>
<p>3．断点调试:使用”小虫子”启动dubug启动</p>
<p>Servlet的体系结构</p>
<p>Servlet —接口===Genericservlet —抽象类===Httpservlet —抽象类</p>
<p>Genericservlet:将servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p>
<p>将来定义servlet类时，可以继承Genericservlet，实现service()方法即可</p>
<p>Httpservlet : 对http协议的一种封装，简化操作</p>
<p>​    1。定义类继承Httpservlet</p>
<p>​    2。复写doGet/doPost方法</p>
<h2 id="14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议"><a href="#14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议" class="headerlink" title="14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议"></a>14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议</h2><p>传输协议∶定义了，客户端和服务器端通信时，发送数据的格式</p>
<p>特点∶</p>
<p>​    1．基于TCP/IP的高级协议</p>
<p>​    2．默认端口号:80</p>
<p>​    3，基于请求/响应模型的:—次请求对应一次响应</p>
<p>​    4．无状态的:每次请求之间相互独立，不能交互数据</p>
<p>历史版本:</p>
<p>1.0:每一次请求响应都会建立新的连接</p>
<p>1.1:复用连接</p>
<p>​    请求消息数据格式</p>
<p>1.请求行</p>
<p>​    请求方式 请求ur1 请求协议/版本</p>
<p>GET /login.html HTTP/1.1</p>
<p>请求方式:</p>
<p>​    HTTP协议有7中请求方式,常用的有2种</p>
<p>GET:</p>
<p>​    1.请求参数在请求行中，在url后。</p>
<p>​    2．请求的url长度有限制的</p>
<p>​    3．不太安全</p>
<p>POST:</p>
<p>​    1.请求参数在请求体中</p>
<p>​    2．请求的url长度没有限制的</p>
<p>​    3。相对安全</p>
<p>2．请求头:客户端浏览器告诉服务器一些信息</p>
<p>请求头名称:请求头值</p>
<p>*常见的请求头︰</p>
<p>1.User-Agent :浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<p>​    可以在服务器端获取该头的信息，解决浏览器的兼容性问题</p>
<p>2.Referer : http: //localhost/login.html</p>
<p>​    告诉服务器，我(当前请求)从哪里来?</p>
<p>*作用:</p>
<p>​    1．防盗链:</p>
<p>​    2．统计工作:</p>
<p>​    3．请求空行</p>
<p>​        空行，就是用于分割POST请求的请求头，和请求体的。</p>
<p>​    4．请求体(正文)∶</p>
<p>​        本封装POST请求消息的请求参数的</p>
<h2 id="15-Request"><a href="#15-Request" class="headerlink" title="15.Request"></a>15.Request</h2><p>1.request对象和response对象的原理</p>
<p>​    1.request和response对象是由服务器创建的。我们来使用它们</p>
<p>​    2.request对象是来获取请求消息，response对象是来设置响应消息</p>
<p>2.request对象继承体系结构:</p>
<p>servletRequest—接口 </p>
<p>​    |  继承</p>
<p>HttpServletRequest —接口</p>
<p>​    |  实现</p>
<p>org.apache.catalina.connector.RequestFacade  类(tomcat)</p>
<p>3.request功能∶</p>
<p>1.获取请求消息数据</p>
<p>1.获取请求行数据</p>
<p>​    GET / day14/ demo1 ?name=zhangsan HTTP/1.1</p>
<p>方法∶</p>
<p>1．获取请求方式:GET</p>
<p>​    String getMethod()</p>
<p>2.(*)获取虚拟自录:/day14</p>
<p>​    String getcontextPath()</p>
<p>3，获取Servlet路径:/demo1</p>
<p>​    String getServletpath()</p>
<p>4、获取get方式请求参数: name=zhangsan</p>
<p>​    String getQuerystring()</p>
<p>5．(*)获取请求URI : / day14/ demo1</p>
<p>​    String getRequestURI():/day14/ demo1</p>
<p>​    StringBuffer getRequestURL():h<a href="http://localhost/day14/demo1">ttp:// localhost/day14/demo1</a></p>
<p>​    URL 统一资源定位符ht<a href="http://localhost/day14/RequestDemo1">tp://localhost/day14/RequestDemo1</a></p>
<p>​    URI  统一资源标识符/day14/RequestDemo1</p>
<p>6．获取协议及版本:HTTP/1.1</p>
<p>​    string getProtocol()</p>
<p>7．获取客户机的IP地址:</p>
<p>​    string getRemoteAddr( )</p>
<p>2．获取请求头数据</p>
<p>方法:</p>
<p>​    (*)string getHeadler (String name) :通过请求头的名称获取请求头的值</p>
<p>​    Enumerationcstring&gt; getHeaderwames():获取所有的请求头名称</p>
<p>3，获取请求体数据:</p>
<p>*请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p>
<p>步骤∶</p>
<p>1.获取流对象</p>
<p>​    BufferedReader getReader():获取字符输入流，只能操作字符数据</p>
<p>​    ServletInputstream getInputStream():获取字节输入流，可以操作所有类型数据</p>
<p>在文件止传知识点后讲解</p>
<p>2.再从流对象中拿数据</p>
<p>2．其他功能∶</p>
<p>1.获取请求参数通用方式∶不论get还是post请求方式都可以使用下列方法来获取请求参数</p>
<p>​    1.string getParameter(string name):根据参数名称获取参数值username=zs&amp;password=123</p>
<p>​    2.string[] getparametervalues(string name):根据参数名称获取参数值的数组hobby=xx8hobby-game</p>
<p>​    3.<code>Enumeration&lt;string&gt; getParameterNames()</code>:获取所有请求的参数名称</p>
<p>​    4.Map<string,string[]> getParameterMap():获取所有参数的map集合</p>
<p>中文乱码问题:</p>
<p>​    get方式:tomcat 8 已经将get方式乱码问题解决了</p>
<p>​    post方式:会乱码</p>
<p>*解决︰在获取参数前，设置request的编码 request.setCharacterEncoding(“UTF-8”);</p>
<p>2.请求转发:一种在服务器内部的资源跳转方式</p>
<p>1.步骤∶</p>
<p>​    1．通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(string path)</p>
<p>​    2．使用RequestDispatcher对象来进行转发∶forward(servletRequest request，ServletResponse response)</p>
<p>2.特点:</p>
<p>​    1。浏览器地址栏路径不发生变化</p>
<p>​    2．只能转发到当前服务器内部资源中。</p>
<p>​    3。转发是一次请求</p>
<p>登录跳转页面：开发步骤</p>
<p>​    1．创建项目，导入html页面，配置文件，jar包</p>
<p>​    2。创建数据库环境</p>
<p>​        driverClassName=com.mysql.cj.jdbc.Driver</p>
<p>​        数据库路径：url=jdbc:mysql:///day14?serverTimezone=GMT%2B8</p>
<p>​    3．创建包cn.itcast.domain,创建类User</p>
<p>​    4．创建包cn.itcast.util,创建类JDBCUtils，使用Druid连接池</p>
<p>​    5．创建包cn.itcast.dao,创建类UserDao,提供login方法</p>
<p>​    6．编写cn.itcast.web. servlet.Loginservlet类</p>
<p>​    8.login.html中form表单的action路径的写法</p>
<p>​        虚拟目录:Servlet的资源路径action=”/data14_text/LoginServlet”</p>
<p>​    9.Beanutils工具类，简化数据封装</p>
<p>​        *用于封装avaBean的</p>
<p>1.JavaBean ∶标准的ava类</p>
<p>1.要求:</p>
<p>​    1．类必须被public修饰</p>
<p>​    2．必须提供空参的构造器</p>
<p>​    3．成员变量必须使用private修饰</p>
<p>​    4。提供公共setter和getter方法</p>
<p>2．功能:封装数据</p>
<p>2．概念∶</p>
<p>成员变量:</p>
<p>属性: setter和getter方法截取后的产物</p>
<p>get和set方法里大多数是和成员变量一致</p>
<p>​    例如: getUsername() —&gt; Username—&gt; username</p>
<p>3．方法:</p>
<p>​    1.setProperty()操作属性，而不是成员变量 设置成员变量gender值为null 设置属性hehe才能改变gender</p>
<p>​    2.getProperty()</p>
<p>​    3.populate(object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</p>
<p>2．响应消息:服务器端发送给客户端的数据</p>
<p>*数据格式∶</p>
<p>1.响应行</p>
<p>1.组成︰协议/版本 响应状态码 状态码描述</p>
<p>​    HTTP/1.1 200 OK</p>
<p>2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。</p>
<p>​    1.状态码都是3位数字</p>
<p>​    2.分类︰</p>
<p>​        1.1xx∶服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p>
<p>​        2.2xx∶成功。代表:200</p>
<p>​        3.3xx︰重定向。代表:302(重定向),304(访问缓存)</p>
<p>​        4.4xx:客户端错误。</p>
<p>​            代表:404(请求路径没有对应的资源)</p>
<p>​             405:请求方式没有对应的doXxx方法</p>
<p>​        5.5xx:服务器端错误。代表:500(服务器内部出现异常)</p>
<p>2．响应头︰</p>
<p>1．格式:头名称:值</p>
<p>2．常见的响应头:</p>
<p>​    1.Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式</p>
<p>​    2.Content-disposition:服务器告诉客户端以什么格式打开响应体数据</p>
<p>​        值:in-line:默认值,在当前页面内打开</p>
<p>​           attachment;filename=xxx∶以附件形式打开响应体。文件下载</p>
<p>3．响应空行</p>
<p>4．响应体:传输的数据</p>
<h2 id="16-Response对象"><a href="#16-Response对象" class="headerlink" title="16.Response对象"></a>16.Response对象</h2><p>功能∶设置响应消息</p>
<p>1．设置响应行</p>
<p>​    1．格式:HTTP/1.1 200 ok</p>
<p>​    2．设置状态码: setStatus(int sc)</p>
<p>2．设置响应头: setHeader(string name，string value)</p>
<p>3．设置响应体︰</p>
<p>*使用步骤︰</p>
<p>1.获取输出流</p>
<p>​    字符输出流:Printwriter getwriter()</p>
<p>​    字节输出流: Servletoutputstream getoutputstream()</p>
<p>2.使用输出流，将数据输出到客户端浏览器</p>
<p>案例∶</p>
<p>1．完成重定向</p>
<p>重定向:资源跳转的方式</p>
<p>代码实现:</p>
<p>//1.设置状态码为302</p>
<p>​    response.setstatus( 302);</p>
<p>//2.设置响应头location</p>
<p>​    response.setHeader(“location”,” /day15/responseDemo2”);*/</p>
<p>//简单的重定向方法</p>
<p>​    response.sendRedirect(“ /day15/responseDemo2”);</p>
<p>重定向的特点: redirect</p>
<p>​    1．地址栏发生变化</p>
<p>​    2．重定向可以访问其他站点(服务器)的资源</p>
<p>​    3．重定向是两次请求。不能使用request对象来共享数据</p>
<p>转发的特点: forward</p>
<p>​    1．转发地址栏路径不变</p>
<p>​    2．转发只能访问当前服务器下的资源</p>
<p>​    3．转发是一次请求，可以使用request对象来共享数据 </p>
<h2 id="17-forward和redirect区别"><a href="#17-forward和redirect区别" class="headerlink" title="17.forward和redirect区别"></a>17.forward和redirect区别</h2><p>路径写法:</p>
<p>1，路径分类</p>
<p>1．相对路径:通过相对路径不可以确定唯一资源</p>
<p>如: ./index.html</p>
<p>不以/开头，以.开头的路径</p>
<p>规则∶找到当前资源和目标资源之间的相对位置关系</p>
<p>​    ./  当前目录</p>
<p>​    ../ 后退一级目录</p>
<p>2．绝对路径:通过绝对路径可以确定唯一资源</p>
<p>​    如: http: //localhost/day15/responseDemo2或 /day15/responseDemo2</p>
<p>以/开头的路径</p>
<p>​    规则:判断定义的路释是给谁用的?判断请求将来从哪儿发出</p>
<p>1.给客户端浏览器使用:需要加虚拟目录(项目的访问路径)</p>
<p>​    建议虚拟目录动态获取:request.getcontextpath()</p>
<p>​    <code>&lt;a&gt; ,&lt;form&gt;</code>,重定向…</p>
<p>2.给服务器使用:不需要加虚拟目录</p>
<p>​    转发路径</p>
<p>2．服务器输出字符数据到浏览器</p>
<p>本步骤︰</p>
<p>​    1。获取字符输出流</p>
<p>​    2．输出数据</p>
<p>注意:</p>
<p>乱码问题∶</p>
<p>​    1.Printwriter pw = response.getwriter();获取的流的默认编码是IS0-8859-1</p>
<p>​    2.设置该流的默认编码</p>
<p>​    3.告诉浏览器响应体使用的编码</p>
<p>​        //简单的形式，设置编码，是在获取流之前设置</p>
<p>​        response.setContentType( “text/html ;charset=utf-8”);</p>
<h2 id="18-ServletContext对象"><a href="#18-ServletContext对象" class="headerlink" title="18.ServletContext对象:"></a>18.ServletContext对象:</h2><p>1.概念∶代表整个web应用，可以和程序的容器(服务器)来通信</p>
<p>2.获取︰</p>
<p>1．通过request对象获取</p>
<p>​    request.getServletContext( );</p>
<p>2．通过Httpservlet获取</p>
<p>​    this.getServletContext();</p>
<p>3．功能∶</p>
<p>1．获取MIME类型:</p>
<p>​    MIME类型:在互联网通信过程中定义的一种文件数据类型</p>
<p>​    格式:大类型/小类型text/htmlimage/ jpeg</p>
<p>​    获取: string getMimeType(string file)</p>
<p>2．域对象︰共享数据</p>
<p>3．获取文件的真实(服务器)路径</p>
<p>案例:</p>
<p>文件下载需求:</p>
<p>​    1．页面显示超链接</p>
<p>​    2．点击超链接后弹出下载提示框</p>
<p>​    3，完成圈片文件下载</p>
<p>分析∶</p>
<p>​    1．超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求</p>
<p>​    2．任何资源都必须弹出下载提示框</p>
<p>​    3．使用响应头设置资源的打开方式∶</p>
<p>​        content-disposition:attachment;filename=xXX</p>
<p>步骤∶</p>
<p>1．定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</p>
<p>2．定义servlet</p>
<p>​    1．获取文件名称</p>
<p>​    2．使用字节输入流加载文件进内存</p>
<p>​    3，指定response的响应头: content-disposition:attachment;filename=xXX</p>
<p>​    4。将数据写出到response输出流</p>
<p>问题∶中文文件名问题</p>
<p>*解决思路︰</p>
<p>​    1．装取客户端使用的浏览器版本信息</p>
<p>​    2．根据不同的版本信息，设置filename的编码方式不同</p>
<h2 id="19-Cookie"><a href="#19-Cookie" class="headerlink" title="19.Cookie"></a>19.Cookie</h2><p>1.概念︰客户端会话技术，将数据保存到客户端</p>
<p>2.快速入门:</p>
<p>*使用步骤︰</p>
<p>1．创建cookie对象，绑定数据</p>
<p>​    new cookie(string name,string value)</p>
<p>2．发送cookie对象</p>
<p>​    response.addcookie(cookie cookie)</p>
<p>3．获取Cookie，拿到数据</p>
<p>​    cookie[] request.getcookies()</p>
<p>3.实现原理</p>
<p>​    基于响应头set-cookie和请求头cookie实现</p>
<p>4.cookie的细节</p>
<p>1.一次可不可以发送多个cookie?</p>
<p>​    *可以可以创建多个cookie对象，使用response调用多次addcookie方法发送cookie即可。</p>
<p>2.cookie在浏览器中保存多长时间?</p>
<p>​    1．默认情况下，当浏览器关闭后，Cookie数据被销毁</p>
<p>​    2．持久化存储∶</p>
<p>​        setMaxAge(int seconds)</p>
<p>​            1.正数∶将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p>
<p>​            2.负数∶默认值</p>
<p>​            3.零∶删除cookie信息</p>
<p>3.cookie能不能存中文?</p>
<p>在tomcat 8之前cookie中不能直接存储中文数据。</p>
<p>需要将中文数据转码—-一般采用URL编码(%E3)</p>
<p>在tomcat 8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p>
<p>4.cookie共享问题?</p>
<p>1.假设在一个tomcat服务器中，部署了多个web项目,那么在这些web项目中cookie能不能共享?</p>
<p>默认情况下cookie不能共享</p>
<p>​    setPath(String path):设固cookie的获取范围。默认情况下，设置当前的虚拟目录</p>
<p>​    如果要共享,则可以将path设置为”/”</p>
<p>2,不同的tomcat服务器间cookie共享问题?</p>
<p>​    setDomain(string path):如果设固一级域名相同，那么多个服务器之间cookie可以共享</p>
<p>​    setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p>
<p>5.cookie的特点和作用</p>
<p>​    1.cookie存储数据在客户端浏览器</p>
<p>​    2.浏览器对于单个cookie 的大小有限制(akb)以及对同一个域名下的总cookie数量也有限制(20个)</p>
<p>*作用:</p>
<p>​    1.cookie—般用于存出少量的不太敏感的数据</p>
<p>​    2．在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>6.案例:记住上一次访问时间</p>
<p>1，需求∶</p>
<p>​    1．访问一个servlet，如果是第一次访问，则提示:您好，欢迎您首次访问。</p>
<p>​    2．如果不是第一次访问，则提示:欢迎回来，您上次访问时间为;显示时间字符串</p>
<p>2．分析∶</p>
<p>​    1．可以采用cookie来完成</p>
<p>​    2．在服务器中的servlet判断是否有一个名为lastTime的cookie</p>
<p>​        1.有:不是第一次访向</p>
<p>1.响应数据∶欢迎回来，您上次访问时间为:2018年6月10日11:50:20</p>
<p>2.写回cookie : lastTime=2018年6月1e日11:50:e1</p>
<p>2．没有∶是第一次访问</p>
<p>1．响应数据:您好，欢迎您首次访问</p>
<p>2．写回cookie : lastTime=2018年6月16日11: 50:01</p>
<h2 id="20-JSP-入门学习"><a href="#20-JSP-入门学习" class="headerlink" title="20.JSP:入门学习"></a>20.JSP:入门学习</h2><p>1.概念∶Java Server Pages : java服务器端页面</p>
<p>​    可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</p>
<p>​    用于简化书写!!!</p>
<p>2.原理</p>
<p>JSP本质上就是一个servlet</p>
<p>3.JSP的脚本:JSP定义ava代码的方式</p>
<p>​    1.&lt;% 代码 %&gt;:定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。成员变量范围小</p>
<p>​    2.&lt;%! 代码 %&gt;∶定义的java代码，在jsp转换后的java类的成员位置。成员变量范围大，全局。</p>
<p>​    3.&lt;%= 代码 %&gt;∶定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</p>
<p>4.JSP的内置对象</p>
<p>在jsp页面中不需要获取和创建，可以直接使用的对象</p>
<p>jsp一共有9个内置对象。</p>
<p>​    request</p>
<p>​    response</p>
<p>​    out:字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似</p>
<p>​    response. getwriter(和out.write()的区别:</p>
<p>​    在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</p>
<p>​    response.getwriter()数据输出永远在out.write()之前</p>
<h2 id="21-Session"><a href="#21-Session" class="headerlink" title="21.Session"></a>21.Session</h2><p>1．概念∶服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<p>2．快速入门:</p>
<p>1．获取Httpsession对象︰</p>
<p>​    Httpsession session = request.getsession();</p>
<p>2．使用Httpsession对象∶</p>
<p>​    object getAttribute(string name)</p>
<p>​    void setAttribute(string name，object value)</p>
<p>​    void removeAttribute(string name)</p>
<p>3．原理</p>
<p>​    session的实现是依赖于cookie的。</p>
<p>4。细节∶</p>
<p>1．当客户端关闭后，服务器不关闭，两次获取session是否为同一个?</p>
<p>默认情况下。不是。</p>
<p>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p>
<p>​    Cookie c = new Cookie(“SESSIONID” , session.getId());</p>
<p>​    c .setMaxAge(60*60);</p>
<p>​    response.addcookie(c);</p>
<p>2．客户端不关闭，服务器关闭后，两次获取的session是同一个吗?</p>
<p>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</p>
<p>session的钝化:</p>
<p>​    在服务器正常关闭之前，将Session对象序列化到硬盘上 </p>
<p>session的活化:</p>
<p>​    在服务器启动后，将session文件转化为内存中的session对象即可。</p>
<p>3.session什么时候被销毁?</p>
<p>​    1.服务器关闭</p>
<p>​    2.session对象调用invalidate() 。</p>
<p>​    3.session默认失效时间30分钟</p>
<p>​        选择性配置修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">	&lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>
<p>4.session的特点</p>
<p>1.session用于存储一次会话的多次请求的数据，存在服务器端</p>
<p>2.session可以存储任意类型，任意大小的数据</p>
<p>session与cookie的区别︰</p>
<p>​    1.session存储数据在服务器端，Cookie在客户端</p>
<p>​    2.session没有数据大小限制,Cookie有</p>
<p>​    3.session数据安全,cookie相对于不安全</p>
<h2 id="21JSP"><a href="#21JSP" class="headerlink" title="21JSP"></a>21JSP</h2><p>1.指令</p>
<p>作用:用于配置JSP页面，导入资源文件</p>
<p>格式∶&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;</p>
<p>分类∶</p>
<p>1.page:配置SP页面的</p>
<p>​    contentType :等同于response.setcontentType()</p>
<p>​    1．设置响应体的mime类型以及字符集</p>
<p>​    2．设置当前jsp页面的编码（只能是高级的IDE才能生效，</p>
<p>​        如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集)</p>
<p>​    import :导包</p>
<p>​    errorPage :当前页面发生异常后，会自动跳转到指定的错误页面</p>
<p>​    isErrorPage :标识当前页面是否是错误页面。</p>
<p>​        *true :是，可以使用内置对象exception.getMessage()</p>
<p>​        *false :否。默认值。不可以使用内置对象exception</p>
<p>2.include:页面包含的。导入页面的资源文件</p>
<p>*&lt;%@include file=”top.jsp”%&gt;</p>
<p>3.taglib:导入资源</p>
<p>​    *&lt;%taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p>
<p>​    *prefix:前缀，自定义的</p>
<p>2．注释:</p>
<p>1.html注释:</p>
<p>​    <!-- -->:只能注释html代码片段</p>
<p>\2. jsp注释∶推荐使用</p>
<p>​    &lt;%— —%&gt;∶可以注释所有</p>
<p>3．内置对象</p>
<p>​    在jsp页面中不需要创建，直接使用的对象</p>
<p>一共有9个:</p>
<p>变量名真实类型作用</p>
<p>​    pageContextPagecontext当前页面共享数据，还可以获取其他八个内置对象</p>
<p>​    requestHttpservletRequest一次请求访问的多个资源(转发)</p>
<p>​    sessionHttpSession一次会话的多个请求间</p>
<p>​    applicationServletContext所有用户间共享数据</p>
<p>​    responseHttpservletResponse响应对象</p>
<p>​    pageObject当前页面(Servlet)的对象this</p>
<p>​    outJspWriter输出对象，数据输出到页面上</p>
<p>​    configServletConfigservlet的配置对象</p>
<p>​    exceptionThrowable异常对象</p>
<h2 id="22-MVC-开发模式"><a href="#22-MVC-开发模式" class="headerlink" title="22.MVC:开发模式"></a>22.MVC:开发模式</h2><p>1.M : Model，模型。JavaBean</p>
<p>​    完成具体的业务操作，如:查询数据库，封装对象</p>
<p>2.V : View，视图。JSP</p>
<p>​    展示数据</p>
<p>3.C: Controller，控制器。Servlet</p>
<p>​    获取用户的输入</p>
<p>调用模型</p>
<p>将数据交给视图进行展示</p>
<p>*优缺点︰</p>
<p>1．优点:</p>
<p>​    1．耦合性低，方便维护，可以利于分工协作</p>
<p>​    2．重用性高</p>
<p>2．缺点∶</p>
<p>​    1．使得项目架构变得复杂，对开发人员要求高</p>
<h2 id="23-EL表达式"><a href="#23-EL表达式" class="headerlink" title="23.EL表达式"></a>23.EL表达式</h2><p>1.概念∶Expression Language表达式语言</p>
<p>2.作用:替换和简化jsp页面中java代码的编写</p>
<p>3.语法∶${表达式}</p>
<p>4.注意:</p>
<p>​    jsp默认支持el表达式的。如果要忽略el表达式</p>
<p>​    1.设置jsp中page指令中:isELIgnored=”true”忽略当前jsp页面中所有的el表达式</p>
<p>​    \2. ${表达式}∶忽略当前这个el表达式</p>
<p>5.使用∶</p>
<p>1.运算:</p>
<p>运算符:</p>
<p>​    1.算数运算符∶+ -  * /(div) %(mod)</p>
<p>​    2.比较运算符∶&gt; &lt; &gt;= &lt;= == !=</p>
<p>​    3.逻辑运算符:&amp;&amp;(and) ll(or)  !(not)</p>
<p>​    4.空运算符: empty</p>
<p>​        功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0</p>
<p>​        ${empty list}  list集合内是否为null</p>
<p>​           ${not empty str}判断字符串、集合、数组是否不为null并且长度大于0 </p>
<p>2.获取值</p>
<p>1.el表达式只能从域对象中获取值</p>
<p>2.语法:</p>
<p>​    1.${域名称.键名}∶从指定域中获取指定键的值</p>
<p>​    域名称:</p>
<p>​        1.pagescope—&gt; pagecontext小</p>
<p>​        2.requestScope—&gt; request</p>
<p>​        3.sessionscope—&gt; session</p>
<p>​        4.applicationscope —&gt; application(servletcontext)大</p>
<p>​        举例:在request域中存储了 name=张三</p>
<p>​        获取∶${requestScope. name}</p>
<p>2.$({键名}∶表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p>
<p>3.获取对象、List集合、 Map集合的值</p>
<p>​    1.对象∶${域名称.键名.属性名}</p>
<p>​      ${requestScope.u.birthday}</p>
<p>​    本质上会去调用对象的getter方法</p>
<p>2.List集合∶${域名称.键名[索引]}</p>
<p>3.Map集合:</p>
<p>​    1.$[域名称.键名.key名称}</p>
<p>​    2.$[域名称.键名[“key名称“]</p>
<p>​    3.隐式对象∶</p>
<p>​        el表达式中有11个隐式对象</p>
<p>​        pagecontext :获取jsp其他八个内置对象</p>
<p>​        ${pagecontext.request.contextPath} :动态获取虚拟目录</p>
<h2 id="24-JSTL"><a href="#24-JSTL" class="headerlink" title="24.JSTL"></a>24.JSTL</h2><p>1.概念:JavaServer Pages Tag Library  JSP标准标签库</p>
<p>​    是由Apache组织提供的开源的免费的jsp标签&lt;标签&gt;</p>
<p>2.作用:用于简化和替换jsp页面上的java代码</p>
<p>3.使用步骤:</p>
<p>​    1.导入jstl相关jar包</p>
<p>​    2.引入标签库:taglib指令:&lt;%@taglib %&gt;</p>
<p>​    3.使用标签</p>
<p>​    4.常用的JSTL标签</p>
<p>​        1.if:相当于java代码的if语句</p>
<p>​            1.属性:</p>
<p>​                test 必须属性，接受boolean表达式</p>
<p>​                    如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p>
<p>​                    一般情况下, test展性值会结合el表达式一起使用</p>
<p>​            2．注意∶</p>
<p>​                c :if标签没有else情况，想要else情况，则可以在定义一个c:if标签</p>
<p>​        2.choose:相当于java代码的switch语句</p>
<p>​            1.使用choose标签声明相当于switch声明</p>
<p>​            2.使用when标签做判断相当于case</p>
<p>​            3.使用otherwise标签做其他情况的声明相当于default</p>
<p>​        3.foreach:相当于java代码的for语句</p>
<p>​            1.完成重复的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 1; i &lt; 10; i ++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        属性:</p>
<p>​            begin:开始值</p>
<p>​            end:结束值</p>
<p>​            var:临时变量</p>
<p>​            step:步长</p>
<p>​            varStatus :循环状态对象</p>
<p>​            index:容器中元素的索引，从0开始</p>
<p>​            count:循环次数，从1开始</p>
<p>​    2.遍历容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list;</span><br><span class="line">for( User user : list)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    属性:</p>
<p>​        items:容器对象</p>
<p>​        var :容器中元素的临时变量</p>
<p>​        varStatus :循环状态对象</p>
<p>​        index:容器中元素的索引，从0开始</p>
<p>​        count:循环次数，从1开始</p>
<p>三层架构∶软件设计架构</p>
<p>1．界面层(表示层)∶用户看的得界面。用户可以通过界面上的组件和服务器进行交互cn.itcast.项目名.web</p>
<p>2．业务逻辑层∶处理业务逻辑的。cn.itcast.项目名.service</p>
<p>3．数据访问层:操作数据存储文件。cn.itcast.项目名.dao</p>
<h2 id="25-Filter-过滤器"><a href="#25-Filter-过滤器" class="headerlink" title="25.Filter:过滤器"></a>25.Filter:过滤器</h2><p>1.概念:</p>
<p>生活中的过滤器:净水器,空气净化器，士匪、</p>
<p>web中的过滤器﹔当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</p>
<p>过滤器的作用:</p>
<p>​    一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤…</p>
<p>2.快速入门:</p>
<p>1.步骤:</p>
<p>​    1.定义干个类，实现接口Filter</p>
<p>​    2.复写方法</p>
<p>​    3.配置拦截路释</p>
<p>​        1.web.xml</p>
<p>​        2.注解@WebFilter(“/*”) //访问所有资源之前，都会执行该过滤器</p>
<p>​        3.过滤器细节:</p>
<p>1.web.xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">	&lt;!--拦截路径--&gt;</span><br><span class="line">	&lt;url-pattern&gt;/*&lt;/ url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>2.过滤器执行流程</p>
<p>​    1.执行过滤器</p>
<p>​    2.执行放行后的资源</p>
<p>​    3.回来执行过滤器放行代码下边的代码</p>
<p>3.过滤器生命周期对法</p>
<p>​    1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</p>
<p>​    2.doFilter:每一次请求被拦截资源时，会执行。执行多次</p>
<p>​    3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</p>
<p>4.过滤器配置详解</p>
<p>拦截路径配置:</p>
<p>​    1.具体资源路径: /index.jsp 只有访问index.jsp资源时，过滤器才会被执行</p>
<p>​    2.拦截目录: /user/ 访问/user下的所有资源时，过滤器都会被执行</p>
<p>​    3.后缀名拦截: *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行</p>
<p>​    4.拦截所有资源: /* 访问所有资源时，过滤器都会被执行</p>
<p>拦截方式配置:资源被访问的方式</p>
<p>注解配置∶</p>
<p>设置dispatcherTypes属性</p>
<p>​    1.REQUEST:默认值。浏览器直接请求资源</p>
<p>​    2.FORWARD∶转发访问资源</p>
<p>​    3.INCLUDE:包含访问资源</p>
<p>​    4.ERROR:错误跳转资源</p>
<p>​    5.ASYNC:异步访问资源</p>
<p>web.xml配置</p>
<p>*设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签即可</p>
<p>5.过滤器链(配置多个过滤器)</p>
<p>执行顺序:如果有两个过滤器∶过滤器1和过滤器2</p>
<p>​    1．过滤器1</p>
<p>​    2．过滤器2</p>
<p>​    3．资源执行</p>
<p>​    4．过滤器2</p>
<p>​    5．过滤器1</p>
<p>过滤器先后顺序问题:</p>
<p>1．注解配置:按照类名的字符串比较规则比较，值小的先执行</p>
<p>​    Demo6大于Demo176大于1</p>
<p>​    Demo6大于Demo76小于7</p>
<p>*如:AFilter和BFilter,AFilter就先执行了。</p>
<p>\2. web.xml配置: <code>&lt;filter-mapping&gt;</code>谁定义在上边，谁先执行</p>
<p>增强对象的功能:</p>
<p>设计模式:一些通用的解决固定问题的方式</p>
<p>​    1．装饰模式</p>
<p>​    2．代理模式</p>
<p>概念:</p>
<p>​    1．真实对象:被代理的对象</p>
<p>​    2．代理对象:</p>
<p>​    3．代理模式:代理对象代理真实对象，达到增强真实对象功能的目的</p>
<p>实现方式:</p>
<p>​    1．静态代理:有一个类文件描述代理模式</p>
<p>​    2．动态代理:在内存中形成代理类</p>
<p>*实现步骤:</p>
<p>​    1．代理对象和真实对象实现相同的接口</p>
<p>​    2．代理对象= Proxy.newInstance();</p>
<p>​    3，使用代理对象调用方法。</p>
<p>​    4．增强方法</p>
<p>增强方式:</p>
<p>​    1．增强参数列表</p>
<p>​    2．增强返回值类型</p>
<p>​    3，增强方法体执行逻辑</p>
<h2 id="26-Listener-监听器"><a href="#26-Listener-监听器" class="headerlink" title="26.Listener :监听器"></a>26.Listener :监听器</h2><p>*概念: web的三大组件之一。</p>
<p>事件监听机制</p>
<p>​    事件:一件事情</p>
<p>​    事件源:事件发生的地方</p>
<p>​    监听器:一个对象</p>
<p>​    注册监听︰将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码</p>
<p>ServletContextListener:监听servletcontext对象的创建和销毁</p>
<p>方法:</p>
<p>​    void contextDestroyed(servletContextEvent sce) : servletContext对象被销毁之前会调用该方法</p>
<p>​    void contextInitialized(ServletContextEvent sce) : servletContext对象创建后会调用该方法</p>
<p>步骤︰</p>
<p>​    1.定义一个类，实现servletcontextListener接口</p>
<p>​    2.复写方法</p>
<p>​    3.配置</p>
<p>1.web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;cn.itcast.web.listener.contextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>
<p>*指定初始化参数<code>&lt;context-param&gt;</code></p>
<p>2.注解∶</p>
<p>@webListener</p>
<p>Query基础:</p>
<p>1.概念∶一个Javascript框架。简化js开发</p>
<p>​    JQuery是一个快速、简洁的Javascript框架，是继Prototype之后又一个优秀的Javascript代码库(或Javascript框架)。JQuery设计的宗旨是”Write Less，Do More””，即倡导写更少的代码，做更多的事情。它封装Javascript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>
<p>​    Javascript框架:本质上就是一些js文件，封装了js的原生代码而已</p>
<p>2.快速入门：</p>
<p>1.步骤</p>
<p>1.下载JQuery</p>
<p>目前jQuery有三个大版本：</p>
<p>​    1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，</p>
<p>​        最终版本：1.12.4 (2016年5月20日)</p>
<p>​    2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，</p>
<p>​        最终版本：2.2.4 (2016年5月20日)</p>
<p>​    3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。</p>
<p>​        目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p>
<p>jquery-xxx.js与jquery-xxx.min.js区别:</p>
<p>​    1.jquery-xxx.js :开发版本。给程序员看的，有良好的缩进和注释。体积大一些</p>
<p>​    2.jquery-xxx.min.js :生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</p>
<p>2.导入JQuery的js文件:导入min.js文件</p>
<p>3.使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let div1 = $(&quot;#div1&quot;);</span><br><span class="line">alert(div1.html());</span><br></pre></td></tr></table></figure>
<p>3.JQuery对象和js对象区别与转换</p>
<p>​    1.JQuery对象在操作时，更加方便。</p>
<p>​    2.JQuery对象和js对象方法不通用．</p>
<p>3．两者相互转换</p>
<p>​    jq — &gt; js : jq对象[索引]或者jq对象.get(索引)</p>
<p>​    js — &gt; jq : $(js对象)</p>
<p>4.选择器：筛选具有相似特征的元素(标签)</p>
<p>1.基本操作学习：</p>
<p>1.事件绑定</p>
<p>​    //1.获取b1按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#b1&quot;).click(function()&#123; </span><br><span class="line">	alert(&quot;abc&quot;); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<p>​    2.入口函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<p>window.onload 和 $(function) 区别</p>
<p>​         window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 </p>
<p>​         $(function)可以定义多次的。 </p>
<p>​    3.样式控制：css方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//$(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</span><br><span class="line">$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);</span><br></pre></td></tr></table></figure>
<p>2.分类</p>
<p>1.基本选择器</p>
<p>​    1.标签选择器（元素选择器）</p>
<p>​        * 语法： $(“html标签名”) 获得所有匹配标签名称的元素</p>
<p>​    2.id选择器</p>
<p>​        * 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</p>
<p>​    3.类选择器</p>
<p>​        * 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</p>
<p>​    4.并集选择器：</p>
<p>​        * 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</p>
<p>2.层级选择器</p>
<p>​    1.后代选择器</p>
<p>​        * 语法： $(“A B “) 选择A元素内部的所有B元素</p>
<p>​    2.子选择器</p>
<p>​        * 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</p>
<p>​    3.属性选择器</p>
<p>​        1.属性名称选择器</p>
<p>​        * 语法： $(“A[属性名]”) 包含指定属性的选择器</p>
<ol>
<li>属性选择器</li>
</ol>
<p>​    * 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</p>
<ol>
<li>复合属性选择器</li>
</ol>
<p>​    * 语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</p>
<ol>
<li>过滤选择器</li>
</ol>
<p>​    1. 首元素选择器</p>
<p>​        * 语法： :first 获得选择的元素中的第一个元素</p>
<ol>
<li>尾元素选择器</li>
</ol>
<p>​        * 语法： :last 获得选择的元素中的最后一个元素</p>
<p>​    3. 非元素选择器</p>
<p>​        * 语法： :not(selector) 不包括指定内容的元素</p>
<p>​    4. 偶数选择器</p>
<p>​        * 语法： :even 偶数，从 0 开始计数</p>
<p>​    5. 奇数选择器</p>
<p>​        * 语法： :odd 奇数，从 0 开始计数</p>
<p>​    6. 等于索引选择器</p>
<p>​        * 语法： :eq(index) 指定索引元素</p>
<p>​    7. 大于索引选择器</p>
<p>​        * 语法： :gt(index) 大于指定索引元素</p>
<p>​    8. 小于索引选择器</p>
<p>​        * 语法： :lt(index) 小于指定索引元素</p>
<p>​    9. 标题选择器</p>
<p>​        * 语法： :header 获得标题（h1~h6）元素，固定写法</p>
<ol>
<li>表单过滤选择器</li>
</ol>
<p>​    1. 可用元素选择器</p>
<p>​        * 语法： :enabled 获得可用元素</p>
<p>​    2. 不可用元素选择器</p>
<p>​        * 语法： :disabled 获得不可用元素</p>
<p>​    3. 选中选择器</p>
<p>​        * 语法： :checked 获得单选/复选框选中的元素</p>
<p>​    4. 选中选择器</p>
<p>​        * 语法： :selected 获得下拉框选中的元素</p>
<ol>
<li><p>DOM操作</p>
</li>
<li><p>内容操作</p>
</li>
</ol>
<p>​        1. html(): 获取/设置元素的标签体内容  <a><font>内容</font></a> —&gt; <font>内容</font></p>
<p>​        2. text(): 获取/设置元素的标签体纯文本内容  <a><font>内容</font></a> —&gt; 内容</p>
<p>​        3. val()： 获取/设置元素的value属性值</p>
<ol>
<li>属性操作</li>
</ol>
<p>​    1. 通用属性操作</p>
<p>​        1. attr(): 获取/设置元素的属性</p>
<p>​        2. removeAttr():删除属性</p>
<p>​        3. prop():获取/设置元素的属性</p>
<p>​        4. removeProp():删除属性</p>
<p>​        * attr和prop区别？</p>
<p>​            1. 如果操作的是元素的固有属性，则建议使用prop</p>
<p>​            2. 如果操作的是元素自定义的属性，则建议使用attr</p>
<p>​    2. 对class属性操作</p>
<p>​        1. addClass():添加class属性值</p>
<p>​        2. removeClass():删除class属性值</p>
<p>​        3. toggleClass():切换class属性切换样式</p>
<p>​            * toggleClass(“one”):</p>
<p>​            * 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加</p>
<ol>
<li>css():</li>
</ol>
<p>​    3. CRUD操作:</p>
<p>​    1. append():父元素将子元素追加到末尾</p>
<ul>
<li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li>
</ul>
<p>​    2. prepend():父元素将子元素追加到开头</p>
<ul>
<li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li>
</ul>
<ol>
<li>appendTo():</li>
</ol>
<ul>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li>
</ul>
<ol>
<li>prependTo()：</li>
</ol>
<ul>
<li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li>
</ul>
<ol>
<li>after():添加元素到元素后边</li>
</ol>
<ul>
<li>对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>before():添加元素到元素前边</li>
</ol>
<ul>
<li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>insertAfter()</li>
</ol>
<ul>
<li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>insertBefore()</li>
</ol>
<ul>
<li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>remove():移除元素</li>
</ol>
<ul>
<li>对象.remove():将对象删除掉</li>
</ul>
<ol>
<li>empty():清空元素的所有后代元素。</li>
</ol>
<ul>
<li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点里面的东西没了  标签还在</li>
</ul>
<h2 id="27-JQuery-高级"><a href="#27-JQuery-高级" class="headerlink" title="27.JQuery 高级"></a>27.JQuery 高级</h2><ol>
<li>动画</li>
</ol>
<p>​    1.三种方式显示和隐藏元素</p>
<p>​        1.默认显示和隐藏方式</p>
<p>​            1.show([speed],[easing],[fn]])</p>
<p>​                1.参数：</p>
<p>​                    1.speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</p>
<p>​                    2.easing：用来指定切换效果，默认是”swing”，可用参数”linear”</p>
<p>​                        *swing：动画执行时效果是 先慢，中间快，最后又慢</p>
<p>​                        *linear：动画执行时速度是匀速的</p>
<p>​                    3.fn：在动画完成时执行的函数，每个元素执行一次。</p>
<p>​            2.hide([speed],[easing],[fn]])</p>
<p>​            3.toggle([speed],[easing],[fn])</p>
<p>​    2.滑动显示和隐藏方式</p>
<p>​        1.slideDown([speed],[easing],[fn])</p>
<p>​        2.slideUp([speed],[easing],[fn]])</p>
<p>​        3.slideToggle([speed],[easing],[fn])</p>
<p>​    3.淡入淡出显示和隐藏方式</p>
<p>​        1.fadeIn([speed],[easing],[fn])</p>
<p>​        2.fadeOut([speed],[easing],[fn])</p>
<p>​        3.fadeToggle([speed],[easing],[fn]])</p>
<p>2.遍历</p>
<p>1.js的遍历方式</p>
<p>​    * for(初始化值;循环结束条件;步长)</p>
<p>2.jq的遍历方式</p>
<p>​    1.jq对象.each(callback)</p>
<p>​        1.语法：</p>
<p>​            jquery对象.each(function(index,element){});</p>
<p>​                * index:就是元素在集合中的索引</p>
<p>​                * element：就是集合中的每一个元素对象</p>
<p>​                * this：集合中的每一个元素对象</p>
<p>​        2.回调函数返回值：</p>
<p>​            * true:如果当前function返回为false，则结束循环(break)。</p>
<p>​            * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</p>
<p>​    2.$.each(object, [callback])</p>
<p>​    3.for..of: jquery 3.0 版本之后提供的方式</p>
<p>​            for(元素对象 of 容器对象)</p>
<p>​    3. 事件绑定</p>
<p>​        1. jquery标准的绑定方式</p>
<p>​            * jq对象.事件方法(回调函数)；</p>
<p>​            * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。</p>
<p>​                * 表单对象.submit();//让表单提交</p>
<p>​        2. on绑定事件/off解除绑定</p>
<p>​            * jq对象.on(“事件名称”,回调函数)</p>
<p>​            * jq对象.off(“事件名称”)</p>
<p>​                * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</p>
<p>​        3. 事件切换：toggle</p>
<p>​            * jq对象.toggle(fn1,fn2…)</p>
<p>​                * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..     </p>
<p>​            * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p>
<p>​                 </p>
<p>​    4. 插件：增强JQuery的功能</p>
<p>​        1. 实现方式：</p>
<p>​            1. $.fn.extend(object) </p>
<p>​                * 增强通过Jquery获取的对象的功能  $(“#id”)</p>
<p>​            2. $.extend(object)</p>
<p>​                * 增强JQeury对象自身的功能  $/jQuery</p>
<h2 id="28-AJAX"><a href="#28-AJAX" class="headerlink" title="28.AJAX"></a>28.AJAX</h2><p>​    1. 概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p>
<p>​        1. 异步和同步：客户端和服务器端相互通信的基础上</p>
<p>​            * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</p>
<p>​            * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p>
<p>​            Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] </p>
<p>​            通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>​            传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p>
<p>​            提升用户的体验</p>
<p>​    2. 实现方式：</p>
<p>\1. 原生的JS实现方式（了解）</p>
<p>\2. JQeury实现方式</p>
<p>​            1. $.ajax()</p>
<p>​                * 语法：$.ajax({键值对});</p>
<p>​                 //使用$.ajax()发送异步请求</p>
<p>​            2. $.get()：发送get请求</p>
<p>​                * 语法：$.get(url, [data], [callback], [type])</p>
<p>​                    * 参数：</p>
<p>​                        * url：请求路径</p>
<p>​                        * data：请求参数</p>
<p>​                        * callback：回调函数</p>
<p>​                        * type：响应结果的类型</p>
<p>​            3. $.post()：发送post请求</p>
<p>​                * 语法：$.post(url, [data], [callback], [type])</p>
<p>​                    * 参数：</p>
<p>​                        * url：请求路径</p>
<p>​                        * data：请求参数</p>
<p>​                        * callback：回调函数</p>
<p>​                        * type：响应结果的类型</p>
<h2 id="29-JSON"><a href="#29-JSON" class="headerlink" title="29.JSON"></a>29.JSON</h2><p>​    1. 概念： JavaScript Object Notation        JavaScript对象表示法</p>
<p>​        * json现在多用于存储和交换文本信息的语法</p>
<p>​        * 进行数据的传输</p>
<p>​        * JSON 比 XML 更小、更快，更易解析。</p>
<p>​    2. 语法：</p>
<p>​        1. 基本规则</p>
<p>​            * 数据在名称/值对中：json数据是由键值对构成的</p>
<p>​                * 键用引号(单双都行)引起来，也可以不使用引号</p>
<p>​                * 值得取值类型：</p>
<p>​                    1. 数字（整数或浮点数）</p>
<p>​                    2. 字符串（在双引号中）</p>
<p>​                    3. 逻辑值（true 或 false）</p>
<p>​                    4. 数组（在方括号中）    {“persons”:[{},{}]}</p>
<p>​                    5. 对象（在花括号中） {“address”:{“province”：”陕西”….}}</p>
<p>​                    6. null</p>
<p>​            * 数据由逗号分隔：多个键值对由逗号分隔</p>
<p>​            * 花括号保存对象：使用{}定义json 格式</p>
<p>​            * 方括号保存数组：[]</p>
<p>​        2. 获取数据:</p>
<p>​            1. json对象.键名</p>
<p>​            2. json对象[“键名”]</p>
<p>​            3. 数组对象[索引]</p>
<p>​            4. 遍历</p>
<p>​    3. JSON数据和Java对象的相互转换</p>
<p>​        * JSON解析器：</p>
<p>​            * 常见的解析器：Jsonlib，Gson，fastjson，jackson</p>
<p>​        1. JSON转为Java对象</p>
<p>​            1. 导入jackson的相关jar包</p>
<p>​            2. 创建Jackson核心对象 ObjectMapper</p>
<p>​            3. 调用ObjectMapper的相关方法进行转换</p>
<p>​                1. readValue(json字符串数据,Class)</p>
<p>​        2. Java对象转换JSON</p>
<p>​            1. 使用步骤：</p>
<p>​                1. 导入jackson的相关jar包</p>
<p>​                2. 创建Jackson核心对象 ObjectMapper</p>
<p>​                3. 调用ObjectMapper的相关方法进行转换</p>
<p>​                    1. 转换方法：</p>
<p>​                        * writeValue(参数1，obj):</p>
<p>​                            参数1：</p>
<p>​                                File：将obj对象转换为JSON字符串，并保存到指定的文件中</p>
<p>​                                Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</p>
<p>​                                OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</p>
<p>​                        * writeValueAsString(obj):将对象转为json字符串</p>
<p>​                    2. 注解：</p>
<p>​                        1. @JsonIgnore：排除属性。</p>
<p>​                        2. @JsonFormat：属性值得格式化</p>
<p>​                            * @JsonFormat(pattern = “yyyy-MM-dd”)</p>
<p>​                    3. 复杂java对象转换</p>
<p>​                        1. List：数组</p>
<p>​                        2. Map：对象格式一致</p>
<p>校验用户名是否存在</p>
<p>​        1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：</p>
<p>​            1. $.get(type):将最后一个参数type指定为”json”</p>
<p>​            2. 在服务器端设置MIME类型</p>
<p>​                response.setContentType(“application/json;charset=utf-8”);</p>
<h2 id="30-Redis"><a href="#30-Redis" class="headerlink" title="30.Redis"></a>30.Redis</h2><p>​    1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库</p>
<p>1.1.什么是NOSQL</p>
<p>​            NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>​            NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<p>​            1.1.1.    NOSQL和关系型数据库比较</p>
<p>​                优点：</p>
<p>​                    1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</p>
<p>​                    2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</p>
<p>​                    3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</p>
<p>​                    4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p>​                缺点：</p>
<p>​                    1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</p>
<p>​                    2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</p>
<p>​                    3）不提供关系型数据库对事务的处理。</p>
<p>​            1.1.2.    非关系型数据库的优势：</p>
<p>​                1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p>
<p>​                2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<p>​            1.1.3.    关系型数据库的优势：</p>
<p>​                1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
<p>​                2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<p>​            1.1.4.    总结</p>
<p>​                关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。</p>
<p>​                一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<p>​        1.2.主流的NOSQL产品</p>
<p>​            •    键值(Key-Value)存储数据库</p>
<p>​                    相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p>
<p>​                    典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </p>
<p>​                    数据模型： 一系列键值对</p>
<p>​                    优势： 快速查询</p>
<p>​                    劣势： 存储的数据缺少结构化</p>
<p>​            •    列存储数据库</p>
<p>​                    相关产品：Cassandra, HBase, Riak</p>
<p>​                    典型应用：分布式的文件系统</p>
<p>​                    数据模型：以列簇式存储，将同一列数据存在一起</p>
<p>​                    优势：查找速度快，可扩展性强，更容易进行分布式扩展</p>
<p>​                    劣势：功能相对局限</p>
<p>​            •    文档型数据库</p>
<p>​                    相关产品：CouchDB、MongoDB</p>
<p>​                    典型应用：Web应用（与Key-Value类似，Value是结构化的）</p>
<p>​                    数据模型： 一系列键值对</p>
<p>​                    优势：数据结构要求不严格</p>
<p>​                    劣势： 查询性能不高，而且缺乏统一的查询语法</p>
<p>​            •    图形(Graph)数据库</p>
<p>​                    相关数据库：Neo4J、InfoGrid、Infinite Graph</p>
<p>​                    典型应用：社交网络</p>
<p>​                    数据模型：图结构</p>
<p>​                    优势：利用图结构相关算法。</p>
<p>​                    劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<p>​        1.3 什么是Redis</p>
<p>​            Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<p>​                1) 字符串类型 string</p>
<p>​                2) 哈希类型 hash</p>
<p>​                3) 列表类型 list</p>
<p>​                4) 集合类型 set</p>
<p>​                5) 有序集合类型 sortedset</p>
<p>​            1.3.1 redis的应用场景</p>
<p>​                •    缓存（数据查询、短连接、新闻内容、商品内容等等）</p>
<p>​                •    聊天室的在线好友列表</p>
<p>​                •    任务队列。（秒杀、抢购、12306等等）</p>
<p>​                •    应用排行榜</p>
<p>​                •    网站访问统计</p>
<p>​                •    数据过期处理（可以精确到毫秒</p>
<p>​                •    分布式集群架构中的session分离</p>
<p>​    2. 下载安装</p>
<p>​        1. 官网：<a href="https://redis.io">https://redis.io</a></p>
<p>​        2. 中文网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a></p>
<p>​        3. 解压直接可以使用：</p>
<p>​            * redis.windows.conf：配置文件</p>
<p>​            * redis-cli.exe：redis的客户端</p>
<p>​            * redis-server.exe：redis服务器端</p>
<p>​    3. 命令操作</p>
<p>​        1. redis的数据结构：</p>
<p>​            * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p>
<p>​                * value的数据结构：</p>
<p>​                    1) 字符串类型 string</p>
<p>​                    2) 哈希类型 hash ： map格式  </p>
<p>​                    3) 列表类型 list ： linkedlist格式。支持重复元素</p>
<p>​                    4) 集合类型 set  ： 不允许重复元素</p>
<p>​                    5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p>
<p>​        2. 字符串类型 string</p>
<p>​            1. 存储： set key value</p>
<p>​                127.0.0.1:6379&gt; set username zhangsan</p>
<p>​                OK</p>
<p>​            2. 获取： get key</p>
<p>​                127.0.0.1:6379&gt; get username</p>
<p>​                “zhangsan”</p>
<p>​            3. 删除： del key</p>
<p>​                127.0.0.1:6379&gt; del age</p>
<p>​                (integer) 1</p>
<p>​        3. 哈希类型 hash</p>
<p>​            1. 存储： hset key field value</p>
<p>​                127.0.0.1:6379&gt; hset myhash username lisi</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; hset myhash password 123</p>
<p>​                (integer) 1</p>
<p>​            2. 获取： </p>
<p>​                * hget key field: 获取指定的field对应的值</p>
<p>​                    127.0.0.1:6379&gt; hgetall myhash</p>
<p>​                    1) “username”</p>
<p>​                    2) “lisi”</p>
<p>​                    3) “password”</p>
<p>​                    4) “123” </p>
<p>​            3. 删除： hdel key field</p>
<p>​                127.0.0.1:6379&gt; hdel myhash username</p>
<p>​                (integer) 1</p>
<p>​        4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>​            1. 添加：</p>
<p>​                1. lpush key value: 将元素加入列表左表</p>
<p>​                2. rpush key value：将元素加入列表右边</p>
<p>​                    127.0.0.1:6379&gt; lpush myList a</p>
<p>​                    (integer) 1</p>
<p>​                    127.0.0.1:6379&gt; lpush myList b</p>
<p>​                    (integer) 2</p>
<p>​                    127.0.0.1:6379&gt; rpush myList c</p>
<p>​                    (integer) 3</p>
<p>​            2. 获取：</p>
<p>​                * lrange key start end ：范围获取</p>
<p>​                    127.0.0.1:6379&gt; lrange myList 0 -1</p>
<p>​                    1) “b”</p>
<p>​                    2) “a”</p>
<p>​                    3) “c”</p>
<p>​            3. 删除：</p>
<p>​                * lpop key： 删除列表最左边的元素，并将元素返回</p>
<p>​                * rpop key： 删除列表最右边的元素，并将元素返回</p>
<p>​        5. 集合类型 set ： 不允许重复元素</p>
<p>​            1. 存储：sadd key value</p>
<p>​                127.0.0.1:6379&gt; sadd myset a</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; sadd myset a</p>
<p>​                (integer) 0</p>
<p>​            2. 获取：smembers key:获取set集合中所有元素</p>
<p>​                127.0.0.1:6379&gt; smembers myset</p>
<p>​                1) “a”</p>
<p>​            3. 删除：srem key value:删除set集合中的某个元素    </p>
<p>​                127.0.0.1:6379&gt; srem myset a</p>
<p>​                (integer) 1</p>
<p>​        6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>​            1. 存储：zadd key score value</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 60 zhangsan</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 50 lisi</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 80 wangwu</p>
<p>​                (integer) 1</p>
<p>​            2. 获取：zrange key start end [withscores]</p>
<p>​                127.0.0.1:6379&gt; zrange mysort 0 -1</p>
<p>​                1) “lisi”</p>
<p>​                2) “zhangsan”</p>
<p>​                3) “wangwu”</p>
<p>​                127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</p>
<p>​                1) “zhangsan”</p>
<p>​                2) “60”</p>
<p>​                3) “wangwu”</p>
<p>​                4) “80”</p>
<p>​                5) “lisi”</p>
<p>​                6) “500”</p>
<p>​            3. 删除：zrem key value</p>
<p>​                127.0.0.1:6379&gt; zrem mysort lisi</p>
<p>​                (integer) 1</p>
<p>​        7. 通用命令</p>
<p>​            1. keys * : 查询所有的键</p>
<p>​            2. type key ： 获取键对应的value的类型</p>
<p>​            3. del key：删除指定的key value</p>
<p>​    4. 持久化</p>
<p>​        1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p>
<p>​        2. redis持久化机制：</p>
<p>​            1. RDB：默认方式，不需要进行配置，默认就使用这种机制</p>
<p>​                * 在一定的间隔时间中，检测key的变化情况，然后持久化数据</p>
<p>​                1. 编辑redis.windwos.conf文件</p>
<p>​                    #   after 900 sec (15 min) if at least 1 key changed</p>
<p>​                    save 900 1</p>
<p>​                    #   after 300 sec (5 min) if at least 10 keys changed</p>
<p>​                    save 300 10</p>
<p>​                    #   after 60 sec if at least 10000 keys changed</p>
<p>​                    save 60 10000</p>
<p>​                    </p>
<p>​                2. 重新启动redis服务器，并指定配置文件名称</p>
<p>​                    D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf    </p>
<p>​                </p>
<p>​            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p>
<p>​                1. 编辑redis.windwos.conf文件</p>
<p>​                    appendonly no（关闭aof） —&gt; appendonly yes （开启aof）</p>
<p>​                    </p>
<p>​                    # appendfsync always ： 每一次操作都进行持久化</p>
<p>​                    appendfsync everysec ： 每隔一秒进行一次持久化</p>
<p>​                    # appendfsync no     ： 不进行持久化</p>
<h2 id="31-Java客户端-Jedis"><a href="#31-Java客户端-Jedis" class="headerlink" title="31.Java客户端 Jedis"></a>31.Java客户端 Jedis</h2><p>​        * Jedis: 一款java操作redis数据库的工具.</p>
<p>​        * 使用步骤：</p>
<p>​            1. 下载jedis的jar包</p>
<p>​            2. 使用</p>
<p>​                //1. 获取连接</p>
<p>​                Jedis jedis = new Jedis(“localhost”,6379);</p>
<p>​                   //2. 操作</p>
<p>​                   jedis.set(“username”,”zhangsan”);</p>
<p>​                //3. 关闭连接</p>
<p>​                jedis.close();</p>
<p>​        * Jedis操作各种redis中的数据结构</p>
<p>​            1) 字符串类型 string</p>
<p>​                set</p>
<p>​                get </p>
<p>​                  //可以使用setex()方法存储可以指定过期时间的 key value</p>
<p>​                jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</p>
<p>​            2) 哈希类型 hash ： map格式  </p>
<p>​                hset</p>
<p>​                hget</p>
<p>​                hgetAll</p>
<p>​               3) 列表类型 list ： linkedlist格式。支持重复元素</p>
<p>​                lpush / rpush</p>
<p>​                lpop / rpop</p>
<p>​                lrange start end : 范围获取</p>
<p>​    4) 集合类型 set  ： 不允许重复元素</p>
<p>​                sadd</p>
<p>​                smembers:获取所有元素</p>
<p>​            5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p>
<p>​                zadd</p>
<p>​                zrange</p>
<p>注意：使用redis缓存一些不经常发生变化的数据。</p>
<p>​            * 数据库的数据一旦发生改变，则需要更新缓存。</p>
<p>​            * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</p>
<p>​            * 在service对应的增删改方法中，将redis数据删除。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>若依实现操作日志</title>
    <url>//%E8%8B%A5%E4%BE%9D%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理完请求后执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;@annotation(controllerLog)&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Log controllerLog, Object jsonResult)</span> &#123;</span><br><span class="line">    handleLog(joinPoint, controllerLog, <span class="literal">null</span>, jsonResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@annotation</code> 是 Spring AOP 中用于匹配带有特定注解的方法的切入点表达式。它允许你指定一个注解类型作为切入点的一部分，并且只有带有指定注解的方法才会被拦截。</p>
<p>在切入点表达式中，<code>@annotation(annotationType)</code> 使用了 <code>@annotation</code> 通配符，后面跟着括号和注解类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.Log)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointcut</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个切入点表达式匹配了所有被 <code>@Log</code> 注解标记的方法，因为它使用了 <code>@annotation</code> 通配符，后面指定了 <code>com.example.Log</code> 这个注解类型。这样，在切面中的通知方法就可以拦截到带有 <code>@Log</code> 注解的方法了。</p>
</blockquote>
]]></content>
      <categories>
        <category>java后端</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
