<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaWeb | 普通LのBlog</title><meta name="keywords" content="JavaWeb"><meta name="author" content="刘晗宇"><meta name="copyright" content="刘晗宇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaWeb1.Junit使用:白盒测试*步骤: 1．定义一个测试类(测试用例) *建议∶ ​    测试类名∶被测试的类名TestCalculatorTest ​    包名:xxx.xxx.xx.testcn.itcast.test 2．定义测试方法:可以独立运行 建议∶ ​    *方法名: test测试的方法名testAdd() ​    *返回值: void ​    *参数列表:空参">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaWeb">
<meta property="og:url" content="http://putongl.github.io/JavaWeb.html">
<meta property="og:site_name" content="普通LのBlog">
<meta property="og:description" content="JavaWeb1.Junit使用:白盒测试*步骤: 1．定义一个测试类(测试用例) *建议∶ ​    测试类名∶被测试的类名TestCalculatorTest ​    包名:xxx.xxx.xx.testcn.itcast.test 2．定义测试方法:可以独立运行 建议∶ ​    *方法名: test测试的方法名testAdd() ​    *返回值: void ​    *参数列表:空参">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://putongl.github.io/img/bizhi2.jpg">
<meta property="article:published_time" content="2023-10-18T08:20:25.322Z">
<meta property="article:modified_time" content="2024-01-26T12:01:40.032Z">
<meta property="article:author" content="刘晗宇">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://putongl.github.io/img/bizhi2.jpg"><link rel="shortcut icon" href="/img/top.jpg"><link rel="canonical" href="http://putongl.github.io/JavaWeb"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-26 20:01:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xxx.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/biaoqian.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/ziti.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="普通LのBlog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="https://music.163.com/#"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.cz01.vip/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.douyin.com/"><i class="fa-fw fas fa-anchor"></i><span> 抖音</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://www.yinghuavideo.com/"><i class="fa-fw fas fa-gamepad"></i><span> 动漫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-folder-open"></i><span> B站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bizhi2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">普通LのBlog</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="https://music.163.com/#"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.cz01.vip/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.douyin.com/"><i class="fa-fw fas fa-anchor"></i><span> 抖音</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://www.yinghuavideo.com/"><i class="fa-fw fas fa-gamepad"></i><span> 动漫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-folder-open"></i><span> B站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> </span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaWeb</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-18T08:20:25.322Z" title="发表于 2023-10-18 16:20:25">2023-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-26T12:01:40.032Z" title="更新于 2024-01-26 20:01:40">2024-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/bizhi2.jpg');"></div><article class="post-content" id="article-container"><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-Junit使用-白盒测试"><a href="#1-Junit使用-白盒测试" class="headerlink" title="1.Junit使用:白盒测试"></a>1.Junit使用:白盒测试</h2><p>*步骤:</p>
<p>1．定义一个测试类(测试用例)</p>
<p>*建议∶</p>
<p>​    测试类名∶被测试的类名TestCalculatorTest</p>
<p>​    包名:xxx.xxx.xx.testcn.itcast.test</p>
<p>2．定义测试方法:可以独立运行</p>
<p>建议∶</p>
<p>​    *方法名: test测试的方法名testAdd()</p>
<p>​    *返回值: void</p>
<p>​    *参数列表:空参</p>
<p>3．给方法加@Test 独立运行 导包</p>
<p>4．导入junit依赖环境</p>
<p>​    *判定结果︰红色∶失败绿色∶成功</p>
<p>​    *—股我们会使用断言操作来处理结果</p>
<p>​    *Assert.assertEquals(期望的结果,运算的结果);</p>
<p>补充∶</p>
<p>​    @Before:修饰的方法会在测试方法之前被自动执行</p>
<p>​    @After:修饰的方法会在测试方法执行之后自动被执行。</p>
<h2 id="2-反射-框架设计的灵魂"><a href="#2-反射-框架设计的灵魂" class="headerlink" title="2.反射:框架设计的灵魂"></a>2.反射:框架设计的灵魂</h2><p>框架:半成品软件。可以在框架的基础上进行软件开发，简化编码</p>
<p>反射:将类的各个组成部分封装为其他对象，这就是反射机制</p>
<p>*好处:</p>
<p>​    1.可以在程序运行过程中，操作这些对象。</p>
<p>​    2.可以解耦,提高程序的可扩展性。</p>
<p>*获取class对象的方式:</p>
<p>​    1.Class.forName(“全类名”)∶将字节码文件加载进内存，返回class对象 全类名：包名.类名</p>
<p>​    *多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p>
<p>2.类名.class :通过类名的属性class获取</p>
<p>​    *多用于参数的传递</p>
<p>3，对象.getclass( : getclass()方法在object类中定义着。</p>
<p>​    *多用于对象的获取字节码的方式</p>
<p>​    结论:同一个字节码文件(* .class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。</p>
<p>class对象功能:</p>
<p>​    获取功能:</p>
<p>​        1,获取成员变量们</p>
<p>​        2,获取构造方法们</p>
<p>​        3,获取成员方法们</p>
<p>​        4.获取类名</p>
<p>Field:成员变量</p>
<p>操作:</p>
<p>​    1。设置值</p>
<p>​        void set(object obj, object value)</p>
<p>​    2．获取值</p>
<p>​        get(object obj)</p>
<p>​    3，忽略访问权限修饰符的安全检查</p>
<p>​        setAccessible(true):暴力反射</p>
<p>​        constructor:构造方法</p>
<p>​    创建对象∶</p>
<p>​        newInstance(object… initargs)</p>
<p>​    如果使用空参数构造方法创建对象，操作可以简化 : class对象的newInstance方法</p>
<h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h2><p>说明程序的，给计算机看的</p>
<p>作用分类:</p>
<p>​    编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</p>
<p>​    代码分析:通过代码里标识的注解对代码进行分析【使用反射】</p>
<p>​    编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】</p>
<p>(1).JDK中预定义的一些注解</p>
<p>​    @override:检测被该注解标注的方法是否是继承自父类(接口)的</p>
<p>​    @Deprecated :该注解标注的内容，表示已过时</p>
<p>​    @suppresswarnings :压制警告</p>
<p>​        —般传递参数all @suppresswarnings(“all”)</p>
<p>(2).自定义注解</p>
<p>格式∶</p>
<p>元注解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称{</span><br><span class="line"></span><br><span class="line">	属性列表;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本质:注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation {}</p>
<p>属性:接口中的抽象方法</p>
<p>要求∶</p>
<p>1．属性的返回值类型有下列取值</p>
<p>​    基本数据类型</p>
<p>​    String</p>
<p>​    枚举注解</p>
<p>​    以上类型的数组</p>
<p>2．定义了属性，在使用时需要给属性赋值</p>
<p>​    1，如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</p>
<p>​    2．如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</p>
<p>​    3．数组赋值时，值使用{ }包裹。如果数组中只有一个值，则省略</p>
<p>元注解:用于描述注解的注解</p>
<p>​    @Target :描述注解能够作用的位置</p>
<p>ElementType取值:</p>
<p>​    TYPE:可以作用于类上</p>
<p>​    METHOD:可以作用于方法上</p>
<p>​    FIELD:可以作用于成员变量上</p>
<p>@Retention:描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)︰当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</p>
<p>@Documented:描述注解是否被抽取到api文档中</p>
<p>@Inherited:描述注解是否被子类继承</p>
<p>(3).在程序使用(解析)注解:获取注解中定义的属性值</p>
<p>​    1，获取注解定义的位置的对象(class,Method,Field)</p>
<p>​    2．获取指定的注解</p>
<p>​        *getAnnotation(class)</p>
<p>​        //其实就是在内存中生成了一个该注解接口的子类实现对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProImpl</span> <span class="keyword">implements</span> <span class="title class_">Pro</span>{</span><br><span class="line">	<span class="keyword">public</span> string <span class="title function_">className</span><span class="params">(()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"cn.itcast.annotation.Demo1"</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">methodName</span><span class="params">({</span></span><br><span class="line"><span class="params">        return <span class="string">"show"</span>;</span></span><br><span class="line"><span class="params">    }</span></span><br><span class="line"><span class="params">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>​    3．调用注解中的抽象方法获取配置的属性值</p>
<h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h2><p>（1）数据库的基本概念</p>
<p>1，数据库的英文单词:DataBase简称: DB</p>
<p>2．什么数据库?</p>
<p>​    用于存储和管理数据的仓库。</p>
<p>3．数据库的特点:</p>
<p>​    1．持久化存储数据的。其实数据库就是一个文件系统</p>
<p>​    2．方便存储和管理数据</p>
<p>​    3．使用了统一的方式操作数据库— SQL</p>
<p>（2）MysQL服务启动</p>
<p>​    1. 手动。</p>
<p>​    2. cmd—&gt; services.msc打开服务的窗口</p>
<p>​    3. 使用管理员打开cmd</p>
<p>​        net start mysql :启动mysql的服务</p>
<p>​        net stop mysql:关闭mysql服务</p>
<p>MysQL登录</p>
<p>​    1.mysql -uroot -p密码</p>
<p>​    2.mysql -h IP地址 -uroot -p连接目标的密码</p>
<p>​    3.mysql —host=IP地址 —user=root —password=连接目标的密码</p>
<p>MysQL退出</p>
<p>​    1.exit</p>
<p>​    2.quit</p>
<p>Structured Query Language :结构化查询语言</p>
<p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”</p>
<p>（3）SQL通用语法</p>
<p>1.SQL语句可以单行或多行书写，以分号结尾。</p>
<p>2可使用空格和缩进来增强语句的可读性。</p>
<p>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p>
<ol>
<li>3种注释</li>
</ol>
<p><em>单行注释: — 注释内容 或 # 注释内容 (mysql特有)</em></p>
<p>多行注释:/<em> 注释 </em>/</p>
<p>（4）SQL分类</p>
<p>1.DDL(Data Definition Language)数据定义语言</p>
<p>​    用来定义数据库对象:数据库，表，列等。关键字: create，drop,alter等</p>
<p>2.DML(Data Manipulation Language)数据操作语言</p>
<p>​    用来对数据库中表的数据进行增删改。关键字:insert，delete，update等</p>
<p>3.DQL(Data Query Language)数据查询语言</p>
<p>​    用来查询数据库中表的记录(敬据)。关键字: select，where 等</p>
<p>4.DCL(Data control Language)数据控制语言(了解)</p>
<p>​    用来定义数据库的访问权限和安全级别，及创建用户。关键字:GRANT,REVOKE等</p>
<ul>
<li>DDL:操作数据库、表</li>
</ul>
<p>1．操作数据库:CRUD</p>
<p>1.1 C(Create):创建</p>
<p>创建数据库:</p>
<p>​    create database 数据库名称;</p>
<p>创建数据库，判断不存在，再创建:</p>
<p>​    create database if not exists数据库名称;</p>
<p>创建数据库，并指定字符集</p>
<p>​    create database数据库名称character set字符集名;</p>
<p>练习:创建db4数据库，判断是否存在，并制定字符集为gbk</p>
<p>​    create database if not exists db4 character set gbk;</p>
<p>2．R(Retrieve):查询</p>
<p>查询所有数据库的名称:</p>
<p>​    show databases;</p>
<p>查询某个数据库的字符集:查询某个数据库的创建语句</p>
<p>​    show create database 数据库名称;</p>
<ol>
<li>U(Update):修改</li>
</ol>
<p>修改数据库的字符集</p>
<p>​    alter database 数据库名称 character set字符集名称;</p>
<ol>
<li>D(Delete):删除</li>
</ol>
<p>删除数据库</p>
<p>​    drop database数据库名称;</p>
<p>判断数据库存在，存在再删除</p>
<p>​    drop database if exists 数据库名称;</p>
<p>5．使用数据库</p>
<p>查询当前正在使用的数据库名称</p>
<p>​    select database();</p>
<p>使用数据库</p>
<p>​    use 数据库名称;</p>
<p>2．操作表</p>
<p>1.c(create):创建</p>
<p>1.1.语法:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">	列名1数据类型1,</span><br><span class="line">	列名2数据类型2，</span><br><span class="line">	....</span><br><span class="line">	列名n数据类型n</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>注意∶最后一列，不需要加逗号(,)</p>
<p>*数据库类型:</p>
<p>1.int :整数类型</p>
<p>age int,</p>
<ol>
<li>double:小数类型</li>
</ol>
<p>​    score double(5,2)</p>
<ol>
<li><p>date:日期，只包含年月日, yyyy-MM-dd</p>
</li>
<li><p>datetime :日期，包含年月日时分秒yyyy-Mm-dd HH: mm : ss</p>
</li>
<li><p>timestamp:时间错类型 包含年月日时分秒yyyy-Mm-ddHH: mm: ss</p>
</li>
</ol>
<p>​        如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</p>
<ol>
<li>varchar:字符串</li>
</ol>
<p>name varchar(20):姓名最大20个字符</p>
<p>zhangsan 8个字符，张三2个字符</p>
<p>*创建表</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>( <span class="number">32</span>),</span><br><span class="line">	age <span class="type">int</span> ,</span><br><span class="line">	score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">	birthday <span class="type">date</span>,</span><br><span class="line">	insert_time <span class="type">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>*复制表:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 like 被复制的表名;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>R(Retrieve):查询</li>
</ol>
<p>查询某个教据库中所有的表名称</p>
<p>​    show tables;</p>
<p>查询表结构</p>
<p>​    desc 表名;</p>
<ol>
<li>U(Update):修改</li>
</ol>
<p>3.1.修改表名</p>
<p>​    alter table 表名 rename to 新的表名;</p>
<p>3.2．修改表的字符集</p>
<p>​    alter table 表名 character set 字符集名称;</p>
<p>3.3．添加一列</p>
<p>​    alter tabie 表名 add 列名 数据类型;</p>
<p>3.4、修改列名称类型</p>
<p>​    alter table 表名 change 列名 新列名 新数据类型;</p>
<p>只改类型</p>
<p>​    alter table 表名 modify 列名 新数据类型;</p>
<p>3.5，删除列</p>
<p>​    alter tabie 表名 drop 列名;</p>
<p>DML:增制改表中数据</p>
<p>1．添加数据∶</p>
<p>语法︰</p>
<p>​    insert into 表名(列名1,列名2,…列名n) values(值1,值2,. ..值n);</p>
<p>*注意:</p>
<p>1.1.列名和值要一一对应。</p>
<p>1.2.如果表名后，不定义列名，则默认给所有列添加值</p>
<p>​    insert into 表名 values(值1,值2,…值n);</p>
<p>1.3．除了数字类型，其他类型需要使用引号(单双都可以)引起来</p>
<p>2．删除数据:|</p>
<p>语法∶[ ] 意思是可选可不选</p>
<p>​    delete from 表名 [where 条件];</p>
<p>*注意︰</p>
<p>​    1.如果不加冬件，则删除表中所有记录。</p>
<p>​    2.如果要删除所有记录</p>
<p>​        1.delete from 表名; —不推荐使用。有多少条记录就会执行多少次删除操作</p>
<p>​        2.TRUNCATE truncate table TABLE 表名; —推荐使用，效率更高先删除表，然后再创建一张一样的表。</p>
<p>​    3．修改数据︰</p>
<p>​        语法:</p>
<p>​        update 表名 set 列名1 =值1，列名2=值2,… [where条件];</p>
<p>​        *注意∶</p>
<p>​            1、如果不加任何条件，则会将表中所有记录全部修改。</p>
<ul>
<li>DQL:查询表中的记录</li>
</ul>
<p>select * from表名;</p>
<p>1．语法︰</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by</span><br><span class="line">分组字段</span><br><span class="line">having</span><br><span class="line">分组之后的条件</span><br><span class="line">order by </span><br><span class="line">排序</span><br><span class="line">limit</span><br><span class="line">分页限定</span><br></pre></td></tr></tbody></table></figure>
<p>2．基础查询</p>
<p>1，多个字段的查询</p>
<p>select 字段名1，字段名2… from表名;</p>
<p>*注意:</p>
<p>​    如果查询所有字段，则可以使用来替代字段列表。</p>
<p>2．去除重复:</p>
<p>​    distinct</p>
<p>3，计算列</p>
<p>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</p>
<p> ifnull(表达式1,表达式2) : null参与的运算，计算结果都为null</p>
<p>​    *表达式1:哪个字段需要判断是否为null</p>
<p>​    *表达式2:如果该字段为null后的替换值。</p>
<p>4．起别名︰</p>
<p>​    as : as也可以省咯</p>
<p>3．条件查询</p>
<p>​    3.1.where子句后跟条件</p>
<p>​    3.2．运算符 &gt;、&lt; 、 &lt;= 、 &gt;= 、= 、&lt;&gt;不等于</p>
<p>BETWEEN. ..AND</p>
<p>IN(集合)</p>
<p>LIKE模糊查询</p>
<p>占位符∶</p>
<p>_ 单个任意字符</p>
<p>% 多个任意字符</p>
<p>IS NULL</p>
<p>and或&amp;&amp;且</p>
<p>or 或 ||或</p>
<p>not 或 ！ </p>
<p>4.排序查询</p>
<p>*语法: order by 子句</p>
<p>order by 排序字段1 排序方式1 ，排序字段2 排序方式2.. .</p>
<p>*排序方式:</p>
<p>*ASC asc:升序，默认的。</p>
<p>*DESC desc:降序。</p>
<p>*注意︰</p>
<p>*如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p>
<p>2．聚合函数:将一列数据作为一个整体，进行纵向的计算。</p>
<p>count :计算个数</p>
<p> 1.一般选择非空的列:主键</p>
<p>  2.count(*) as total 设置列名为total计算个数与</p>
<p>max :计算最大值</p>
<p>min :计算最小值</p>
<p>sum :计算和</p>
<p>avg :计算平均值</p>
<p>*注意:聚合函数的计算，排除null值。</p>
<p>解决方案:</p>
<p>1.选择不包含非空的列进行计算</p>
<p>2.IF NULL if null函数</p>
<p>3.分组查询:</p>
<p>​    1.语法:group by 分组字段;</p>
<p>​    2．注意:</p>
<p>​        1.分组之后查询的字段:分组字段、聚合函数</p>
<p>​        2.where和having 的区别?</p>
<p>​            1.where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</p>
<p>​            2.where后不可以跟聚合函数，having可以进行聚合函数的判断。</p>
<p>4、分页查询</p>
<p>​    1．语法:limit开始的索引,每页查询的条数;</p>
<p>​    2．公式:开始的索引=(当前的页码-1)*每页显示的条数</p>
<p>—每页显示3条记录</p>
<p>SELECT *FROM student LIMIT 0,3;—第1页</p>
<p>SELECT * FROM student LIMIT 3,3; —第2页</p>
<p>SELECT * FROM student LIMIT 6,3; —第3页</p>
<p>3.limit是一个MySQL”方言”</p>
<p>约束</p>
<p>*概念:对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p>本分类:</p>
<p>1．主键约束:primary key</p>
<p>2．非空约束:not null</p>
<p>3．唯一约束: unique</p>
<p>4．外键约束:foreign key</p>
<p>*非空约束:not null某一列的值不能为null</p>
<p>1.创建表时添加约束</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	NAME VARCHAR( 20) NOT NULL -- name为非空</span><br><span class="line">	name varchar(20) not null</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>2．创建表完后，添加非空约束</p>
<p>​    ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</p>
<p>​    alter table stu modify name varchar(20) not null</p>
<p>3.删除name的非空约束</p>
<p>​    ALTER TABLE stu MODIFY NAME VARCHAR( 20);</p>
<p>​    *唯一约束:unique，某一列的值不能重复</p>
<p>1．注意:</p>
<p>唯一约束可以有NULL值，但是只能有一条记录为null</p>
<p>2．在创建表时，添加唯一约束</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	phone_number VARCHAR(20) UNIQUE --手机号</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>3.删除唯一约束</p>
<p>​    ALTER TABLE stu DROP INDEX phone_number;</p>
<p>4．在表创建完后，添加唯一约束</p>
<p>​    ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</p>
<p>主键约束: primary key。</p>
<p>1.注意∶</p>
<p>​    1.含义:非空且唯一</p>
<p>​    2.一张表只能有一个字段为主键</p>
<p>​    3.主键就是表中记录的唯一标识</p>
<p>2.在创建表时，添加主键约束</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key ,--给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>3．删除主键</p>
<p>​    错误alter table stu modify id int ;</p>
<p>​    ALTER TABLE stu DROP PRIMARY KEY;  drop primary</p>
<p>4．创建完表后,添加主键</p>
<p>​    ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p>
<p>5，自动增长:</p>
<p>​    1.概念∶如桌某一列是数值类型的，使用auto_increment可以来完成值得自动增长</p>
<p>​    2．在创建表时，添加主键约束，并且完成主键自增长</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key auto_increment,--给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>3．删除自动增长</p>
<p>​    ALTER TABLE stu MODIFY id INT;</p>
<p>4．添加自动增长</p>
<p>​    ALTER TABLE stu MODIFY id INT AUTO_INCRENENT;</p>
<p>*外键约束:foreign key,让表于表产生关系，从而保证数据的准确性。</p>
<p>1．在创建表时，可以添加外键</p>
<p>*语法∶</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">	.....</span><br><span class="line">	外键列,</span><br><span class="line">	constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>2．删除外键</p>
<p>​    ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; foreign key</p>
<p>3，创建表之后，添加外键</p>
<p>​    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称 (主表列名称);</p>
<p>​    alter table 表名 ADD constraint 外键名称 foreign key references主表名称 (主表列名称);</p>
<p>4.级联操作</p>
<p>1。添加级联操作</p>
<p>语法:ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p>
<p>FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</p>
<p>foreign key (外键字段名称) references 主表名称 (主表列名称) on update cascade on delete cascade</p>
<p>2．分类:</p>
<p>1．级联更新:ON UPDATE CASCADE</p>
<p>2．级联删除:ON DELETE CASCADE </p>
<p>数据库的设计</p>
<p>1.多表之间的关系</p>
<p>1.分类:</p>
<p>1.一对一(了解)∶</p>
<p>​    *如∶人和身份证</p>
<p>​    *分析:—个人只有一个身份证，一个身份证只能对应一个人</p>
<p>2.一对多(多对一）:</p>
<p>​    *如∶部门和员工</p>
<p>​    *分析:—个部门有多个员工，一个员工只能对应一个部门</p>
<p>3．多对多∶</p>
<p>​    *如:学生和课程</p>
<p>​    *分析:—个学生可以选择很多门课程，一个课程也可以被很多学生选择</p>
<p>2．实现关系∶</p>
<p>​    1.一对多(多对一) :</p>
<p>​        *如∶部门和员工</p>
<p>​        *实现方式:在多的一方建立外键，指向一的一方的主键。</p>
<p>2，多对多∶</p>
<p>​    *如:学生和课程</p>
<p>​    实现方式∶多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</p>
<p>3.一对一(了解)∶</p>
<p>​    *如:人和身份证</p>
<p>​    *实现方式:一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</p>
<p>2．数据库设计的范式</p>
<p>​    *概念∶设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p>
<p>​    设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p>​    目前关系数据库有六种范式∶第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。</p>
<p>*分类:</p>
<p>​    1，第一范式(1NF):每一列都是不可分割的原子数据项</p>
<p>​    2．第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖)</p>
<p>*几个概念:</p>
<p>​    1，函数依赖∶A—&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</p>
<p>​        例如:学号—&gt;姓名。(学号，课程名称)—&gt;分数</p>
<p>​    2．完全函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。例如:(学号，课程名称)—&gt;分数</p>
<p>​    3，部分函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。例如:(学号，课程名称)—&gt;姓名</p>
<p>​    4，传递函数依赖∶A—&gt;8,B — &gt;c，如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组)的值可以确定唯一C属性的值，则称C传递函数依赖于A</p>
<p>​        例如:学号—&gt;系名，系名—&gt;系主任</p>
<p>​    5，码;如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</p>
<p>​        例如:该表中码为︰(学号，课程名称)可以确定唯一的其他属性</p>
<p>*主属性:码属性组中的所有属性</p>
<p>*非主属性:除过码属性组的属性</p>
<p>3．第三范式(3NF)︰在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖)</p>
<p>数据库的备份和还原</p>
<p>1，命令行:</p>
<p>*语法∶</p>
<p>​    备份: mysqldump -u用户名 -p密码 数据库的名称 &gt; 保存的路径</p>
<p>还原:</p>
<p>​    1．登录数据库</p>
<p>​    2．创建数据库</p>
<p>​    3．使用数据库</p>
<p>​    4。执行文件。source 文件路径</p>
<p>2．图形化工具︰</p>
<p>多表查询∶</p>
<p>查询语法∶</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">列名列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where.. .. 条件</span><br></pre></td></tr></tbody></table></figure>
<p>笛卡尔积∶</p>
<p>*有两个集合A,B .取这两个集合的所有组成情况。</p>
<p>*要完成多表查询，需要消除无用的数据</p>
<p>*多表查询的分类:</p>
<p>1.内连接查询:</p>
<p>1.隐式内连接:使用where条件消除无用数据</p>
<p>​    SELECT * FROM emp,dept WHERE emp. “ dept_id= dept. id ;</p>
<p>2．显式内连接:</p>
<p>​    语法: select 字段列表 from 表名1 [inner] join 表名2 on 条件</p>
<p>例如︰</p>
<p>SELECT * FROM emp INNER JOIN dept ON emp. dept_id = dept. id ;</p>
<p>SELECT * FROM emp JOIN dept ON emp. “ dept_id’= dept.’ id’;</p>
<p>3．内连接查询∶</p>
<p>​    1.从哪些表中查询数据</p>
<p>​    2.条件是什么</p>
<p>​    3.查询哪些字段</p>
<p>2.外链接查询:</p>
<p>1．左外连接:</p>
<p>​    *语法: select 字段列表 from 表1 left [outer] join 表2 on 条件;</p>
<p>​    *查询的是左表所有数据以及其交集部分。</p>
<p>2．右外连接:</p>
<p>​    语法: select 字段列表 from表1 right [outer] join 表2 on 条件;</p>
<p>​    *查询的是右表所有数据以及其交集部分。</p>
<p>3.子查询:</p>
<p>​    概念∶查询中嵌套查询，称嵌套查询为子查询。</p>
<p>​        —查询工资最高的员工信息</p>
<p>​        — 1查询最高的工资是多少 9000</p>
<p>​            SELECT MAX( salary) FROM emp;</p>
<p>​        —2查询员工信息，并且工资等于9008的</p>
<p>​            SELECT * FROM emp WHERE emp.”salary”= 9000;</p>
<p>​        —一条sql就完成这个操作。子查询</p>
<p>​            SELECT * FROM emp WHERE emp.’salary’ = (SELECT MAX( salary) FROM emp);</p>
<p>*子查询不同情况</p>
<p>1，子查询的结果是单行单列的∶</p>
<p>​    子查询可以作为条件，使用运算符去判断。运算符∶ &gt; &gt;= &lt; &lt;= =</p>
<p>​    —查询员工工资小于平均工资的人</p>
<p>​    SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</p>
<p>2．子查询的结果是多行单列的∶</p>
<p>​    子查询可以作为条件，使用运算符in来判断</p>
<p>​    —查询”财务部和’市场部”所有的员工信息</p>
<p>​    SELECT id FROM dept WHERE NAME =‘财务部’OR NAME = ‘巿场部”;</p>
<p>​    SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</p>
<p>—子查询</p>
<p>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept MHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</p>
<p>3，子查询的结果是多行多列的:</p>
<p>*子查询可以作为—张虚拟表参与查询</p>
<p>—查询员工入职日期是?2011-11-11日之后的员工信息和部门信息</p>
<p>—子查询</p>
<p>​    SELECT <em> FROM dept t1 ,(SELECT </em> FROM emp WHERE emp. join_date &gt; ‘2011-11-11’) t2 WHERE t1.id = t2.dept_id;</p>
<p>—普通内连接</p>
<p>​    SELECT FROM emp t1,dept t2 WHERE t1.’ dept_id’ = t2. id’ AND t1.” join_date’&gt; ‘2011-11-11’</p>
<p>事务</p>
<p>1，事务的基本介绍</p>
<p>​    1.概念∶</p>
<p>​        *如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p>
<p>​    2．操作:</p>
<p>​        1.开启事务:start transaction;</p>
<p>​        2.回滚:rollback;</p>
<p>​        3.提交:commit;</p>
<p>MysQL数据库中事务默认自动提交</p>
<p>*事务提交的两种方式:</p>
<p>自动提交∶</p>
<p>​    *mysql就是自动提交的</p>
<p>​    *一条DML(增删改语句会自动提交一次事务。</p>
<p>手动提交:</p>
<p>​    oracle数据库默认是手动提交事务需要先开后事务，再提交</p>
<p>*修改事务的默认提交方式∶</p>
<p>​    查看事务的默认提交方式:SELECT @autocommit; — 1代表自动提交0代表手动提交</p>
<p>​    修改默认提交方式:set @@autocommit = 0;</p>
<p>2．事务的四大特征:</p>
<p>​    1．原子性:是不可分割的最小操作单位，要么同时成功，要么同时失败。</p>
<p>​    2，持久性:当事务提交或回液后，数据库会持久化的保存数据。</p>
<p>​    3，隔离性:多个事务之间。相互独立。</p>
<p>​    4，一致性:事务操作前后，数据总量不变</p>
<p>3.事务的隔离级别(了解)</p>
<p>​    *概念∶多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题.</p>
<p>*存在问题:</p>
<p>​    1．脏读:一个事务，读取到另一个事务中没有提交的数据</p>
<p>​    2．不可重复读(虚读):在同一个事务中，两次读取到的数据不一样。</p>
<p>​    3．幻读:一个事务操作(DNL)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p>
<p>*隔离级别∶</p>
<p>​    1.read uncommitted : 读未提交</p>
<p>​        产生的问题:脏读、不可重复读．幻读</p>
<p>​    2.read committed :读已提交(oracle)</p>
<p>​        产生的问题:不可重复读、幻读</p>
<p>​    3.repeatable read:可重复读(rysQL默认)</p>
<p>​        产生的问题:幻读</p>
<p>​    4.serializable :串行化</p>
<p>​        可以解决所有的问题</p>
<p>注意:隔离级别从小到大安全性越来越高，但是效率越来越低</p>
<p>数据库查询隔离级别:</p>
<p>​    l select @atx_isolation;</p>
<p>​    l sellect @@transaction_isolation;</p>
<p>*数据库设置隔离级别:</p>
<p>​    l set global transaction isolation level 级别字符串;</p>
<p>DCL :</p>
<p>*SQL分类:</p>
<p>​    1.DDL:操作数据库和表</p>
<p>​    2.DML:增删改表中数据</p>
<p>​    3.DQL:查询表中数据</p>
<p>​    4.DCL:管理用户，授权</p>
<p>l DBA:数据库管理员</p>
<p>DCL:管理用户，授权</p>
<p>1．管理用户</p>
<p>​    1．添加用户:</p>
<p>​        *语法:CREATE USER ‘用户名”@’主机名’ IDENTIFIED identified BY ‘密码’;</p>
<p>​    2．删除用户:</p>
<p>​        *语法- DROP USER ‘用户名’@”主机名’;</p>
<p>​    3．修改用户密码:</p>
<p>​        UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’;</p>
<p>​        UPDATE USER SET PASSWORD = PASSWORD( ‘ abc ‘ ) WHERE USER = ‘lisi’;</p>
<p>​        SET PASSWORD FOR “用户名’@”主机名’= PASSWORD(“新密码”);</p>
<p>​        SET PASSWORD FOR “root’@’ localhost’ = PASSWORD( “123”);</p>
<p>mysq1中忘记了root用户的密码?</p>
<p>​    1.cmd — &gt;net stop mysql停止mysql服务</p>
<p>​        本需要管理员运行该cmd</p>
<p>​    2．使用无验证方式启动mysql服务: mysqld —skip-grant-tables</p>
<p>​    3．打开新的cmd窗口,直接输入mysql命今，敲回车。就可以登录成功</p>
<p>​    4.use mysql ;</p>
<p>​    5.update user set password = password(‘你的新密码’) where user = ‘root ‘;    </p>
<p>​    6.关闭两个窗口</p>
<p>​    7.打开任务管理器，手动结束mysqld.exe的进程</p>
<p>​    8.启动mysql服务</p>
<p>​    9.使用新密码登录。</p>
<p>4．查询用户:</p>
<p>​    — 1．切换到mysql数据库</p>
<p>​        USE myql;</p>
<p>​    — 2.查询user表</p>
<p>​        SELECT * FROM USER;</p>
<p>*通配符:%表示可以在任意主机使用用户登录数据库</p>
<p>2．权限管理:</p>
<p>1．查询权限:</p>
<p>—查询权限</p>
<p>​    SHOW GRANTS grants FOR “用户名’@”主机名”;</p>
<p>​    SHOW GRANTS FOR “lisi’@’ %”;</p>
<p>2．授予权限:</p>
<p>—授予权限</p>
<p>​    grant 权限列表 on 数据库名.表名 to ‘用户名”@’主机名”;</p>
<p>—给张三用户授予所有权限，在任意数据库任意表上</p>
<p>​    GRANT ALL ON <em>.</em> TO “ zhangsan’@” localhost “ ;</p>
<p>所以权限列表all所以数据库名和表名都是*</p>
<p>3．撤销权限:</p>
<p>—撤销权限:</p>
<p>​    revoke 权限列表 on 数据库名.表名 from `用户名’@”主机名’;</p>
<p>​    REVOKE UPDATE ON db3.” account“  FROM ‘lisi’@”%’;</p>
<h2 id="5-JDBC"><a href="#5-JDBC" class="headerlink" title="5.JDBC"></a>5.JDBC</h2><p>1．概念:Java DataBase Connectivity Java 数据库连接，Java语言操作数据库</p>
<p>JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我门可以使用这套接口(JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<p>2．快速入门:</p>
<p>*步骤:</p>
<p>1.导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p>
<p>​    1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</p>
<p>​    2.右键—&gt;add as Library</p>
<p>2．注册驱动</p>
<p>3。获取数据库连接对象connection</p>
<p>4．定义sql</p>
<p>5，获取执行sql语句的对象 statement</p>
<p>6．执行sql，接受返回结果</p>
<p>7．处理结果</p>
<p>8.释放资源</p>
<p>3．详解各个对象︰</p>
<p>1.DhiverManager :驱动管理对象</p>
<p>*功能∶</p>
<p>1。注册驱动:告诉程序该使用哪一个数据库驱动jar</p>
<p>static void registerDriver(Driver driver) :注册与给定的驱动程序DerverManger</p>
<p>写代码使用:class.forName( “ com.mysql .jdbc.Driver”);</p>
<p>通过查看源码发现:在com.mysqi.jdbc.Driver类中存在静态代码块 自动执行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static {</span><br><span class="line">    try {</span><br><span class="line">        java.sql. DriverMianager.registerDriver(new Driver());</span><br><span class="line">    } catch (SQLException E) {</span><br><span class="line">        throw new RuntimeException("can't register driver!");</span><br><span class="line">    }	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意: mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
<p>2．获取数据库连接:</p>
<p>方法:static connection getConnection(string url，string user，string password)</p>
<p>*参数︰</p>
<p>ur1:指定连接的路径</p>
<p>语法:jdbc : mysql://ip地址(域名):端口号/数据库名称</p>
<p>例子:jdbc : mysql:// localhost: 3306/db3</p>
<p>细节∶如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则ur1可以简写为: jdbc:mysq1://数据库名称</p>
<p>​    user :用户名</p>
<p>​    password :密码</p>
<p>2.Connectibn :数据库连接对象</p>
<p>1.功能∶</p>
<p>1.获取执行sql的对象</p>
<p>​    statement createstatement(</p>
<p>​    Preparedstatement preparestatement(string sql)</p>
<p>2.管理事务︰开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开后事务</p>
<p>​    提交事务: commit( )</p>
<p>​    回滚事务: rollback()</p>
<p>3.Statement :执行sql的对象</p>
<p>1。执行sql</p>
<p>​    1.boolean execute(string sql) :可以执行任意的sql了解</p>
<p>​    2.int executeupdate(string sql)︰执行DML (insert、update、delete)语句、DDL(create,alter、drop)语句</p>
<p>​        *返回值:影响的行数，可以通过这个影响的行数判断DNL语句是否执行成功 返回值&gt;o的则执行成功，反之，则失败。</p>
<p>​    3.Resultset executeQuery(string sql):执行DQL (select)语句</p>
<p>​    4.Resultset :结果集对象,封装查询结果</p>
<p>​        boolean next():游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p>
<p>​        getXxx(参数):获取数据[</p>
<p>​    Xxx:代表数据类型―如: int getInt() , string getstring()</p>
<p>​    参数:int : 代表列的编号,从1开始如: getstring(1)</p>
<p>​    string :代表列名称。如:getDouble(“balance”)</p>
<p>​    *注意:</p>
<p>​    使用步骤:</p>
<p>​        1。游标向下移动一行</p>
<p>​        2．判断是否有数据</p>
<p>​        3．获取数据</p>
<p>​    5.PreparedStatement :执行sql的对象</p>
<p>1，SQL注入问题∶在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p>
<p>​    1．输人用户随便，输入密码:a’ or ‘a’ = ‘a</p>
<p>​    2.sql : select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</p>
<p>2．解决sql注入问题;使用Preparedstatement对象来解决</p>
<p>3。预编译的SQL:参数使用?作为占位符</p>
<p>4，步骤︰</p>
<p>​    1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar</p>
<p>​    2.注册驱动</p>
<p>​    3.获取数据库连接对象connection</p>
<p>​    4.定义sql</p>
<p>​        注意∶ sql的参数使用?作为占位符。</p>
<p>​        如: select * from user where username = ? and password = ?;</p>
<p>5．获取执行sql语句的对象Preparedstatement </p>
<p>​    Connection.preparestatement(string sql)</p>
<p>6．给?赋值</p>
<p>​    方法. setXxx(参数1，参数2)Xxx类型</p>
<p>​    参数1：?的位置编号 从1开始</p>
<p>​    参数2：?的值</p>
<p>7．执行sql，接受返回结果，不需要传递sql语句</p>
<p>8．处理结果</p>
<p>9．释放资源</p>
<p>注意︰后期都会使用Preparedstatement来完成增删改查的所有操作</p>
<p>1.可以防止SQL注入</p>
<p>2.效率更高:</p>
<p>​    抽取JDBC工具类:JDBCUtils</p>
<p>*目的:简化书写</p>
<p>*分析:</p>
<p>​    1.注册驱动也抽取</p>
<p>​    2.抽取一个方法获取连接对象</p>
<p>*需求:不想传递参数（麻烦)，还得保证工具类的通用性。</p>
<p>*解决:配置文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.properties</span><br><span class="line">url=</span><br><span class="line">user=</span><br><span class="line">password=</span><br></pre></td></tr></tbody></table></figure>
<p>3．抽取一个方法释放资源</p>
<p>JDBC控制事务:</p>
<p>1.事务:一个包含多个步骠的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
<p>2.操作:</p>
<p>​    1.开启事务</p>
<p>​    2.提交事务</p>
<p>​    3.回滚事务</p>
<p>3．使用connection对象来管理事务</p>
<p>开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</p>
<p>​    在执行sql之前开启事务</p>
<p>提交事务: commit()</p>
<p>​    当所有sql都执行完提交事务</p>
<p>回滚事务:roillback()</p>
<p>​    在catch中回滚事务</p>
<p>数据库连接池</p>
<p>1．概念:其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>​    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
<p>2．好处:</p>
<p>​    1.节约资源</p>
<p>​    2.用户访问高效</p>
<p>3．实现︰</p>
<p>​    1,标准接口:DataSource javax.sql包下的</p>
<p>​    1.方法︰</p>
<p>​        *获取连接:getConnection()</p>
<p>​        *归还连接:Connection.close()。如果连接对象connection是从连接池中获取的，那么调用connection.close()方法，则不会再关闭连接了。而是归还连接</p>
<p>​    2.—般我们不去实现它，有数据库厂商来实现</p>
<p>​        1.C3PO∶数据库连接池技术</p>
<p>​        2.Druid :数据库连接池实现技术，由阿里巴巴提供的</p>
<p>​        4.C3Pe:数据库连接池技术</p>
<p>*步骤∶</p>
<p>1．导入jar包（3个)c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ,</p>
<p>​    *不要忘记导入数据库驱动jar包</p>
<p>2．定义配置文件:</p>
<p>​    名称:c3po.properties或者c3pe-config.xml</p>
<p>​    路径︰直接将文件放在src目录下即可。</p>
<p>3．创建核心对象 数据库连接池对象ComboPooledDatasource</p>
<p>4．获取连接: getConnection</p>
<p>5.Druid :数据库连接池实现技术，由阿里巴巴提供的</p>
<p>本步骤∶</p>
<p>1.导入jar包druid-1.e.9.jar</p>
<p>2．定义配置文件;</p>
<p>​    是properties形式的</p>
<p>​    可以叫任意名称，可以放在任意目录下</p>
<p>3．加载配置文件。Properties</p>
<p>​     //获取src路径下的文件的方式—-&gt;ClassLoader类加载器，加载字节码文件进内存，获取src文件下资源的路径 类名.class.getClassLoader(); </p>
<p>​    ClassLoader classLoader = JDBCUtils.class.getClassLoader();</p>
<p>4．获取数据库连接池对象:通过工厂来来获取DruidDataSourceFactory</p>
<p>5．获取连接:getconnection</p>
<h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><p>spring框架对JDBC的简单封装。提供了一个DBCTemplate对象简化JDBC的开发步骤︰</p>
<p>1．导入jar包</p>
<p>2．创建JdbcTemplate对象。依赖于数据源Datasource</p>
<p>​    JdbcTemplate template = new JdbcTemplate(ds) ;</p>
<p>3．调用JdbcTemplate的方法来完成CRUD的操作</p>
<p>​    update():执行DML语句。增、删、改语句</p>
<p>​    queryForMap() :查询结果将结果集封装为map集合，将列名作为key，将值作为value将这条记录封装为一个map集合</p>
<p>​        注意:这个方法查询的结果集长度只能是1</p>
<p>​    queryForList():查询结果将结果集封装为list集合</p>
<p>​        注意:将每一条记录封装为一个Map集合，再好Map集合装载到List集合中query():查询结果，将结果封装为JavaBean对象</p>
<p>​        query的参数:RowMapper</p>
<p>​        一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p>
<p>​        *new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p>
<p>queryForObject :查询结果，将结果封装为对象</p>
<p>​        —般用于聚合函数的查询</p>
<p>web概念概述</p>
<p>Javaweb :</p>
<p>*使用ava语言开发基于互联网的项目</p>
<p>*软件架构:</p>
<p>1.C/S: client/server客户端/服务器端</p>
<p>*在用户本地有一个客户端程序，在远程有一个服务器端程序如:Qo，迅雷…</p>
<p>优点:T.1．用户体验好缺点∶</p>
<p>​    1.开发、安装，部署，维护麻烦</p>
<p>​    2.B/S: Browser/Server浏览器/服务器端</p>
<p>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序*优点:</p>
<p>1.开发、安装，部署，维护简单缺点︰</p>
<p>1，如果应用过大，用户的体验可能会受到影响2．对硬件要求过高</p>
<p>B/S架构详解</p>
<p>*资源分类:</p>
<p>1.静态资源:</p>
<p>​    本使用静态网页开发技术发布的资源。本特点:</p>
<p>​    所有用户访问，得到的结果是—样的。</p>
<p>​    本如:文本，图片，音频、视频,HTML ,css,javaScript</p>
<p>​    如果用户请求的是静态资源，那么服务器会直接将静右资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</p>
<p>2.动态资源:</p>
<p>​    使用动态网页及时发布的资源。*特点:</p>
<p>​    *所有用户访问，得到的结果可能不一样。如:jsp/servlet,php,asp…</p>
<p>​    *如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</p>
<p>​    *我们要学习动态资源，必须先学习静态资源!</p>
<p>​    *静态资源:</p>
<p>*HTML:用于搭建基础网页，展示页面的内容</p>
<p>CSS:用于美化页面，布局页面</p>
<p>JavaScript :控制页面的元素，让页面有一些动态的效果</p>
<h2 id="6-HTML"><a href="#6-HTML" class="headerlink" title="6.HTML"></a>6.HTML</h2><p>1、概念︰是最基础的网页开发语言</p>
<p>​    *Hyper Text Markup Language超文本标记语言</p>
<p>超文本:</p>
<p>​    *超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p>
<p>标记语言:</p>
<p>​    由标签构成的语言。&lt;标签名称&gt;如html, xml</p>
<p>​    标记语言不是编程语言</p>
<p>2．快速入门∶</p>
<p>​    *语法∶</p>
<p>​    1.html文档后缀名.html或者.htm</p>
<p>​    2．标签分为</p>
<p>​        1．围堵标签:有开始标签和结束标签。如<code>&lt;html&gt; &lt;/html&gt;</code></p>
<p>​        2。自闭和标签∶开始标签和结束标签在一起。如<code>&lt;br/&gt;</code> 换行标签</p>
<p>​        3．标签可以嵌套:</p>
<p>​            需要正确嵌套，不能你中有我，我中有你</p>
<p>​        错误∶<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></p>
<p>​        正确:<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></p>
<p>​        4．在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p>
<p>​        5.html的标签不区分大小写，但是建议使用小写。</p>
<p>​    3．标签学习:</p>
<p>​        1．文件标签:构成html最基本的标签</p>
<p>​        html : html文档的根标签</p>
<p>​        head :头标签。用于指定html文档的一些属性。引入外部的资源*</p>
<p>​        title:标题标签。</p>
<p>​        body :体标签</p>
<p>*&lt; I DOCTYPE html&gt; : html5中定义该文档是html文档.</p>
<p>2．文本标签:和文本有关的标签</p>
<p>注释:<l--注释内容-->*</l--注释内容--></p>
<p>标题标签</p>
<p>h1~h6:字体大小逐渐递减</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;:段落标签</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt;:换行标签</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr&gt;:展示一条水平线 属性∶ color :颜色 width :宽度 size :高度</span><br></pre></td></tr></tbody></table></figure>
<p>align :对其方式center :居中 left :左对齐 right :右对齐</p>
<p>width :</p>
<p>​    1．数值: width=’20’,数值的单位，默认是px(像素)</p>
<p>​    2．数值%:占比相对于父元素的比例</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;:字体加粗</span><br><span class="line">&lt;i&gt;:字体斜体</span><br><span class="line">&lt;font&gt;:字体标签</span><br><span class="line">&lt;center&gt; :文本居中</span><br></pre></td></tr></tbody></table></figure>
<p>属性:color :颜色<em> size :大小</em> face :字体</p>
<p>*属性定义∶color :</p>
<p>​    1.英文单词: red ,green, blue</p>
<p>​    2.rgb(值1，值2,值3):值的范国:0~255如rgb(0,0,255)</p>
<p>​    3.#值1值2值3:值的范国:00~FF之间。如:#FF00FF 16进制配比</p>
<p>3，图片标签:</p>
<p>img :展示图片</p>
<p>属性:</p>
<p>src :指定图片的位置</p>
<p>alt：加载不出来输出的 名字</p>
<p> 相对路径 </p>
<p>​    以.开头的路径 </p>
<p>​    ./ 代表当前目录 </p>
<p>​    ../ 后退 上一级目录</p>
<p>4.列表标签</p>
<p>有序列表</p>
<p>​    ol：列表<code>&lt;ol type="A" start="5"&gt;</code></p>
<p>​    li：列表的项</p>
<p>无序列表ul   li</p>
<p>5．链接标签∶</p>
<p>​    <code>&lt;a&gt;</code>:定义一个超链接</p>
<p>​    属性: href :指定访问资源的URL(统一资源定位符)为空在本页面跳转javascript:void(0);阻止他的返回</p>
<p>​    target :指定打开资源的方式</p>
<p>​    _self:默认值，在当前页面打开</p>
<p>​    _blank :在新建空白页面打开</p>
<p>6.div和span</p>
<p>​    div：每个div占满一整行，块级标签</p>
<p>​    span：文本信息在一行展示，行内标签 内联标签</p>
<p>7.语义化标签：html5中为了提高程序的可读性，提供的一些标签</p>
<p>1.<code>&lt;header&gt; &lt;/header&gt;</code>:定义一个文档的头部分</p>
<p>2.<code>&lt;footer&gt; &lt;/footer&gt;</code>：定义一个文章的低部</p>
<p>8.表格标签</p>
<p>​    table :定义表格</p>
<p>​    width :宽度</p>
<p>​    border :边框</p>
<p>​    cellpadding :定义内容和单元格的距离</p>
<p>​    cellspacing:定义单元格之间的距离。如果指定为0，则单元格的线会合为一条.</p>
<p>​    bgcolor :背景色</p>
<p>​    align :对齐方式</p>
<p>​    margin:指定外边距，auto水平居中</p>
<p>​    tr :定义行</p>
<p>​    bgcolor :背景色</p>
<p>​    align :对齐方式</p>
<p>​    td :定义单元格</p>
<p>​    colspan：合并列</p>
<p>​    rowspan：合并行</p>
<p>​    th :定义表头单元格</p>
<p>​    <code>&lt;caption&gt;</code> :表格标题</p>
<p>​    <code>&lt;thead&gt;</code> :表示表格的头部分</p>
<p>​    <code>&lt;tbody&gt;</code>:表示表格的体部分</p>
<p>​    <code>&lt;tfoot&gt;</code> :表示表格的脚部分</p>
<p>HTML标签∶</p>
<p>​    表单标签表单︰</p>
<p>​    *概念︰用于采集用户输入的数据的。用于和服务器进行交互。</p>
<p>​         form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p>
<p>属性:</p>
<p>​    action :指定提交数据的URL</p>
<p>​    method:指定提交方式</p>
<p>​    分类:—共7种，2种比较常用</p>
<p>get :</p>
<p>​    1，请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。</p>
<p>​    2，请求参数大小是有限制的。</p>
<p>​    3，不太安全。</p>
<p>post :</p>
<p>​    1．请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)</p>
<p>​    2．请求参数的大小没有限制。</p>
<p>​    3．较为安全。</p>
<p>​        *表单项中的数据要想被提交︰必须指定其name属性</p>
<p>​        *表单项标签︰</p>
<p>input :可以通过type属性值，改变元素展示的样式</p>
<p>type属性:</p>
<p>​    *text:文本输入框，默认值</p>
<p>​    *placeholder :指定输人框的提示信息，当输入框的内容发生变化，会自动清空提示信息</p>
<p>password :密码输入框隐藏密码 变成圆点</p>
<p>radio:单选框</p>
<p>注意︰</p>
<p>​    1.要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p>
<p>​    2.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
<p>​    3.checked属性，可以指定默认值</p>
<p>​        checkbox :复选框</p>
<p>注意︰</p>
<p>​    1.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
<p>​    2.checked属性，可以指定默认值 默认被选中</p>
<p>​    file:文件选择框</p>
<p>​    hidden :隐藏域,用于提交一些信息，虽然看不到，但值会被提交</p>
<p>按钮:</p>
<p>​    submit:提交按钮。可以提交表单</p>
<p>​    button:普通按钮</p>
<p>​    image :图片提交按钮</p>
<p>​    src属性指定图片的路径</p>
<p>​    label :指定输入项的文字描进信息</p>
<p>*注意∶</p>
<p>​    label的for属性一般会和input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p>
<p>​    select:下拉列表</p>
<p>*子元素: option，指定列表项</p>
<p>​    textarea :文本域</p>
<p>​    cols :指定列数，每一行有多少个字符</p>
<p>​    rows :默认多少行。</p>
<p>​    css:页面美化和布局控制</p>
<p>1．概念: cascading style sheets 层叠样式表</p>
<p>​    *层叠:多个样式可以作用在同一个html的元秦上，同时生效</p>
<p>2．好处∶</p>
<p>​    1．功能强大</p>
<p>​    2．将内容展示和样式控制分离</p>
<p>​        降低耦合度。解耦</p>
<p>​        让分工协作更容易提高开发效率</p>
<p>​    3.css的使用:css与html结合方式</p>
<p>​    1。内联样式</p>
<p>​        在标签内使用style属性指定css代码</p>
<p>*如: <code>&lt;div style="color : red;"&gt;hello css&lt;/div&gt;</code></p>
<p>2．内部样式</p>
<p>在head标签内，定义style标签，style标签的标签体内容就是css代码</p>
<p>如∶</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div{</span><br><span class="line">	color: blue;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>3．外部样式</p>
<p>1．定义css资源文件。</p>
<p>2．在head标签内，定义link标签，引入外部的资源文件</p>
<p>如：</p>
<p>a.css文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div{</span><br><span class="line">	color:green;</span><br><span class="line">}</span><br><span class="line">&lt;link rel="stylesheet" herf="css/a.css"&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>*注意:</p>
<p>1,2,3种方式css作用范围越来越大</p>
<p>1方式不常用，后期常用2,3</p>
<p>3种格式可以写为:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@import "css/a.css";</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>4.css语法∶</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择器{</span><br><span class="line">	属性名1:属性值1;</span><br><span class="line">	属性名2:属性值2;</span><br><span class="line">	....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>选择器:筛选具有相似特征的元素</p>
<p>注意︰</p>
<p>每—对属性需要使用;隔开，最后一对属性可以不加;</p>
<p>5．选择器︰筛选具有相似特征的元秦</p>
<p>​    *分类︰</p>
<p>​    1，基础选择器</p>
<p>​        1.id选择器∶选择具体的id属性值的元素.建议在一个html页面中id值唯一</p>
<p>​        语法: #id属性值{}</p>
<p>​        2．元素选择器:选择具有相同标签名称的元素</p>
<p>​        本语法︰标签名称{}</p>
<p>​        本注意:id选择器优先级高于元素选择器</p>
<p>​        3．类选择器:选择具有相同的class属性值的元素。</p>
<p>​        语法:.class属性值{}</p>
<p>​        本注意:类选择器选择器优先级高于元素选择器</p>
<p>​    2.扩展选择器</p>
<p>​        1.选择所有元秦:</p>
<p>​            语法︰*{}</p>
<p>​        2.并集选择器︰</p>
<p>​            语法：*选择器1,选择器2{}</p>
<p>​        3.子选择器∶筛选选择器1元素下的选择器2元素</p>
<p>​            语法;选择器1 选择器2{}</p>
<p>​        4.父选择器∵:筛选选择器2的父元素选择器1</p>
<p>​            语法:选择器1&gt;选择器2{}</p>
<p>​        5.属性选择器:选择元素名称，属性名-属性值的元素</p>
<p>​            多语法:元素名称[属性名=”属性值”]{ }</p>
<p>​        6.伪类选择器:选择一些元素具有的状态</p>
<p>​            *语法:元素:状态{ }</p>
<p>​    *如: <code>&lt;a&gt;</code></p>
<p>​        *状态︰</p>
<p>​            link :初始化的状态</p>
<p>​            visited :被访问过的状态</p>
<p>​            active : 正在访问状态</p>
<p>​            hover:鼠标悬浮状态</p>
<p>6．属性</p>
<p>1．字体、文本</p>
<p>​    font-size :字体大小</p>
<p>​    color :文本颜色</p>
<p>​    text-align :对其方式 </p>
<p>​    line-height :行高</p>
<p>2．背景</p>
<p>​    background :</p>
<p>3，边框</p>
<p>​    border :设置边框，符合属性</p>
<p>4．尺寸 width :宽度</p>
<p>​    height :高度</p>
<h2 id="7-Javascript"><a href="#7-Javascript" class="headerlink" title="7.Javascript"></a>7.Javascript</h2><p>概念:一门客户端本语营</p>
<p>​    运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p>
<p>​    脚本语言:不需要编译,直接就可以被浏览器解析执行了</p>
<p>功能:</p>
<p>​    可以来培强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</p>
<p>ECMAScript :客户端脚本语言的标准</p>
<p>1．基本语法:</p>
<p>1.与html结合方式</p>
<p>1．内部s :</p>
<p>*定义<code>&lt;script&gt;</code>，标签体内容就是js代码</p>
<p>2．外部s :</p>
<p>*定义<code>&lt;script&gt;</code>，通过src属性引入外部的js文件</p>
<p>*注意︰</p>
<p>1.<code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</p>
<p>2.<code>&lt;script&gt;</code>可以定义多个。</p>
<p>​    2．注释</p>
<p>​        1，单行注释://注释内容</p>
<p>​        2．多行注释∶/<em>注释内容</em>/</p>
<p>​        3．数据类型:</p>
<p>1．原始数据类型(基本数据类型):</p>
<p>​        1.number:数字。整数/小数/NaN(not a number 一个不是数字的数字类型)</p>
<p>​        2.string :字符串。字符串”abc” “a” “abc ‘ 无字符</p>
<p>2.boolean: true和false</p>
<p>3.null :一个对象为空的占位符</p>
<p>4.undefined :未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</p>
<p>2.引用数据类型:对象</p>
<p>4．变量</p>
<p>*变量:一小块存储数据的内存空间</p>
<p>Java语言是强类型语言，而Javascript是弱类型语言。</p>
<p>强类型︰在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p>
<p>弱类型:在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p>
<p>*语法∶</p>
<p>​    *var变量名=初始化值;</p>
<p>​    *typeof运算符:获取变量的类型。</p>
<p>注:null运算后得到的是object</p>
<p>5．运算符</p>
<p>1，—元运算符︰只有一个运算数的运算符</p>
<p>​    ++,— , +(正号),-(负号)</p>
<p>​    ++ —:自增(自减)++(—)在前，先自增(自减)，再运算++(—)在后，先运算，再自增(自减)</p>
<p>​    +(-):正负号</p>
<p>注意。在s中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p>
<p>其他类型转number:</p>
<p>​    string转number:按照字面值转换。如果字面值不是数字，则转为NaN(不是数字的数字)</p>
<p>​    boolean转number: true转为1,false转为-1</p>
<p>2．算数运算符</p>
<p>​    + - * / % …</p>
<p>3．赋值运算符</p>
<p>​    = += -+…</p>
<p>4．比较运算符</p>
<p>​    &lt; &gt; &gt;= &lt;= == ===(全等于)</p>
<p>比较方式</p>
<p>1．类型相同:直接比较</p>
<p>​    字符串,按照字典顺序比较。按位逐一比较，直到得出大小为止。</p>
<p>2．类型不同:先进行类型转换，再比较</p>
<p>​    *===:全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p>
<p>5．逻辑运算符</p>
<p>​     &amp;&amp; || !</p>
<p>​    逻辑运算符:&amp;&amp;:与（短路)</p>
<p>​    l|:或（短路)</p>
<p>​    !:非</p>
<p>*其他类型转boolean:</p>
<p>​    1.number:0或NaN为假，其他为真</p>
<p>​    2.string:除了空字符串(“”)，其他都是true</p>
<p>​    3.null&amp;undefined:都是false</p>
<p>​    4.对象:所有对象都为true</p>
<p>6．三元运算符</p>
<p>  ? : </p>
<p>6．流程控制语句</p>
<p>1.if…else. . .</p>
<p>2.switch:[</p>
<p>*在java中, switch语句可以接受的数据类型: byte int shor char,枚举(1.5) ,string(1.7)</p>
<p>​    switch(变量):</p>
<p>​    case 值:</p>
<p>​    *在JS中, switch语句可以接受任意的原始数据类型</p>
<p>​    3.while</p>
<p>​    4.do . ..while</p>
<p>​    5.for</p>
<p>7．特殊语法</p>
<p>1．语句以;结尾，如果一行只有一条语句则﹔可以省略(不建议)</p>
<p>2．变量的定义使用var关键字，也可以不使用</p>
<p>​    *用:定义的变量是局部变量</p>
<p>​    *不用:定义的变量是全局变量(不建议)</p>
<h3 id="1-Function-函数-方法-对象"><a href="#1-Function-函数-方法-对象" class="headerlink" title="1.Function:函数(方法)对象"></a>1.Function:函数(方法)对象</h3><p>1．创建:</p>
<p>1.var fun = new Function(形式参数列表,方法体);//忘掉吧</p>
<p>2.function 方法名称(形式参数列表){</p>
<p>​    方法体</p>
<p>}</p>
<p>3.var 方法名= function(形式参数列表){</p>
<p>​    方法体</p>
<p>}</p>
<p>2．方法:</p>
<p>3．属性:</p>
<p>​    length :代表形参的个数</p>
<p>4．特点:</p>
<p>​    1．方法定义是，形参的类型不用写,返回值类型也不写。</p>
<p>​    2．方法是一个对象，如果定义名称相同的方法，会覆盖</p>
<p>​    3．在JS中，方法的调用只与方法的名称有关，和参数列表无关</p>
<p>​    4．在方法声明中有一个隐藏的内置对象（数组）, arguments ,封装所有的实际参数</p>
<p>​    5．调用:</p>
<p>​        方法名称(实际参数列表);</p>
<p>​    Array:数组对象</p>
<p>1．创建:</p>
<p>​    1.var arr = new Array(元素列表);</p>
<p>​    2.var arr = new_Array(默认长度);</p>
<p>​    3.var arr =[元素列表];</p>
<p>2．方法</p>
<p>​    join(参数):将数组中的元素按照指定的分隔符拼接为字符串</p>
<p>​    push()向数组的末尾添加一或更多元素，并返回新的长度。</p>
<p>3．属性</p>
<p>​    length :数组的长度</p>
<p>4．特点:</p>
<p>​    1.Js中，数组元素的类型可变的。</p>
<p>​    2.Js中，数组长度可变的。</p>
<h3 id="2-Date-日期对象"><a href="#2-Date-日期对象" class="headerlink" title="2.Date:日期对象"></a>2.Date:日期对象</h3><p>​    1．创建:</p>
<p>​        var date =new Date( );</p>
<p>​    2．方法:</p>
<p>​        toLocalestring():返回当前date对象对应的时间本地字符串格式</p>
<p>​        getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p>
<p>​    Number</p>
<p>​    String</p>
<h3 id="3-RegExp-正则表达式对象"><a href="#3-RegExp-正则表达式对象" class="headerlink" title="3.RegExp:正则表达式对象"></a>3.RegExp:正则表达式对象</h3><p>1.正则表达式:定义字符串的组成规则。</p>
<p>1,单个字符:[ ]</p>
<p>​    如:[a][ab] [a-zA-Zo-9_]</p>
<p>​    特殊符号代表特殊含义的单个字符:</p>
<p>​        \d:单个数字字符[0-9]</p>
<p>​        \w:单个单词字符[a-zA-Z0-9_]</p>
<p>2．量词符号:</p>
<p>​    ?:表示出现0次或1次</p>
<p>​    *:表示出现0次或多次</p>
<p>​    +:出现1次或多次</p>
<p>​    {m,n}:表示m&lt;=数量&lt;=n</p>
<p>​    m如果缺省:{,n}:最多n次</p>
<p>​    n如果缺省:{m,}最少m次</p>
<p>3.开始结束符号</p>
<p>​    ^：开始</p>
<p>​    $：结束</p>
<p>2．正则对象:</p>
<p>1．创建</p>
<p>​    1.var reg =new_RegExp(”正则表达式”);</p>
<p>​    \2. var reg =/正则表达式/;</p>
<p>2．方法</p>
<p>​    1.test(参数):验证指定的字符串是否符合正则定义的规范</p>
<h3 id="4-Global"><a href="#4-Global" class="headerlink" title="4.Global"></a>4.Global</h3><p>1．特点:全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</p>
<p>2．方法:</p>
<p>​    encodeURI( ) : url编码</p>
<p>​    decodeURI(() : url解码</p>
<p>​    encodeURIComponent() : url编码,编码的字符更多</p>
<p>​    decodeURIComponent() : url解码</p>
<p>​    parseInt():将字符串转为数字</p>
<p>*逐—判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</p>
<p>isNaN():判断一个值是否是NaN</p>
<p>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false</p>
<p>eval():讲JavaScript字符串，并把它作为脚本代码来执行。</p>
<p> 3.URL编码</p>
<p>​    传智播客=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p>
<h2 id="8-BOM"><a href="#8-BOM" class="headerlink" title="8.BOM"></a>8.BOM</h2><p>1．概念︰Browser object Model 浏览器对象模型</p>
<p>​    将浏览器的各个组成部分封装成对象。</p>
<p>2．组成:window :窗口对象</p>
<p>​    Navigator :浏览器对象</p>
<p>​    screen :显示器屏幕对象</p>
<p>​    History : 历史记录对象</p>
<p>​    Location :地址栏对象</p>
<p>​    DOM简单学习:为了满足案例要求</p>
<p>*功能:控制html文档的内容</p>
<p>*代码∶获取页面标签(元秦)对象 Element</p>
<p>​    *document.getElementById(“id值”):通过元素的id获取元素对象</p>
<p>*操作Element对象︰</p>
<p>​    1.修改属性值∶</p>
<p>​        1.明确获取的对象是哪一个?</p>
<p>​        2.查看API文档，找其中有哪些属性可以设置</p>
<p>​    2．修改标签体内容︰</p>
<p>​    属性:innerHTML</p>
<p>​    事件简单学习</p>
<p>​    *功能:某些组件被执行了某些操作后，触发某些代码的执行。</p>
<p>​    *如何绑定事件</p>
<p>1．直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p>
<p>​    1.事件:onclickl—单击事件</p>
<p>2．通过js获取元素对象，指定事件属性，设置一个函数</p>
<p>​    window:窗口对象</p>
<p>​    1、创建</p>
<p>​    2．方法</p>
<p>​        1．与弹出框有关的方法:</p>
<p>​        alert(）显示带有一段消,息和一个确认按钮的警告框。</p>
<p>​        confirm()  显示带有一段消息以及确认按钮和取消按钮的对话框。</p>
<p>​    如果用户点击确定按钮,则方法返回true</p>
<p>​    如果用户点击取消按钮，则方法返回false</p>
<p>​    prompt() 显示可提示用户输入的对话框。</p>
<p>​    返回值:获取用户输入的值</p>
<p>2．与打开关闭有关的方法:</p>
<p>​    close()关闭浏览器窗口。</p>
<p>​        谁调用我，我关谁</p>
<p>​    open()打开一个新的浏览器窗口</p>
<p>​        返回新的window对象</p>
<p>3．与定时器有关的方式</p>
<p>​    setTimeout()在指定的毫秒数后调用函数或计算表达式。</p>
<p>*参数:</p>
<p>​    1.js代码或者方法对象</p>
<p>​    2．毫秒值</p>
<p>​    *返回值:唯—标识，用于取消定时器</p>
<p>​        clearTimeout()取消由setTimeout()方法设置的 timeout。</p>
<p>​        setInterval()</p>
<p>​    按照指定的周期（以毫秒计）来调用函数或计算表达式。</p>
<p>​        clearInterval()取消由setInterval()设置的timeout。</p>
<p>3．属性</p>
<p>4．特点</p>
<p>Window对象不需要创建可以直接使用window使用。window .方法名();</p>
<p>window引用可以省略。方法名();</p>
<p>Location对象 :地址栏对象</p>
<p>1．创建(获取)∶</p>
<p>1.window. location</p>
<p>\2. location</p>
<p>2．方法︰</p>
<p>​    reload(重新加载当前文档。刷新)</p>
<p>3。属性</p>
<p>​    href设置或返回完整的URL。跳转页面</p>
<p>​    History :历史记录对象</p>
<p>1．创建(获取)∶</p>
<p>​    1.window.history</p>
<p>​    2.history</p>
<p>2．方法:</p>
<p>​    back() 加载history列表中的前一个URL。</p>
<p>​    forward() 加载history列表中的下一个URL。</p>
<p>​    go(参数) 加载history列表中的某个具体页面。</p>
<p>参数:正数∶前进几个历史记录</p>
<p>​     负数:后退几个历史记录</p>
<p>3．属性∶</p>
<p>​    *length返回当前窗口历史列表中的URL数量。</p>
<h2 id="9-DOM"><a href="#9-DOM" class="headerlink" title="9.DOM"></a>9.DOM</h2><p>*概念: Document object Model文档对象模型</p>
<p>*将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p>
<p>W3C DOM 标准被分为3个不同的部分∶</p>
<p>核心DOM -针对任何结构化文档的标准模型</p>
<p>​    Document :文档对象</p>
<p>​    Eiement:元素对象</p>
<p>​    Attfibute :属性对象</p>
<p>​    Text :文本对象</p>
<p>​    Comment:注释对象</p>
<p>​    Node :节点对象，其他5个的父对象</p>
<p>​    XML DOM -针对XML文档的标准模型</p>
<p>​    HTML DOM -针对HTML文档的标准模型</p>
<p>核心DOM模型:</p>
<p>*Document :文档对象</p>
<p>1.创建(获取):在html dom模型中可以使用window对象来获取</p>
<p>​    1.window. document</p>
<p>​    2.document</p>
<p>2。方法:</p>
<p>​    1．获取Element对象︰ </p>
<p>​        1.getElementById() :根据id属性值获取元素对象。id属性值一般唯</p>
<p>​        2.getElementsByTagName():根据元素名称获取元素对象们。返回值是一个数组</p>
<p>​        3.getElementsByclassName( ) :根据class属性值获取元素对象们。返回值是一个数组</p>
<p>​        4.getElementsByName():根据name属性值获取元素对象们。返回值是一个数组</p>
<p>2．创建其他DOM对象:</p>
<p>​    createAttribute( name)：创建指定名称的属性节点，并返回新的attr对象</p>
<p>​    createcomment()：创建注释节点</p>
<p>​    createElement()：创建元素节点</p>
<p>​    createTextNode( )：创建文本节点</p>
<p>3．属性</p>
<p>Element :元素对象</p>
<p>1，获取/创建:通过document来获取和创建</p>
<p>2．方法:</p>
<p>​    1.removeAttribute() :删除属性</p>
<p>​    2.setAttribute(): 设置属性</p>
<p>Node :节点对象，其他5个的父对象</p>
<p>特点:所有dom对象都可以被认为是一个节点</p>
<p>方法:</p>
<p>CRUD dom树:︰</p>
<p>​    appendchild():向节点的子节点列表的结尾添加新的子节点。</p>
<p>​    removechild():删除(并返回)当前节点的指定子节点。</p>
<p>​    replacechild():用新节点替换一个子节点。</p>
<p>属性:</p>
<p>​    *parentNode返回节点的父节点。</p>
<p>HTML DOM</p>
<p>​    1．标签体的设置和获取: innerHTML</p>
<p>​    2．使用html元秦对象的属性</p>
<p>​    3．控制元素样式</p>
<p>1。使用元素的style属性来设置</p>
<p>如:</p>
<p>//修改样式方式1</p>
<p>​    div1.style.border = “1px solid red” ;</p>
<p>​    div1.style.width = “200px”;</p>
<p>​    font-size—&gt; fontsize//字体大小</p>
<p>​    div1.style.fontsize = “20px”;</p>
<p>2．提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p>
<h2 id="10-Bootstrap"><a href="#10-Bootstrap" class="headerlink" title="10.Bootstrap"></a>10.Bootstrap</h2><p>​    1．概念︰一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap是基于 HTML、JS、 Javascript 的，它简洁灵活，使得web开发更加快捷。</p>
<p><em>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</em>好处:</p>
<p>​        1，定义了很多的css毕式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</p>
<p>​        2．响应式布局。</p>
<p>​        同一套页面可以兼容不同分辨率的设备。</p>
<p>​    2．快速入门</p>
<p>​        1.下载Bootstrap</p>
<p>​        2．在项目中将这三个文件夹复制</p>
<p>​        3、创建html页面，引入必要的资源文件</p>
<p>响应式布局:</p>
<p>​    同一套页面可以兼容不同分辨率的设备。</p>
<p>​    实现∶依赖于棚格系统:将一行平均分成12个格子，可以指定元素占几个格子步骤∶</p>
<p>1，定义容器。相当于之前的table.</p>
<p>容器分类∶</p>
<p>​    1.container :两边留白  固定宽度</p>
<p>​    2.container-fluid :每一种设备都是100%的宽度</p>
<p>2．定义行。相当于之前的tr样式: row</p>
<p>3．定义元素。相当于之前的td样式指定该元素在不同的设备上，所占的格子数目。样式: col-设备代号-格子数目</p>
<p>设备代号︰</p>
<p>1.xs :超小屏幕手机(&lt;768px) : col-xs-12</p>
<p>2.sm :小屏蒂平板(≥768px)</p>
<p>3.md : 中等屏蒂桌面显示器(≥992px)</p>
<p>4.lg :大屏蒂大桌面显示器(≥1200px)</p>
<p>注意︰</p>
<p>​    1.一行中如果格子数目超过12，则超出部分自动换行。</p>
<p>​    2．栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</p>
<p>​    3．如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</p>
<p>css样式和js插件</p>
<p>1.全局CSS样式:</p>
<p>​    按钮:class=”btn btn-default”</p>
<p>图片:</p>
<p>​    class=”img-responsive”:图片在任意尺寸都占100%</p>
<p>图片形状:</p>
<pre><code> class="img-rounded":方形: 
</code></pre><p>​    class=”img-circle”:圆形 </p>
<p>​    class=”img-thumbnail”相框</p>
<p>表格</p>
<p>​    table 添加表格</p>
<p>​    table’- bordered 表格边框 </p>
<p>​    table- hover 鼠标悬停效果</p>
<p>表单</p>
<p>​    *给表单项添加: class=”form-control”</p>
<p>2.组件:</p>
<p>​    导航条</p>
<p>​    分页条</p>
<p>3.插件︰</p>
<p>​    轮播图</p>
<p>​    事件监听机制:</p>
<p>*概念:某些组件被执行了某些操作后，触发某些代码的执行。</p>
<p>​    事件:某些操作。如:单击，双击，键盘按下了，鼠标移动了</p>
<p>​    事件源:组件。如:按钮文本输入框…</p>
<p>​    监听器∶代码。</p>
<p>​    注册监听∶将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</p>
<p>*常见的事件︰</p>
<p>1．点击事件∶</p>
<p>​    1.onclick:单击事件</p>
<p>​    2.ondblclick :双击事件</p>
<p>2．焦点事件</p>
<p>​    1.onblur :失去焦点</p>
<p>​        一般用于表单校验</p>
<p>​    2.onfocus:元素获得焦点。</p>
<p>​    3．加载事件:</p>
<p>​        1.onload : —张页面或─幅图像完成加载。</p>
<p>​    4．鼠标事件︰</p>
<p>​        1.onmousedown 鼠标按钮被按下。</p>
<p>​            定义方法时，定义一个形参，接受event对象。</p>
<p>​            event对象的button属性可以获取鼠标哪个键被点击了 </p>
<p>​        2.onmouseup鼠标按键被松开。</p>
<p>​        3.onmousemove鼠标被移动。</p>
<p>​        4.onmouseover鼠标移到某元素之上。</p>
<p>​        5.onmouseout鼠标从某元素移开。</p>
<p>​    5.键盘事件:</p>
<p>​        1.onkeydown某个键盘按键被按下。</p>
<p>​        2.onkeyup某个键盘按键被松开。</p>
<p>​        3.onkeypress某个键盘按键被按下并松开。</p>
<p>​    6．选择和改变</p>
<p>​        1.onchange 域的内容被改变。</p>
<p>​        2.onselect文本被选中。</p>
<p>​    7.表单事件:</p>
<p>​        1.onsubmit确认按钮被点击。</p>
<p>​            可以阻止表单的提交</p>
<p>​        2.onreset重置按钮被点击。</p>
<h2 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h2><p>1。概念︰Extensible Markup Language 可扩展标记语言</p>
<p>*可扩展︰标签都是自定义的。<code>&lt;user&gt; &lt;student&gt;</code></p>
<p>*功能</p>
<p>*存储数据</p>
<p>1．配置文件</p>
<p>2．在网络中传输</p>
<p>xml与html的区别</p>
<p>​    1.xml标签都是自定义的，html标签是预定义。</p>
<p>​    2.xml的语法严格，html语法松散</p>
<p>​    3.xml是存储数据的，html是展示数据</p>
<p>2．语法︰</p>
<p>*基本语法︰</p>
<p>​    1.xml文档的后缀名.xml</p>
<p>​    2.xml第一行必须定义为文档声明</p>
<p>​    3.xml文档中有且仅有一个根标签</p>
<p>​    4.属性值必须使用引号(单双都可)引起来</p>
<p>​    5.标签必须正确关闭</p>
<p>​    6.xml标签名称区分大小写</p>
<p>*快速人门:</p>
<p>*组成部分∶</p>
<p>1，文档声明</p>
<p>​    1．格式:<code>&lt;?xml 属性列表 ?&gt;</code></p>
<p>2．属性列表:</p>
<p>​    version :版本号，必须的属性</p>
<p>​    encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值:ISO-8859-1</p>
<p>​    standalone :是否独立</p>
<p>取值:</p>
<p>​    yes :不依赖其他文件</p>
<p>​    no:依赖其他文件</p>
<p>2．指令(了解)∶结合css的</p>
<p><code>&lt;?xml-stylesheet type="text/css" href=fa.css" ?&gt;</code></p>
<p>3．标签︰标签名称自定义的</p>
<p>规则: 名称可以包含字母、数字以及其他的字符名称</p>
<p>​     不能以数字或者标点符号开始</p>
<p>​     名称不能以字母xml(或者XML、 xml等等)开始</p>
<p>​     名称不能包含空格</p>
<p>4.属性:</p>
<p>​    id属性值唯一</p>
<p>5，文本:</p>
<p>CDATA区:在该区域中的数据会被原样展示</p>
<p>格式:&lt; ![CDATA[ 数据 ]]&gt;</p>
<p>约束:规定xml文档的书写规则</p>
<p>*作为框架的使用者(程序员)∶</p>
<p>​    1．能够在xml中引入约束文档</p>
<p>​    2．能够简单的读懂约束文档</p>
<p>*分类︰</p>
<p>​    1.DTD:—种简单的约束技术</p>
<p>​    2.schema :—种复杂的约束技术</p>
<p>DTD :</p>
<p>*引人dtd文档到xml文档中</p>
<p>*内部dtd :将约束规则定义在xml文档中I</p>
<p>*外部dtd:将约束的规则定义在外部的dtd文件中</p>
<p>*本地:<code>&lt;! DOCTYPE 根标签名 SYSTEM "dtd文件的位置"&gt;</code></p>
<p>*网络:<code>&lt;!DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL"&gt;</code></p>
<p>schema :</p>
<p>引入:</p>
<p>​    1.填写xml文档的根元秦</p>
<p>​    2.引入xsi前缀， xmlns :xsi=”http: / /www . w3. org/2001/xNLSchema-instance”</p>
<p>​    3.引入xsd文件命名空间.  xsi:schemaLocation=”http : / / ww.itcast.cn/xml student.xsd”</p>
<p>​    4.为每一个xsd约束声明一个前缀,作为标识 xmlns=”http: / / www.itcast.cn/xml”</p>
<p>3．解析∶操作xml文档，将文档中的数据读取到内存中</p>
<p>*操作xml文档</p>
<p>1．解析(读取)∶将文档中的数据读取到内存中</p>
<p>2．写入:将内存中的数据保存到xml文档中。持久化的存储</p>
<p>*解析xml的方式:</p>
<p>1.DOM∶将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p>
<p>​    *优点:操作方便，可以对文档进行CRUD的所有操作</p>
<p>​    *缺点∶占内存</p>
<p>2.SAX:逐行读取，基于事件驱动的。</p>
<p>​    *优点:不占内存。</p>
<p>​    *缺点:只能读取，不能增删改</p>
<p>xml常见的解析器∶</p>
<p>​    1.JAXP : sun公司提供的解析器，支持dom和sax两种思想</p>
<p>​    2.DOM43 :一款非常优秀的解析器</p>
<p>​    3.Jsoup : jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容它提供了一套非常省力的API，可通过DOM,cSs以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>​    4.PULL : Android操作系统内置的解析器，sax方式的。</p>
<p>对象的使用:</p>
<p>1.Jsoup :工具类，可以解析html或xml文档，返回Document</p>
<p>​    parse :解析html或xml文档，返回Document</p>
<p>​    parse(File in，string charsetName ):解析xml或html文件的。</p>
<p>​    parse(string html):解析xml或html字符出</p>
<p>​    parse(URL_url,int timeoutNillis):通过网络路径获取指定的html或xml的文档对象</p>
<p>2.Document :文档对象。代表内存中的dom树</p>
<h2 id="12-获取Element对象"><a href="#12-获取Element对象" class="headerlink" title="12.获取Element对象"></a>12.获取Element对象</h2><p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p>
<p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p>
<p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p>
<p>3.Elements :元素Element对象的集合。可以当做ArrayList<element>来使用</element></p>
<p>4.Element :元素对象</p>
<p>1.获取子元素对象</p>
<p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p>
<p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p>
<p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p>
<p>2.获取属性值</p>
<p>​    string attr( string key):根据属性名称获取属性值</p>
<p>3.获取文本内容</p>
<p>​    string text():获取标签的纯文本内容</p>
<p>​    string html():获取标签体的所有内容(包括子标签的标签和文本内容)</p>
<p>5.Node :节点对象</p>
<p>是Document和Element的父类</p>
<p>快捷查询方式:</p>
<p>1.selector:选择器</p>
<p>​    使用的方法:Elementsselect(string cssQuery)</p>
<p>​    语法:参考selector类中定义的语法</p>
<p>2.XPath : XPath即为ML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p>
<p>​    *使用Jsoup的xpath需要额外导入jar包。</p>
<p>​    *查询w3cshool参考手册xml中，使用xpath的语法完成查询</p>
<p>web服务器软件∶</p>
<p>​    服务器︰安装了服务器软件的计算机</p>
<p>​    服务器软件∶接收用户的请求，处理请求，做出响应</p>
<p>​    web服务器软件:接收用户的请求，处理请求，做出响应。</p>
<p>​    在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 </p>
<p>web容器</p>
<p>常见的java相关的web服务器软件</p>
<p>​     webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​     websphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​    JBOSS :JBOSs公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p>
<p>​    Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的javaEE规范servlet/jsp。开源的，免费的。</p>
<p>​    JavaEE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p>
<p>​    Tomcat:web服务器软件</p>
<p>启动︰</p>
<p>bin/startup.bat ,双击运行该文件即可</p>
<p>​    访问:浏览器输入:localhost:8080回车访问自己</p>
<p><a href="http://别人的ip:8o80访问别人">http://别人的ip:8o80访问别人</a></p>
<p>​    可能遇到的问题: 1.黑窗口一闪而过: 原因:没有正确配置AVA_HOME环境变量</p>
<p>解决方案:正确配置JAvA_HOME环境变量</p>
<p>2．启动报错:</p>
<p>1．暴力∶找到占用的端口号，并目找到对应的进程，杀死该进程</p>
<p>   cmdnetstat -ano</p>
<p>2．温柔∶修效自身的端口号</p>
<p>​    conflserver.xml</p>
<p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p>
<p>好处∶在访问时，就不用输入端口号</p>
<p>5．关闭:</p>
<p>1．正常关闭:</p>
<p>​    bin/shutdown.bat</p>
<p>​    进入程序ctrl+c</p>
<p>2．强制关闭∶</p>
<p>​    点击启动窗口的×</p>
<p>6.配置:</p>
<p>部署项目的方式:</p>
<p>1.直接将项目放到webapps目录下即可。</p>
<p>​    localhost:8080/hello/hello.html</p>
<p>​    hello:项目的访问路径—&gt;虚拟目录</p>
<p>简化部署:将项目打成一个war包，再将war包放置到webapps目录下。</p>
<p>war包会自动解压缩</p>
<p>2.配置conf/server.xml文件在<code>&lt;Host&gt;</code>标签体中配置&lt;context docBase=”D: \hello” path=” /hehe” / &gt;</p>
<p>​    docBase:项目存放的路径</p>
<p>​    path :虚拟目录</p>
<p>3.在conf\catalina\localhost创建任意名称的xml文件。在文件中编写</p>
<p>&lt;context docBase=”D: \hello”/&gt;</p>
<p>虚拟目录:xml文件的名称</p>
<p>静态项目和动态项目:</p>
<p>​    目录结构</p>
<p>java动态项目的目录结构∶</p>
<p>​    —项目的根目录</p>
<p>​    — WEB-INF目录∶</p>
<p>​    — web.xml : web项目的核心配置文件</p>
<p>​    — classes目录:放置字节码文件的目录</p>
<p>​    — lib目录∶放置依赖的jar包</p>
<p>将Tomcat集成到IDEA中，并且创建avaEE的项目，部署项目。</p>
<h2 id="13-Servlet-server-applet"><a href="#13-Servlet-server-applet" class="headerlink" title="13.Servlet : server applet"></a>13.Servlet : server applet</h2><p>*概念:运行在服务器端的小程序</p>
<p>servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p>
<p>将来我们自定义一个类，实现servlet接口，复写方法。</p>
<p>快速入门:</p>
<p>1．创建JavaEE项目</p>
<p>2．定义一个类，实现servlet接口</p>
<p>*public class servletDemo1 implements servlet</p>
<p>3．实现接中的抽象方法</p>
<p>4．配置servlet</p>
<p>在web.xml中配置∶</p>
<p><code>&lt;!--配置servlet --&gt;</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;cn.itcast.web.servlet.servletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;demo1&lt;/ servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>执行原理:</p>
<p>1，当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的servlet的资源路径</p>
<p>2．查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</p>
<p>3．如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</p>
<p>4 . tomcat会将字节码文件加载进内存，并且创建其对象</p>
<p>5．调用其方法</p>
<p>servlet中的生命周期方法:</p>
<p>1．被创建:执行init方法，只执行一次</p>
<p>servlet什么时候被创建?</p>
<p>​    默认情况下，第一次被访问时，servlet被创建</p>
<p>​    可以配置执行servlet的创建时机。</p>
<p>在<code>&lt;servlet&gt;</code>标签下配置</p>
<p>1．第一次被访问时，创建</p>
<p>*<code>&lt;load-on-startup&gt;</code>的值为负数</p>
<p>2．在服务器启动时，创建</p>
<p>*<code>&lt;load-on-startup&gt;</code>的值为0或正整数</p>
<p>​    Servlet的init方法，只执行一次，说明一个servlet在内存中只存在一个对象，Servlet是单例的</p>
<p>*多个用户同时访问时，可能存在线程安全问题。</p>
<p>*解决∶尽量不要在servlet中定义成员变量。应使用局部变量，即使定义了成员变量，也不要对修改值</p>
<p>2．提供服务:执行service方法，执行多次</p>
<p>​    每次访问servlet时, service方法都会被调用一次。</p>
<p>3．被销毁:执行destroy方法，只执行一次</p>
<p>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p>
<p>​    只有服务器正常关闭时，才会执行destroy方法。</p>
<p>destroy方法在servlet被销毁之前执行，一般用于释放资源</p>
<p>servlet3.0 :</p>
<p>*好处:</p>
<p>​    *支持注解配置。可以不需要web.xml了。</p>
<p>*步骤：</p>
<p>​    1．创建JavaEE项目，选择servlet的版本3.0以上，可以不创建web.xml</p>
<p>​    2．定义一个类，实现servlet接口</p>
<p>​    3，复写方法</p>
<p>​    4、在类上使用@WebServlet注解，进行配置</p>
<p>@WebServlet(”/资源路径”)  千万别少 / 不然服务器打不开</p>
<p>IDEA和tomcat的相关配置</p>
<p>1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件</p>
<p>​    查看控制台的log : using CATALINA_BASE: “C:\Users\liu.IntelliJIdea2019.3\system\tomcat_JavaWeb”</p>
<p>2．工作空间项目和tomcat部署的web项目tomcat真正访问的是“tomcat部署的web项目””，”tomcat部署的web项目””对应着”工作空间项目”的web目录下的所有资源</p>
<p>​    WEB-INF目录下的资源不能被浏览器百接访问。</p>
<p>3．断点调试:使用”小虫子”启动dubug启动</p>
<p>Servlet的体系结构</p>
<p>Servlet —接口===Genericservlet —抽象类===Httpservlet —抽象类</p>
<p>Genericservlet:将servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p>
<p>将来定义servlet类时，可以继承Genericservlet，实现service()方法即可</p>
<p>Httpservlet : 对http协议的一种封装，简化操作</p>
<p>​    1。定义类继承Httpservlet</p>
<p>​    2。复写doGet/doPost方法</p>
<h2 id="14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议"><a href="#14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议" class="headerlink" title="14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议"></a>14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议</h2><p>传输协议∶定义了，客户端和服务器端通信时，发送数据的格式</p>
<p>特点∶</p>
<p>​    1．基于TCP/IP的高级协议</p>
<p>​    2．默认端口号:80</p>
<p>​    3，基于请求/响应模型的:—次请求对应一次响应</p>
<p>​    4．无状态的:每次请求之间相互独立，不能交互数据</p>
<p>历史版本:</p>
<p>1.0:每一次请求响应都会建立新的连接</p>
<p>1.1:复用连接</p>
<p>​    请求消息数据格式</p>
<p>1.请求行</p>
<p>​    请求方式 请求ur1 请求协议/版本</p>
<p>GET /login.html HTTP/1.1</p>
<p>请求方式:</p>
<p>​    HTTP协议有7中请求方式,常用的有2种</p>
<p>GET:</p>
<p>​    1.请求参数在请求行中，在url后。</p>
<p>​    2．请求的url长度有限制的</p>
<p>​    3．不太安全</p>
<p>POST:</p>
<p>​    1.请求参数在请求体中</p>
<p>​    2．请求的url长度没有限制的</p>
<p>​    3。相对安全</p>
<p>2．请求头:客户端浏览器告诉服务器一些信息</p>
<p>请求头名称:请求头值</p>
<p>*常见的请求头︰</p>
<p>1.User-Agent :浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<p>​    可以在服务器端获取该头的信息，解决浏览器的兼容性问题</p>
<p>2.Referer : http: //localhost/login.html</p>
<p>​    告诉服务器，我(当前请求)从哪里来?</p>
<p>*作用:</p>
<p>​    1．防盗链:</p>
<p>​    2．统计工作:</p>
<p>​    3．请求空行</p>
<p>​        空行，就是用于分割POST请求的请求头，和请求体的。</p>
<p>​    4．请求体(正文)∶</p>
<p>​        本封装POST请求消息的请求参数的</p>
<h2 id="15-Request"><a href="#15-Request" class="headerlink" title="15.Request"></a>15.Request</h2><p>1.request对象和response对象的原理</p>
<p>​    1.request和response对象是由服务器创建的。我们来使用它们</p>
<p>​    2.request对象是来获取请求消息，response对象是来设置响应消息</p>
<p>2.request对象继承体系结构:</p>
<p>servletRequest—接口 </p>
<p>​    |  继承</p>
<p>HttpServletRequest —接口</p>
<p>​    |  实现</p>
<p>org.apache.catalina.connector.RequestFacade  类(tomcat)</p>
<p>3.request功能∶</p>
<p>1.获取请求消息数据</p>
<p>1.获取请求行数据</p>
<p>​    GET / day14/ demo1 ?name=zhangsan HTTP/1.1</p>
<p>方法∶</p>
<p>1．获取请求方式:GET</p>
<p>​    String getMethod()</p>
<p>2.(*)获取虚拟自录:/day14</p>
<p>​    String getcontextPath()</p>
<p>3，获取Servlet路径:/demo1</p>
<p>​    String getServletpath()</p>
<p>4、获取get方式请求参数: name=zhangsan</p>
<p>​    String getQuerystring()</p>
<p>5．(*)获取请求URI : / day14/ demo1</p>
<p>​    String getRequestURI():/day14/ demo1</p>
<p>​    StringBuffer getRequestURL():h<a target="_blank" rel="noopener" href="http://localhost/day14/demo1">ttp:// localhost/day14/demo1</a></p>
<p>​    URL 统一资源定位符ht<a target="_blank" rel="noopener" href="http://localhost/day14/RequestDemo1">tp://localhost/day14/RequestDemo1</a></p>
<p>​    URI  统一资源标识符/day14/RequestDemo1</p>
<p>6．获取协议及版本:HTTP/1.1</p>
<p>​    string getProtocol()</p>
<p>7．获取客户机的IP地址:</p>
<p>​    string getRemoteAddr( )</p>
<p>2．获取请求头数据</p>
<p>方法:</p>
<p>​    (*)string getHeadler (String name) :通过请求头的名称获取请求头的值</p>
<p>​    Enumerationcstring&gt; getHeaderwames():获取所有的请求头名称</p>
<p>3，获取请求体数据:</p>
<p>*请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p>
<p>步骤∶</p>
<p>1.获取流对象</p>
<p>​    BufferedReader getReader():获取字符输入流，只能操作字符数据</p>
<p>​    ServletInputstream getInputStream():获取字节输入流，可以操作所有类型数据</p>
<p>在文件止传知识点后讲解</p>
<p>2.再从流对象中拿数据</p>
<p>2．其他功能∶</p>
<p>1.获取请求参数通用方式∶不论get还是post请求方式都可以使用下列方法来获取请求参数</p>
<p>​    1.string getParameter(string name):根据参数名称获取参数值username=zs&amp;password=123</p>
<p>​    2.string[] getparametervalues(string name):根据参数名称获取参数值的数组hobby=xx8hobby-game</p>
<p>​    3.<code>Enumeration&lt;string&gt; getParameterNames()</code>:获取所有请求的参数名称</p>
<p>​    4.Map<string,string[]> getParameterMap():获取所有参数的map集合</string,string[]></p>
<p>中文乱码问题:</p>
<p>​    get方式:tomcat 8 已经将get方式乱码问题解决了</p>
<p>​    post方式:会乱码</p>
<p>*解决︰在获取参数前，设置request的编码 request.setCharacterEncoding(“UTF-8”);</p>
<p>2.请求转发:一种在服务器内部的资源跳转方式</p>
<p>1.步骤∶</p>
<p>​    1．通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(string path)</p>
<p>​    2．使用RequestDispatcher对象来进行转发∶forward(servletRequest request，ServletResponse response)</p>
<p>2.特点:</p>
<p>​    1。浏览器地址栏路径不发生变化</p>
<p>​    2．只能转发到当前服务器内部资源中。</p>
<p>​    3。转发是一次请求</p>
<p>登录跳转页面：开发步骤</p>
<p>​    1．创建项目，导入html页面，配置文件，jar包</p>
<p>​    2。创建数据库环境</p>
<p>​        driverClassName=com.mysql.cj.jdbc.Driver</p>
<p>​        数据库路径：url=jdbc:mysql:///day14?serverTimezone=GMT%2B8</p>
<p>​    3．创建包cn.itcast.domain,创建类User</p>
<p>​    4．创建包cn.itcast.util,创建类JDBCUtils，使用Druid连接池</p>
<p>​    5．创建包cn.itcast.dao,创建类UserDao,提供login方法</p>
<p>​    6．编写cn.itcast.web. servlet.Loginservlet类</p>
<p>​    8.login.html中form表单的action路径的写法</p>
<p>​        虚拟目录:Servlet的资源路径action=”/data14_text/LoginServlet”</p>
<p>​    9.Beanutils工具类，简化数据封装</p>
<p>​        *用于封装avaBean的</p>
<p>1.JavaBean ∶标准的ava类</p>
<p>1.要求:</p>
<p>​    1．类必须被public修饰</p>
<p>​    2．必须提供空参的构造器</p>
<p>​    3．成员变量必须使用private修饰</p>
<p>​    4。提供公共setter和getter方法</p>
<p>2．功能:封装数据</p>
<p>2．概念∶</p>
<p>成员变量:</p>
<p>属性: setter和getter方法截取后的产物</p>
<p>get和set方法里大多数是和成员变量一致</p>
<p>​    例如: getUsername() —&gt; Username—&gt; username</p>
<p>3．方法:</p>
<p>​    1.setProperty()操作属性，而不是成员变量 设置成员变量gender值为null 设置属性hehe才能改变gender</p>
<p>​    2.getProperty()</p>
<p>​    3.populate(object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</p>
<p>2．响应消息:服务器端发送给客户端的数据</p>
<p>*数据格式∶</p>
<p>1.响应行</p>
<p>1.组成︰协议/版本 响应状态码 状态码描述</p>
<p>​    HTTP/1.1 200 OK</p>
<p>2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。</p>
<p>​    1.状态码都是3位数字</p>
<p>​    2.分类︰</p>
<p>​        1.1xx∶服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p>
<p>​        2.2xx∶成功。代表:200</p>
<p>​        3.3xx︰重定向。代表:302(重定向),304(访问缓存)</p>
<p>​        4.4xx:客户端错误。</p>
<p>​            代表:404(请求路径没有对应的资源)</p>
<p>​             405:请求方式没有对应的doXxx方法</p>
<p>​        5.5xx:服务器端错误。代表:500(服务器内部出现异常)</p>
<p>2．响应头︰</p>
<p>1．格式:头名称:值</p>
<p>2．常见的响应头:</p>
<p>​    1.Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式</p>
<p>​    2.Content-disposition:服务器告诉客户端以什么格式打开响应体数据</p>
<p>​        值:in-line:默认值,在当前页面内打开</p>
<p>​           attachment;filename=xxx∶以附件形式打开响应体。文件下载</p>
<p>3．响应空行</p>
<p>4．响应体:传输的数据</p>
<h2 id="16-Response对象"><a href="#16-Response对象" class="headerlink" title="16.Response对象"></a>16.Response对象</h2><p>功能∶设置响应消息</p>
<p>1．设置响应行</p>
<p>​    1．格式:HTTP/1.1 200 ok</p>
<p>​    2．设置状态码: setStatus(int sc)</p>
<p>2．设置响应头: setHeader(string name，string value)</p>
<p>3．设置响应体︰</p>
<p>*使用步骤︰</p>
<p>1.获取输出流</p>
<p>​    字符输出流:Printwriter getwriter()</p>
<p>​    字节输出流: Servletoutputstream getoutputstream()</p>
<p>2.使用输出流，将数据输出到客户端浏览器</p>
<p>案例∶</p>
<p>1．完成重定向</p>
<p>重定向:资源跳转的方式</p>
<p>代码实现:</p>
<p>//1.设置状态码为302</p>
<p>​    response.setstatus( 302);</p>
<p>//2.设置响应头location</p>
<p>​    response.setHeader(“location”,” /day15/responseDemo2”);*/</p>
<p>//简单的重定向方法</p>
<p>​    response.sendRedirect(“ /day15/responseDemo2”);</p>
<p>重定向的特点: redirect</p>
<p>​    1．地址栏发生变化</p>
<p>​    2．重定向可以访问其他站点(服务器)的资源</p>
<p>​    3．重定向是两次请求。不能使用request对象来共享数据</p>
<p>转发的特点: forward</p>
<p>​    1．转发地址栏路径不变</p>
<p>​    2．转发只能访问当前服务器下的资源</p>
<p>​    3．转发是一次请求，可以使用request对象来共享数据 </p>
<h2 id="17-forward和redirect区别"><a href="#17-forward和redirect区别" class="headerlink" title="17.forward和redirect区别"></a>17.forward和redirect区别</h2><p>路径写法:</p>
<p>1，路径分类</p>
<p>1．相对路径:通过相对路径不可以确定唯一资源</p>
<p>如: ./index.html</p>
<p>不以/开头，以.开头的路径</p>
<p>规则∶找到当前资源和目标资源之间的相对位置关系</p>
<p>​    ./  当前目录</p>
<p>​    ../ 后退一级目录</p>
<p>2．绝对路径:通过绝对路径可以确定唯一资源</p>
<p>​    如: http: //localhost/day15/responseDemo2或 /day15/responseDemo2</p>
<p>以/开头的路径</p>
<p>​    规则:判断定义的路释是给谁用的?判断请求将来从哪儿发出</p>
<p>1.给客户端浏览器使用:需要加虚拟目录(项目的访问路径)</p>
<p>​    建议虚拟目录动态获取:request.getcontextpath()</p>
<p>​    <code>&lt;a&gt; ,&lt;form&gt;</code>,重定向…</p>
<p>2.给服务器使用:不需要加虚拟目录</p>
<p>​    转发路径</p>
<p>2．服务器输出字符数据到浏览器</p>
<p>本步骤︰</p>
<p>​    1。获取字符输出流</p>
<p>​    2．输出数据</p>
<p>注意:</p>
<p>乱码问题∶</p>
<p>​    1.Printwriter pw = response.getwriter();获取的流的默认编码是IS0-8859-1</p>
<p>​    2.设置该流的默认编码</p>
<p>​    3.告诉浏览器响应体使用的编码</p>
<p>​        //简单的形式，设置编码，是在获取流之前设置</p>
<p>​        response.setContentType( “text/html ;charset=utf-8”);</p>
<h2 id="18-ServletContext对象"><a href="#18-ServletContext对象" class="headerlink" title="18.ServletContext对象:"></a>18.ServletContext对象:</h2><p>1.概念∶代表整个web应用，可以和程序的容器(服务器)来通信</p>
<p>2.获取︰</p>
<p>1．通过request对象获取</p>
<p>​    request.getServletContext( );</p>
<p>2．通过Httpservlet获取</p>
<p>​    this.getServletContext();</p>
<p>3．功能∶</p>
<p>1．获取MIME类型:</p>
<p>​    MIME类型:在互联网通信过程中定义的一种文件数据类型</p>
<p>​    格式:大类型/小类型text/htmlimage/ jpeg</p>
<p>​    获取: string getMimeType(string file)</p>
<p>2．域对象︰共享数据</p>
<p>3．获取文件的真实(服务器)路径</p>
<p>案例:</p>
<p>文件下载需求:</p>
<p>​    1．页面显示超链接</p>
<p>​    2．点击超链接后弹出下载提示框</p>
<p>​    3，完成圈片文件下载</p>
<p>分析∶</p>
<p>​    1．超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求</p>
<p>​    2．任何资源都必须弹出下载提示框</p>
<p>​    3．使用响应头设置资源的打开方式∶</p>
<p>​        content-disposition:attachment;filename=xXX</p>
<p>步骤∶</p>
<p>1．定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</p>
<p>2．定义servlet</p>
<p>​    1．获取文件名称</p>
<p>​    2．使用字节输入流加载文件进内存</p>
<p>​    3，指定response的响应头: content-disposition:attachment;filename=xXX</p>
<p>​    4。将数据写出到response输出流</p>
<p>问题∶中文文件名问题</p>
<p>*解决思路︰</p>
<p>​    1．装取客户端使用的浏览器版本信息</p>
<p>​    2．根据不同的版本信息，设置filename的编码方式不同</p>
<h2 id="19-Cookie"><a href="#19-Cookie" class="headerlink" title="19.Cookie"></a>19.Cookie</h2><p>1.概念︰客户端会话技术，将数据保存到客户端</p>
<p>2.快速入门:</p>
<p>*使用步骤︰</p>
<p>1．创建cookie对象，绑定数据</p>
<p>​    new cookie(string name,string value)</p>
<p>2．发送cookie对象</p>
<p>​    response.addcookie(cookie cookie)</p>
<p>3．获取Cookie，拿到数据</p>
<p>​    cookie[] request.getcookies()</p>
<p>3.实现原理</p>
<p>​    基于响应头set-cookie和请求头cookie实现</p>
<p>4.cookie的细节</p>
<p>1.一次可不可以发送多个cookie?</p>
<p>​    *可以可以创建多个cookie对象，使用response调用多次addcookie方法发送cookie即可。</p>
<p>2.cookie在浏览器中保存多长时间?</p>
<p>​    1．默认情况下，当浏览器关闭后，Cookie数据被销毁</p>
<p>​    2．持久化存储∶</p>
<p>​        setMaxAge(int seconds)</p>
<p>​            1.正数∶将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p>
<p>​            2.负数∶默认值</p>
<p>​            3.零∶删除cookie信息</p>
<p>3.cookie能不能存中文?</p>
<p>在tomcat 8之前cookie中不能直接存储中文数据。</p>
<p>需要将中文数据转码—-一般采用URL编码(%E3)</p>
<p>在tomcat 8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p>
<p>4.cookie共享问题?</p>
<p>1.假设在一个tomcat服务器中，部署了多个web项目,那么在这些web项目中cookie能不能共享?</p>
<p>默认情况下cookie不能共享</p>
<p>​    setPath(String path):设固cookie的获取范围。默认情况下，设置当前的虚拟目录</p>
<p>​    如果要共享,则可以将path设置为”/”</p>
<p>2,不同的tomcat服务器间cookie共享问题?</p>
<p>​    setDomain(string path):如果设固一级域名相同，那么多个服务器之间cookie可以共享</p>
<p>​    setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p>
<p>5.cookie的特点和作用</p>
<p>​    1.cookie存储数据在客户端浏览器</p>
<p>​    2.浏览器对于单个cookie 的大小有限制(akb)以及对同一个域名下的总cookie数量也有限制(20个)</p>
<p>*作用:</p>
<p>​    1.cookie—般用于存出少量的不太敏感的数据</p>
<p>​    2．在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>6.案例:记住上一次访问时间</p>
<p>1，需求∶</p>
<p>​    1．访问一个servlet，如果是第一次访问，则提示:您好，欢迎您首次访问。</p>
<p>​    2．如果不是第一次访问，则提示:欢迎回来，您上次访问时间为;显示时间字符串</p>
<p>2．分析∶</p>
<p>​    1．可以采用cookie来完成</p>
<p>​    2．在服务器中的servlet判断是否有一个名为lastTime的cookie</p>
<p>​        1.有:不是第一次访向</p>
<p>1.响应数据∶欢迎回来，您上次访问时间为:2018年6月10日11:50:20</p>
<p>2.写回cookie : lastTime=2018年6月1e日11:50:e1</p>
<p>2．没有∶是第一次访问</p>
<p>1．响应数据:您好，欢迎您首次访问</p>
<p>2．写回cookie : lastTime=2018年6月16日11: 50:01</p>
<h2 id="20-JSP-入门学习"><a href="#20-JSP-入门学习" class="headerlink" title="20.JSP:入门学习"></a>20.JSP:入门学习</h2><p>1.概念∶Java Server Pages : java服务器端页面</p>
<p>​    可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</p>
<p>​    用于简化书写!!!</p>
<p>2.原理</p>
<p>JSP本质上就是一个servlet</p>
<p>3.JSP的脚本:JSP定义ava代码的方式</p>
<p>​    1.&lt;% 代码 %&gt;:定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。成员变量范围小</p>
<p>​    2.&lt;%! 代码 %&gt;∶定义的java代码，在jsp转换后的java类的成员位置。成员变量范围大，全局。</p>
<p>​    3.&lt;%= 代码 %&gt;∶定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</p>
<p>4.JSP的内置对象</p>
<p>在jsp页面中不需要获取和创建，可以直接使用的对象</p>
<p>jsp一共有9个内置对象。</p>
<p>​    request</p>
<p>​    response</p>
<p>​    out:字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似</p>
<p>​    response. getwriter(和out.write()的区别:</p>
<p>​    在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</p>
<p>​    response.getwriter()数据输出永远在out.write()之前</p>
<h2 id="21-Session"><a href="#21-Session" class="headerlink" title="21.Session"></a>21.Session</h2><p>1．概念∶服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<p>2．快速入门:</p>
<p>1．获取Httpsession对象︰</p>
<p>​    Httpsession session = request.getsession();</p>
<p>2．使用Httpsession对象∶</p>
<p>​    object getAttribute(string name)</p>
<p>​    void setAttribute(string name，object value)</p>
<p>​    void removeAttribute(string name)</p>
<p>3．原理</p>
<p>​    session的实现是依赖于cookie的。</p>
<p>4。细节∶</p>
<p>1．当客户端关闭后，服务器不关闭，两次获取session是否为同一个?</p>
<p>默认情况下。不是。</p>
<p>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p>
<p>​    Cookie c = new Cookie(“SESSIONID” , session.getId());</p>
<p>​    c .setMaxAge(60*60);</p>
<p>​    response.addcookie(c);</p>
<p>2．客户端不关闭，服务器关闭后，两次获取的session是同一个吗?</p>
<p>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</p>
<p>session的钝化:</p>
<p>​    在服务器正常关闭之前，将Session对象序列化到硬盘上 </p>
<p>session的活化:</p>
<p>​    在服务器启动后，将session文件转化为内存中的session对象即可。</p>
<p>3.session什么时候被销毁?</p>
<p>​    1.服务器关闭</p>
<p>​    2.session对象调用invalidate() 。</p>
<p>​    3.session默认失效时间30分钟</p>
<p>​        选择性配置修改</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">	&lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>4.session的特点</p>
<p>1.session用于存储一次会话的多次请求的数据，存在服务器端</p>
<p>2.session可以存储任意类型，任意大小的数据</p>
<p>session与cookie的区别︰</p>
<p>​    1.session存储数据在服务器端，Cookie在客户端</p>
<p>​    2.session没有数据大小限制,Cookie有</p>
<p>​    3.session数据安全,cookie相对于不安全</p>
<h2 id="21JSP"><a href="#21JSP" class="headerlink" title="21JSP"></a>21JSP</h2><p>1.指令</p>
<p>作用:用于配置JSP页面，导入资源文件</p>
<p>格式∶&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;</p>
<p>分类∶</p>
<p>1.page:配置SP页面的</p>
<p>​    contentType :等同于response.setcontentType()</p>
<p>​    1．设置响应体的mime类型以及字符集</p>
<p>​    2．设置当前jsp页面的编码（只能是高级的IDE才能生效，</p>
<p>​        如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集)</p>
<p>​    import :导包</p>
<p>​    errorPage :当前页面发生异常后，会自动跳转到指定的错误页面</p>
<p>​    isErrorPage :标识当前页面是否是错误页面。</p>
<p>​        *true :是，可以使用内置对象exception.getMessage()</p>
<p>​        *false :否。默认值。不可以使用内置对象exception</p>
<p>2.include:页面包含的。导入页面的资源文件</p>
<p>*&lt;%@include file=”top.jsp”%&gt;</p>
<p>3.taglib:导入资源</p>
<p>​    *&lt;%taglib prefix=”c” uri=”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p>
<p>​    *prefix:前缀，自定义的</p>
<p>2．注释:</p>
<p>1.html注释:</p>
<p>​    <!-- -->:只能注释html代码片段</p>
<p>\2. jsp注释∶推荐使用</p>
<p>​    &lt;%— —%&gt;∶可以注释所有</p>
<p>3．内置对象</p>
<p>​    在jsp页面中不需要创建，直接使用的对象</p>
<p>一共有9个:</p>
<p>变量名真实类型作用</p>
<p>​    pageContextPagecontext当前页面共享数据，还可以获取其他八个内置对象</p>
<p>​    requestHttpservletRequest一次请求访问的多个资源(转发)</p>
<p>​    sessionHttpSession一次会话的多个请求间</p>
<p>​    applicationServletContext所有用户间共享数据</p>
<p>​    responseHttpservletResponse响应对象</p>
<p>​    pageObject当前页面(Servlet)的对象this</p>
<p>​    outJspWriter输出对象，数据输出到页面上</p>
<p>​    configServletConfigservlet的配置对象</p>
<p>​    exceptionThrowable异常对象</p>
<h2 id="22-MVC-开发模式"><a href="#22-MVC-开发模式" class="headerlink" title="22.MVC:开发模式"></a>22.MVC:开发模式</h2><p>1.M : Model，模型。JavaBean</p>
<p>​    完成具体的业务操作，如:查询数据库，封装对象</p>
<p>2.V : View，视图。JSP</p>
<p>​    展示数据</p>
<p>3.C: Controller，控制器。Servlet</p>
<p>​    获取用户的输入</p>
<p>调用模型</p>
<p>将数据交给视图进行展示</p>
<p>*优缺点︰</p>
<p>1．优点:</p>
<p>​    1．耦合性低，方便维护，可以利于分工协作</p>
<p>​    2．重用性高</p>
<p>2．缺点∶</p>
<p>​    1．使得项目架构变得复杂，对开发人员要求高</p>
<h2 id="23-EL表达式"><a href="#23-EL表达式" class="headerlink" title="23.EL表达式"></a>23.EL表达式</h2><p>1.概念∶Expression Language表达式语言</p>
<p>2.作用:替换和简化jsp页面中java代码的编写</p>
<p>3.语法∶${表达式}</p>
<p>4.注意:</p>
<p>​    jsp默认支持el表达式的。如果要忽略el表达式</p>
<p>​    1.设置jsp中page指令中:isELIgnored=”true”忽略当前jsp页面中所有的el表达式</p>
<p>​    \2. ${表达式}∶忽略当前这个el表达式</p>
<p>5.使用∶</p>
<p>1.运算:</p>
<p>运算符:</p>
<p>​    1.算数运算符∶+ -  * /(div) %(mod)</p>
<p>​    2.比较运算符∶&gt; &lt; &gt;= &lt;= == !=</p>
<p>​    3.逻辑运算符:&amp;&amp;(and) ll(or)  !(not)</p>
<p>​    4.空运算符: empty</p>
<p>​        功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0</p>
<p>​        ${empty list}  list集合内是否为null</p>
<p>​           ${not empty str}判断字符串、集合、数组是否不为null并且长度大于0 </p>
<p>2.获取值</p>
<p>1.el表达式只能从域对象中获取值</p>
<p>2.语法:</p>
<p>​    1.${域名称.键名}∶从指定域中获取指定键的值</p>
<p>​    域名称:</p>
<p>​        1.pagescope—&gt; pagecontext小</p>
<p>​        2.requestScope—&gt; request</p>
<p>​        3.sessionscope—&gt; session</p>
<p>​        4.applicationscope —&gt; application(servletcontext)大</p>
<p>​        举例:在request域中存储了 name=张三</p>
<p>​        获取∶${requestScope. name}</p>
<p>2.$({键名}∶表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p>
<p>3.获取对象、List集合、 Map集合的值</p>
<p>​    1.对象∶${域名称.键名.属性名}</p>
<p>​      ${requestScope.u.birthday}</p>
<p>​    本质上会去调用对象的getter方法</p>
<p>2.List集合∶${域名称.键名[索引]}</p>
<p>3.Map集合:</p>
<p>​    1.$[域名称.键名.key名称}</p>
<p>​    2.$[域名称.键名[“key名称“]</p>
<p>​    3.隐式对象∶</p>
<p>​        el表达式中有11个隐式对象</p>
<p>​        pagecontext :获取jsp其他八个内置对象</p>
<p>​        ${pagecontext.request.contextPath} :动态获取虚拟目录</p>
<h2 id="24-JSTL"><a href="#24-JSTL" class="headerlink" title="24.JSTL"></a>24.JSTL</h2><p>1.概念:JavaServer Pages Tag Library  JSP标准标签库</p>
<p>​    是由Apache组织提供的开源的免费的jsp标签&lt;标签&gt;</p>
<p>2.作用:用于简化和替换jsp页面上的java代码</p>
<p>3.使用步骤:</p>
<p>​    1.导入jstl相关jar包</p>
<p>​    2.引入标签库:taglib指令:&lt;%@taglib %&gt;</p>
<p>​    3.使用标签</p>
<p>​    4.常用的JSTL标签</p>
<p>​        1.if:相当于java代码的if语句</p>
<p>​            1.属性:</p>
<p>​                test 必须属性，接受boolean表达式</p>
<p>​                    如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p>
<p>​                    一般情况下, test展性值会结合el表达式一起使用</p>
<p>​            2．注意∶</p>
<p>​                c :if标签没有else情况，想要else情况，则可以在定义一个c:if标签</p>
<p>​        2.choose:相当于java代码的switch语句</p>
<p>​            1.使用choose标签声明相当于switch声明</p>
<p>​            2.使用when标签做判断相当于case</p>
<p>​            3.使用otherwise标签做其他情况的声明相当于default</p>
<p>​        3.foreach:相当于java代码的for语句</p>
<p>​            1.完成重复的操作</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt; 10; i ++){</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​        属性:</p>
<p>​            begin:开始值</p>
<p>​            end:结束值</p>
<p>​            var:临时变量</p>
<p>​            step:步长</p>
<p>​            varStatus :循环状态对象</p>
<p>​            index:容器中元素的索引，从0开始</p>
<p>​            count:循环次数，从1开始</p>
<p>​    2.遍历容器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list;</span><br><span class="line">for( User user : list){</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​    属性:</p>
<p>​        items:容器对象</p>
<p>​        var :容器中元素的临时变量</p>
<p>​        varStatus :循环状态对象</p>
<p>​        index:容器中元素的索引，从0开始</p>
<p>​        count:循环次数，从1开始</p>
<p>三层架构∶软件设计架构</p>
<p>1．界面层(表示层)∶用户看的得界面。用户可以通过界面上的组件和服务器进行交互cn.itcast.项目名.web</p>
<p>2．业务逻辑层∶处理业务逻辑的。cn.itcast.项目名.service</p>
<p>3．数据访问层:操作数据存储文件。cn.itcast.项目名.dao</p>
<h2 id="25-Filter-过滤器"><a href="#25-Filter-过滤器" class="headerlink" title="25.Filter:过滤器"></a>25.Filter:过滤器</h2><p>1.概念:</p>
<p>生活中的过滤器:净水器,空气净化器，士匪、</p>
<p>web中的过滤器﹔当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</p>
<p>过滤器的作用:</p>
<p>​    一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤…</p>
<p>2.快速入门:</p>
<p>1.步骤:</p>
<p>​    1.定义干个类，实现接口Filter</p>
<p>​    2.复写方法</p>
<p>​    3.配置拦截路释</p>
<p>​        1.web.xml</p>
<p>​        2.注解@WebFilter(“/*”) //访问所有资源之前，都会执行该过滤器</p>
<p>​        3.过滤器细节:</p>
<p>1.web.xml配置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">	&lt;!--拦截路径--&gt;</span><br><span class="line">	&lt;url-pattern&gt;/*&lt;/ url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>2.过滤器执行流程</p>
<p>​    1.执行过滤器</p>
<p>​    2.执行放行后的资源</p>
<p>​    3.回来执行过滤器放行代码下边的代码</p>
<p>3.过滤器生命周期对法</p>
<p>​    1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</p>
<p>​    2.doFilter:每一次请求被拦截资源时，会执行。执行多次</p>
<p>​    3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</p>
<p>4.过滤器配置详解</p>
<p>拦截路径配置:</p>
<p>​    1.具体资源路径: /index.jsp 只有访问index.jsp资源时，过滤器才会被执行</p>
<p>​    2.拦截目录: /user/ 访问/user下的所有资源时，过滤器都会被执行</p>
<p>​    3.后缀名拦截: *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行</p>
<p>​    4.拦截所有资源: /* 访问所有资源时，过滤器都会被执行</p>
<p>拦截方式配置:资源被访问的方式</p>
<p>注解配置∶</p>
<p>设置dispatcherTypes属性</p>
<p>​    1.REQUEST:默认值。浏览器直接请求资源</p>
<p>​    2.FORWARD∶转发访问资源</p>
<p>​    3.INCLUDE:包含访问资源</p>
<p>​    4.ERROR:错误跳转资源</p>
<p>​    5.ASYNC:异步访问资源</p>
<p>web.xml配置</p>
<p>*设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签即可</p>
<p>5.过滤器链(配置多个过滤器)</p>
<p>执行顺序:如果有两个过滤器∶过滤器1和过滤器2</p>
<p>​    1．过滤器1</p>
<p>​    2．过滤器2</p>
<p>​    3．资源执行</p>
<p>​    4．过滤器2</p>
<p>​    5．过滤器1</p>
<p>过滤器先后顺序问题:</p>
<p>1．注解配置:按照类名的字符串比较规则比较，值小的先执行</p>
<p>​    Demo6大于Demo176大于1</p>
<p>​    Demo6大于Demo76小于7</p>
<p>*如:AFilter和BFilter,AFilter就先执行了。</p>
<p>\2. web.xml配置: <code>&lt;filter-mapping&gt;</code>谁定义在上边，谁先执行</p>
<p>增强对象的功能:</p>
<p>设计模式:一些通用的解决固定问题的方式</p>
<p>​    1．装饰模式</p>
<p>​    2．代理模式</p>
<p>概念:</p>
<p>​    1．真实对象:被代理的对象</p>
<p>​    2．代理对象:</p>
<p>​    3．代理模式:代理对象代理真实对象，达到增强真实对象功能的目的</p>
<p>实现方式:</p>
<p>​    1．静态代理:有一个类文件描述代理模式</p>
<p>​    2．动态代理:在内存中形成代理类</p>
<p>*实现步骤:</p>
<p>​    1．代理对象和真实对象实现相同的接口</p>
<p>​    2．代理对象= Proxy.newInstance();</p>
<p>​    3，使用代理对象调用方法。</p>
<p>​    4．增强方法</p>
<p>增强方式:</p>
<p>​    1．增强参数列表</p>
<p>​    2．增强返回值类型</p>
<p>​    3，增强方法体执行逻辑</p>
<h2 id="26-Listener-监听器"><a href="#26-Listener-监听器" class="headerlink" title="26.Listener :监听器"></a>26.Listener :监听器</h2><p>*概念: web的三大组件之一。</p>
<p>事件监听机制</p>
<p>​    事件:一件事情</p>
<p>​    事件源:事件发生的地方</p>
<p>​    监听器:一个对象</p>
<p>​    注册监听︰将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码</p>
<p>ServletContextListener:监听servletcontext对象的创建和销毁</p>
<p>方法:</p>
<p>​    void contextDestroyed(servletContextEvent sce) : servletContext对象被销毁之前会调用该方法</p>
<p>​    void contextInitialized(ServletContextEvent sce) : servletContext对象创建后会调用该方法</p>
<p>步骤︰</p>
<p>​    1.定义一个类，实现servletcontextListener接口</p>
<p>​    2.复写方法</p>
<p>​    3.配置</p>
<p>1.web.xml</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;cn.itcast.web.listener.contextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>*指定初始化参数<code>&lt;context-param&gt;</code></p>
<p>2.注解∶</p>
<p>@webListener</p>
<p>Query基础:</p>
<p>1.概念∶一个Javascript框架。简化js开发</p>
<p>​    JQuery是一个快速、简洁的Javascript框架，是继Prototype之后又一个优秀的Javascript代码库(或Javascript框架)。JQuery设计的宗旨是”Write Less，Do More””，即倡导写更少的代码，做更多的事情。它封装Javascript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>
<p>​    Javascript框架:本质上就是一些js文件，封装了js的原生代码而已</p>
<p>2.快速入门：</p>
<p>1.步骤</p>
<p>1.下载JQuery</p>
<p>目前jQuery有三个大版本：</p>
<p>​    1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，</p>
<p>​        最终版本：1.12.4 (2016年5月20日)</p>
<p>​    2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，</p>
<p>​        最终版本：2.2.4 (2016年5月20日)</p>
<p>​    3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。</p>
<p>​        目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p>
<p>jquery-xxx.js与jquery-xxx.min.js区别:</p>
<p>​    1.jquery-xxx.js :开发版本。给程序员看的，有良好的缩进和注释。体积大一些</p>
<p>​    2.jquery-xxx.min.js :生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</p>
<p>2.导入JQuery的js文件:导入min.js文件</p>
<p>3.使用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let div1 = $("#div1");</span><br><span class="line">alert(div1.html());</span><br></pre></td></tr></tbody></table></figure>
<p>3.JQuery对象和js对象区别与转换</p>
<p>​    1.JQuery对象在操作时，更加方便。</p>
<p>​    2.JQuery对象和js对象方法不通用．</p>
<p>3．两者相互转换</p>
<p>​    jq — &gt; js : jq对象[索引]或者jq对象.get(索引)</p>
<p>​    js — &gt; jq : $(js对象)</p>
<p>4.选择器：筛选具有相似特征的元素(标签)</p>
<p>1.基本操作学习：</p>
<p>1.事件绑定</p>
<p>​    //1.获取b1按钮</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$("#b1").click(function(){ </span><br><span class="line">	alert("abc"); </span><br><span class="line">}); </span><br></pre></td></tr></tbody></table></figure>
<p>​    2.入口函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(function () {</span><br><span class="line">}); </span><br></pre></td></tr></tbody></table></figure>
<p>window.onload 和 $(function) 区别</p>
<p>​         window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 </p>
<p>​         $(function)可以定义多次的。 </p>
<p>​    3.样式控制：css方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//$("#div1").css("background-color","red");</span><br><span class="line">$("#div1").css("backgroundColor","pink");</span><br></pre></td></tr></tbody></table></figure>
<p>2.分类</p>
<p>1.基本选择器</p>
<p>​    1.标签选择器（元素选择器）</p>
<p>​        * 语法： $(“html标签名”) 获得所有匹配标签名称的元素</p>
<p>​    2.id选择器</p>
<p>​        * 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</p>
<p>​    3.类选择器</p>
<p>​        * 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</p>
<p>​    4.并集选择器：</p>
<p>​        * 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</p>
<p>2.层级选择器</p>
<p>​    1.后代选择器</p>
<p>​        * 语法： $(“A B “) 选择A元素内部的所有B元素</p>
<p>​    2.子选择器</p>
<p>​        * 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</p>
<p>​    3.属性选择器</p>
<p>​        1.属性名称选择器</p>
<p>​        * 语法： $(“A[属性名]”) 包含指定属性的选择器</p>
<ol>
<li>属性选择器</li>
</ol>
<p>​    * 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</p>
<ol>
<li>复合属性选择器</li>
</ol>
<p>​    * 语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</p>
<ol>
<li>过滤选择器</li>
</ol>
<p>​    1. 首元素选择器</p>
<p>​        * 语法： :first 获得选择的元素中的第一个元素</p>
<ol>
<li>尾元素选择器</li>
</ol>
<p>​        * 语法： :last 获得选择的元素中的最后一个元素</p>
<p>​    3. 非元素选择器</p>
<p>​        * 语法： :not(selector) 不包括指定内容的元素</p>
<p>​    4. 偶数选择器</p>
<p>​        * 语法： :even 偶数，从 0 开始计数</p>
<p>​    5. 奇数选择器</p>
<p>​        * 语法： :odd 奇数，从 0 开始计数</p>
<p>​    6. 等于索引选择器</p>
<p>​        * 语法： :eq(index) 指定索引元素</p>
<p>​    7. 大于索引选择器</p>
<p>​        * 语法： :gt(index) 大于指定索引元素</p>
<p>​    8. 小于索引选择器</p>
<p>​        * 语法： :lt(index) 小于指定索引元素</p>
<p>​    9. 标题选择器</p>
<p>​        * 语法： :header 获得标题（h1~h6）元素，固定写法</p>
<ol>
<li>表单过滤选择器</li>
</ol>
<p>​    1. 可用元素选择器</p>
<p>​        * 语法： :enabled 获得可用元素</p>
<p>​    2. 不可用元素选择器</p>
<p>​        * 语法： :disabled 获得不可用元素</p>
<p>​    3. 选中选择器</p>
<p>​        * 语法： :checked 获得单选/复选框选中的元素</p>
<p>​    4. 选中选择器</p>
<p>​        * 语法： :selected 获得下拉框选中的元素</p>
<ol>
<li><p>DOM操作</p>
</li>
<li><p>内容操作</p>
</li>
</ol>
<p>​        1. html(): 获取/设置元素的标签体内容  <a><font>内容</font></a> —&gt; <font>内容</font></p>
<p>​        2. text(): 获取/设置元素的标签体纯文本内容  <a><font>内容</font></a> —&gt; 内容</p>
<p>​        3. val()： 获取/设置元素的value属性值</p>
<ol>
<li>属性操作</li>
</ol>
<p>​    1. 通用属性操作</p>
<p>​        1. attr(): 获取/设置元素的属性</p>
<p>​        2. removeAttr():删除属性</p>
<p>​        3. prop():获取/设置元素的属性</p>
<p>​        4. removeProp():删除属性</p>
<p>​        * attr和prop区别？</p>
<p>​            1. 如果操作的是元素的固有属性，则建议使用prop</p>
<p>​            2. 如果操作的是元素自定义的属性，则建议使用attr</p>
<p>​    2. 对class属性操作</p>
<p>​        1. addClass():添加class属性值</p>
<p>​        2. removeClass():删除class属性值</p>
<p>​        3. toggleClass():切换class属性切换样式</p>
<p>​            * toggleClass(“one”):</p>
<p>​            * 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加</p>
<ol>
<li>css():</li>
</ol>
<p>​    3. CRUD操作:</p>
<p>​    1. append():父元素将子元素追加到末尾</p>
<ul>
<li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li>
</ul>
<p>​    2. prepend():父元素将子元素追加到开头</p>
<ul>
<li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li>
</ul>
<ol>
<li>appendTo():</li>
</ol>
<ul>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li>
</ul>
<ol>
<li>prependTo()：</li>
</ol>
<ul>
<li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li>
</ul>
<ol>
<li>after():添加元素到元素后边</li>
</ol>
<ul>
<li>对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>before():添加元素到元素前边</li>
</ol>
<ul>
<li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>insertAfter()</li>
</ol>
<ul>
<li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>insertBefore()</li>
</ol>
<ul>
<li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li>
</ul>
<ol>
<li>remove():移除元素</li>
</ol>
<ul>
<li>对象.remove():将对象删除掉</li>
</ul>
<ol>
<li>empty():清空元素的所有后代元素。</li>
</ol>
<ul>
<li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点里面的东西没了  标签还在</li>
</ul>
<h2 id="27-JQuery-高级"><a href="#27-JQuery-高级" class="headerlink" title="27.JQuery 高级"></a>27.JQuery 高级</h2><ol>
<li>动画</li>
</ol>
<p>​    1.三种方式显示和隐藏元素</p>
<p>​        1.默认显示和隐藏方式</p>
<p>​            1.show([speed],[easing],[fn]])</p>
<p>​                1.参数：</p>
<p>​                    1.speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</p>
<p>​                    2.easing：用来指定切换效果，默认是”swing”，可用参数”linear”</p>
<p>​                        *swing：动画执行时效果是 先慢，中间快，最后又慢</p>
<p>​                        *linear：动画执行时速度是匀速的</p>
<p>​                    3.fn：在动画完成时执行的函数，每个元素执行一次。</p>
<p>​            2.hide([speed],[easing],[fn]])</p>
<p>​            3.toggle([speed],[easing],[fn])</p>
<p>​    2.滑动显示和隐藏方式</p>
<p>​        1.slideDown([speed],[easing],[fn])</p>
<p>​        2.slideUp([speed],[easing],[fn]])</p>
<p>​        3.slideToggle([speed],[easing],[fn])</p>
<p>​    3.淡入淡出显示和隐藏方式</p>
<p>​        1.fadeIn([speed],[easing],[fn])</p>
<p>​        2.fadeOut([speed],[easing],[fn])</p>
<p>​        3.fadeToggle([speed],[easing],[fn]])</p>
<p>2.遍历</p>
<p>1.js的遍历方式</p>
<p>​    * for(初始化值;循环结束条件;步长)</p>
<p>2.jq的遍历方式</p>
<p>​    1.jq对象.each(callback)</p>
<p>​        1.语法：</p>
<p>​            jquery对象.each(function(index,element){});</p>
<p>​                * index:就是元素在集合中的索引</p>
<p>​                * element：就是集合中的每一个元素对象</p>
<p>​                * this：集合中的每一个元素对象</p>
<p>​        2.回调函数返回值：</p>
<p>​            * true:如果当前function返回为false，则结束循环(break)。</p>
<p>​            * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</p>
<p>​    2.$.each(object, [callback])</p>
<p>​    3.for..of: jquery 3.0 版本之后提供的方式</p>
<p>​            for(元素对象 of 容器对象)</p>
<p>​    3. 事件绑定</p>
<p>​        1. jquery标准的绑定方式</p>
<p>​            * jq对象.事件方法(回调函数)；</p>
<p>​            * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。</p>
<p>​                * 表单对象.submit();//让表单提交</p>
<p>​        2. on绑定事件/off解除绑定</p>
<p>​            * jq对象.on(“事件名称”,回调函数)</p>
<p>​            * jq对象.off(“事件名称”)</p>
<p>​                * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</p>
<p>​        3. 事件切换：toggle</p>
<p>​            * jq对象.toggle(fn1,fn2…)</p>
<p>​                * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..     </p>
<p>​            * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p>
<p>​                 </p>
<p>​    4. 插件：增强JQuery的功能</p>
<p>​        1. 实现方式：</p>
<p>​            1. $.fn.extend(object) </p>
<p>​                * 增强通过Jquery获取的对象的功能  $(“#id”)</p>
<p>​            2. $.extend(object)</p>
<p>​                * 增强JQeury对象自身的功能  $/jQuery</p>
<h2 id="28-AJAX"><a href="#28-AJAX" class="headerlink" title="28.AJAX"></a>28.AJAX</h2><p>​    1. 概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p>
<p>​        1. 异步和同步：客户端和服务器端相互通信的基础上</p>
<p>​            * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</p>
<p>​            * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p>
<p>​            Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] </p>
<p>​            通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>​            传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p>
<p>​            提升用户的体验</p>
<p>​    2. 实现方式：</p>
<p>\1. 原生的JS实现方式（了解）</p>
<p>\2. JQeury实现方式</p>
<p>​            1. $.ajax()</p>
<p>​                * 语法：$.ajax({键值对});</p>
<p>​                 //使用$.ajax()发送异步请求</p>
<p>​            2. $.get()：发送get请求</p>
<p>​                * 语法：$.get(url, [data], [callback], [type])</p>
<p>​                    * 参数：</p>
<p>​                        * url：请求路径</p>
<p>​                        * data：请求参数</p>
<p>​                        * callback：回调函数</p>
<p>​                        * type：响应结果的类型</p>
<p>​            3. $.post()：发送post请求</p>
<p>​                * 语法：$.post(url, [data], [callback], [type])</p>
<p>​                    * 参数：</p>
<p>​                        * url：请求路径</p>
<p>​                        * data：请求参数</p>
<p>​                        * callback：回调函数</p>
<p>​                        * type：响应结果的类型</p>
<h2 id="29-JSON"><a href="#29-JSON" class="headerlink" title="29.JSON"></a>29.JSON</h2><p>​    1. 概念： JavaScript Object Notation        JavaScript对象表示法</p>
<p>​        * json现在多用于存储和交换文本信息的语法</p>
<p>​        * 进行数据的传输</p>
<p>​        * JSON 比 XML 更小、更快，更易解析。</p>
<p>​    2. 语法：</p>
<p>​        1. 基本规则</p>
<p>​            * 数据在名称/值对中：json数据是由键值对构成的</p>
<p>​                * 键用引号(单双都行)引起来，也可以不使用引号</p>
<p>​                * 值得取值类型：</p>
<p>​                    1. 数字（整数或浮点数）</p>
<p>​                    2. 字符串（在双引号中）</p>
<p>​                    3. 逻辑值（true 或 false）</p>
<p>​                    4. 数组（在方括号中）    {“persons”:[{},{}]}</p>
<p>​                    5. 对象（在花括号中） {“address”:{“province”：”陕西”….}}</p>
<p>​                    6. null</p>
<p>​            * 数据由逗号分隔：多个键值对由逗号分隔</p>
<p>​            * 花括号保存对象：使用{}定义json 格式</p>
<p>​            * 方括号保存数组：[]</p>
<p>​        2. 获取数据:</p>
<p>​            1. json对象.键名</p>
<p>​            2. json对象[“键名”]</p>
<p>​            3. 数组对象[索引]</p>
<p>​            4. 遍历</p>
<p>​    3. JSON数据和Java对象的相互转换</p>
<p>​        * JSON解析器：</p>
<p>​            * 常见的解析器：Jsonlib，Gson，fastjson，jackson</p>
<p>​        1. JSON转为Java对象</p>
<p>​            1. 导入jackson的相关jar包</p>
<p>​            2. 创建Jackson核心对象 ObjectMapper</p>
<p>​            3. 调用ObjectMapper的相关方法进行转换</p>
<p>​                1. readValue(json字符串数据,Class)</p>
<p>​        2. Java对象转换JSON</p>
<p>​            1. 使用步骤：</p>
<p>​                1. 导入jackson的相关jar包</p>
<p>​                2. 创建Jackson核心对象 ObjectMapper</p>
<p>​                3. 调用ObjectMapper的相关方法进行转换</p>
<p>​                    1. 转换方法：</p>
<p>​                        * writeValue(参数1，obj):</p>
<p>​                            参数1：</p>
<p>​                                File：将obj对象转换为JSON字符串，并保存到指定的文件中</p>
<p>​                                Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</p>
<p>​                                OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</p>
<p>​                        * writeValueAsString(obj):将对象转为json字符串</p>
<p>​                    2. 注解：</p>
<p>​                        1. @JsonIgnore：排除属性。</p>
<p>​                        2. @JsonFormat：属性值得格式化</p>
<p>​                            * @JsonFormat(pattern = “yyyy-MM-dd”)</p>
<p>​                    3. 复杂java对象转换</p>
<p>​                        1. List：数组</p>
<p>​                        2. Map：对象格式一致</p>
<p>校验用户名是否存在</p>
<p>​        1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：</p>
<p>​            1. $.get(type):将最后一个参数type指定为”json”</p>
<p>​            2. 在服务器端设置MIME类型</p>
<p>​                response.setContentType(“application/json;charset=utf-8”);</p>
<h2 id="30-Redis"><a href="#30-Redis" class="headerlink" title="30.Redis"></a>30.Redis</h2><p>​    1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库</p>
<p>1.1.什么是NOSQL</p>
<p>​            NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>​            NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<p>​            1.1.1.    NOSQL和关系型数据库比较</p>
<p>​                优点：</p>
<p>​                    1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</p>
<p>​                    2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</p>
<p>​                    3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</p>
<p>​                    4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p>​                缺点：</p>
<p>​                    1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</p>
<p>​                    2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</p>
<p>​                    3）不提供关系型数据库对事务的处理。</p>
<p>​            1.1.2.    非关系型数据库的优势：</p>
<p>​                1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p>
<p>​                2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<p>​            1.1.3.    关系型数据库的优势：</p>
<p>​                1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
<p>​                2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<p>​            1.1.4.    总结</p>
<p>​                关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。</p>
<p>​                一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<p>​        1.2.主流的NOSQL产品</p>
<p>​            •    键值(Key-Value)存储数据库</p>
<p>​                    相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p>
<p>​                    典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </p>
<p>​                    数据模型： 一系列键值对</p>
<p>​                    优势： 快速查询</p>
<p>​                    劣势： 存储的数据缺少结构化</p>
<p>​            •    列存储数据库</p>
<p>​                    相关产品：Cassandra, HBase, Riak</p>
<p>​                    典型应用：分布式的文件系统</p>
<p>​                    数据模型：以列簇式存储，将同一列数据存在一起</p>
<p>​                    优势：查找速度快，可扩展性强，更容易进行分布式扩展</p>
<p>​                    劣势：功能相对局限</p>
<p>​            •    文档型数据库</p>
<p>​                    相关产品：CouchDB、MongoDB</p>
<p>​                    典型应用：Web应用（与Key-Value类似，Value是结构化的）</p>
<p>​                    数据模型： 一系列键值对</p>
<p>​                    优势：数据结构要求不严格</p>
<p>​                    劣势： 查询性能不高，而且缺乏统一的查询语法</p>
<p>​            •    图形(Graph)数据库</p>
<p>​                    相关数据库：Neo4J、InfoGrid、Infinite Graph</p>
<p>​                    典型应用：社交网络</p>
<p>​                    数据模型：图结构</p>
<p>​                    优势：利用图结构相关算法。</p>
<p>​                    劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<p>​        1.3 什么是Redis</p>
<p>​            Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<p>​                1) 字符串类型 string</p>
<p>​                2) 哈希类型 hash</p>
<p>​                3) 列表类型 list</p>
<p>​                4) 集合类型 set</p>
<p>​                5) 有序集合类型 sortedset</p>
<p>​            1.3.1 redis的应用场景</p>
<p>​                •    缓存（数据查询、短连接、新闻内容、商品内容等等）</p>
<p>​                •    聊天室的在线好友列表</p>
<p>​                •    任务队列。（秒杀、抢购、12306等等）</p>
<p>​                •    应用排行榜</p>
<p>​                •    网站访问统计</p>
<p>​                •    数据过期处理（可以精确到毫秒</p>
<p>​                •    分布式集群架构中的session分离</p>
<p>​    2. 下载安装</p>
<p>​        1. 官网：<a target="_blank" rel="noopener" href="https://redis.io">https://redis.io</a></p>
<p>​        2. 中文网：<a target="_blank" rel="noopener" href="http://www.redis.net.cn/">http://www.redis.net.cn/</a></p>
<p>​        3. 解压直接可以使用：</p>
<p>​            * redis.windows.conf：配置文件</p>
<p>​            * redis-cli.exe：redis的客户端</p>
<p>​            * redis-server.exe：redis服务器端</p>
<p>​    3. 命令操作</p>
<p>​        1. redis的数据结构：</p>
<p>​            * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p>
<p>​                * value的数据结构：</p>
<p>​                    1) 字符串类型 string</p>
<p>​                    2) 哈希类型 hash ： map格式  </p>
<p>​                    3) 列表类型 list ： linkedlist格式。支持重复元素</p>
<p>​                    4) 集合类型 set  ： 不允许重复元素</p>
<p>​                    5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p>
<p>​        2. 字符串类型 string</p>
<p>​            1. 存储： set key value</p>
<p>​                127.0.0.1:6379&gt; set username zhangsan</p>
<p>​                OK</p>
<p>​            2. 获取： get key</p>
<p>​                127.0.0.1:6379&gt; get username</p>
<p>​                “zhangsan”</p>
<p>​            3. 删除： del key</p>
<p>​                127.0.0.1:6379&gt; del age</p>
<p>​                (integer) 1</p>
<p>​        3. 哈希类型 hash</p>
<p>​            1. 存储： hset key field value</p>
<p>​                127.0.0.1:6379&gt; hset myhash username lisi</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; hset myhash password 123</p>
<p>​                (integer) 1</p>
<p>​            2. 获取： </p>
<p>​                * hget key field: 获取指定的field对应的值</p>
<p>​                    127.0.0.1:6379&gt; hgetall myhash</p>
<p>​                    1) “username”</p>
<p>​                    2) “lisi”</p>
<p>​                    3) “password”</p>
<p>​                    4) “123” </p>
<p>​            3. 删除： hdel key field</p>
<p>​                127.0.0.1:6379&gt; hdel myhash username</p>
<p>​                (integer) 1</p>
<p>​        4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>​            1. 添加：</p>
<p>​                1. lpush key value: 将元素加入列表左表</p>
<p>​                2. rpush key value：将元素加入列表右边</p>
<p>​                    127.0.0.1:6379&gt; lpush myList a</p>
<p>​                    (integer) 1</p>
<p>​                    127.0.0.1:6379&gt; lpush myList b</p>
<p>​                    (integer) 2</p>
<p>​                    127.0.0.1:6379&gt; rpush myList c</p>
<p>​                    (integer) 3</p>
<p>​            2. 获取：</p>
<p>​                * lrange key start end ：范围获取</p>
<p>​                    127.0.0.1:6379&gt; lrange myList 0 -1</p>
<p>​                    1) “b”</p>
<p>​                    2) “a”</p>
<p>​                    3) “c”</p>
<p>​            3. 删除：</p>
<p>​                * lpop key： 删除列表最左边的元素，并将元素返回</p>
<p>​                * rpop key： 删除列表最右边的元素，并将元素返回</p>
<p>​        5. 集合类型 set ： 不允许重复元素</p>
<p>​            1. 存储：sadd key value</p>
<p>​                127.0.0.1:6379&gt; sadd myset a</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; sadd myset a</p>
<p>​                (integer) 0</p>
<p>​            2. 获取：smembers key:获取set集合中所有元素</p>
<p>​                127.0.0.1:6379&gt; smembers myset</p>
<p>​                1) “a”</p>
<p>​            3. 删除：srem key value:删除set集合中的某个元素    </p>
<p>​                127.0.0.1:6379&gt; srem myset a</p>
<p>​                (integer) 1</p>
<p>​        6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>​            1. 存储：zadd key score value</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 60 zhangsan</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 50 lisi</p>
<p>​                (integer) 1</p>
<p>​                127.0.0.1:6379&gt; zadd mysort 80 wangwu</p>
<p>​                (integer) 1</p>
<p>​            2. 获取：zrange key start end [withscores]</p>
<p>​                127.0.0.1:6379&gt; zrange mysort 0 -1</p>
<p>​                1) “lisi”</p>
<p>​                2) “zhangsan”</p>
<p>​                3) “wangwu”</p>
<p>​                127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</p>
<p>​                1) “zhangsan”</p>
<p>​                2) “60”</p>
<p>​                3) “wangwu”</p>
<p>​                4) “80”</p>
<p>​                5) “lisi”</p>
<p>​                6) “500”</p>
<p>​            3. 删除：zrem key value</p>
<p>​                127.0.0.1:6379&gt; zrem mysort lisi</p>
<p>​                (integer) 1</p>
<p>​        7. 通用命令</p>
<p>​            1. keys * : 查询所有的键</p>
<p>​            2. type key ： 获取键对应的value的类型</p>
<p>​            3. del key：删除指定的key value</p>
<p>​    4. 持久化</p>
<p>​        1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p>
<p>​        2. redis持久化机制：</p>
<p>​            1. RDB：默认方式，不需要进行配置，默认就使用这种机制</p>
<p>​                * 在一定的间隔时间中，检测key的变化情况，然后持久化数据</p>
<p>​                1. 编辑redis.windwos.conf文件</p>
<p>​                    #   after 900 sec (15 min) if at least 1 key changed</p>
<p>​                    save 900 1</p>
<p>​                    #   after 300 sec (5 min) if at least 10 keys changed</p>
<p>​                    save 300 10</p>
<p>​                    #   after 60 sec if at least 10000 keys changed</p>
<p>​                    save 60 10000</p>
<p>​                    </p>
<p>​                2. 重新启动redis服务器，并指定配置文件名称</p>
<p>​                    D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf    </p>
<p>​                </p>
<p>​            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p>
<p>​                1. 编辑redis.windwos.conf文件</p>
<p>​                    appendonly no（关闭aof） —&gt; appendonly yes （开启aof）</p>
<p>​                    </p>
<p>​                    # appendfsync always ： 每一次操作都进行持久化</p>
<p>​                    appendfsync everysec ： 每隔一秒进行一次持久化</p>
<p>​                    # appendfsync no     ： 不进行持久化</p>
<h2 id="31-Java客户端-Jedis"><a href="#31-Java客户端-Jedis" class="headerlink" title="31.Java客户端 Jedis"></a>31.Java客户端 Jedis</h2><p>​        * Jedis: 一款java操作redis数据库的工具.</p>
<p>​        * 使用步骤：</p>
<p>​            1. 下载jedis的jar包</p>
<p>​            2. 使用</p>
<p>​                //1. 获取连接</p>
<p>​                Jedis jedis = new Jedis(“localhost”,6379);</p>
<p>​                   //2. 操作</p>
<p>​                   jedis.set(“username”,”zhangsan”);</p>
<p>​                //3. 关闭连接</p>
<p>​                jedis.close();</p>
<p>​        * Jedis操作各种redis中的数据结构</p>
<p>​            1) 字符串类型 string</p>
<p>​                set</p>
<p>​                get </p>
<p>​                  //可以使用setex()方法存储可以指定过期时间的 key value</p>
<p>​                jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</p>
<p>​            2) 哈希类型 hash ： map格式  </p>
<p>​                hset</p>
<p>​                hget</p>
<p>​                hgetAll</p>
<p>​               3) 列表类型 list ： linkedlist格式。支持重复元素</p>
<p>​                lpush / rpush</p>
<p>​                lpop / rpop</p>
<p>​                lrange start end : 范围获取</p>
<p>​    4) 集合类型 set  ： 不允许重复元素</p>
<p>​                sadd</p>
<p>​                smembers:获取所有元素</p>
<p>​            5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p>
<p>​                zadd</p>
<p>​                zrange</p>
<p>注意：使用redis缓存一些不经常发生变化的数据。</p>
<p>​            * 数据库的数据一旦发生改变，则需要更新缓存。</p>
<p>​            * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</p>
<p>​            * 在service对应的增删改方法中，将redis数据删除。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘晗宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://putongl.github.io/JavaWeb.html">http://putongl.github.io/JavaWeb.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://putongl.github.io" target="_blank">普通LのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaWeb/">JavaWeb</a></div><div class="post_share"><div class="social-share" data-image="/img/bizhi2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/javaSE.html"><img class="prev-cover" src="/img/bizhi16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">javaSE</div></div></a></div><div class="next-post pull-right"><a href="/centos7%E5%BC%80%E6%94%BE%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3.html"><img class="next-cover" src="/img/bizhi9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">centos7开放及查看端口</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"><div class="author-info__name">刘晗宇</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/putongl"><i class="fab fa-github"></i><span>Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/putongl" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liu15373992353@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">各</font> <font color="#e66d98">花</font> <font color="#e66cc6">各</font> <font color="#cc6de6">有</font> <font color="#9770e6">各</font> <font color="#6d93e6">花</font> <font color="#6fcde6">香</font> <p align="center"><img src="/img/cebian.gif"></p> <p align="center">邮箱:shuai132325@gmail.com</p> <p align="center">QQ号:1826627978</p></b></div><b><timing></timing></b></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><b><i class="fas fa-stream"></i><span>目录</span></b></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><b><a class="toc-link" href="#JavaWeb"><span class="toc-number">1.</span> <span class="toc-text">JavaWeb</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Junit%E4%BD%BF%E7%94%A8-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.Junit使用:白盒测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%81%B5%E9%AD%82"><span class="toc-number">1.2.</span> <span class="toc-text">2.反射:框架设计的灵魂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">3.注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.</span> <span class="toc-text">4.数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JDBC"><span class="toc-number">1.5.</span> <span class="toc-text">5.JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-JDBC"><span class="toc-number">1.5.1.</span> <span class="toc-text">Spring JDBC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-HTML"><span class="toc-number">1.6.</span> <span class="toc-text">6.HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Javascript"><span class="toc-number">1.7.</span> <span class="toc-text">7.Javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Function-%E5%87%BD%E6%95%B0-%E6%96%B9%E6%B3%95-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.Function:函数(方法)对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Date-%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.Date:日期对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-RegExp-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.RegExp:正则表达式对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Global"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.Global</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-BOM"><span class="toc-number">1.8.</span> <span class="toc-text">8.BOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-DOM"><span class="toc-number">1.9.</span> <span class="toc-text">9.DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Bootstrap"><span class="toc-number">1.10.</span> <span class="toc-text">10.Bootstrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-XML"><span class="toc-number">1.11.</span> <span class="toc-text">11.XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%8E%B7%E5%8F%96Element%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">12.获取Element对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Servlet-server-applet"><span class="toc-number">1.13.</span> <span class="toc-text">13.Servlet : server applet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-HTTP-%E6%A6%82%E5%BF%B5-Hyper-Text-Transfer-Protocol%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.14.</span> <span class="toc-text">14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Request"><span class="toc-number">1.15.</span> <span class="toc-text">15.Request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Response%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.16.</span> <span class="toc-text">16.Response对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-forward%E5%92%8Credirect%E5%8C%BA%E5%88%AB"><span class="toc-number">1.17.</span> <span class="toc-text">17.forward和redirect区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-ServletContext%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.18.</span> <span class="toc-text">18.ServletContext对象:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Cookie"><span class="toc-number">1.19.</span> <span class="toc-text">19.Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-JSP-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.20.</span> <span class="toc-text">20.JSP:入门学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Session"><span class="toc-number">1.21.</span> <span class="toc-text">21.Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21JSP"><span class="toc-number">1.22.</span> <span class="toc-text">21JSP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-MVC-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.23.</span> <span class="toc-text">22.MVC:开发模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.24.</span> <span class="toc-text">23.EL表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-JSTL"><span class="toc-number">1.25.</span> <span class="toc-text">24.JSTL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Filter-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.26.</span> <span class="toc-text">25.Filter:过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Listener-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.27.</span> <span class="toc-text">26.Listener :监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-JQuery-%E9%AB%98%E7%BA%A7"><span class="toc-number">1.28.</span> <span class="toc-text">27.JQuery 高级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-AJAX"><span class="toc-number">1.29.</span> <span class="toc-text">28.AJAX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-JSON"><span class="toc-number">1.30.</span> <span class="toc-text">29.JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Redis"><span class="toc-number">1.31.</span> <span class="toc-text">30.Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-Java%E5%AE%A2%E6%88%B7%E7%AB%AF-Jedis"><span class="toc-number">1.32.</span> <span class="toc-text">31.Java客户端 Jedis</span></a></li></ol></b></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><b><i class="fas fa-history"></i><span>最新文章</span></b></div><div class="aside-list"><div class="aside-list-item"><b><a class="thumbnail" href="/Swagger.html" title="Swagger"><img src="/img/bizhi7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Swagger"></a><div class="content"><a class="title" href="/Swagger.html" title="Swagger">Swagger</a><time datetime="2024-05-24T02:54:40.080Z" title="发表于 2024-05-24 10:54:40">2024-05-24</time></div></b></div><div class="aside-list-item"><b><a class="thumbnail" href="/%E8%8B%A5%E4%BE%9D%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.html" title="若依实现操作日志"><img src="/img/bizhi7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="若依实现操作日志"></a><div class="content"><a class="title" href="/%E8%8B%A5%E4%BE%9D%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.html" title="若依实现操作日志">若依实现操作日志</a><time datetime="2024-04-23T06:13:44.550Z" title="发表于 2024-04-23 14:13:44">2024-04-23</time></div></b></div><div class="aside-list-item"><b><a class="thumbnail" href="/%E6%A6%82%E5%BF%B5POJO%E3%80%81DTO%E3%80%81DAO%E3%80%81PO%E3%80%81BO%E3%80%81VO%E3%80%81QO%E3%80%81ENTITY%E8%AF%A6%E8%A7%A3.html" title="概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解"><img src="/img/bizhi1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解"></a><div class="content"><a class="title" href="/%E6%A6%82%E5%BF%B5POJO%E3%80%81DTO%E3%80%81DAO%E3%80%81PO%E3%80%81BO%E3%80%81VO%E3%80%81QO%E3%80%81ENTITY%E8%AF%A6%E8%A7%A3.html" title="概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解">概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解</a><time datetime="2024-04-22T07:53:28.005Z" title="发表于 2024-04-22 15:53:28">2024-04-22</time></div></b></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><b><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></b></p></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>  @media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></div></footer></div><div id="rightside"><div id="rightside-config-hide"><b><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></b></div><div id="rightside-config-show"><b><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></b></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title"><b>搜索</b></div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><b><input class="local-search-box--input" placeholder="搜索文章" type="text"></b></div></div></div><hr><div id="local-search-results"></div><b><span class="search-close-button"><i class="fas fa-times"></i></span></b></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
    document.getElementById('loading-box').style.opacity = '0'
    setTimeout(function(){
      document.getElementById('loading-box').classList.add("loaded")
    }, 3000);
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').style.transition = '';
    document.getElementById('loading-box').style.opacity = '1'
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 3000);</script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/sakura.js"></script><script src="/js/timing.js"></script><script src="/js/biaoqian.js"></script><script src="/js/mouse_move.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>