<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>普通l</title>
  
  
  <link href="http://putongl.github.io/atom.xml" rel="self"/>
  
  <link href="http://putongl.github.io/"/>
  <updated>2023-12-12T00:50:50.106Z</updated>
  <id>http://putongl.github.io/</id>
  
  <author>
    <name>普通L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>anaconda的默认位置修改pkgs以及默认创建环境踩坑</title>
    <link href="http://putongl.github.io/python.html"/>
    <id>http://putongl.github.io/python.html</id>
    <published>2023-12-12T00:50:56.508Z</published>
    <updated>2023-12-12T00:50:50.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="anaconda的默认位置修改pkgs以及默认创建环境踩坑"><a href="#anaconda的默认位置修改pkgs以及默认创建环境踩坑" class="headerlink" title="anaconda的默认位置修改pkgs以及默认创建环境踩坑"></a>anaconda的默认位置修改pkgs以及默认创建环境踩坑</h1><p>即可anaconda 的默认pkgs缓存位置以及创建环境位置 使用conda info 打印出来默认位置确实使你安装在d盘的位置但是由于d盘你没有给用户设置完全控制所以无法使用 即系统自动顺应到c盘去 所以只需要去你要修改的文件及右键属性点击安全选项给用户设置完全控制即可如图</p><p><img src="https://s2.loli.net/2023/11/22/UsHFv6NgJbzonGc.png" alt="image-20231122175804082"></p><p><img src="https://s2.loli.net/2023/11/22/FdO1I5GBismlxqz.png" alt="image-20231122175904116"></p><p><img src="https://s2.loli.net/2023/11/22/FCgtScvIyG5R4uN.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;anaconda的默认位置修改pkgs以及默认创建环境踩坑&quot;&gt;&lt;a href=&quot;#anaconda的默认位置修改pkgs以及默认创建环境踩坑&quot; class=&quot;headerlink&quot; title=&quot;anaconda的默认位置修改pkgs以及默认创建环境踩坑&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="http://putongl.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>将项目上传到gitee上面</title>
    <link href="http://putongl.github.io/git.html"/>
    <id>http://putongl.github.io/git.html</id>
    <published>2023-11-09T00:22:08.317Z</published>
    <updated>2023-11-09T00:21:23.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将项目上传到gitee上"><a href="#将项目上传到gitee上" class="headerlink" title="将项目上传到gitee上"></a>将项目上传到gitee上</h2><p>1.新建仓库</p><p><img src="https://s2.loli.net/2023/11/09/45LPbOEIiAagoS3.webp" alt="image.png"></p><p><img src="https://s2.loli.net/2023/11/09/i51aHGPbW9tEVe2.webp" alt="image.png"></p><p>出现这样的界面就创建仓库成功了</p><p><img src="https://s2.loli.net/2023/11/09/1fZWhxG3A2TsYrU.webp" alt="image.png"></p><p>然后git全局设置（配置你的用户名及邮箱）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;木倾心&quot;</span><br><span class="line">$ git config --global user.email &quot;自己的邮箱&quot;</span><br></pre></td></tr></table></figure><p>在本地项目打开终端</p><p><img src="https://s2.loli.net/2023/11/09/sXazqONBI8t4Hdy.webp" alt="image.png"></p><p><img src="https://s2.loli.net/2023/11/09/luMAN3YRmUnyzIr.webp" alt="image.png"></p><p>然后初始化本地环境，把该项目变成可被git管理的仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://s2.loli.net/2023/11/09/5WBITKGatfZgFoC.webp" alt="image.png"></p><p>添加该项目下的所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add . （不要忘记后面那个点）</span><br></pre></td></tr></table></figure><p>添加该项目所有文件到本地仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#x27;本次提交的说明&#x27; (提交说明尽量写得有意义)</span><br></pre></td></tr></table></figure><p>将本地代码库与远程代码库相关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://gitee.com/mu-qingxin/自己gitee创建仓库地址</span><br></pre></td></tr></table></figure><p>将本地代码推送到指定远程的仓库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin &quot;master&quot; </span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="1-不用初始化ReadMe文件，造成本地和远程的不同步"><a href="#1-不用初始化ReadMe文件，造成本地和远程的不同步" class="headerlink" title="1.不用初始化ReadMe文件，造成本地和远程的不同步"></a>1.不用初始化ReadMe文件，造成本地和远程的不同步</h3><h3 id="2-报错：-git-push后出现错误-rejected-master-gt-master-non-fast-forward"><a href="#2-报错：-git-push后出现错误-rejected-master-gt-master-non-fast-forward" class="headerlink" title="2.报错：[git push后出现错误 ![rejected] master -&gt; master(non-fast-forward) ]"></a>2.报错：[git push后出现错误 ![rejected] master -&gt; master(non-fast-forward) ]</h3><p>我们提交代码<code>git push</code>后出现如下错误提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">To https://gitee.com/xxxxx/vue_shop.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;https://gitee.com/xxxxx/vue_shop.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/09/TijUrupa92fbXYZ.png" alt="img"></p><ul><li>原因</li></ul><p>Git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。<br>远程仓库和本地仓库存在差异。<br>一般都是因为你在码云创建的仓库有ReadMe文件，而本地没有，造成本地和远程的不同步</p><ul><li>解决方法：</li></ul><p>方法一、同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、git pull origin master --allow-unrelated-histories //把远程仓库和本地同步，消除差异</span><br><span class="line">2、重新add和commit相应文件</span><br><span class="line">3、git push origin master</span><br><span class="line">4、此时就能够上传成功了</span><br></pre></td></tr></table></figure><p>如果只是因为本地没有ReadMe文件，那么就在本地生成一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master  //本地生成ReadMe文件</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>方法二：强推</p><p>即利用强覆盖方式用你本地的代码替代git仓库内的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><p>该命令会强制上传覆盖远程文件，慎用</p><p>方法三、</p><p>先把git的东西fetch到你本地然后merge后再push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将项目上传到gitee上&quot;&gt;&lt;a href=&quot;#将项目上传到gitee上&quot; class=&quot;headerlink&quot; title=&quot;将项目上传到gitee上&quot;&gt;&lt;/a&gt;将项目上传到gitee上&lt;/h2&gt;&lt;p&gt;1.新建仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="http://putongl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://putongl.github.io/SpringBoot.html"/>
    <id>http://putongl.github.io/SpringBoot.html</id>
    <published>2023-10-18T11:41:56.613Z</published>
    <updated>2023-10-18T11:41:28.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="一：开发"><a href="#一：开发" class="headerlink" title="一：开发"></a>一：开发</h2><h3 id="1-RestController"><a href="#1-RestController" class="headerlink" title="1.@RestController"></a>1.@RestController</h3><p>@RestController指在Spring中@RestController的作用等同于@Controller + @ResponseBody。</p><h3 id="2-REST风格"><a href="#2-REST风格" class="headerlink" title="2.REST风格"></a>2.REST风格</h3><p>2.1简介</p><p>​    按照REST风格访问资源时使用行为动作区分对资源进行了何种操作</p><p>​    <a href="http://localhost/users">http://localhost/users</a>        查询全部用户信息GET(查询)</p><p>​    <a href="http://localhost/users/1">http://localhost/users/1</a>        查询指定用户信息GET(查询)</p><p>​    <a href="http://localhost/users">http://localhost/users</a>        添加用户信息POST(新增/保存)</p><p>​    <a href="http://localhost/users">http://localhost/users</a>        修改用户信息PUT(修改/更新)</p><p>​    <a href="http://localhost/users/1">http://localhost/users/1</a>        删除用户信息DELETE（删除)</p><p>​    根据REST风格对资源进行访问称为RESTful</p><p>注意事项</p><p>​    上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范</p><p>​    描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、account..</p><p>2.2@GetMapping        查询</p><p>@PostMapping        添加</p><p>@PutMapping            修改</p><p>@DeleteMapping        删除</p><p>@PatchMapping        对资源数据打补丁或局部更新 </p><p>即<em>@GetMapping用于处理请求方法的GET类型，@ PostMapping用于处理请求方法的POST</em>类型等。</p><p>如果我们想使用传统的<em>@RequestMapping</em>注释实现URL处理程序，那么它应该是这样的：        </p><p>​    @RequestMapping(value = “/get/{id}”, method = RequestMethod.GET)</p><p>新方法可以简化为：</p><p>​    @GetMapping(“/get/{id}”)</p><h3 id="3-SpringBoot默认配置文件"><a href="#3-SpringBoot默认配置文件" class="headerlink" title="3.SpringBoot默认配置文件"></a>3.SpringBoot默认配置文件</h3><p>application.properties</p><p>基础配置</p><p>属性配置</p><p>​    修改配置</p><p>​    修改服务器端口</p><p>​        server.port=80</p><p>​    关闭运行日志图标（banner）</p><p>​        spring.main.banner-mode=off</p><p>​    设置日志相关</p><p>​        logging.level.root=debug</p><p>SpringBoot内置属性查询</p><p>​    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>​    官方文档中参考文档第一项：Application Properties</p><h3 id="4-SpringBoot提供了3种配置文件的格式"><a href="#4-SpringBoot提供了3种配置文件的格式" class="headerlink" title="4.SpringBoot提供了3种配置文件的格式"></a>4.SpringBoot提供了3种配置文件的格式</h3><p>​        properties（传统格式/默认格式）</p><p>​        yml（主流格式）</p><p>​        yaml</p><p>SpringBoot配置文件加载顺序</p><p>​    application.properties &gt; application.yml &gt; application.yaml</p><p>​    常用配置文件种类</p><p>​        application.yml</p><p>4.1 配置文件间的加载优先级</p><p>​    properties（最高）</p><p>​    yml</p><p>​    yaml（最低）</p><p>4.2 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p><p>4.3 YAML（YAML Ain’t Markup Language），一种数据序列化格式</p><p>​    优点：</p><p>​        容易阅读</p><p>​        容易与脚本语言交互</p><p>​        以数据为核心，重数据轻格式</p><p>​    YAML文件扩展名</p><p>​        .yml（主流）</p><p>​        .yaml</p><p>4.4. yaml语法规则</p><p>​    大小写敏感</p><p>​    属性层级关系使用多行描述，每行结尾使用冒号结束</p><p>​    使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</p><p>​    属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</p><p>​    # 表示注释</p><p>​    注意：属性名冒号后面与数据之间有一个空格</p><p>4.5 字面值、对象数据格式、数组数据格式（略）</p><p>4.6 使用@Value配合SpEL读取单个数据</p><p>​    如果数据存在多层级，依次书写层级名称即可</p><p>​    使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}</p><p>​    yaml数据读取</p><p>​        1. 在配置文件中可以使用${属性名}方式引用属性值</p><p>​        2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</p><p>4.7     1. 使用Environment对象封装全部配置信息</p><p>​        2. 使用@Autowired自动装配数据到Environment对象中</p><p>4.8     @Component</p><p>​         @ConfigurationProperties(prefix = “datasource”)</p><pre><code>     1. 使用@ConfigurationProperties注解绑定配置信息到封装类中     2. 封装类需要定义为Spring管理的bean，否则无法进行属性注入</code></pre><h3 id="5-整合第三方技术"><a href="#5-整合第三方技术" class="headerlink" title="5.整合第三方技术"></a>5.整合第三方技术</h3><h4 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h4><p>​    1. 导入测试对应的starter    </p><p>​    2. 测试类使用@SpringBootTest修饰</p><p>​    3. 使用自动装配的形式添加要测试的对象</p><p>​    如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定</p><p>​        classes：设置SpringBoot启动类</p><p>​    小结：</p><p>​        1. 测试类如果存在于引导类所在包或子包中无需指定引导类</p><p>​        2. 测试类在引导启动类的父类，测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p><h4 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h4><p>​    1. 勾选MyBatis技术，也就是导入MyBatis对应的starter</p><p>​    2. 数据库连接相关信息转换成配置</p><p>​    3. 数据库SQL映射需要添加@Mapper被容器识别到</p><p>​    1. MySQL 8.X驱动强制要求设置时区</p><p>​        修改url，添加serverTimezone设定</p><p>​        修改MySQL数据库配置（略）</p><p>​    2. 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p><h4 id="整合MyBatis-Plus"><a href="#整合MyBatis-Plus" class="headerlink" title="整合MyBatis-Plus"></a>整合MyBatis-Plus</h4><p>1：手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取</p><p>​        由于SpringBoot中未收录MyBatis-Plus的坐标版本，需要指定对应的Version</p><p>2.数据层接口使用BaseMapper简化开发</p><p>3.需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</p><h4 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h4><ol><li><p>整合Druid需要导入Druid对应的starter</p></li><li><p>根据Druid提供的配置方式进行配置</p></li><li><p>整合第三方技术通用方式</p></li></ol><p>​        导入对应的starter</p><p>​        根据提供的配置格式，配置非默认值对应的配置项</p><h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><p>一个Java类库，提供了一组注解，简化POJO实体类开发</p><p>Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或eques方法，同时可以自动化日志变量。</p><p>lombok版本由SpringBoot提供，无需指定版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用注解：@Data</p><h3 id="7-开启日志"><a href="#7-开启日志" class="headerlink" title="7.开启日志"></a>7.开启日志</h3><p>使用配置方式开启日志，设置日志输出方式为标准输出，打印到控制台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h3 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h3><ol><li>使用IPage封装分页数据</li></ol><p>​    IPage对象中封装了分页操作中的所有数据</p><p>​    数据</p><p>​    当前页码值</p><p>​    每页数据总量</p><p>​    最大页码值</p><p>​    数据总量</p><ol><li>分页操作依赖MyBatisPlus分页拦截器实现功能</li></ol><p>​        分页操作是在MyBatisPlus的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能，</p><p>​        使用MyBatisPlus拦截器MybatisPlusInterceptor实现</p><ol><li>借助MyBatisPlus日志查阅执行SQL语句</li></ol><h3 id="9-条件查询"><a href="#9-条件查询" class="headerlink" title="9.条件查询"></a>9.条件查询</h3><ol><li><p>使用QueryWrapper对象封装查询条件</p></li><li><p>推荐使用LambdaQueryWrapper对象</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lqw.like(name != null,Book::getName,name);</span><br></pre></td></tr></table></figure><ol><li><p>所有查询操作封装成方法调用</p></li><li><p>查询条件支持动态条件拼装</p></li></ol><h3 id="10-业务层开发"><a href="#10-业务层开发" class="headerlink" title="10.业务层开发"></a>10.业务层开发</h3><p>Service层接口定义与数据层接口定义具有较大区别，不要混用</p><p>​    selectByUserNameAndPassword(String username,String password);</p><p>​    login(String username,String password);</p><p>快速开发：</p><p>​    1. 使用通用接口（ISerivce）快速开发Service</p><p>​    2. 使用通用实现类（ServiceImpl）快速开发ServiceImpl</p><p>​    3. 可以在通用接口基础上做功能重载或功能追加</p><p>​    4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失</p><h3 id="11-表现层开发"><a href="#11-表现层开发" class="headerlink" title="11.表现层开发"></a>11.表现层开发</h3><p>1.基于Restful进行表现层接口开发</p><p>​    新增：POST</p><p>​    删除：DELETE</p><p>​    修改：PUT</p><p>​    查询：GET</p><p>2.接收参数</p><p>​    实体数据：@RequestBody</p><p>​    路径变量：@PathVariable</p><p>3.使用Postman测试表现层接口功能</p><h3 id="12-表现层消息一致性处理"><a href="#12-表现层消息一致性处理" class="headerlink" title="12.表现层消息一致性处理"></a>12.表现层消息一致性处理</h3><ol><li><p>设计统一的返回值结果类型便于前端开发读取数据</p></li><li><p>返回值结果类型可以根据需求自行设定，没有固定格式</p></li><li><p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p></li></ol><p>​    前后端协议联调</p><p>​        前后端分离结构设计中页面归属前端服务器</p><p>​        单体工程中页面放置在resources目录下的static目录中（建议执行clean）</p><h3 id="13-业务消息一致性处理"><a href="#13-业务消息一致性处理" class="headerlink" title="13.业务消息一致性处理"></a>13.业务消息一致性处理</h3><p>修改表现层返回结果的模型类，封装出现异常后对应的信息</p><p>​    flag：false</p><p>​    Data: null</p><p>​    消息(msg): 要显示信息</p><h2 id="二：运维"><a href="#二：运维" class="headerlink" title="二：运维"></a>二：运维</h2><h3 id="1-命令行启动常见问题及解决方案"><a href="#1-命令行启动常见问题及解决方案" class="headerlink" title="1.命令行启动常见问题及解决方案"></a>1.命令行启动常见问题及解决方案</h3><p>Windonws端口被占用</p><p># 查询端口</p><p>​    netstat -ano</p><p># 查询指定端口</p><p>​    netstat -ano |findstr “端口号”</p><p># 根据进程PID查询进程名称</p><p>​    tasklist |findstr “进程PID号”</p><p># 根据PID杀死任务</p><p>​    taskkill /F /PID “进程PID号”</p><p># 根据进程名称杀死任务</p><p>​    taskkill -f -t -im “进程名称”</p><h3 id="2-临时属性设置"><a href="#2-临时属性设置" class="headerlink" title="2.临时属性设置"></a>2.临时属性设置</h3><ol><li><p>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</p></li><li><p>临时属性添加方式：java –jar 工程名.jar –-属性名=值</p></li><li><p>多个临时属性之间使用空格分隔</p></li><li><p>临时属性必须是当前boot工程支持的属性，否则设置无效</p></li></ol><h3 id="3-传递启动属性"><a href="#3-传递启动属性" class="headerlink" title="3.传递启动属性"></a>3.传递启动属性</h3><p>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</p><p>​        //不希望用户在外面用临时参数覆盖掉你的参数</p><p>​        //为了安全性</p><p>​        SpringApplication.run(SsmpApplication.class);</p><h3 id="4-配置文件分类"><a href="#4-配置文件分类" class="headerlink" title="4.配置文件分类"></a>4.配置文件分类</h3><ol><li>SpringBoot中4级配置文件</li></ol><p>1级： file ：config/application.yml 【最高】</p><p>​    工程路径config目录中配置文件：服务于运维经理整体调控</p><p>2级： file ：application.yml</p><p>​    工程路径配置文件：服务于运维人员配置涉密线上环境</p><p>3级：classpath：config/application.yml</p><p>​    项目类路径config目录中配置文件：服务于项目经理整体调控</p><p>4级：classpath：application.yml 【最低】</p><p>​    项目类路径配置文件：服务于开发人员本机开发与测试</p><ol><li>作用：</li></ol><p>​    1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p><p>​    3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p><ol><li>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</li></ol><h3 id="5-多环境开发"><a href="#5-多环境开发" class="headerlink" title="5.多环境开发"></a>5.多环境开发</h3><ul><li>配置文件书写技巧（一）</li></ul><p>主配置文件中设置公共配置（全局）</p><p>环境分类配置文件中常用于设置冲突属性（局部）</p><ol><li><p>可以使用独立配置文件定义环境属性</p></li><li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p></li></ol><p>​        但properties文件多环境配置仅支持多文件格式</p><ul><li>多环境开发独立配置文件书写技巧（二）</li></ul><p>根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p><p>​    application-devDB.yml</p><p>​    application-devRedis.yml</p><p>​    application-devMVC.yml</p><p>从Spring2.4版开始使用group属性替代include属性，降低了配置书写量</p><p>​    使用group属性定义多种主环境与子环境的包含关系</p><p>​    spring:</p><p>​        profiles:</p><p>​        active: dev</p><p>​        group:</p><p>​            “dev”: devDB,devRedis,devMVC</p><p>​            “pro”: proDB,proRedis,proMVC</p><p>​            “test”: testDB,testRedis,testMVC</p><p>​            dev先加载，然后devDB,devRedis,devMVC依次加载，相同属性时，最后加载的环境属性生效</p><p>​    多环境开发使用group属性设置配置文件分组，便于线上维护管理</p><p>​        1. 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</p><p>​        2. 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</p><h3 id="6-日志基础操作"><a href="#6-日志基础操作" class="headerlink" title="6.日志基础操作"></a>6.日志基础操作</h3><p>日志（log）作用</p><p>​    编程期调试代码</p><p>​    运营期记录信息</p><p>​        记录日常运营重要信息（峰值流量、平均响应时长……）</p><p>​        记录应用报错信息（错误堆栈）</p><p>​        记录运维过程数据（扩容、宕机、报警……）</p><p>日志级别</p><p>​    TRACE：运行堆栈信息，使用率低</p><p>​    DEBUG：程序员调试代码使用</p><p>​    INFO：记录运维过程数据</p><p>​    WARN：记录运维过程报警数据</p><p>​    ERROR：记录错误堆栈信息</p><p>​    FATAL：灾难信息，合并计入ERROR</p><p>基于lombok提供的@Slf4j注解为类快速添加日志对象</p><p>日志输出格式控制</p><p><img src="https://s2.loli.net/2023/10/18/xuSDGiNVK8EsqrX.png" alt="截图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">pattern:</span><br><span class="line">console: &quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span><br><span class="line">%d：日期</span><br><span class="line">%m：消息</span><br><span class="line">%n：换行</span><br></pre></td></tr></table></figure><h2 id="三、开发实用篇"><a href="#三、开发实用篇" class="headerlink" title="三、开发实用篇"></a>三、开发实用篇</h2><h3 id="1-启动热部署"><a href="#1-启动热部署" class="headerlink" title="1.启动热部署"></a>1.启动热部署</h3><p>​    开启开发者工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>激活热部署：Ctrl + F9    重新构建项目</p><p>关于热部署：热部署仅仅加载当前开发者自定义开发的资源，不加载jar资源</p><p>​    重启（Restart）：自定义开发代码，包含类、页面、配置文件等，加载位置restart类加载器</p><p>​    重载（ReLoad）：jar包，加载位置base类加载器</p><p>自动启动热部署</p><p>​    激活方式：Idea失去焦点5秒后启动热部署</p><p>热部署范围配置</p><p>​    默认不触发重启的目录列表</p><p>​        /META-INF/maven</p><p>​        /META-INF/resources</p><p>​        /resources</p><p>​        /static</p><p>​        /public</p><p>​        /templates</p><p>自定义不参与重启排除项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devtools:</span><br><span class="line">restart:</span><br><span class="line">exclude: public/**,static/**</span><br></pre></td></tr></table></figure><p>禁用热部署：设置高优先级属性禁用热部署</p><h3 id="2-ConfigurationProperties"><a href="#2-ConfigurationProperties" class="headerlink" title="2.@ConfigurationProperties"></a>2.@ConfigurationProperties</h3><p>@ConfigurationProperties</p><p>​    使用@ConfigurationProperties为第三方bean绑定属性</p><p>@EnableConfigurationProperties</p><p>​    @EnableConfigurationProperties（<em>*</em>.class）可以使加载的类不用加载为bean,也就是可以不用@Component注解</p><p>​        App类不用扫描bean,直接@Import(<em>*</em>.class)Enable注解的类加载进去    //降低耦合度</p><p>​    @EnableConfigurationProperties注解可以将使用@ConfigurationProperties注解对应的类加入Spring容器</p><p>​    @EnableConfigurationProperties与@Component不能同时使用    </p><p>解除使用@ConfigurationProperties注释警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-宽松绑定"><a href="#3-宽松绑定" class="headerlink" title="3.宽松绑定"></a>3.宽松绑定</h3><p>@ConfigurationProperties绑定属性支持属性名宽松绑定</p><p>​    驼峰模式:ipAddress: 192.168.1.1</p><p>​    下划线模式:ip_address: 192.168.1.2</p><p>​    中划线模式 :ip-address: 192.168.1.3</p><p>​    常量模式:IP_ADDRESS: 192.168.1.4</p><p>宽松绑定不支持注解@Value引用单个属性的方式</p><p>绑定前缀名命名规范：仅能使用纯小写字母、数字、下划线作为合法的字符</p><p>数据校验:开启数据校验有助于系统安全性，J2EE规范中JSR303规范定义了一组有关数据校验相关的API</p><p>​    导入JSR303与Hibernate校验框架坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用@Validated注解启用校验功能</p><p>使用具体校验规则规范数据校验格式</p><p>注意：yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</p><h3 id="4-加载测试专用属性"><a href="#4-加载测试专用属性" class="headerlink" title="4.加载测试专用属性"></a>4.加载测试专用属性</h3><p>在启动测试环境时可以通过properties参数设置测试环境专用的属性</p><p>​    @SpringBootTest(properties = {“test.prop=testValue1”})    </p><p>​    优势：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效</p><p>在启动测试环境时可以通过args参数设置测试环境专用的传入参数</p><p>​    @SpringBootTest(args = {“—test.arg=testValue2”})</p><p>使用@Import注解加载当前测试类专用的配置</p><p>模拟端口</p><p>​    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p><p>业务层测试事务回滚</p><p>​    为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚</p><p>​    如果想在测试用例中提交事务，可以通过@Rollback注解设置</p><p>​    @Transactional</p><p>​    @Rollback(false)</p><p>使用随机数据替换测试用例中书写固定的数据，使用SpringBoot提供的随机数为其赋值</p><p>​    ${random.int}表示随机整数</p><p>​    ${random.int(10)}表示10以内的随机数</p><p>​    ${random.int(10,20)}表示10到20的随机数</p><p>​    其中()可以是任意字符，例如[]，!!均可</p><h3 id="5-数据层解决方案"><a href="#5-数据层解决方案" class="headerlink" title="5.数据层解决方案"></a>5.数据层解决方案</h3><p>• SQL</p><p>• NoSQL</p><p>​    现有数据层解决方案技术选型</p><p>​    数据源：DruidDataSource</p><p>​    持久化技术：MyBatis-Plus / MyBatis</p><p>​    数据库：MySQL</p><p>数据源配置</p><p>​    SpringBoot提供了3种内嵌的数据源对象供开发者选择</p><p>​        HikariCP：默认内置数据源对象</p><p>​        Tomcat提供DataSource：HikariCP不可用的情况下，且在web环境中，将使用tomcat服务器配置的数据源对象</p><p>​        Commons DBCP：Hikari不可用，tomcat数据源也不可用，将使用dbcp数据源</p><p>通用配置无法设置具体的数据源配置信息，仅提供基本的连接相关配置，如需配置，在下一级配置中设置具体设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql://localhost:3306/ssm_db</span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">        hikari:</span><br><span class="line">            maximum-pool-size: 50</span><br></pre></td></tr></table></figure><p>内置持久化解决方案——JdbcTemplate</p><p>​    JdbcTemplate配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    jdbc:</span><br><span class="line">    template:</span><br><span class="line">        query-timeout: -1 # 查询超时时间</span><br><span class="line">        max-rows: 500 # 最大行数</span><br><span class="line">        fetch-size: -1 # 缓存行数</span><br></pre></td></tr></table></figure><p>内嵌数据库</p><p>SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率</p><p>​    H2，HSQL，Derby</p><p>Redis</p><p>Redis是一款key-value存储结构的内存级NoSQL数据库</p><p>​    支持多种数据存储格式</p><p>​    支持持久化</p><p>​    支持集群</p><p>Redis下载（ Windows版）</p><p>​    <a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>​    Redis安装与启动（ Windows版）</p><p>​    Windows解压安装或一键式安装</p><p>​    服务端启动命令</p><p>​        redis-server.exe redis.windows.conf</p><p>​    客户端启动命令</p><p>​        redis-cli.exe</p><p>lettcus与jedis区别</p><p>​    jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响。</p><p>​    lettcus(默认)基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作。</p><h3 id="6-Mongodb"><a href="#6-Mongodb" class="headerlink" title="6.Mongodb"></a>6.Mongodb</h3><p>MongoDB是一个开源、高性能、无模式的文档型数据库。NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库</p><p>新增：db.集合名称.insert/save/insertOne(文档)</p><p>修改：db.集合名称.update(条件，{操作种类:{文档}})</p><p>删除：db.集合名称.remove(条件)</p><ol><li>基础查询</li></ol><p>​    查询全部：db.集合.find();</p><p>​    查第一条：db.集合.findOne()</p><p>​    查询指定数量文档：db.集合.find().limit(10)         //查10条文档</p><p>​    跳过指定数量文档：db.集合.find().skip(20)         //跳过20条文档</p><p>​    统计：db.集合.count()</p><p>​    排序：db.集合.sort({age:1})                     //按age升序排序</p><p>​    投影：db.集合名称.find(条件,{name:1,age:1})     //仅保留name与age域</p><ol><li>条件查询</li></ol><p>​    基本格式：db.集合.find({条件})</p><p>​    模糊查询：db.集合.find({域名:/正则表达式/})     //等同SQL中的like，比like强大，可以执行正则所有规则</p><p>​    条件比较运算：db.集合.find({域名:{$gt:值}})         //等同SQL中的数值比较操作，例如：name&gt;18</p><p>​    包含查询：db.集合.find({域名:{$in:[值1，值2]}})     //等同于SQL中的in</p><p>​    条件连接查询：db.集合.find({$and:[{条件1},{条件2}]})     //等同于SQL中的and、or</p><p>配置客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">data:</span><br><span class="line">mongodb:</span><br><span class="line">uri: mongodb://localhost/itheima</span><br></pre></td></tr></table></figure><h3 id="7-ElasticSearch（ES）"><a href="#7-ElasticSearch（ES）" class="headerlink" title="7.ElasticSearch（ES）"></a>7.ElasticSearch（ES）</h3><p>1.创建/查询/删除索引</p><p>​    PUT <a href="http://localhost:9200/books">http://localhost:9200/books</a></p><p>​    GET <a href="http://localhost:9200/books">http://localhost:9200/books</a></p><p>​    DELETE <a href="http://localhost:9200/books">http://localhost:9200/books</a></p><p>​    用Ik分词器创建索引并指定规则</p><p>2.创建文档（往里面加数据）</p><p>​    POST <a href="http://localhost:9200/books/_doc">http://localhost:9200/books/_doc</a> #使用系统生成id</p><p>​    POST <a href="http://localhost:9200/books/_create/1">http://localhost:9200/books/_create/1</a> #使用指定id，</p><p>​    POST <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a> #使用指定id，不存在创建，存在更新（版本递增）</p><p>3.查询文档</p><p>​    GET <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a> #查询单个文档</p><p>​    GET <a href="http://localhost:9200/books/_search">http://localhost:9200/books/_search</a> #查询全部文档</p><p>4.条件查询</p><p>​    GET <a href="http://localhost:9200/books/_search?q=name:springboot">http://localhost:9200/books/_search?q=name:springboot</a></p><p>5.删除文档</p><p>​    DELETE <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a></p><p>6.修改文档（全量修改）</p><p>​    PUT <a href="http://localhost:9200/books/_doc/1">http://localhost:9200/books/_doc/1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;springboot&quot;,</span><br><span class="line">&quot;type&quot;:&quot;springboot&quot;,</span><br><span class="line">&quot;description&quot;:&quot;springboot&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.修改文档（部分修改）</p><p>​    POST <a href="http://localhost:9200/books/_update/1">http://localhost:9200/books/_update/1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;doc&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;springboot&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.idea导入坐标高级的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="8-整合第三方技术"><a href="#8-整合第三方技术" class="headerlink" title="8.整合第三方技术"></a>8.整合第三方技术</h3><p>缓存是一种介于数据永久存储介质与数据应用之间的数据临时存储介质</p><p>​    使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能</p><p>缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间</p><p>SpringBoot提供了缓存技术，方便缓存使用</p><p>SpringBoot提供的缓存技术除了提供默认的缓存方案，还可以对其他缓存技术进行整合，统一接口，方便缓存技术的开发与管理</p><p>​    Generic</p><p>​    JCache</p><p>​    Ehcache</p><p>​    Hazelcast</p><p>​    Infinispan</p><p>​    Couchbase</p><p>​    Redis</p><p>​    Caffeine</p><p>​    Simple（默认）</p><p>缓存供应商变更:memcached</p><p>SpringBoot未提供对memcached的整合，需要使用硬编码方式实现客户端初始化管理</p><p>缓存供应商变更:jetcache</p><p>jetCache对SpringCache进行了封装，在原有功能基础上实现了多级缓存、缓存统计、自动刷新、异步调用、数据报表等功能</p><p>jetCache设定了本地缓存与远程缓存的多级缓存解决方案</p><p>本地缓存（local）</p><p>​    LinkedHashMap</p><p>​    Caffeine</p><p>远程缓存（remote）</p><p>​    Redis</p><p>​    Tair</p><p>缓存供应商变更:j2cache</p><p>j2cache是一个缓存整合框架，可以提供缓存的整合方案，使各种缓存搭配使用，自身不提供缓存功能</p><p>基于 ehcache + redis 进行整合</p><p>​    加入j2cache坐标，加入整合缓存的坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;j2cache-spring-boot2-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.0-release&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;j2cache-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.4-release&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置使用j2cache（application.yml）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j2cache:</span><br><span class="line">config-location: j2cache.properties</span><br></pre></td></tr></table></figure><p>配置一级缓存与二级缓存以及一级缓存数据到二级缓存的发送方式（j2cache.properties）</p><p>​    # 配置1级缓存</p><p>​        j2cache.L1.provider_class = ehcache</p><p>​        ehcache.configXml = ehcache.xml</p><p>​    # 配置1级缓存数据到2级缓存的广播方式：可以使用redis提供的消息订阅模式，也可以使用jgroups多播实现</p><p>​        j2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</p><p>​    # 配置2级缓存</p><p>​        j2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProvider</p><p>​        j2cache.L2.config_section = redis</p><p>​        redis.hosts = localhost:6379</p><h3 id="9-SpringBoot整合Quartz"><a href="#9-SpringBoot整合Quartz" class="headerlink" title="9.SpringBoot整合Quartz"></a>9.SpringBoot整合Quartz</h3><p>相关概念</p><p>​    工作（Job）：用于定义具体执行的工作</p><p>​    工作明细（JobDetail）：用于描述定时工作相关的信息</p><p>​    触发器（Trigger）：用于描述触发工作的规则，通常使用cron表达式定义调度规则</p><p>​    调度器（Scheduler）：描述了工作明细与触发器的对应关系</p><h3 id="10-SpringBoot整合JavaMail"><a href="#10-SpringBoot整合JavaMail" class="headerlink" title="10.SpringBoot整合JavaMail"></a>10.SpringBoot整合JavaMail</h3><p>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件的传输协议</p><p>POP3（Post Office Protocol - Version 3）：用于接收电子邮件的标准协议</p><p>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</p><p>配置JavaMail</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">mail:</span><br><span class="line">host: </span><br><span class="line">smtp.qq.com</span><br><span class="line">username: *********@qq.com</span><br><span class="line">password: *********</span><br></pre></td></tr></table></figure><h3 id="11-消息"><a href="#11-消息" class="headerlink" title="11.消息"></a>11.消息</h3><p>消息发送方：生产者</p><p>消息接收方：消费者</p><p>​    同步消息</p><p>​    异步消息</p><p>企业级应用中广泛使用的三种异步消息传递技术 JMS AMQP MQTT</p><p>JMS</p><p>​    JMS（Java Message Service）：一个规范，等同于JDBC规范，提供了与消息服务相关的API接口</p><p>JMS消息模型</p><p>​    peer-2-peer：点对点模型，消息发送到一个队列中，队列保存消息。队列的消息只能被一个消费者消费，或超时</p><p>​    publish-subscribe：发布订阅模型，消息可以被多个消费者消费，生产者和消费者完全独立，不需要感知对方的存在JMS消息种类</p><p>​    TextMessage</p><p>​    MapMessage</p><p>​    BytesMessage</p><p>​    StreamMessage</p><p>​    ObjectMessage</p><p>​    Message （只有消息头和属性）</p><p>JMS实现：ActiveMQ、Redis、HornetMQ、RabbitMQ、RocketMQ（没有完全遵守JMS规范）</p><p>AMQP</p><p>​    AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS</p><p>​    优点：具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现</p><p>AMQP消息模型</p><p>​    direct exchange</p><p>​    fanout exchange</p><p>​    topic exchange</p><p>​    headers exchange</p><p>​    system exchange</p><p>AMQP消息种类：byte[]</p><p>AMQP实现：RabbitMQ、StormMQ、RocketMQ</p><p>MQTT</p><p>​    MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一</p><p>Kafka</p><p>​    Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。</p><p>ActiveMQ</p><p>启动服务</p><p>​    activemq.bat</p><p>访问服务器</p><p>​    <a href="http://127.0.0.1:8161/">http://127.0.0.1:8161/</a></p><p>服务端口：61616，管理后台端口：8161</p><p>用户名&amp;密码：admin</p><p>SpringBoot整合ActiveMQ</p><p>配置ActiveMQ（采用默认配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    activemq:</span><br><span class="line">        broker-url: tcp://localhost:61616</span><br><span class="line">    jms:</span><br><span class="line">        //发布订阅模式，是否一对多</span><br><span class="line">        pub-sub-domain: true</span><br><span class="line">        template:</span><br><span class="line">            default-destination: itheima</span><br></pre></td></tr></table></figure><p>SpringBoot整合RabbitMQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置RabbitMQ （采用默认配置）</span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        port: 5672</span><br></pre></td></tr></table></figure><p>绑定键匹配规则</p><p>​    * (星号)： 用来表示一个单词 ，且该单词是必须出现的</p><p>​    # (井号)： 用来表示任意数量</p><div class="table-container"><table><thead><tr><th>匹配键</th><th>topic.<em>.</em></th><th>topic.#</th></tr></thead><tbody><tr><td>ic.order.id</td><td>true</td><td>true</td></tr><tr><td>order.topic.id</td><td>false</td><td>false</td></tr><tr><td>topic.sm.order.id</td><td>false</td><td>true</td></tr><tr><td>topic.sm.id</td><td>false</td><td>true</td></tr><tr><td>topic.id.order</td><td>true</td><td>true</td></tr><tr><td>topic.id</td><td>false</td><td>true</td></tr><tr><td>topic.order</td><td>false</td><td>true</td></tr></tbody></table></div><p>RocketMQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置RocketMQ （采用默认配置）</span><br><span class="line">rocketmq:</span><br><span class="line">    name-server: localhost:9876</span><br><span class="line">    producer:</span><br><span class="line">        group: group_rocketmq</span><br></pre></td></tr></table></figure><p>Kafka</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置Kafka （采用默认配置）</span><br><span class="line">spring:</span><br><span class="line">    kafka:</span><br><span class="line">        bootstrap-servers: localhost:9092</span><br><span class="line">        consumer:</span><br><span class="line">            group-id: order</span><br></pre></td></tr></table></figure><h3 id="12-监控"><a href="#12-监控" class="headerlink" title="12.监控"></a>12.监控</h3><p>监控的意义</p><p>​    监控服务状态是否宕机</p><p>​    监控服务运行指标（内存、虚拟机、线程、请求等）</p><p>​    监控日志</p><p>​    管理服务（服务下线）</p><p>监控的实施方式</p><p>​    显示监控信息的服务器：用于获取服务信息，并显示对应的信息</p><p>​    运行的服务：启动时主动上报，告知监控服务器自己需要受到监控</p><p>可视化监控平台</p><p>​    Spring Boot Admin，开源社区项目，用于管理和监控SpringBoot应用程序。 客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Admin服务端</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">Admin客户端</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Admin服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure><p>设置启用Spring-Admin</p><p>​    启动类上加@EnableAdminServer</p><p>Admin客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    boot:</span><br><span class="line">        admin:</span><br><span class="line">            client:</span><br><span class="line">                url: http://localhost:8080</span><br><span class="line">management:</span><br><span class="line">    endpoint:</span><br><span class="line">        health:</span><br><span class="line">            show-details: always</span><br><span class="line">    endpoints:</span><br><span class="line">        web:</span><br><span class="line">            exposure:</span><br><span class="line">                include: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>监控原理</p><p>​    Actuator提供了SpringBoot生产就绪功能，通过端点的配置与访问，获取端点信息</p><p>​    端点描述了一组监控信息，SpringBoot提供了多个内置端点，也可以根据需要自定义端点信息</p><p>​    访问当前应用所有端点信息：/actuator</p><p>​    访问端点详细信息：/actuator/端点名称</p><p>health 显示应用程序健康信息</p><p>info     显示应用程序信息</p><p>liquibase 显示已应用的 Liquibase 数据库迁移</p><p>metrics 显示当前应用程序的指标度量信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">启用指定端点</span><br><span class="line">management:</span><br><span class="line">    endpoint:</span><br><span class="line">        health: # 端点名称</span><br><span class="line">            enabled: true</span><br><span class="line">            show-details: always</span><br><span class="line">        beans: # 端点名称</span><br><span class="line">            enabled: true</span><br><span class="line">启用所有端点</span><br><span class="line">management:</span><br><span class="line">    endpoints:</span><br><span class="line">        enabled-by-default: true</span><br></pre></td></tr></table></figure><p>暴露端点功能</p><p>端点中包含的信息存在敏感信息，需要对外暴露端点功能时手动设定指定端点信息</p><div class="table-container"><table><thead><tr><th>属性</th><th>默认</th></tr></thead><tbody><tr><td>management.endpoints.jmx.exposure.exclude</td><td></td></tr><tr><td>management.endpoints.jmx.exposure.include</td><td>*</td></tr><tr><td>management.endpoints.web.exposure.exclude</td><td></td></tr><tr><td>management.endpoints.web.exposure.include</td><td>info, health</td></tr></tbody></table></div><p>自定义监控指标</p><p>为info端点添加自定义指标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">appName: @project.artifactId@</span><br><span class="line">version: @project.version@</span><br><span class="line">author: itheima</span><br></pre></td></tr></table></figure><p>自定义端点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Endpoint(id=&quot;pay&quot;)</span><br><span class="line">public class PayEndPoint &#123;</span><br><span class="line">    @ReadOperation</span><br><span class="line">    public Object getPay()&#123;</span><br><span class="line">        //调用业务操作，获取支付相关信息结果，最终return出去</span><br><span class="line">        Map payMap = new HashMap();</span><br><span class="line">        payMap.put(&quot;level 1&quot;,103);</span><br><span class="line">        payMap.put(&quot;level 2&quot;,315);</span><br><span class="line">        payMap.put(&quot;level 3&quot;,666);</span><br><span class="line">        return payMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-Bean"><a href="#13-Bean" class="headerlink" title="13.Bean"></a>13.Bean</h3><p>—@Configuration(proxyBeanMethods = true)    //默认为true</p><p>​    使用proxyBeanMethods=true可以保障调用此方法得到的对象是从容器中获取的而不是重新创建的</p><p>​    proxyBeanMethods=false    //每次bean创建一个新的对象</p><p>—导入实现了ImportSelector接口的类，实现对导入源的编程式处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector&#123;</span><br><span class="line">    public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        boolean flag = metadata.hasAnnotation(&quot;org.springframework.context.annotation.Import&quot;);</span><br><span class="line">        //各种各样的判断，判定完毕后，决定是否装在指定的bean</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            return new String[]&#123;&quot;com.itheima.domain.Dog&quot;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String[]&#123;&quot;com.itheima.domain.Cat&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Import(MyImportSelector.class)    //dog类导入ImportSelector，可以查dog类中的所有信息</span><br><span class="line">public class dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—导入实现了ImportBeanDefinitionRegistrar接口的类，通过BeanDefinition的注册器注册实名bean，实现对容器中bean的裁定例如对现有bean的覆盖，进而达成不修改源代码的情况下更换实现的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//可以自定义bean的名称</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(dog.class).getBeanDefinition();</span><br><span class="line">            registry.registerBeanDefinition(&quot;yellow&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—导入实现了BeanDefinitionRegistryPostProcessor接口的类，通过BeanDefinition的注册器注册实名bean，实现对容器中bean的最终裁定    后处理器，最后进行裁决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;bookService&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14.bean的加载控制</p><p>使用@Conditional注解的派生注解设置各种组合条件控制bean的加载</p><p>匹配指定类</p><p>​    @ConditionalOnClass(Mouse.class)</p><p>​    @ConditionalOnMissingClass(“com.itheima.bean.Wolf”)</p><p>匹配指定类型的bean</p><p>​    @ConditionalOnBean(Mouse.class)</p><p>​    @ConditionalOnBean(name=”com.itheima.bean.Mouse”)</p><p>​    @ConditionalOnBean(name=”jerry”)</p><p>匹配指定环境</p><p>​    @ConditionalOnWebApplication</p><p>​    @ConditionalOnNotWebApplication</p><p>自动配置原理</p><ol><li><p>收集Spring开发者的编程习惯，整理开发过程使用的常用技术列表——&gt;(技术集A)</p></li><li><p>收集常用技术(技术集A)的使用参数，整理开发过程中每个技术的常用设置列表——&gt;(设置集B)</p></li><li><p>初始化SpringBoot基础环境，加载用户自定义的bean和导入的其他坐标，形成初始化环境</p></li><li><p>将技术集A包含的所有技术都定义出来，在Spring/SpringBoot启动时默认全部加载</p></li><li><p>将技术集A中具有使用条件的技术约定出来，设置成按条件加载，由开发者决定是否使用该技术（与初始化环境比对）</p></li><li><p>将设置集B作为默认配置加载（约定大于配置），减少开发者配置工作量</p></li><li><p>开放设置集B的配置覆盖接口，由开发者根据自身需要决定是否覆盖默认配置</p></li></ol><p>变更自动配置</p><p>自定义自动配置（META-INF/spring.factories）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itheima.bean.CartoonCatAndMouse</span><br></pre></td></tr></table></figure><p>控制SpringBoot内置自动配置类加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    autoconfigure:</span><br><span class="line">        exclude: </span><br><span class="line">            - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span><br><span class="line">            - org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration(excludeName = &quot;org.springframework.boot.autoconfigure.context.LifecycleAutoConfigurati</span><br></pre></td></tr></table></figure><ol><li><p>通过配置文件exclude属性排除自动配置</p></li><li><p>通过注解@EnableAutoConfiguration属性排除自动配置项</p></li><li><p>启用自动配置只需要满足自动配置条件即可</p></li><li><p>可以根据需求开发自定义自动配置项</p></li></ol><p>15.自定义starter</p><p>案例：记录系统访客独立IP访问次数</p><p>​    1. 每次访问网站行为均进行统计</p><p>​    2. 后台每10秒输出一次监控信息（格式：IP+访问次数）</p><p>业务功能开发</p><p>​    1. 使用自动配置加载业务功能</p><p>​    2. 切记使用之前先clean后install安装到maven仓库，确保资源更新</p><p>开启定时任务功能</p><p>​    @EnableScheduling</p><p>​    @Scheduled(cron = “0/10 <em> </em> <em> </em> ?”)</p><p>​        1. 完成业务功能定时显示报表</p><p>​        2. String.format()</p><p>定义属性类，加载对应属性</p><p>​    @ConfigurationProperties(prefix = “tools.ip”)</p><p>配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tools:</span><br><span class="line">    ip:</span><br><span class="line">        cycle: 2</span><br><span class="line">        cycle-reset: false</span><br><span class="line">        mode: detail</span><br></pre></td></tr></table></figure><p>设置加载IpProperties类为bean,自定义bean名称</p><p>​    @Component(“ipProperties”)</p><p>放弃配置属性创建bean方式，改为手工控制</p><p>​    @Import(IpProperties.class)</p><p>使用#{beanName.attrName}读取bean的属性</p><p>​    @Scheduled(cron = “0/#{ipProperties.cycle} <em> </em> <em> </em> ?”)    //有配置文件，用配置文件的，没配置文件用自己定义的5秒</p><p>自定义拦截器</p><p>​    统计功能的调用，不可能在源码中把要加载的统计功能一个方法一个方法的全部配置上去</p><p>​    在所有的方法调用之前把统计功能执行一遍    Aop思想    在web层用拦截器，放到starter里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class IpInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IpCountService ipCountService;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置核心配置类，加载拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    //将拦截器加载为bean</span><br><span class="line">    @Bean</span><br><span class="line">    public IpInterceptor ipInterceptor()&#123;</span><br><span class="line">        return new IpInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //注册拦截器，填写拦截的路径</span><br><span class="line">        registry.addInterceptor(ipInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助功能开发：开启yml的提示功能</p><p>导入配置处理器坐标    </p><p>在starter项目中加载坐标，复制出来META-INF/spring-configuration-metadata.json，配置好了消除坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>进行自定义提示功能开发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;hints&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;tools.ip.model&quot;,</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;value&quot;: &quot;detail&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;详细模式.&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;value&quot;: &quot;simple&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;极简模式.&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;一：开发&quot;&gt;&lt;a href=&quot;#一：开发&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SpringBoot" scheme="http://putongl.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SSM</title>
    <link href="http://putongl.github.io/SSM.html"/>
    <id>http://putongl.github.io/SSM.html</id>
    <published>2023-10-18T08:20:25.329Z</published>
    <updated>2023-10-18T08:18:15.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三大框架"><a href="#三大框架" class="headerlink" title="三大框架"></a>三大框架</h1><h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><h3 id="1-Spring是什么"><a href="#1-Spring是什么" class="headerlink" title="1. Spring是什么"></a>1. Spring是什么</h3><p>​    Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和AOP（Aspect OrientedProgramming：面向切面编程）为内核。提供了展现层 SpringMVC 和持久层 Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架</p><p>1.3 Spring的优势</p><p>​    1）方便解耦，简化开发</p><p>​        通过 Spring 提供的 IoC容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。</p><p>​        用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>​    2）AOP 编程的支持</p><p>​        通过 Spring的 AOP 功能，方便进行面向切面编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松实现。</p><p>​    3）声明式事务的支持</p><p>​        可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。</p><p>​    4）方便程序的测试</p><p>​        可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情</p><h3 id="2-Spring快速入门"><a href="#2-Spring快速入门" class="headerlink" title="2.Spring快速入门"></a>2.Spring快速入门</h3><p>​        ① 导入 Spring 开发的基本包坐标</p><p>​        ② 编写 Dao 接口和实现类</p><p>​        ③ 创建 Spring 核心配置文件</p><p>​        ④ 在 Spring 配置文件中配置 UserDaoImpl</p><p>​        ⑤ 使用 Spring 的 API 获得 Bean 实例</p><p>Spring的开发步骤</p><p>​        ① 导入坐标</p><p>​        ② 创建Bean</p><p>​        ③ 创建applicationContext.xml</p><p>​        ④ 在配置文件中进行配置</p><p>​        ⑤ 创建ApplicationContext对象getBean</p><h3 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3.Spring配置文件"></a>3.Spring配置文件</h3><p>3.1 Bean标签基本配置</p><p>​    用于配置对象交由Spring 来创建。</p><p>​    默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p><p>​    基本属性：</p><p>​        id：Bean实例在Spring容器中的唯一标识</p><p>​        class：Bean的全限定名称</p><p>3.2 Bean标签范围配置</p><p>scope：指对象的作用范围，取值如下：</p><div class="table-container"><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中</td></tr><tr><td>session</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</td></tr><tr><td>global session</td><td>WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session</td></tr></tbody></table></div><p>1）当scope的取值为singleton时</p><p>​    Bean的实例化个数：1个</p><p>​    Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例        加载核心配置文件时创建</p><p>Bean的生命周期：</p><p>​    对象创建：当应用加载，创建容器时，对象就被创建了</p><p>​    对象运行：只要容器在，对象一直活着</p><p>​    对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p><p>2）当scope的取值为prototype时</p><p>​    Bean的实例化个数：多个</p><p>​    Bean的实例化时机：当调用getBean()方法时实例化Bean</p><p>​    对象创建：当使用对象时，创建新的对象实例</p><p>​    对象运行：只要对象在使用中，就一直活着</p><p>​    对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</p><p>3.3 Bean生命周期配置</p><p>​    init-method：指定类中的初始化方法名称</p><p>​    destroy-method：指定类中销毁方法名称</p><p>3.4 Bean实例化三种方式</p><p>​    无参构造方法实例化</p><p>​    工厂静态方法实例化</p><p>​        工厂实例方法实例化</p><p>3.7 Bean的依赖注入概念</p><p>​    依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p><p>​    在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p><p>​    IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p><p>​    那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p><p>​    简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p><p>Bean的依赖注入方式</p><div class="table-container"><table><thead><tr><th>构造方法</th><th>set方法</th></tr></thead><tbody><tr><td>构造注入</td><td>name表示构造方法形参列表的参数名</td></tr><tr><td>set注入</td><td>name表示set方法的后缀名称</td></tr><tr><td>ref</td><td>引用容器中bean的id</td></tr></tbody></table></div><p>Spring的重点配置</p><p>标签</p><p>​    id属性:在容器中Bean实例的唯一标识，不允许重复</p><p>​    class属性:要实例化的Bean的全限定名</p><p>​    scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</p><p>标签：属性注入</p><p>​    name属性：属性名称</p><p>​    value属性：注入的普通属性值</p><p>​    ref属性：注入的对象引用值</p><p>​    <code>&lt;list&gt;</code>标签</p><p>​    <code>&lt;map&gt;</code>标签</p><p>​    <code>&lt;properties&gt;</code>标签</p><p>​    <code>&lt;constructor-arg&gt;</code>构造标签    相当于<code>&lt;bean&gt;</code>标签</p><p>​    <code>&lt;import&gt;</code>标签:导入其他的Spring的分文件</p><h3 id="4-Spring相关API"><a href="#4-Spring相关API" class="headerlink" title="4.Spring相关API"></a>4.Spring相关API</h3><p>4.2 ApplicationContext的实现类</p><p>​    1）ClassPathXmlApplicationContext</p><p>​        它是从类的根路径下加载配置文件 推荐使用这种</p><p>​    2）FileSystemXmlApplicationContext</p><p>​        它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><p>​    3）AnnotationConfigApplicationContext</p><p>​        当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p><p>4.3 getBean()方法</p><p>​    1.传标签的id        适用于一个类型多个bean</p><p>​        使用当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p><p>​    2.传字节码对象类型        适用于一个类型一个bean，当存在一个类型多个bean时分辨不出来，不能使用</p><p>​        当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</p><h2 id="2-Spring配置数据源"><a href="#2-Spring配置数据源" class="headerlink" title="2.Spring配置数据源"></a>2.Spring配置数据源</h2><h3 id="1-数据源（连接池）的作用"><a href="#1-数据源（连接池）的作用" class="headerlink" title="1.数据源（连接池）的作用"></a>1.数据源（连接池）的作用</h3><p>​    常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p><p>1.2抽取jdbc配置文件</p><p>​    applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p><p>​    首先，需要引入context命名空间和约束路径：</p><p>​    命名空间：xmlns:context=”<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“</p><p>​    约束路径：</p><p>​        <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></p><p>​        <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p><p>1.5 知识要点</p><p>Spring容器加载properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="2-Spring注解开发"><a href="#2-Spring注解开发" class="headerlink" title="2.Spring注解开发"></a>2.Spring注解开发</h3><p>2.1 Spring原始注解</p><p>Spring原始注解主要是替代的配置</p><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table></div><p>2.2 Spring新注解</p><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p><p>​    非自定义的Bean的配置：<code>&lt;bean&gt;</code></p><p>​    加载properties文件的配置：<code>&lt;context:property-placeholder&gt;</code></p><p>​    组件扫描的配置：<code>&lt;context:component-scan&gt;</code></p><p>​    引入其他文件：<code>&lt;import&gt;</code></p><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>Spring的核心配置类        总    -&gt;    分</td></tr><tr><td>@ComponentScan</td><td>扫描     跟xml中一样</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties 文件中的配置</td></tr><tr><td>@Import</td><td>导入分类        用于导入其他配置类</td></tr></tbody></table></div><h3 id="3-Spring集成Junit"><a href="#3-Spring集成Junit" class="headerlink" title="3.Spring集成Junit"></a>3.Spring集成Junit</h3><p>3.1 原始Junit测试Spring的问题</p><p>​    在测试类中，每个测试方法都有以下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure><p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p><p>3.3 Spring集成Junit步骤</p><p>​    ① 导入spring集成Junit的坐标</p><p>​    ② 使用@Runwith注解替换原来的运行期</p><p>​    ③ 使用@ContextConfiguration指定配置文件或配置类</p><p>​    ④ 使用@Autowired注入需要测试的对象</p><p>​    ⑤ 创建测试方法进行测试</p><h2 id="3-SpringMVC入门"><a href="#3-SpringMVC入门" class="headerlink" title="3.SpringMVC入门"></a>3.SpringMVC入门</h2><h3 id="1-Spring集成web环境"><a href="#1-Spring集成web环境" class="headerlink" title="1.Spring集成web环境"></a>1.Spring集成web环境</h3><p>1.1 ApplicationContext应用上下文获取方式</p><p>​    应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p><p>​    在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了</p><p>1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</p><p>所以我们需要做的只有两件事：</p><p>​    ① 在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</p><p>​    ② 使用WebApplicationContextUtils获得应用上下文对象ApplicationContext</p><p>1.5 知识要点</p><p>Spring集成web环境步骤</p><p>​    ① 配置ContextLoaderListener监听器</p><p>​    ② 使用WebApplicationContextUtils获得应用上下文</p><h3 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2.SpringMVC 简介"></a>2.SpringMVC 简介</h3><p>2.1 SpringMVC概述</p><p>​    SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p><p>​    SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p><p>2.3 SpringMVC快速入门</p><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤：</p><p>​    ① 导入SpringMVC相关坐标</p><p>​    ② 配置SpringMVC核心控制器DispathcerServlet</p><p>​    ③ 创建Controller类和视图页面</p><p>​    ④ 使用注解配置Controller类中业务方法的映射地址</p><p>​    ⑤ 配置SpringMVC核心文件 spring-mvc.xml</p><p>​    ⑥ 客户端发起请求测试</p><p>2.4 知识要点</p><p>​    SpringMVC的开发步骤</p><p>​    ① 导入SpringMVC相关坐标</p><p>​    ② 配置SpringMVC核心控制器DispathcerServlet</p><p>​    ③ 创建Controller类和视图页面</p><p>​    ④ 使用注解配置Controller类中业务方法的映射地址</p><p>​    ⑤ 配置SpringMVC核心文件 spring-mvc.xml</p><p>​    ⑥ 客户端发起请求测试</p><h3 id="3-SpringMVC组件解析"><a href="#3-SpringMVC组件解析" class="headerlink" title="3.SpringMVC组件解析"></a>3.SpringMVC组件解析</h3><ol><li>前端控制器：DispatcherServlet</li></ol><p>​    用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p><ol><li>处理器映射器：HandlerMapping</li></ol><p>​    HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><ol><li>处理器适配器：HandlerAdapter</li></ol><p>​    通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><ol><li>处理器：Handler</li></ol><p>​    它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</p><ol><li>视图解析器：View Resolver</li></ol><p>​    View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p><ol><li>视图：View</li></ol><p>​    SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p><h3 id="4-SpringMVC注解解析"><a href="#4-SpringMVC注解解析" class="headerlink" title="4.SpringMVC注解解析"></a>4.SpringMVC注解解析</h3><p>@RequestMapping</p><p>​    作用：用于建立请求 URL 和处理请求方法之间的对应关系</p><p>​    位置：</p><p>​        类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录</p><p>​        方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p><p>​    属性：</p><p>​        value：用于指定请求的URL。它和path属性的作用是一样的</p><p>​        method：用于指定请求的方式</p><p>​        params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</p><p>​    例如：</p><p>​        params = {“accountName”}，表示请求参数必须有accountName</p><p>​        params = {“moeny!100”}，表示请求参数中money不能是100</p><ol><li><p>mvc命名空间引入</p></li><li><p>组件扫描</p></li></ol><p>​    SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用进行组件扫描。</p><p>3.4 SpringMVC的XML配置解析</p><p>​    视图解析器</p><p>​    SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</p><p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p><p>​    REDIRECT_URL_PREFIX = “redirect:”     —重定向前缀</p><p>​    FORWARD_URL_PREFIX = “forward:”         —转发前缀（默认值）</p><p>​    prefix = “”; —视图名称前缀</p><p>​    suffix = “”; —视图名称后缀</p><h3 id="5-pringMVC的请求和响应"><a href="#5-pringMVC的请求和响应" class="headerlink" title="5.pringMVC的请求和响应"></a>5.pringMVC的请求和响应</h3><ol><li>SpringMVC的数据响应</li></ol><p>1.1 SpringMVC的数据响应方式</p><p>1） 页面跳转</p><p>​    直接返回字符串</p><p>​    通过ModelAndView对象返回</p><p>2） 回写数据</p><p>​    直接返回字符串</p><p>​    返回对象或集合</p><p>1.3 回写数据</p><p>返回对象或集合</p><p>​    在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。</p><p>​    在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p><p>​    使用自动加载 RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用替代注解处理器和适配器的配置。</p><p>​    同时使用默认底层就会集成jackson进行对象或集合的json格式字符串的转换。</p><ol><li>SpringMVC 获得请求数据</li></ol><p>2.1 获得请求参数</p><p>​    客户端请求参数的格式是：name=value&amp;name=value… …</p><p>​    服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p><p>​        基本类型参数</p><p>​        POJO类型参数</p><p>​        数组类型参数</p><p>​        集合类型参数</p><p>2.2 获得基本类型参数</p><p>​    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。</p><p>2.3 获得POJO类型参数</p><p>​    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p><p>2.4 获得数组类型参数</p><p>​    Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p><p>2.5 获得集合类型参数</p><p>​    获得集合参数时，要将集合参数包装到一个POJO中才可以。</p><p>​    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。</p><p>​    注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p><p>​        1.在spring-mvc.xml配置文件中指定放行的资源 </p><p>​        2.使用标签</p><p>2.6 请求数据乱码问题</p><p>​    当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p><p>2.7 参数绑定注解@requestParam</p><p>​    当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。</p><p>​    注解@RequestParam还有如下参数可以使用：</p><p>​        value：与请求参数名称</p><p>​        required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错</p><p>​        defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</p><p>2.8 获得Restful风格的参数</p><p>​    Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>​    Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><p>​        GET：用于获取资源</p><p>​        POST：用于新建资源</p><p>​        PUT：用于更新资源</p><p>​        DELETE：用于删除资源</p><p>​    例如：</p><p>​        /user/1 GET ： 得到 id = 1 的 user</p><p>​        /user/1 DELETE： 删除 id = 1 的 user</p><p>​        /user/1 PUT： 更新 id = 1 的 user</p><p>​        /user POST： 新增 user</p><p>​    上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p><p>2.9 自定义类型转换器</p><p>​    • SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p><p>​    • 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p><p>自定义类型转换器的开发步骤：</p><p>​    ① 定义转换器类实现Converter接口</p><p>​    ② 在配置文件中声明转换器</p><p>​    ③ 在中引用转换器</p><p>2.10 获得Servlet相关API</p><p>​    SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p><p>​        HttpServletRequest</p><p>​        HttpServletResponse</p><p>​        HttpSession</p><p>2.11 获得请求头</p><ol><li>@RequestHeader</li></ol><p>​    使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p><p>@RequestHeader注解的属性如下：</p><p>​    value：请求头的名称</p><p>​    required：是否必须携带此请求头</p><ol><li>@CookieValue</li></ol><p>​        使用@CookieValue可以获得指定Cookie的值</p><p>​    @CookieValue注解的属性如下：</p><p>​        value：指定cookie的名称</p><p>​        required：是否必须携带此cookie</p><p>2.12 文件上传</p><ol><li>文件上传客户端三要素</li></ol><p>​        表单项type=“file”</p><p>​        表单的提交方式是post</p><p>​        表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data”</p><ol><li>文件上传原理</li></ol><p>​        当form表单修改为多部分表单时，request.getParameter()将失效。</p><p>​        enctype=“application/x-www-form-urlencoded”时，form表单的正文内容格式是：</p><p>​        key=value&amp;key=value&amp;key=value</p><p>​        当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：</p><p>2.13 单文件上传步骤</p><p>​    ① 导入fileupload和io坐标</p><p>​    ② 配置文件上传解析器</p><p>​    ③ 编写文件上传代码</p><p>2.15 多文件上传实现    同一个文件名</p><p>​    多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[ ]即可</p><ol><li>Spring JdbcTemplate基本使用</li></ol><p>1.1 JdbcTemplate概述</p><p>​    它是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p><p>1.2 JdbcTemplate开发步骤</p><p>​    ① 导入spring-jdbc和spring-tx坐标</p><p>​    ② 创建数据库表和实体</p><p>​    ③ 创建JdbcTemplate对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(dataSource);</span><br></pre></td></tr></table></figure><p>④ 执行数据库操作</p><p>更新操作：</p><p>​    jdbcTemplate.update (sql,params)</p><p>查询操作：</p><p>​    jdbcTemplate.query (sql,Mapper,params)</p><p>​    jdbcTemplate.queryForObject(sql,Mapper,params)</p><p>web层用注解  service层和dao层用配置文件</p><h3 id="6-SpringMVC拦截器"><a href="#6-SpringMVC拦截器" class="headerlink" title="6.SpringMVC拦截器"></a>6.SpringMVC拦截器</h3><p>1.1 拦截器（interceptor）的作用</p><p>​    Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p><p>1.2 拦截器和过滤器区别</p><div class="table-container"><table><thead><tr><th>区别</th><th>过滤器（Filter）</th><th>拦截器（Interceptor）</th></tr></thead><tbody><tr><td>使用范围</td><td>是 servlet 规范中的一部分，任何Java Web 工程都可以使用</td><td>是 SpringMVC 框架自己的，只有使用了SpringMVC 框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截</td><td>在中配置了/**之后，也可以多所有资源进行拦截，但是可以通过标签排除不需要拦截的资源</td></tr></tbody></table></div><p>1.3 拦截器是快速入门</p><p>自定义拦截器很简单，只有如下三步：</p><p>​    ① 创建拦截器类实现HandlerInterceptor接口</p><p>​    ② 配置拦截器</p><p>​    ③ 测试拦截器的拦截效果</p><p>1.4 多拦截器操作同上，在编写一个MyHandlerInterceptor2操作，测试执行顺序</p><p>​    12    21    21        跟栈一样，先进后出，后进先出</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法</td></tr><tr><td>postHandle()</td><td>该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作</td></tr><tr><td>afterCompletion()</td><td>该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是preHandle 方法的返回值为true 时才能被调用</td></tr></tbody></table></div><h3 id="7-SpringMVC异常处理机制"><a href="#7-SpringMVC异常处理机制" class="headerlink" title="7.SpringMVC异常处理机制"></a>7.SpringMVC异常处理机制</h3><ol><li>SpringMVC异常处理</li></ol><p>1.1 异常处理的思路</p><p>​    系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>​    系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理</p><p>1.2 异常处理两种方式</p><p>​    使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</p><p>​    实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p><p>​        ① 创建异常处理器类实现HandlerExceptionResolver</p><p>​        ② 配置异常处理器</p><p>​        ③ 编写异常页面</p><p>​        ④ 测试异常跳转</p><h2 id="4-面向切面编程AOP"><a href="#4-面向切面编程AOP" class="headerlink" title="4.面向切面编程AOP"></a>4.面向切面编程AOP</h2><h3 id="1-Spring-的-AOP-简介"><a href="#1-Spring-的-AOP-简介" class="headerlink" title="1. Spring 的 AOP 简介"></a>1. Spring 的 AOP 简介</h3><p>1.1 什么是 AOP</p><p>​    AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>​    动态代理：解耦合，不改变源码的同时，增强原方法的功能</p><p>​    AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p><p>1.2 AOP 的作用及其优势</p><p>​    作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>​    优势：减少重复代码，提高开发效率，并且便于维护</p><p>1.3 AOP 的底层实现</p><p>​    实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><p>1.4 AOP 的动态代理技术</p><p>​    常用的动态代理技术</p><p>​    JDK 代理 : 基于接口的动态代理技术</p><p>​    cglib 代理：基于父类的动态代理技术</p><p>1.7 AOP 相关概念</p><p>​    Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>​    在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p><div class="table-container"><table><thead><tr><th>Target（目标对象）</th><th>代理的目标对象</th></tr></thead><tbody><tr><td>Proxy （代理）</td><td>一个类被 AOP 织入增强后，就产生一个结果代理类</td></tr><tr><td>Joinpoint（连接点）</td><td>所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点<br />可以被增强的方法叫做连接点</td></tr><tr><td>Pointcut（切入点）</td><td>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br />需要被增强的方法</td></tr><tr><td>Advice（通知/ 增强）</td><td>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br />增强的方法</td></tr><tr><td>Aspect（切面）</td><td>是切入点和通知（引介）的结合</td></tr><tr><td>Weaving（织入）</td><td>是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入<br />将切点和通知结合的过程</td></tr></tbody></table></div><p>1.8 AOP 开发明确的事项</p><ol><li>需要编写的内容</li></ol><p>​    编写核心业务代码（目标类的目标方法）</p><p>​    编写切面类，切面类中有通知(增强功能方法)</p><p>​    在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p><ol><li>AOP 技术实现的内容</li></ol><p>​    Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><ol><li>AOP 底层使用哪种代理方式</li></ol><p>​    在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式</p><p>1.9 知识要点</p><p>​    aop：面向切面编程</p><p>​    aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理</p><p>​    aop的重点概念：</p><p>​        Pointcut（切入点）：被增强的方法</p><p>​        Advice（通知/ 增强）：封装增强业务逻辑的方法</p><p>​        Aspect（切面）：切点+通知</p><p>​        Weaving（织入）：将切点与通知结合的过程</p><p>​    开发明确事项：</p><p>​        谁是切点（切点表达式配置）</p><p>​        谁是通知（切面类中的增强方法）</p><p>​        将切点和通知进行织入配置</p><h3 id="2-基于-XML-的-AOP-开发"><a href="#2-基于-XML-的-AOP-开发" class="headerlink" title="2.基于 XML 的 AOP 开发"></a>2.基于 XML 的 AOP 开发</h3><p>2.1 快速入门</p><p>​    ① 导入 AOP 相关坐标</p><p>​    ② 创建目标接口和目标类（内部有切点）</p><p>​    ③ 创建切面类（内部有增强方法）</p><p>​    ④ 将目标类和切面类的对象创建权交给 spring</p><p>​    ⑤ 在 applicationContext.xml 中配置织入关系</p><p>​    ⑥ 测试代码</p><p>2.2 XML 配置 AOP 详解</p><ol><li>切点表达式的写法</li></ol><p>表达式语法：</p><p>​    execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p><p>​    访问修饰符可以省略</p><p>​    返回值类型、包名、类名、方法名可以使用星号* 代表任意</p><p>​    包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p><p>​    参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br><span class="line">execution(public void com.itheima.aop.Target.method())</span><br><span class="line">execution(void com.itheima.aop.Target.*(..))</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><ol><li>通知的类型</li></ol><p>通知的配置语法：</p><div class="table-container"><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td></td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td></td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td></td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td></td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td></td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table></div><ol><li>切点表达式的抽取</li></ol><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p><p>2.3知识要点</p><p>aop的织入</p><p>​    通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知</p><p>​    切点表达式的写法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p><h3 id="3-基于注解的-AOP-开发"><a href="#3-基于注解的-AOP-开发" class="headerlink" title="3.基于注解的 AOP 开发"></a>3.基于注解的 AOP 开发</h3><p>3.1 快速入门</p><p>基于注解的aop开发步骤：</p><p>​    ① 创建目标接口和目标类（内部有切点）</p><p>​    ② 创建切面类（内部有增强方法）</p><p>​    ③ 将目标类和切面类的对象创建权交给 spring</p><p>​    ④ 在切面类中使用注解配置织入关系</p><p>​    ⑤ 在配置文件中开启组件扫描和 AOP 的自动代理</p><p>​    ⑥ 测试</p><p>3.2 注解配置 AOP 详解</p><ol><li>注解通知的类型</li></ol><p>通知的配置语法：@通知注解(“切点表达式”)</p><div class="table-container"><table><thead><tr><th>名称</th><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>@Before</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>@AfterReturning</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>@Around</td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>@AfterThrowing</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>@After</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table></div><ol><li>切点表达式的抽取</li></ol><p>​    同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@@Component(&quot;myAspect&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">@Before(&quot;MyAspect.myPoint()&quot;)</span><br><span class="line">public void before()&#123;</span><br><span class="line">System.out.println(&quot;前置代码增强.....&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void myPoint()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解aop开发步骤</p><p>​    ① 使用@Aspect标注切面类</p><p>​    ② 使用@通知注解标注通知方法</p><p>​    ③ 在配置文件中配置aop自动代理</p><h2 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h2><h3 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1.编程式事务控制相关对象"></a>1.编程式事务控制相关对象</h3><p>1.1 PlatformTransactionManager </p><p>​    PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus getTransaction(TransactionDefination defination)</td><td>获取事务的状态信息</td></tr><tr><td>void commit(TransactionStatus status)</td><td>提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>回滚事务</td></tr></tbody></table></div><p>注意：</p><p>​    PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：</p><p>​    Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager </p><p>​    Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p><p>1.2 TransactionDefinitionTransactionDefinition </p><p>是事务的定义信息对象，里面有如下方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getIsolationLevel()</td><td>获得事务的隔离级别</td></tr><tr><td>int getPropogationBehavior()</td><td>获得事务的传播行为</td></tr><tr><td>int getTimeout()</td><td>获得超时时间</td></tr><tr><td>boolean isReadOnly()</td><td>是否只读</td></tr></tbody></table></div><ol><li>事务隔离级别</li></ol><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p><p>​    ISOLATION_DEFAULT</p><p>​    ISOLATION_READ_UNCOMMITTED</p><p>​    ISOLATION_READ_COMMITTED</p><p>​    ISOLATION_REPEATABLE_READ</p><p>​    ISOLATION_SERIALIZABLE</p><ol><li>事务传播行为</li></ol><p>​    REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</p><p>​    SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</p><p>​    MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p><p>​    REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p><p>​    NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p><p>​    NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p><p>​    NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p><p>​    超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p><p>​    是否只读：建议查询时设置为只读</p><p>1.3 TransactionStatus</p><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasSavepoint()</td><td>是否存储回滚点</td></tr><tr><td>boolean isCompleted()</td><td>事务是否完成</td></tr><tr><td>boolean isNewTransaction()</td><td>是否是新事务</td></tr><tr><td>boolean isRollbackOnly()</td><td>事务是否回滚</td></tr></tbody></table></div><h3 id="2-基于-XML-的声明式事务控制"><a href="#2-基于-XML-的声明式事务控制" class="headerlink" title="2.基于 XML 的声明式事务控制"></a>2.基于 XML 的声明式事务控制</h3><p>2.1 什么是声明式事务控制</p><p>​    Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p><p>声明式事务处理的作用</p><p>​    事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p><p>​    在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p><p>​    注意：Spring 声明式事务控制底层就是AOP。</p><p>2.2 声明式事务控制的实现</p><p>声明式事务控制明确事项：</p><p>​    谁是切点？</p><p>​    谁是通知？</p><p>​    配置切面？</p><p>2.3 切点方法的事务参数的配置</p><p>其中， 代表切点方法的事务参数的配置，例如：</p><p>​    name：切点方法名称</p><p>​    isolation:事务的隔离级别</p><p>​    propogation：事务的传播行为</p><p>​    timeout：超时时间</p><p>​    read-only：是否只读</p><p>2.4 知识要点</p><p>​    声明式事务控制的配置要点</p><p>​    平台事务管理器配置</p><p>​    事务通知的配置</p><p>​    事务aop织入的配置</p><h3 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3.基于注解的声明式事务控制"></a>3.基于注解的声明式事务控制</h3><p>3.2 注解配置声明式事务控制解析</p><p>​    ① 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p><p>​    ② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p><p>​    ③ 使用在方法上，不同的方法可以采用不同的事务参数配置。</p><p>​    ④ Xml配置文件中要开启事务的注解驱动</p><p>3.3 知识要点</p><p>​    注解声明式事务控制的配置要点</p><p>​    平台事务管理器配置（xml方式）</p><p>​    事务通知的配置（@Transactional注解配置）</p><p>​    事务注解驱动的配置 </p><h2 id="5-MyBatis入门操作"><a href="#5-MyBatis入门操作" class="headerlink" title="5.MyBatis入门操作"></a>5.MyBatis入门操作</h2><h3 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1.Mybatis简介"></a>1.Mybatis简介</h3><p>1.2 原始jdbc操作的分析</p><p>原始jdbc开发存在的问题如下：</p><p>​    ① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</p><p>​    ② sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。</p><p>​    ③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p><p>应对上述问题给出的解决方案：</p><p>​    ① 使用数据库连接池初始化连接资源</p><p>​    ② 将sql语句抽取到xml配置文件中</p><p>​    ③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p><p>1.3 什么是Mybatis</p><p>​    mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p><p>​    mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p><p>​    最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p><h3 id="2-MyBatis开发步骤"><a href="#2-MyBatis开发步骤" class="headerlink" title="2.MyBatis开发步骤"></a>2.MyBatis开发步骤</h3><p>MyBatis开发步骤：</p><p>​    ① 添加MyBatis的坐标</p><p>​    ② 创建user数据表</p><p>​    ③ 编写User实体类</p><p>​    ④ 编写映射文件UserMapper.xml</p><p>​    ⑤ 编写核心文件SqlMapConfig.xml</p><p>​    ⑥ 编写测试类</p><p>2.2 环境搭建</p><ol><li><p>导入MyBatis的坐标和其他相关坐标</p></li><li><p>MyBatis的增删改查操作</p></li></ol><p>知识小结</p><p>增删改查映射配置与API：</p><p>查询数据：List userList = sqlSession.selectList(“userMapper.findAll”);</p><p>​        select * from User</p><p>添加数据：sqlSession.insert(“userMapper.add”, user);</p><p>​        insert into user values(#{id},#{username},#{password})</p><p>修改数据：sqlSession.update(“userMapper.update”, user);</p><p>​        update user set username=#{username},password=#{password} where id=#{id}</p><p>删除数据：sqlSession.delete(“userMapper.delete”,3);</p><p>​        delete from user where id=#{id}</p><h3 id="5-MyBatis核心配置文件概述"><a href="#5-MyBatis核心配置文件概述" class="headerlink" title="5.MyBatis核心配置文件概述"></a>5.MyBatis核心配置文件概述</h3><p>5.1 MyBatis核心配置文件层级关系</p><p><img src="https://s2.loli.net/2023/10/17/JOETG5mYS7KMZNh.png" alt="image-20231017162302226"></p><p>5.2 MyBatis常用配置解析</p><ol><li>environments标签</li></ol><p>数据库环境的配置，支持多环境配置</p><p>​    其中，事务管理器（transactionManager）类型有两种：</p><p>​        • JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p><p>​        • MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p><p>其中，数据源（dataSource）类型有三种：</p><p>​    • UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p><p>​    • POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p><p>​    • JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p><ol><li>mapper标签</li></ol><p>该标签的作用是加载映射的，加载方式有如下几种：</p><p>​    • 使用相对于类路径的资源引用，例如：<code>&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;</code></p><p>​    • 使用完全限定资源定位符（URL），例如：<code>&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</code></p><p>​    • 使用映射器接口实现类的完全限定类名，例如：<code>&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</code></p><p>​    • 将包内的映射器接口实现全部注册为映射器，例如：<code>&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</code></p><ol><li>Properties标签</li></ol><p>​    实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p><ol><li>typeAliases标签</li></ol><p>类型别名是为Java 类型设置一个短的名字。</p><p>配置typeAliases，为com.itheima.domain.User定义别名为user</p><p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p><div class="table-container"><table><thead><tr><th>别名</th><th>数据类型</th></tr></thead><tbody><tr><td>string</td><td>String</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><h3 id="6-MyBatis相应API"><a href="#6-MyBatis相应API" class="headerlink" title="6.MyBatis相应API"></a>6.MyBatis相应API</h3><p>6.1 SqlSession工厂构建器SqlSessionFactoryBuilder</p><p>​    常用API：SqlSessionFactory build(InputStream inputStream)</p><p>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br></pre></td></tr></table></figure><p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p><p>6.2 SqlSession工厂对象SqlSessionFactory</p><p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：</p><div class="table-container"><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>openSession()</td><td>会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中</td></tr><tr><td>openSession(boolean autoCommit)</td><td>参数为是否自动提交，如果设置为true，那么不需要手动提交事务</td></tr></tbody></table></div><p>6.3 SqlSession会话对象</p><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</p><p>执行语句的方法主要有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T selectOne(String statement, Object parameter) </span><br><span class="line">List selectList(String statement, Object parameter) </span><br><span class="line">int insert(String statement, Object parameter) </span><br><span class="line">int update(String statement, Object parameter) </span><br><span class="line">int delete(String statement, Object parameter)</span><br></pre></td></tr></table></figure><p>操作事务的方法主要有：</p><p>​    void commit()</p><p>​    void rollback()</p><p>1.Mybatis的Dao层实现</p><p>代理开发方式</p><ol><li>代理开发方式介绍</li></ol><p>​    采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。</p><p>​    Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper 接口开发需要遵循以下规范：</p><p>​    1、 Mapper.xml文件中的namespace与mapper接口的全限定名相同</p><p>​    2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p><p>​    3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</p><p>​    4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p><p>MyBatis的Dao层实现的两种方式：</p><p>手动对Dao进行实现：传统开发方式</p><p>代理方式对Dao进行实现：</p><p>UserMapper userMapper = sqlSession.getMapper(UserMapper.class)</p><p><img src="https://s2.loli.net/2023/10/17/mWkVbga4nILj3MJ.png" alt="image-20231017162629569"></p><p>1.MyBatis映射文件深入</p><p>1.1 动态sql语句</p><ol><li>动态sql语句概述</li></ol><p>​    Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。‘</p><ol><li>动态 SQL 之 <code>&lt;if&gt;</code></li></ol><p>​    我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from User</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;if test=&quot;id!=0&quot;&gt;</span><br><span class="line">and id=#&#123;id&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;username!=null&quot;&gt;</span><br><span class="line">and username=#&#123;username&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol><li>动态 SQL 之 <code>&lt;foreach&gt;</code></li></ol><p>​    循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from User</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">#&#123;id&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>foreach标签的属性含义如下：</p><p>标签用于遍历集合，它的属性：</p><p>​    • collection：代表要遍历的集合元素，注意编写时不要写#{}</p><p>​    • open：代表语句的开始部分</p><p>​    • close：代表结束部分</p><p>​    • item：代表遍历集合的每个元素，生成的变量名</p><p>​    • sperator：代表分隔符</p><p>1.2 SQL片段抽取</p><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p><p>MyBatis映射文件配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;：查询</span><br><span class="line">&lt;insert&gt;：插入</span><br><span class="line">&lt;update&gt;：修改</span><br><span class="line">&lt;delete&gt;：删除</span><br><span class="line">&lt;where&gt;：where条件</span><br><span class="line">&lt;if&gt;：if判断</span><br><span class="line">&lt;foreach&gt;：循环</span><br><span class="line">&lt;sql&gt;：sql片段抽取</span><br></pre></td></tr></table></figure><ol><li>MyBatis核心配置文件深入</li></ol><p>1.1 typeHandlers标签</p><p>​    无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>​    你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p><p>开发步骤：</p><p>​    ① 定义转换类继承类BaseTypeHandler</p><p>​    ② 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法</p><p>​    ③ 在MyBatis核心配置文件中进行注册</p><p>​    ④ 测试转换是否正确</p><p>1.2 plugins标签</p><p>​    MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据</p><p>开发步骤：</p><p>​    ① 导入通用PageHelper的坐标</p><p>​    ② 在mybatis核心配置文件中配置PageHelper插件</p><p>​    ③ 测试分页数据获取</p><p>MyBatis核心配置文件常用标签：</p><p>​    1、properties标签：该标签可以加载外部的properties文件</p><p>​    2、typeAliases标签：设置类型别名</p><p>​    3、environments标签：数据源环境配置标签</p><p>​    4、typeHandlers标签：配置自定义类型处理器</p><p>​    5、plugins标签：配置MyBatis的插件    </p><p>MyBatis多表配置方式：</p><p>​    一对一配置：使用做配置</p><p>​    一对多配置：使用+做配置</p><p>​    多对多配置：使用+做配置</p><p>1.Mybatis的注解开发</p><p>​    1.1 MyBatis的常用注解</p><p>​    这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。</p><p>​    @Insert：实现新增</p><p>​    @Update：实现更新</p><p>​    @Delete：实现删除</p><p>​    @Select：实现查询</p><p>​    @Result：实现结果集封装</p><p>​    @Results：可以与@Result 一起使用，封装多个结果集</p><p>​    @One：实现一对一结果集封装</p><p>​    @Many：实现一对多结果集封装</p><p>1.3 MyBatis的注解实现复杂映射开发</p><p>​    实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置</p><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Results</td><td>代替的是标签该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（））</td></tr><tr><td>@Resut</td><td>代替了标签和标签@Result中属性介绍：column：数据库的列名property：需要装配的属性名one：需要使用的@One 注解（@Result（one=@One）（）））many：需要使用的@Many 注解（@Result（many=@many）（））</td></tr><tr><td>@One （一对一）</td><td>代替了 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One注解属性介绍：select: 指定用来多表查询的 sqlmapper使用格式：@Result(column=” “,property=””,one=@One(select=””))</td></tr><tr><td>@Many （多对一）</td><td>代替了标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。使用格式：@Result(property=””,column=””,many=@Many(select=””))</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三大框架&quot;&gt;&lt;a href=&quot;#三大框架&quot; class=&quot;headerlink&quot; title=&quot;三大框架&quot;&gt;&lt;/a&gt;三大框架&lt;/h1&gt;&lt;h2 id=&quot;1-Spring简介&quot;&gt;&lt;a href=&quot;#1-Spring简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SSM" scheme="http://putongl.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>javaSE</title>
    <link href="http://putongl.github.io/javaSE.html"/>
    <id>http://putongl.github.io/javaSE.html</id>
    <published>2023-10-18T08:20:25.324Z</published>
    <updated>2023-10-18T08:17:05.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javaSE"><a href="#javaSE" class="headerlink" title="javaSE"></a>javaSE</h2><h3 id="1-DOS命令："><a href="#1-DOS命令：" class="headerlink" title="1.DOS命令："></a>1.DOS命令：</h3><p>切换盘符    d：</p><p>dir              查看当前路径内容</p><p>cd 目录      进入当前目录   cd java</p><p>cd..            回到上级目录</p><p>cd 目录1\目录2..     进如多级目录</p><p>cd\             退回盘符目录</p><p>cls             清屏</p><p>exit            退出窗口</p><h3 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的执行从main开始</p><h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p>字符串常量“ “</p><p>字符常量‘ ’</p><p>空常量null</p><p>布尔常量ture false</p><h3 id="4-字节"><a href="#4-字节" class="headerlink" title="4.字节"></a>4.字节</h3><p>1B是1字节</p><p>1B=8bit</p><p>1KB=1024B</p><p>4.基本数据类型</p><p>整数  占位数</p><p>byte   1</p><p>short  2</p><p>int（默认）4</p><p>long   8</p><p>浮点（小数）float     4         1.4-3.4</p><p>double（默认）8        </p><p>字符 char        2</p><p>布尔 boolean    1</p><p>引用数据类型</p><p>类  class</p><p>接口 interface</p><p>数组  [ ]</p><p>小驼峰命名fristName</p><p>大驼峰命名GoodStudent</p><h3 id="5-报错"><a href="#5-报错" class="headerlink" title="5.报错"></a>5.报错</h3><p>​    非法字符  中英文符号问题</p><p>​    不存在    大小写写错了</p><h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>自动类型转换       </p><p>​    把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量</p><p>​        byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double    </p><p>​        char-&gt;int-&gt;long-&gt;float-&gt;double</p><p>​    强制类型转换相反        </p><p>​        把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p><p>​        目标数据类型 变量名=（目标数据类型）值或变量</p><p>​        int k=(int)88.88 double比int大 值的范围比目标数据类型大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println((a);<span class="comment">//97</span></span><br><span class="line">System.out.println((<span class="type">char</span>) a);  <span class="comment">//a</span></span><br></pre></td></tr></table></figure><h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p>​    字符串+字符串         拼接</p><p>​    字符串+数字+数字         拼接</p><p>​    数字+数字+字符串        前面两个数字相加拼接字符串</p><h3 id="8-赋值运算符"><a href="#8-赋值运算符" class="headerlink" title="8.赋值运算符"></a>8.赋值运算符</h3><p>​    +=    a=a+b    把左边和右边相加赋值给左边</p><p>​    -=    *=    /=    a=a+b</p><p>​    %=将a%b的余数给a</p><h3 id="9-自增自减"><a href="#9-自增自减" class="headerlink" title="9.自增自减"></a>9.自增自减</h3><p>​    单独使用 相等    i++=i++    i—=—i</p><p>​    参与操作使用</p><p>（1）放在变量后，先参与操作再++ —</p><pre><code>  int j=i++;        i赋值给j后自增 System.out.println(i);    i=11        i的值为i++  System.out.println(j);    j=10        j的值为未自增的i</code></pre><p>（2）放在变量前，先++ — 再参与操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int j=++i;i自增后赋值给j</span><br><span class="line">System.out.println(i);i=11i的值为i++</span><br><span class="line">System.out.println(j);j=11j的值为自增后的i</span><br></pre></td></tr></table></figure><p>9.关系运算符</p><p>​    ==为等于     !=不等于</p><p>​    =为赋值        成立为ture，不成立false</p><p>9.逻辑运算符</p><p>​    &amp; 与     a&amp;b 有false则为false</p><p>​    | 或         a|b    有ture则ture</p><p>​    ^ 异或    a^b    结果不同为ture 结果相同为false</p><p>​    ! 非        !a  结果与a相反</p><p>短路运算符</p><p>​    &amp;&amp;    短路与    有false则为false</p><p>​    ||    短路或    有ture则ture</p><p>注意：&amp;无论左边真假，右边都执行</p><p>​    &amp;&amp;左边真，右边执行，左边假，右边不执行</p><p>​    |无论左边真假，右边都执行</p><p>​    ||左边真，右边不执行，左边假，右边执行</p><h3 id="10-三元运算符"><a href="#10-三元运算符" class="headerlink" title="10.三元运算符"></a>10.三元运算符</h3><p>​    格式：关系表达式?表达式1:表达式2；</p><p>范例：a&gt;b?a:b;</p><p>​    首先计算关系表达式a&gt;b</p><p>​    若值为ture，输出表达式1 a</p><p>​    若值为false，输出表达式2 b</p><h3 id="11-switch语句"><a href="#11-switch语句" class="headerlink" title="11.switch语句"></a>11.switch语句</h3><p>表达式和case值比较相等替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">case 值1:语句体1; （春夏秋冬）case穿透case 1;</span><br><span class="line"> break;   case 2;</span><br><span class="line">case 值2:语句体2; case 3;</span><br><span class="line">break;春</span><br><span class="line">...</span><br><span class="line">default:</span><br><span class="line">语句体n+1;</span><br><span class="line">[break;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-循环语句"><a href="#12-循环语句" class="headerlink" title="12.循环语句"></a>12.循环语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(1.初始化语句;2.条件判断语句;4.条件控制语句)&#123;</span><br><span class="line">3.循环体语句;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i &lt;= 5; i++)&#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意数字指定位上的数字咋求</p><p>先使用整除操作将要求书移动到各位上，再取余操作求最后一位值</p><p>123456789        先除10000，在对10取余得5</p><p>while循环        先判断后执行</p><p>初始化语句；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(条件判断语句)&#123;</span><br><span class="line">循环体语句；</span><br><span class="line">条件控制语句；</span><br><span class="line">&#125;</span><br><span class="line">例.int i=1；</span><br><span class="line">while(i&lt;=5)&#123;</span><br><span class="line">循环体语句；</span><br><span class="line">i++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while循环        先执行后判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化语句；</span><br><span class="line">do&#123;</span><br><span class="line">循环体语句；</span><br><span class="line">条件控制语句；</span><br><span class="line">&#125;while（条件判断语句）；</span><br><span class="line">例.int j=1；</span><br><span class="line">do&#123;</span><br><span class="line">循环体语句；</span><br><span class="line">j++；</span><br><span class="line">&#125;while（j&lt;=5）;</span><br></pre></td></tr></table></figure><p>死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for（；；）&#123;循环体；&#125;</span><br><span class="line">while（true）&#123;循环体；&#125;</span><br><span class="line">do&#123;&#125;while（true）；</span><br></pre></td></tr></table></figure><h3 id="13-跳转控制语句break句和continue语句"><a href="#13-跳转控制语句break句和continue语句" class="headerlink" title="13.跳转控制语句break句和continue语句"></a>13.跳转控制语句break句和continue语句</h3><p>​    1、break语句:用在switch条件语句和循环语句中，它的作用是终止某个case (或循环)并跳出switch结构（或跳出当前的循环)。</p><p>​    2、continue语句:用在循环语句中，它的作用是终止本次循环，执行下—次循环(首先返回到循环是否执行的判断处)</p><p>​    continue        跳过某次循环体内容；继续下一次执行</p><p>​    break        终止循环体进行</p><h3 id="14-数据输入Scanner"><a href="#14-数据输入Scanner" class="headerlink" title="14.数据输入Scanner"></a>14.数据输入Scanner</h3><p>随机值Random</p><p>（1）导包     import java.util.Scanner;（Random）</p><p>手动导包 import java.util.Scanner;</p><p>快捷键导包 Alt +回车</p><p>自动导包     Scanner</p><p>（2）创建对象Scanner sc = new Scanner(System.in);</p><pre><code>  Random r = new Random();</code></pre><p>（3）接收数据 int hight1 = sc.nextInt();</p><pre><code>  获取随机数 int number=r.nextInt(10) + 1;    (从0到10获取随机数)包0不包括10</code></pre><h3 id="15-数组"><a href="#15-数组" class="headerlink" title="15.数组"></a>15.数组</h3><p>（1）数组动态初始化  </p><p>int[ ] arr = new int[3];    </p><p>//左边：int：说明数组的元素类型是int类型</p><p>​      [ ]：说明这是一个数组</p><p>​      arr：数组的名称</p><p>//右边：new：为数组申请内存空间</p><p>​      int：说明数组的元素类型是int类型</p><p>​      [ ]：说明这是一个数组</p><p>3:数组长度，其实就是数组的元素个数</p><p>​    int[ ] arr 栈内存：储存局部变量 例如：arr；使用完毕立即消失</p><p>​    new int[3] 堆内存：储存new出来的内容</p><p>​    //只指定数组长度，由系统分配初始值</p><p>​    整数：0          浮点数：0.0        布尔：false    </p><p>​    字符：空字符    引用数据类型:null</p><p>​    每一个new出来的东西都有一个地址值    使用完毕会在垃圾回收器空闲的时被回收</p><p>（2）索引：是数组中数据的编号方式    index</p><p>​    数组名[索引]等同于变量名，是一种特殊的变量名</p><p>​    特征：从0开始连续增加每次加1</p><p>（3）静态初始化</p><p>​    格式：数组类型[ ] 变量名 = new 数组类型[ ]{数据1，数据2，….}；</p><p>​    int[ ] arr      = new int[ ]{1,2,3};</p><p>​    简化格式：数组类型[ ] 变量名 = {数据1，数据2，数据3，….}；</p><p>（4）数组遍历通用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[ ] arr = &#123;11,22,33&#125;;</span><br><span class="line">for(int x=0;x&lt;=arr.length;x++)&#123;</span><br><span class="line">System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）数组获取最值</p><p>​    int[] arr = {15,4164,4894,8434,8746};    int max = arr[0];    for(int i=1;i<arr.length;i++){        if(arr[i] > max){            max = arr[i];        }    }    System.out.println(max);</p><h3 id="16-方法"><a href="#16-方法" class="headerlink" title="16.方法"></a>16.方法</h3><p>两个明确：</p><p>返回值类型：void/int</p><p>参数：int[ ] arr    </p><p>(1).定义: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void getMax (int number1，int number2，.... )&#123;</span><br><span class="line">方法内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)调用：方法名(变量名/常数);</p><p>int number1；</p><p>int number2；</p><p>getMax(number1/10，number2);</p><p>形参：方法定义中的参数    int number</p><p>实参：方法调用中的参数    10    number</p><p>带返回值方法的定义    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int（数据类型） getMAX（int a,int b）&#123;</span><br><span class="line">return 100；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return后的返回值与方法定义类型上的数据类型要匹配</p><p>调用格式</p><p>int flag = getMax(10,20)</p><p>（3）方法不能嵌套</p><p>​    void表示无返回值可以省略return；也可以单独写return</p><p>（4）方法通用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static 返回值类型 方法名（参数）&#123;</span><br><span class="line">方法体；</span><br><span class="line">return 数据；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public static        修饰符，记住这个格式</p><p>返回值类型        返回的数据的数据类型，没有数据返回填void，且一班不填return</p><p>方法名            调用方法时使用的标识</p><p>参数                由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>方法体            完成功能的代码块</p><p>return            有数据返回，写相应的数据类型，把数据返回给调用者</p><ul><li>调用时</li></ul><p>void类型，直接调用</p><p>非void类型，推荐用变量接收调用（返回啥类型，用啥类型接收）sout（getMax（10））；</p><h3 id="17-方法重载"><a href="#17-方法重载" class="headerlink" title="17.方法重载"></a>17.方法重载</h3><p>多个方法在同一个类中</p><p>多个方法有相同方法名</p><p>多个方法参数不相同，类型不同或数量不同</p><p>（1）基本类型    int number = 100；</p><p>​    方法参数传递形参的改变不会改变实参的值</p><p>（2）引用类型    int arr [ ] = {10，20，30}；</p><p>​    形参的改变影响实参值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();输出内容换行</span><br><span class="line">System.out.print();输出内容不换行</span><br></pre></td></tr></table></figure><h3 id="18-面向对象"><a href="#18-面向对象" class="headerlink" title="18.面向对象"></a>18.面向对象</h3><p>(1)类是有共同属性和行为的抽象</p><p>​    类是对象的抽象（数据类型）</p><p>​    对象是类的实体</p><p>(2)成员变量：类中方法外的变量（堆内存）有默认初始化值</p><p>​    局部变量：方法中的变量（栈内存）没有初始化值</p><p>(3)private  限制修饰符    //封装</p><p>​    作用：保护成员不被别的类使用，被private修饰的成员只能在本类中使用</p><p>​    set变量名(参数)    用于设置成员变量的名    用public修饰</p><p>​    get变量名()          用于获取成员变量的值    用public修饰</p><p>(4)this         //局部变量和成员变量同名时</p><p>​    被谁调用指的是谁的变量    this.name修饰成员变量</p><p>​    this.name = name            name修饰局部变量</p><p>(5)构造方法</p><p>无参构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Student()&#123;</span><br><span class="line">System.out.println(&quot;默认的构造方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">修饰符 类名(参数)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">例：</span><br><span class="line">public class Student&#123;</span><br><span class="line">public Student()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若没有定义构造方法，系统自动给与一个无参数构造方法</p><p>如果定义了构造方法，系统将不再提供默认构造方法</p><p>如果定义了构造方法还要使用无参数构造方法就必须再写一个无参构造方法（手动给出）</p><h3 id="19-API"><a href="#19-API" class="headerlink" title="19.API"></a>19.API</h3><p>(1)String构造方法        //不可变</p><p>​    public String()                创建一个空白字符串对象，不含任何内容</p><p>​    public String(char[] chs)        根据字符数组的内容来创建字符串对象</p><p>​    public String(byte[] bys)        根据字节数组的内容来创建字符串对象</p><p>​    String s = “abc”；            直接赋值的方式创建字符串对象，内容是abc</p><p>(2)字符串的比较</p><pre><code> ==         基本类型：比较数值是否相等 引用类型：比较地址是否相同        字符串String是类也是引用</code></pre><p>​    public boolean equals(Object anObgect)    比较字符串内容，区分大小写</p><p>​    比较字符串的内容equals()</p><p>​    sout(s1.equals(s2));    字符串常量放前面不会造成空指针异常</p><p>​    public char charAt(int index)        返回指定索引处的char值</p><p>​    public lit length()                返回字符串长度</p><p>(3)StringBuilder            //可变字符串</p><p>​    public StringBuilder()            空白可变字符串</p><p>​    public StringBuilder(String str)    根据字符串内容创建可变字符串对象</p><p>​    sb.append(“任意数”)            添加数据</p><p>​    sb.reverse()                    返回相反数据</p><p>​    sb.toString()                    StringBuilder转化为String</p><h3 id="20-快捷键"><a href="#20-快捷键" class="headerlink" title="20.快捷键"></a>20.快捷键</h3><p>​    alt+insert    自动生成构造方法和get方法 多选shift</p><p>​    \t   等于tab键 </p><h3 id="21-面向对象三大特征：封装性，继承性，多态性"><a href="#21-面向对象三大特征：封装性，继承性，多态性" class="headerlink" title="21.面向对象三大特征：封装性，继承性，多态性"></a>21.面向对象三大特征：封装性，继承性，多态性</h3><p>​    继承：共性抽取</p><p>​    父类，基类，超类</p><p>​    子类，派生类</p><p>（1）父子继承关系中，成员变量重名，则创建对象时有两种访问方式：</p><p>直接通过子类对象访问成员变量：       new zi.numzi(成员变量)</p><p>​    等号左边是谁，则优先用谁，没药则向上找</p><p>通过成员方法访问成员变量：           调用方法</p><p>​    该方法属于谁则优先用谁，没有则向上找</p><p>（2）</p><p>局部变量：           直接写成员变量名</p><p>本类成员变量：       this.成员变量名</p><p>父类成员变量：       super.成员变量名</p><p>（3）</p><p>成员方法</p><p>创建对象是谁，优先用谁，没有则向上找</p><p>注意：</p><p>无论成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类</p><p>重写（Override）</p><p>概念：在继承关系中，方法名称一样，参数列表也一样</p><p>重写（Override）：方法名称一样，参数列表【也一样】。覆盖、覆写</p><p>重载（Overload）：方法名称一样，参数列表【不一样】。</p><p>方法覆盖重写的特点，创建的是子类对象，则优先用子类方法。new谁用谁</p><p>方法覆盖注意事项：</p><p>1.必须保证父子类之间方法名称相同，参数列表也相同</p><p>​    @Override：写在方法前面，用来检测是不是有效的正确覆盖重写</p><p>​    这个注释就算不写，只要满足要求，也是正确的方法覆盖重写</p><p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p><p>​    小扩展提示：java.lang.Object类是是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p><p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p><p>​    小扩展提示：public &gt; protected &gt; (default) &gt; private</p><p>​    备注：（default）不是关键字default，而是什么都不写留空</p><p>（4）构造方法：</p><p>​    构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有</p><p>​    不能被static、final、synchronized、abstract和native修饰</p><p>​    继承关系中，父子类构造方法的访问特点</p><p>​        1.子类构造方法中有一个默认隐含的”super()“调用，所以一定是先调用父类构造，后执行子类构造</p><p>​        2.子类构造可以通过super关键字调用父类重载构造    //方法名称一样，参数列表【不一样】</p><p>​        3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p><p>总结：</p><p>子类必须调用父类构造方法，不写则赠送super()，写了则用指定的super调用，super只能有一个还必须是第一个</p><p>super关键字用来访间父类内容，而this关键字用来访问本类内容。用法也有三种;</p><p>​    1.在本类的成员方法中,访间本类的成员变量。</p><p>​    2.在本类的成员方法中,访同本类的另一个成员方法。</p><p>​    3.在本类的构造法中,访间本类的另一个构造方法。</p><p>​        在第三种用法当中专注意:</p><p>​        A.this(…)调用也必须是构造方法的第一个语句，唯——个。   构造方法调用直接super(…) 或this(…)</p><p>​        B.super和this两种构造调用,不能同时使用。</p><h3 id="22-继承特点："><a href="#22-继承特点：" class="headerlink" title="22.继承特点："></a>22.继承特点：</h3><p>（1）Java语言是单维承的。</p><p>一个类的直接父类只能有唯——个。</p><p>class A{}</p><p>class B extends A {}     // 正确</p><p>class C{}</p><p>class D extends A.C{}    //错误</p><p>（2）Java语言可以多级继承。</p><p>我有一个父亲。我父亲还有一个父亲。也就是爷爷。</p><p>classA {}</p><p>class B extends A {}     //正确</p><p>class C extends B{}      //正确</p><p>（3）—个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。可以有很多个兄弟姐妹。生二胎。</p><p>class A {}</p><p>class B extends A {}    //正确</p><p>class C extends A {}    //正确</p><h3 id="23-抽象：子类就是父类，猫就是动物"><a href="#23-抽象：子类就是父类，猫就是动物" class="headerlink" title="23.抽象：子类就是父类，猫就是动物"></a>23.抽象：子类就是父类，猫就是动物</h3><p>抽象方法:就是加上abstract关键字,然后去掉大括号，直接分号结束。</p><p>抽象类。抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p><p>如何使用抽象类和抽象方法:</p><p>​    1.不能直接创建new抽象类对象。</p><p>​    2.必须用一个子类来继承抽象父类。</p><p>​    3.子类必须覆盖重写抽象父类当中所有的抽象方法。</p><p>​        覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</p><p>​    4.创建子类对象进行使用。</p><p>​        关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><p>1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><p>​    理解:假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p><p>2抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><p>​    理解:子类的构造方法中,有默认的super)，需要访问父类构造方法。</p><p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><p>​    理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p><p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p><p>​    理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p><p>特点：</p><p>成员变量：可以是变量也可以是常量</p><p>构造方法：有构造方法，但是不能实例化</p><p>那么，构造方法的作用是什么呢?用于子类访问父类数据的初始化</p><p>成员方法：可以有抽象方法:限定子类必须完成某些动作也可以有非抽象方法:提高代码复用性</p><h3 id="24-多态"><a href="#24-多态" class="headerlink" title="24.多态"></a>24.多态</h3><p>多态的好处:提高了程序的扩展性</p><p>具体体现:定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作多态的弊端:不能使用子类的特有功能</p><h3 id="25-接口"><a href="#25-接口" class="headerlink" title="25.接口"></a>25.接口</h3><p>（1）接口的成员特点</p><p>成员变量</p><p>​    只能是常量        默认修饰符: public static final构造方法</p><p>​    接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在一个类如果没有父类，默认继承自Object类</p><p>成员方法</p><p>​    只能是抽象方法    默认修饰符: public abstract</p><p>特点：</p><p>​    接口用关键字interface修饰</p><p>​    public interface接口名{}</p><p>​    类实现接口用implements表示</p><p>​    public class类名implements接口名{}</p><p>​    接口不能实例化</p><p>​    接口如何实例化呢?参照多态的方式，通过实现类对象实例化，这叫接口多态。多态的形式:具体类多态，抽象类多态，接口多态。</p><p>​    多态的前提:有继承或者实现关系;有方法重写;有父(类/接口)引用指向(子/实现)类对象</p><p>​    接口的实现类</p><p>​    要么重写接口中的所有抽象方法要么是抽象类</p><p>（2）类和类的关系</p><p>继承关系，只能单继承，但是可以多层继承</p><p>类和接口的关系</p><p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p>接口和接口的关系</p><p>继承关系，可以单继承，也可以多继承</p><p>1.类名作为形参和返回值</p><p>​    方法的形参是类名，其实需要的是该类的对象</p><p>​    方法的返回值是类名，其实返回的是该类的对象</p><p>2.抽象类名作为形参和返回值</p><p>​    方法的形参是抽象类名，其实需要的是该抽象类的子类对象</p><p>​    方法的返回值是抽象类名,其实返回的是该抽象类的子类对象</p><p>​    基本数据类型当做形式参数给的是值。           int String</p><p>​    引用数据类型当做形式参数给的是地址值。        引用类</p><p>3.接口名作为形参和返回值</p><p>​    方法的形参是接口名，其实需要的是该接口的实现类对象</p><p>​    方法的返回值是接口名，其实返回的是该接口的实现类对象</p><h3 id="26-内部类"><a href="#26-内部类" class="headerlink" title="26.内部类"></a>26.内部类</h3><p>(1).内部类的访问特点</p><p>​    内部类可以直接访问外部类的成员，包括私有</p><p>​    外部类要访问内部类的成员，必须创建对象</p><p>(2).局部内部类        class前无修饰词</p><p>​    局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><p>(3).匿名内部类        局部内部类的特殊形式</p><p>也要在方法里面写</p><p>前提：存在一个类或接口，类可以是具体类也可以是抽象类</p><p>本质：是一个继承了该类或实现了该接口的子类匿名对象</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或接口名()&#123;</span><br><span class="line">重写方法；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h3 id="27-Math无构造方法，如果是静态的直接用类名调用方法"><a href="#27-Math无构造方法，如果是静态的直接用类名调用方法" class="headerlink" title="27.Math无构造方法，如果是静态的直接用类名调用方法"></a>27.Math无构造方法，如果是静态的直接用类名调用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int abs (int a):返回参数的绝对值</span><br><span class="line"></span><br><span class="line">public static double ceil (double a):返回大于或等于参数的最小double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static double floor (double a)。返回小于或等于参数的最大double值，等于一个整数</span><br><span class="line"></span><br><span class="line">public static int round (fLoat a)。按照四舍五入返回最接近参数的int</span><br><span class="line"></span><br><span class="line">public static int max (int a,int b)。返回两个int值中的较大值</span><br><span class="line"></span><br><span class="line">public static int min (int a,int b)。返回两个int值中的较小值(自学)</span><br><span class="line"></span><br><span class="line">public static double pow (double a, double b)，返回a的b次幂的值</span><br><span class="line"></span><br><span class="line">public static double random ()。返回值为double的正值，[0.0,1.0]</span><br></pre></td></tr></table></figure><h3 id="28-System类"><a href="#28-System类" class="headerlink" title="28.System类"></a>28.System类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//public static void exit(int status):终止当前运行的java虚拟机，非零表示异常终止</span><br><span class="line"></span><br><span class="line">//public static  long currentTimeMillis():返回当前时间，以毫秒为单位 1970年1月1日</span><br></pre></td></tr></table></figure><h3 id="28-Object类"><a href="#28-Object类" class="headerlink" title="28.Object类"></a>28.Object类</h3><p>Object是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或者间接的继承自该类</p><p>构造方法: public Object()</p><p>回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法?因为它们的顶级父类只有无参构造方法</p><p>//看方法的源码，选中方法Ctrl+B</p><p>//建议所有子类重写toString方法    自动生成即可</p><p>​    public String toString()            返回对象的字符串表示形式。建议所有子类重写该方法，自动生成</p><p>​    public boolean equals(Object obj)    比较对象是否相等。默认比较地址，重写可以比较内容，自动生成</p><h3 id="29-Arrays"><a href="#29-Arrays" class="headerlink" title="29.Arrays"></a>29.Arrays</h3><p>1冒泡排序</p><p>​    如果有n个数据进行排序，总共需要比较n-1次</p><p>​    每一次比较完毕，下一次的比较就会少一个数据参与</p><p>2.public static String toString(int[]a) 返回指定数组的内容的字符串表示形式    打印数组的中的数据</p><p>​    public static void sort(int[] a)            按照数字顺序排列指定的数组</p><h3 id="30-基本数据类型包装类"><a href="#30-基本数据类型包装类" class="headerlink" title="30.基本数据类型包装类"></a>30.基本数据类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用的操作之一:用于基本数据类型与字符串之间的转换</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>lnteger</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><p>1.int转换为String</p><p>​    public static String valueOf(int i):返回int参数的字符串表示形式。该方法是String类中的方法</p><p>2.String转换为int</p><p>​    public static int parseInt(Strings):将字符串解析为int类型。该方法是Integer类中的方法</p><p>3.自动装箱和拆箱</p><p>​    装箱:把基本数据类型转换为对应的包装类类型</p><p>​    拆箱:把包装类类型转换为对应的基本数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(100);</span><br><span class="line">Integer i = 100;//自动装箱</span><br><span class="line">i = i.intValue() + 200;</span><br><span class="line">i += 200;// i = i + 200; i + 200自动拆箱; i= i + 200;是自动装箱</span><br></pre></td></tr></table></figure><h3 id="31-Date类"><a href="#31-Date类" class="headerlink" title="31.Date类"></a>31.Date类</h3><p>构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Date()分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</span><br><span class="line"></span><br><span class="line">public Date(long date)分配一个Date对象，并将其初始化为表示从标准基准时间起指定的亳秒数</span><br></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long getTime()获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值</span><br><span class="line"></span><br><span class="line">public void setTime(long time)设置时间，给的是毫秒值</span><br></pre></td></tr></table></figure><h3 id="32-SimpleDateFormat-类"><a href="#32-SimpleDateFormat-类" class="headerlink" title="32.SimpleDateFormat 类"></a>32.SimpleDateFormat 类</h3><p>y    年；M     月；d    日；H    时；m    分；s    秒</p><p>构造方法;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public simpLeDateFormat() :构造一个SimpLeDateFormat，使用默认模式和日期格式</span><br><span class="line"></span><br><span class="line">public SimpleDateFormat (String pattern):构造一个SimpleDateFormat使用给定的模式和默认的日期格式格式化:</span><br></pre></td></tr></table></figure><p>从 Date到string</p><p>​    public final String format(Date date):将日期格式化成日期/时间字符串解析。</p><p>从 String到 Date</p><p>​    public Date parse (String source):从给定字符串的开始解析文本以生成日期</p><h3 id="33-Calendar类"><a href="#33-Calendar类" class="headerlink" title="33.Calendar类"></a>33.Calendar类</h3><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p><p>calendar提供了一个类方法 getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化:</p><p>Calendar rightNow = Calendar.getInstance();</p><p>常用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int get(int field)返回给定日历字段的值 年月日</span><br><span class="line"></span><br><span class="line">public abstract void add(int field, int amount)根据日历的规则，将指定的时间量添加或减去给定的日历字段</span><br><span class="line"></span><br><span class="line">public final void set(int year,int month,int date)设置当前日历的年月日</span><br></pre></td></tr></table></figure><h3 id="34-异常"><a href="#34-异常" class="headerlink" title="34.异常"></a>34.异常</h3><p>1.异常体系</p><p>​                Throwable</p><p>​    Error                            Exception</p><p>RuntimeException        非RuntimeException</p><p>Error:严重问题，不需要处理</p><p>Exception:称为异常类，它表示程序本身可以处理的问题</p><p>RuntimeException:在编译期是不检查的，出现问题后，需要我们回来修改代码</p><p>非RuntimeException:编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了</p><p>2.JVM的默认处理方案    java虚拟机</p><p>如果程序出现了问题，我们没有做任何处理，最终JⅣM会做默认的处理</p><p>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台.程序停止执行</p><p>3.异常处理之try…catch…</p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch (异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行流程:</p><p>程序从try里面的代码开始执行</p><p>出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统</p><p>当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理</p><p>执行完毕之后，程序还可以继续往下执行</p><ol><li>Throwable的成员方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法名说明</span><br><span class="line"></span><br><span class="line">public String getMessage()返回此 throwable的详细消息字符串</span><br><span class="line"></span><br><span class="line">public String toString()返回此可抛出的简短描述</span><br><span class="line"></span><br><span class="line">public void printStackTrace()把异常的错误信息输出在控制台</span><br></pre></td></tr></table></figure><p>5.Java 中的异常被分为两大类:编译时异常和运行时异常，也被称为受检异常和非受检异常</p><p>所有的 RuntimeException类及其子类的实例被称为运行时异常，其他的异常都是编译时异常</p><p>编译时异常:必须显示处理，否则程序就会发生错误,无法通过编译</p><p>运行时异常:无需显示处理,也可以和编译时异常一样处理</p><p>6.异常处理之throws</p><p>虽然我们通过try…catch…可以对异常进行处理，但是并不是所有的情况我们都有权限进行异常的处理也就是说，有些时候可能出现的异常是我们处理不了的，这个时候该怎么办呢?</p><p>格式:throws 异常类名;</p><p>注意:这个格式是跟在方法的括号后面的</p><p>编译时异常必须要进行处理，两种处理方案: try..catch ..或者throws，如果采用throws这种方案，将来谁调用谁处理运行时异常可以不处理，出现问题后，需要我们回来修改代码</p><p>7.throws和throw的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">throwsthrow</span><br><span class="line"></span><br><span class="line">用在方法声明后面，跟的是异常类名用在方法体内，跟的是异常对象名</span><br><span class="line"></span><br><span class="line">表示抛出异常，由该方法的调用者来处理   表示抛出异常，由方法体内的语句处理</span><br></pre></td></tr></table></figure><p>表示出现异常的一种可能性，并不一定会发生这些异常    执行throw一定抛出了某种异常</p><h3 id="35-集合"><a href="#35-集合" class="headerlink" title="35.集合"></a>35.集合</h3><p>只能存储引用类型，不能存储基本类型，int类型的包装类lnteger是引用类型</p><p>集合类体系结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集合</span><br><span class="line">collection单列Map双列</span><br><span class="line"></span><br><span class="line">接口List可重复   Set不可重复HashMap</span><br><span class="line"></span><br><span class="line">实现类ArrayList  LinkedList     HashSet  TreeSet LinkedHashSet</span><br></pre></td></tr></table></figure><p>(1)Collection集合概述    E是元素类型</p><p>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素JDK不提供此接口的任何直接实现，它提供更具体的子接口(如Set和List)实现</p><p>创建Collection集合的对象</p><p>多态的方式</p><p>具体的实现类ArrayList</p><p>(2)Collection集合常用方法</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>void clear()</td><td>清空集合中的元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度，也就是集合中元素的个数</td></tr></tbody></table></div><p>(3)Collection集合的遍历</p><p>Iterator:迭代器，集合的专用遍历方式</p><p>Iterator iterator():返回此集合中元素的迭代器，通过集合的iterator)方法得到</p><p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p><p>Iterator中的常用方法</p><p>​    E next():返回迭代中的下一个元素</p><p>​    boolean hasNext():如果迭代具有更多元素，则返回true</p><p>(4)List集合概述</p><p>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</p><p>与Set集合不同，列表通常允许重复的元素</p><p>List集合特点</p><p>​    有序:存储和取出的元素顺序一致</p><p>​    可重复:存储的元素可以重复</p><p>List集合特有方法:</p><div class="table-container"><table><thead><tr><th>void add(int index,E element)</th><th>在此集合中的指定位置插入指定的元素</th></tr></thead><tbody><tr><td>E  remove( int index)</td><td>册除指定索引处的元素，返回被册除的元素</td></tr><tr><td>E set(int index,E element):</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E  get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table></div><p>并发修改异常</p><p>​    ConcurrentModificationException</p><p>产生原因</p><p>​    迭代器遍历的过程中，add通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p><p>解决方案</p><p>​    用for循环遍历，然后用集合对象做对应的操作即可</p><p>(5)Listlterator:列表迭代器</p><p>通过List集合的listlterator()方法得到，所以说它是List集合特有的迭代器</p><p>用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</p><p>Listlterator中的常用方法</p><p>​    E next():返回迭代中的下一个元素</p><p>​    boolean hasNext():如果迭代具有更多元素，则返回true </p><p>​    previous():返回列表中的上一个元素</p><p>​    boolean hasPrevious():如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</p><p>​    void add(E e):将指定的元素插入列表</p><p>(6)增强for循环</p><p>增强for:简化数组和Collection集合的遍历</p><p>实现lterable接口的类允许其对象成为增强型for语句的目标它是JDK5之后出现的，其内部原理是一个lterator迭代器</p><p>增强for的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(元素数据类型  变量名:数组或者Collection集合)&#123;</span><br><span class="line">//在此处使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br><span class="line">范例:</span><br><span class="line">int[]arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(int i : arr) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(7)List集合常用子类:ArrayList，LinkedList</p><p>​    ArrayList:底层数据结构是数组，查询快，增删慢</p><p>​    LinkedList:底层数据结构是链表，查询慢，增删快</p><p>(8)LinkedList集合的特有功能</p><p>​    方法名                                    说明</p><p>public void addFirst(E e)            在该列表开头插入指定的元素</p><p>public void addLast(E e)            将指定的元索追加到此列表的末尾</p><p>public E getFirst()                    返回此列表中的第一个元素</p><p>public E getLast()                    返回此列表中的最后一个元素</p><p>public E removeFirst()            从此列表中删除并返回第一个元素</p><p>public E removeLast()            从此列表中删除并返回最后一个元素</p><p>(9)Set集合概述和特点Set集合特点</p><p>不包含重复元素的集合</p><p>没有带索引的方法，所以不能使用普通for循环遍历</p><p>(10)哈希值:是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p><p>Object类中有一个方法可以获取对象的哈希值</p><p>public int hashCode():返回对象的哈希码值</p><p>对象的哈希值特点</p><p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p><p>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</p><p>(11)HashSet集合特点</p><p>底层数据结构是哈希表</p><p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致没有带索引的方法，所以不能使用普通for循环遍历</p><p>由于是Set集合，所以是不包含重复元素的集合    保证元素唯一性，重写hashCode和equals方法</p><p>先比哈希值，再通过equals比较内容</p><p>(12)LinkedHashSet集合特点</p><p>哈希表和链表实现的Set接口，具有可预测的迭代次序</p><p>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</p><p>由哈希表保证元素唯一，也就是说没有重复的元素</p><p>(13)TreeSet集合特点</p><p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p><p>TreeSet():根据其元素的自然排序进行排序</p><p>TreeSet(Comparator comparator):根据指定的比较器进行排序</p><p>没有带索引的方法，所以不能使用普通for循环遍历</p><p>由于是Set集合，所以不包含重复元素的集合</p><p>无参</p><p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</p><p>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</p><p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><p>比较器  带参</p><p>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</p><p>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法</p><p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><p>(14)泛型概述</p><p>泛型:是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p><p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢?顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型</p><p>这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口</p><p>泛型定义格式:</p><p>​    &lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是形参</p><p>​    &lt;类型1,类型2..&gt;︰指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</p><p>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</p><p>泛型的好处:</p><p>​    把运行时期的问题提前到了编译期间</p><p>​    避免了强制类型转换</p><p>泛型类的定义格式:</p><p>​    格式:修饰符class类名&lt;类型&gt;{}</p><p>​    范例: public class Generic{ }</p><p>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p><p>类型通配符</p><p>为了表示各种泛型List的父类，可以使用类型通配符</p><p>类型通配符:</p><p>List:表示元素类型未知的List，它的元素可以匹配任何的类型</p><p>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</p><p>如果说我们不希望List是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p><p>类型通配符上限: </p><p>List:它表示的类型是Number或者其子类型</p><p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p><p>类型通配符下限:</p><p>List :它表示的类型是Number或者其父类型</p><p>(15)可变参数</p><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p><p>格式:修饰符返回值类型方法名(数据类型…变量名){}</p><p>范例: public static int sum(int… a){}</p><p>可变参数注意事项</p><p>这里的变量其实是一个数组</p><p>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</p><p>可变参数的使用</p><p>Arrays工具类中有一个静态方法:</p><p>public static  List asList(T… a):返回由指定数组支持的固定大小的列表</p><p>返回的集合不能做增删操作，可以做修改操作</p><p>List接口中有一个静态方法:</p><p>public static  List of(E… elements):返回包含任意数量元素的不可变列表</p><p>返回的集合不能做增删改操作</p><p>Set接口中有一个静态方法:</p><p>public static  Set of(E… elements):返回一个包含任意数量元素的不可变集合</p><p>返回的集合不能做增删操作，没有修改的方法</p><p>(16)Map集合概述</p><p>lnterface MapK:键的类型;V:值的类型</p><p>将键映射到值的对象;不能包含重复的键;每个键可以映射到最多一个值</p><p>举例:学生的学号和姓名</p><p>itheima001    林青霞</p><p>itheima002    张曼玉</p><p>itheima003    王祖贤</p><p>创建Map集合的对象</p><p>多态的方式</p><p>具体的实现类HashMap</p><p>(17)Map集合的基本功能</p><p>方法名                                        说明</p><p>v put(K key,V value)                添加元素</p><p>v remove(Object key)                根据键删除健值对元素</p><p>void clear()                                移除所有的键值对元素</p><p>boolean containsKey(Object key)    判断集合是否包含指定的键</p><p>boolean containsValue(Object value)判断集合是否包含指定的值</p><p>boolean isEmpty()                    判断集合是否为空</p><p>int size()                                    集合的长度，也就是集合中键值对的个数</p><p>(18)Map集合的获取功能</p><p>方法名                                    说明</p><p>v get(Object key)                根据键获取值</p><p>Set keySet()                    获取所有键的集合</p><p>Collection values()            获取所有值的集合</p><p>Set &gt; entrySet()                获取所有键值对对象的集合</p><p>(19)Map集合的遍历1</p><p>获取所有键的集合。用keySet()方法实现</p><p>遍历键的集合，获取到每一个键。用增强for实现</p><p>根据键去找值。用get(Object key)方法实现</p><p>Map集合的遍历2</p><p>获取所有键值对对象的集合</p><p>Set &gt; entrySet():获取所有键值对对象的集合遍历键值对对象的集合，得到每一个键值对对象</p><p>用增强for实现，得到每一个Map.Entry根据键值对对象获取键和值</p><p>用getKey()得到键</p><p>用getValue()得到值</p><p>(20)Collections概述和使用Collections类的概述是针对集合操作的工具类</p><p>Collections类的常用方法</p><p>public static &gt; void sort(List list):将指定的列表按升序排序</p><p>public static void reverse(List list):反转指定列表中元素的顺序</p><p>public static void shuffle(List list):使用默认的随机源随机排列指定的列表</p><h3 id="36-数据结构"><a href="#36-数据结构" class="headerlink" title="36.数据结构"></a>36.数据结构</h3><p>栈：先进后出</p><p>队列：先进先出</p><p>数组是一种查询快，增删慢的模型</p><p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p><p>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低添加数据时，添加位置后的每个数据后移，再添加元素，添加效率极低</p><p>链表是一种增删快，查询慢的模型(对比数组)</p><h3 id="37-File"><a href="#37-File" class="headerlink" title="37.File"></a>37.File</h3><p>File类概述和构造方法</p><p>File:它是文件和目录路径名的抽象表示文件和目录是可以通过File封装成对象的</p><p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p><p>方法名                                说明</p><p>File(String pathname)        通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</p><p>File(String parent, String child)从父路径名字符串和子路径名字符串创建新的File实例</p><p>File(File parent, String child)    从父抽象路径名和子路径名字符串创建新的File实例</p><p>File类创建功能</p><p>方法名                        说明</p><p>public boolean createNewFile()    当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</p><p>public boolean mkdir()            创建由此抽象路径名命名的目录</p><p>public boolean mkdirs)            创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</p><p>FiLe类的判断和获取功能:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean isDirectory():测试此抽象路径名表示的FiLe是否为目录</span><br><span class="line"></span><br><span class="line">public booLean isFile():测试此抽象路径名表示的FiLe是否为文件</span><br><span class="line"></span><br><span class="line">public boolean exists()。测试此抽象路径名表示的FiLe是否存在</span><br><span class="line"></span><br><span class="line">public String getAbsolutePath():返回此抽象路径名的绝对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getPath()。将此抽象路径名转换为相对路径名字符串</span><br><span class="line"></span><br><span class="line">public String getName()。返回由此抽象路径名表示的文件或自录的名称</span><br><span class="line"></span><br><span class="line">public String[ ] list()，返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span><br><span class="line"></span><br><span class="line">public File[] listFiles()。返回此抽象路径名表示的目录中的文件和目录的File对象数组</span><br></pre></td></tr></table></figure><p>FiLe类删除功能:</p><p>public booLean delete( ):册除由此抽象路径名表示的文件或目录</p><p>绝对路径和相对路径的区别</p><p>绝对路径:完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如: E\itcast\ljava.txt</p><p>相对路径:必须使用取自其他路径名的信息进行解释。例如: myFile\Wava.txt</p><p>删除目录时的注意事项:</p><p>如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录</p><h3 id="38-递归"><a href="#38-递归" class="headerlink" title="38.递归"></a>38.递归</h3><p>递归概述:以编程的角度来看，递归指的是方法定义中调用方法本身的现象</p><p>递归解决问题的思路:</p><p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算</p><p>递归解决问题要找到两个内容:</p><p>递归出口:否则会出现内存溢出</p><p>递归规则:与原问题相似的规模较小的问题</p><h3 id="39-字节流写数据"><a href="#39-字节流写数据" class="headerlink" title="39.字节流写数据"></a>39.字节流写数据</h3><p>(1)字节流抽象基类</p><p>lnputStream:这个抽象类是表示字节输入流的所有类的超类</p><p>OutputStream:这个抽象类是表示字节输出流的所有类的超类</p><p>子类名特点:子类名称都是以其父类名作为子类名的后缀</p><p>FileOutputStream:文件输出流用于将数据写入File</p><p>构造方法:</p><p>​    FileOutputStream(String name):创建文件输出流以指定的名称写入文件</p><p>​    FileOutputStream (File file):创建文件输出流以写入由指定的 File对象表示的文件</p><p>使用字节输出流写数据的步骤:</p><p>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)</p><p>调用字节输出流对象的写数据方法</p><p>​        // void write (int b)。将指定的字节写入此文件输出流</p><p>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</p><p>​        //void close ()。关闭此文件输出流并释放与此流相关联的任何系统资源。</p><p>(2)IO流分类:</p><p>按照数据的流向</p><p>输入流:读数据</p><p>输出流:写数据</p><p>按照数据类型来分</p><p>字节流:字节输入流;字节输出流</p><p>字符流:字符输入流;字符输出流</p><p>如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流,否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流</p><p>(3)字节流写数据的3种方式</p><p>方法名                                                    说明</p><p>void write(int b)                            将指定的字节写入此文件输出流—次,写一个字节数据            </p><p>void write(byte[] b)将b.length        字节从指定的字节数组写入此文件输出流一次写一个字节数组数据</p><p>void write(byte[] b, int off, int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流一次写一个字节数组的部分数据</p><p>(4)字节流写数据的两个小问题</p><p>字节流写数据如何实现换行呢?</p><p>写完数据后，加换行符</p><p>windows:\r\n</p><p>linux:\n</p><p>mac\r</p><p>字节流写数据如何实现追加写入呢?</p><p>public FileOutputStream(String name,boolean append)</p><p>创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头</p><p>(5)字节流写数据加异常处理</p><p>finally:在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p><p>特点:被finally控制的语句一定会执行，除非JVM退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">执行所有清除操作;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>(6)字节缓冲流:</p><p>BufferOutputStream:该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</p><p>BufferedlnputStream:创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</p><p>构造方法:</p><p>字节缓冲输出流:BufferedOutputStream(OutputStream out)</p><p>字节缓冲输入流: BufferedInputStream(InputStream in)</p><p>为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?</p><p>字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</p><p>byte[] getBytes(String charsetName) 使用命名的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中。 </p><h3 id="40-1-字符流"><a href="#40-1-字符流" class="headerlink" title="40.(1)字符流"></a>40.(1)字符流</h3><p>为什么会出现字符流</p><p>由于字节流操作中文不是特别的方便，所以Java就提供字符流·</p><p>字符流=字节流＋编码表</p><p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢?</p><p>汉字在存储的时候，无论选择哪种编码存储,第一个字节都是负数</p><p>(2)编码表</p><p>基础知识:</p><p>计算机中储存的信息都是用二进制数表示的;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果</p><p>按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。这里强调一下:按照A编码存储，必须按照A编码解析，这样才能显示正确的文本符号。否则就会导致乱码现象</p><p>字符编码:就是一套自然语言的字符与二进制数之间的对应规则(A65)</p><p>字符集:</p><p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p><p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCIl字符集、GBXXX字符集. Unicode字符集等</p><p>ASCI字符集:</p><p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)∶是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)</p><p>基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p><p>GBXXX字符集:</p><p>GB2312:简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了</p><p>GBK:最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等</p><p>GB18030:最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等</p><p>Unicode字符集:</p><p>为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF32。最为常用的UTF-8编码</p><p>UTF-8编码:可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组(IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码</p><p>编码规则:</p><p>128个US-ASCI字符，只需一个字节编码拉丁文等字符，需要二个字节编码</p><p>大部分常用字(含中文)，使用三个字节编码</p><p>其他极少使用的Unicode辅助字符，使用四字节编码</p><p>小结:采用何种规则编码，就要采用对应规则解码，否则就会出现乱码</p><p>(3)字符串中的编码解码问题</p><p>编码:</p><p>bytel]getBytes():使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p><p>bytelgetBytes(String charsetName):使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p><p>解码:</p><p>String(byte[] bytes):通过使用平台的默认字符集解码指定的字节数组来构造新的String</p><p>String(byte[] bytes, String charsetName):通过指定的字符集解码指定的字节数组来构造新的String</p><p>字符流抽象基类</p><p>Reader:字符输入流的抽象类</p><p>Writer:字符输出流的抽象类</p><p>字符流中和编码解码问题相关的两个类:</p><p>lnputStreamReader:是从字节流到字符流的桥梁</p><p>它读取字节,并使用指定的编码将其解码为字符</p><p>它使用的字符集可以由名称指定，也可以被明码指定，或者可以接受平台的默认字符集</p><p>OutputStreamWriter是从字符流到字节流的桥梁</p><p>是从字符流到字节流的桥梁,使用指定的编码将写入的字符编码为字节</p><p>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集</p><p>构造方法:</p><p>OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter。  </p><p>OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 </p><p>InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader。  </p><p>InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader。 </p><p>字符流写数据的5种方式</p><p>方法名                                                    说明</p><p>void write(int c)                                    写一个字符</p><p>void write(char[]cbuf)                            写入一个字符数组</p><p>void write(char[]cbuf, int off, int len)    写入字符数组的一部分</p><p>void write(String str)                            写一个字符串</p><p>void write(String str, int off, int len)        写一个字符串的一部分</p><p>方法名        说明</p><p>flush()        刷新流，还可以继续写数据</p><p>close()        关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</p><p>字符流读数据</p><p>方法名            说明</p><p>int read()            —次读一个字符数据</p><p>int read(char[] cbuf)—次读一个字符数组数据</p><p>字节是byte  字符是char</p><p>转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化书写，转换流提供了对应的子类</p><p>FileReader:用于读取字符文件的便捷类</p><p>FileReader(String fileName)</p><p>FileWriter:用于写入字符文件的便捷类</p><p>FileWriter(String fileName)</p><p>数据源和目的地的分析</p><p>数据源: myCharStream)(ConversionStreamDemojava—-读数据——Reader —-InputStreamReader —-FileReader</p><p>目的地: myCharStreamll Copy.java —-写数据—-Writer —- OutputStreamWriter —- FileWriter</p><p>(4)字符缓冲流:</p><p>BufferedWriter:将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p><p>BufferedReader:从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p><p>构造方法:</p><p>​    BufferedWriter(Writer out)</p><p>​    BufferedReader(Reader in)</p><p>字符缓冲流特有功能</p><p>BufferedWriter:</p><p>void newLine():写一行行分隔符，行分隔符字符串由系统属性定义</p><p>BufferedReader:</p><p>public String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null     只读内容不读换行符号</p><p>String split(“,”);    //字符串中按逗号分割，分成字符串数组</p><p>String转换为int类型</p><p>Integer.parseInt（String）方法</p><p>parseInt（）是Integer包装类里的一个方法，可以将字符串解析为带符号的整数</p><p>TreeSet 比较排序 Student</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Student s) &#123;</span><br><span class="line">    //return 0;   //s2和s1是同一个接口</span><br><span class="line">    //return 1;      //正序   升序</span><br><span class="line">    //return -1;      //倒叙    降序</span><br><span class="line">    //按年龄排序</span><br><span class="line">    int num = this.age-s.age;   //this是s1，s 是s2     this在前，s在后升序  反过来降序</span><br><span class="line">    int num2 = num == 0?this.name.compareTo(s.name):num; //如果年龄相同num=0则比较name，不等于直接输出num</span><br><span class="line">    return num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeSet比较器排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Student s1, Student s2) &#123;</span><br><span class="line">//                int num = (s2.getChinese()+s2.getMath())-(s1.getChinese()+s1.getMath());</span><br><span class="line">                //主要条件  s1-this   s2-s  s在前，this在后  s-this降序</span><br><span class="line">                int num = s2.getSum()-s1.getSum();</span><br><span class="line">                int num2 = num == 0?s1.getChinese()-s2.getChinese():num;    //s1-s2有啥讲究</span><br><span class="line">                int num3 = num2 == 0?s1.getName().compareTo(s2.getName()):num2;</span><br><span class="line">                return num3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>//s1-s2  升序  s1小    小减大 从小往大</p><p>//s2-s1  降序  s2大    大减小 从大往小</p><p>static修饰，类名可以直接访问</p><p>(5)复制文件的异常处理</p><p>try…catch…finally的做法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">执行所有清除操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7改进方案:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try(定义流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自动释放资源</p><p>JDK9改进方案:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line">try(输入流对象;输出流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名  变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动释放资源</p><h3 id="41-标准输入输出流"><a href="#41-标准输入输出流" class="headerlink" title="41.标准输入输出流"></a>41.标准输入输出流</h3><p>System类中有两个静态的成员变量:</p><p>public static final lnputStream in:标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源</p><p>public static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标</p><p>自己实现键盘录入数据:</p><p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in);</p><p>写起来太麻烦，Java就提供了一个类实现键盘录入</p><p>Scanner sc = new Scanner(System.in);</p><p>输出语句的本质:是一个标准的输出流</p><p>PrintStream ps = System.out;</p><p>PrintStream类有的方法，System.out都可以使用</p><p>打印流分类:</p><p>字节打印流:PrintStream</p><p>字符打印流:PrintWriter</p><p>打印流的特点:</p><p>只负责输出数据，不负责读取数据有自己的特有方法</p><p>字节打印流</p><p>PrintStream(String fileName):使用指定的文件名创建新的打印流</p><p>使用继承父类的方法写数据，查看的时候会转码;使用自己的特有方法写数据，查看的数据原样输出</p><p>字符打印流PrintWriter的构造方法:</p><p>方法名                        说明</p><p>PrintWriter(String fileName)        使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新</p><p>PrintWriter(Writer out,boolean autoFlush)创建一个新的PrintWriter</p><p>out:字符输出流</p><p>autoFlush:一个布尔值，如果为真，则println , printf ，或format方法将刷新输出缓冲区</p><h3 id="42-对象序列化"><a href="#42-对象序列化" class="headerlink" title="42.对象序列化"></a>42.对象序列化</h3><p>对象序列化:就是将对象保存到磁盘中，或者在网络中传输对象</p><p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含:对象的类型、对象的数据和对象中存储的属性等信息字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p><p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流:</p><p>(1)对象序列化流:ObjectOutputStream</p><p>将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取(重构)对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象</p><p>构造方法:</p><p>ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</p><p>序列化对象的方法:</p><p>void writeObject(Object obj):将指定的对象写入ObjectOutputStream</p><p>注意:</p><p>一个对象要想被序列化，该对象所属的类必须必须实现Serializable接口</p><p>Serializable是一个标记接口，实现该接口，不需要重写任何方法</p><p>(2)对象反序列化流:ObiectlnoutStream</p><p>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</p><p>构造方法:</p><p>ObjectInputStream(InputStream in):创建从指定的InputStream读取的ObjectInputStream</p><p>反序列化对象的方法:</p><p>Object readObject():从ObjectInputStream读取一个对象</p><p>(3)对象序列化流问题</p><p>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢?</p><p>会出问题，抛出InvalidClassException异常</p><p>如果出问题了，如何解决呢?</p><p>给对象所属的类加一个serialVersionUID</p><p>private static final long serialVersionUID = 42L;</p><p>如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢?</p><p>给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p><p>(4) Properties概述:</p><p>是一个Map体系的集合类·</p><p>Properties可以保存到流中或从流中加载</p><p>练习: Properties作为Map集合的使用</p><p>Properties作为集合的特有方法:</p><p>方法名                                            说明</p><p>Object setProperty(String key, String value)    设置集合的键和值，都是String类型，底层调用Hashtable方法 put</p><p>String getProperty(String key)                使用此属性列表中指定的键搜索属性</p><p>Set stringPropertyNames()                    从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p><p>Properties和IO流结合的方法:</p><p>方法名                                    说明</p><p>void load(InputStream inStream)            从输入字节流读取属性列表（键和元素对)</p><p>void load(Reader reader)                    从输入字符流读取属性列表〔键和元素对)</p><p>void store(OutputStream out, Stringcomments)    将此属性列表〔键和元素对)写入此 Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</p><p>void store(Writer writer,String comments)    将此属性列表〔键和元素对)写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</p><h3 id="43-实现多线程"><a href="#43-实现多线程" class="headerlink" title="43.实现多线程"></a>43.实现多线程</h3><p>1.1进程</p><p>进程:是正在运行的程序</p><p>是系统进行资源分配和调用的独立单位</p><p>每一个进程都有它自己的内存空间和系统资源</p><p>1.2线程</p><p>线程:是进程中的单个顺序控制流，是一条执行路径</p><p>单线程:一个进程如果只有一条执行路径，则称为单线程程序</p><p>多线程:一个进程如果有多条执行路径，则称为多线程程序</p><p>1.3多线程的实现方式</p><p>方式1：继承Threac类</p><p>定义一个类MyThread继承Thread类</p><p>在MyThread类中重写run()方法</p><p>创建MyThread类的对象</p><p>启动线程</p><p>两个小问题:</p><p>为什么要重写run方法?</p><p>​    因为run()是用来封装被线程执行的代码</p><p>run()方法和start()方法的区别?</p><p>​    run():封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>​    start():启动线程;然后由JVM调用此线程的run()方法.</p><p>1.4设置和获取线程名称Thread类中设置和获取线程名称的方法</p><p>void setName(String name):将此线程的名称更改为等于参数name</p><p>String getName():返回此线程的名称</p><p>通过构造方法也可以设置线程名称</p><p>如何获取main()方法所在的线程名称?</p><p>public static Thread currentThread():返回对当前正在执行的线程对象的引用</p><p>线程有两种调度模型</p><p>分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p><p>抢占式调度模型:优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程</p><p>获取的CPU时间片相对多一些</p><p>Java使用的是抢占式调度模型</p><p>假如计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</p><p>Thread类中设置和获取线程优先级的方法</p><p>public final int getPriority():返回此线程的优先级</p><p>public final void setPriority(int newPriority):更改此线程的优先级</p><p>线程默认优先级是5;线程优先级的范围是:1-10</p><p>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p><p>1.6线程控制</p><p>方法名                                说明</p><p>static void sleep(long millis)        使当前正在执行的线程停留(暂停执行)指定的亳秒数</p><p>sleep后没有执行权，会被其他线程抢走,其他线程执行后也sleep，接着等待sleep结束后重新抢执行权</p><p>void join()                        等待这个线程死亡</p><p>void setDaemon(boolean  on)    将此线程标记为守护线程，当运行的线程都是守护线程时（主线程执行完毕），Java虚拟机将退出        主线程死后，守护线程也会死</p><p>多线程的实现方案有两种</p><p>继承Thread类</p><p>实现Runnable接口</p><p>相比继承Thread类，实现Runnable接口的好处</p><p>避免了Java单继承的局限性</p><p>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p><p>2.3同步代码块</p><p>锁多条语句操作共享数据，可以使用同步代码块实现</p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(任意对象)&#123;</span><br><span class="line">多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁</p><p>同步的好处和弊端</p><p>好处:解决了多线程的数据安全问题</p><p>弊端:当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p><p>2.4同步方法</p><p>同步方法:就是把synchronized关键字加到方法上</p><p>格式:</p><p>修饰符 synchronized 返回值类型 方法名(方法参数){    }</p><p>同步方法的锁对象是什么呢?        this</p><p>同步静态方法:就是把synchronized关键字加到静态方法上</p><p>格式:</p><p>修饰符 static synchronized  返回值类型 方法名(方法参数){    }</p><p>同步静态方法的锁对象是什么呢?        类名.class</p><p>2.5 Lock锁</p><p>Lock中提供了获得锁和释放锁的方法</p><p>void lock():获得锁</p><p>void unlock():释放锁</p><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法</p><p>ReentrantLock():创建一个ReentrantLock的实例</p><p>Object类的等待和唤醒方法:</p><p>方法名            说明</p><p>void wait()    导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</p><p>void notify()    唤醒正在等待对象监视器的单个线程</p><p>void notifyAll()    唤醒正在等待对象监视器的所有线程</p><h3 id="44-网络编程三要素"><a href="#44-网络编程三要素" class="headerlink" title="44.网络编程三要素"></a>44.网络编程三要素</h3><ul><li>(1)IP地址</li></ul><p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而lP地址就是这个标识号。也就是设备的标识</p><p>常用命令:</p><p>ipconfig:查看本机IP地址</p><p>ping IP地址:检查网络是否连通</p><p>特殊IP地址:</p><p>127.0.0.1:是回送地址，可以代表本机地址，一般用来测试使用</p><p>lnetAddress:此类表示Internet协议(IP）地址</p><p>方法名                    说明</p><p>static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</p><p>String getHostName()        获取此lP地址的主机名</p><p>String getHostAddress()        返回文本显示中的IP地址字符串</p><ul><li>(2)端口</li></ul><p>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢?如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</p><p>端口:设备上应用程序的唯一标识</p><p>端口号:用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p><ul><li>(3)协议</li></ul><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</p><p>协议:计算机网络中，连接和通信的规则被称为网络通信协议</p><p>UDP协议</p><p>用户数据报协议(User Datagram Protocol)</p><p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p><p>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时,由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</p><p>发送数据的步骤</p><p>创建发送端的Socket对象(DatagramSocket)</p><p>DatagramSocket()</p><p>创建数据，并把数据打包</p><p>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</p><p>调用DatagramSocket对象的方法发送数据</p><p>void send(DatagramPacket p)</p><p>关闭发送端</p><p>void close()</p><p>接收数据的步骤</p><p>创建接收端的Socket对象(DatagramSocket)</p><p>DatagramSocket(int port)</p><p>创建一个数据包。用于接收数据</p><p>DatagrarmPacket(byte[] buf, int length)</p><p>调用DatagramSocket对象的方法接收数据</p><p>void receive(DatagramPacketp)</p><p>解析数据包，并把数据在控制台显示</p><p>byte[] getData()</p><p>int getLength()</p><p>关闭接收端</p><p>void close()</p><p>TCP协议</p><p>传输控制协议(Transmission Control Protocol)</p><p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据,它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p><p>三次握手:TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求第三次握手，客户端再次向服务器端发送确认信息，确认连接</p><p>发送数据的步骤</p><p>创建客户端的Socket对象</p><p>(Socket)Socket(String host, int port)</p><p>获取输出流，写数据</p><p>OutputStreamgetOutputStream()</p><p>释放资源</p><p>void close()</p><p>接收数据的步骤</p><p>创建服务器端的Socket对象(ServerSocket)</p><p>ServerSocket(int port)</p><p>监听客户端连接。返回一个Socket对象</p><p>Socket accept()</p><p>获取输入流，读数据，并把数据显示在控制台</p><p>lnputStream getInputStream()</p><p>释放资源</p><p>void close()</p><p>//public void shutdownOutput()   关闭客户端的输出流。相当于给流中加入一个结束标记-1</p><h3 id="45-Lambda"><a href="#45-Lambda" class="headerlink" title="45.Lambda"></a>45.Lambda</h3><p>(1)Lambda表达式的格式</p><p>格式:(形式参数)-&gt;{代码块}</p><p>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空即可</p><p>箭头 -&gt;:由英文中画线和大于符号组成，固定写法。代表指向动作</p><p>代码块:是我们具体要做的事情，也就是以前我们写的方法体内容</p><p>(2)Lambda表达式的使用前提</p><p>有一个接口</p><p>接口中有且仅有一个抽象方法</p><p>(3)Lambda表达式的省略模式</p><p>省略规则:</p><p>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p><p>如果参数有且仅有一个，那么小括号可以省略</p><p>如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</p><p>(4)注意事项:</p><p>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p><p>必须有上下文环境，才能推导出Lambda对应的接口</p><p>根据局部变量的赋值得知Lambda对应的接口:Runnable r = () -&gt; System.out.printin(“Lambda表达式T);</p><p>根据调用方法的参数得知Lambda对应的接口: new Thread(()-&gt; System.out.printIn(“Lambda表达式”))start();</p><p>Lambda表达式和匿名内部类的区别</p><p>所需类型不同</p><p>匿名内部类:可以是接口，也可以是抽象类,还可以是具体类    new 接口</p><p>Lambda表达式:只能是接口</p><p>使用限制不同</p><p>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</p><p>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</p><p>实现原理不同</p><p>匿名内部类:编译之后，产生一个单独的.class字节码文件</p><p>Lambda表达式:编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</p><p>(5)接口的组成</p><p>常量public static final</p><p>抽象方法public abstract</p><p>默认方法(Java 8)</p><p>静态方法(Java 8)</p><p>私有方法(Java 9)</p><p>接口中默认方法</p><p>接口中默认方法的定义格式:</p><p>格式: public default返回值类型方法名(参数列表){}</p><p>范例: public default void show3( ){}</p><p>接口中默认方法的注意事项:</p><p>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字</p><p>public可以省略,default不能省略</p><p>接口中静态方法</p><p>接口中静态方法的定义格式:</p><p>格式: public static返回值类型方法名(参数列表){}</p><p>范例: public static void show(){}</p><p>接口中静态方法的注意事项:</p><p>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</p><p>public可以省略,static不能省略</p><p>接口中私有方法</p><p>当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java9增加私有方法的必然性</p><p>接口中私有方法的定义格式:</p><p>格式1: private返回值类型方法名(参数列表){}</p><p>范例1: private void show(){ }</p><p>格式2: private static返回值类型方法名(参数列表){}</p><p>范例2: private static void method0{}</p><p>接口中私有方法的注意事项:</p><p>默认方法可以调用私有的静态方法和非静态方法.</p><p>静态方法只能调用私有的静态方法</p><p>(6)方法引用符</p><p>::该符号为引用运算符，而它所在的表达式被称为方法引用</p><p>Lambda表达式: usePrintable(s-&gt; System.out.println(s));</p><p>分析:拿到参数s 之后通过Lambda表达式，传递合System.out.println方法去处理</p><p>方法引用:usePrintable(System.out:printIn);</p><p>分析:直接使用System.out中的printIn方法来取代Lambda，代码更加的简洁</p><p>推导与省略</p><p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导</p><p>如果使用方法引用，也是同样可以根据上下文进行推导</p><p>方法引用是Lambda的孪生兄弟</p><p>(7)引用对象的实例方法。其实就引用类中的成员方法</p><p>得先创建对象  new 对象</p><p>格式:对象::成员方法</p><p>范例:“HelloWorld”:toUpperCase</p><p>String类中的方法: public String toUpperCase()将此String所有字符转换为大写</p><p>(8)引用类的实例方法，其实就是引用类中的成员方法</p><p>格式:类名::成员方法</p><p>范例: String::substring</p><p>String类中的方法: public String substring(int beginIndex,int endIndex)</p><p>从beginIndex开始到endlndex结束，截取字符串。返回一个子串，子串的长度为endlndex-beginIndex</p><p>(9)引用构造器，其实就是引用构造方法</p><p>格式:类名::new</p><p>范例:Student::new</p><h3 id="46-1-函数式接口"><a href="#46-1-函数式接口" class="headerlink" title="46(1)函数式接口"></a>46(1)函数式接口</h3><p>:有且仅有一个抽象方法的接口</p><p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p><p>如何检测一个接口是不是函数式接口呢?</p><p>@Functionallnterface</p><p>放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是，编译失败</p><p>注意</p><p>我们自己定义函数式接口的时候，@Functionallnterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</p><p>(2)如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</p><p>startThread( ()  -&gt;  System.out.println(Thread.currentThread().getName() +”线程启动了”));</p><p>(3)函数式接口作为方法的返回值</p><p>如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static Comparator getComparator() &#123;</span><br><span class="line">return (s1, s2) -&gt; s1.length( - s2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)Supplier接口</p><p>Supplier:包含一个无参的方法</p><p>T get():获得结果</p><p>该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</p><p>Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用</p><p>(5)Predicate接口</p><p>Predicate:常用的四个方法</p><p>​    boolean test(T t):对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值</p><p>​    default Predicate negate():返回一个逻辑的否定，对应逻辑非</p><p>​    default Predicate and(Predicate other):返回一个组合判断，对应短路与default </p><p>​    Predicate or(Predicate other):返回一个组合判断，对应短路或</p><p>Predicate接口通常用于判断参数是否满足指定的条件</p><p>(6)Function接口</p><p>Function:常用的两个方法  将T转换为R</p><p>R apply(T t):将此函数应用于给定的参数</p><p>default  Function andThen(Function after):返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</p><p>Function接口通常用于对参数讲行外理，转换(休理逻罗辑由Lambda表达式实现)，然后返回一个新的值</p><h3 id="47-使用Stream流的方式"><a href="#47-使用Stream流的方式" class="headerlink" title="47.使用Stream流的方式"></a>47.使用Stream流的方式</h3><p>(1)完成filter过滤操作</p><p>void forEach(Consumer action)：逐一处理流中的元素</p><p>list.stream().filter(s -&gt; s.startsWith(“张”)).filter(s-&gt; s.length()== 3).forEach(System.out::printIn);</p><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义:生成流、过滤姓张、过滤长度为3、逐一打印</p><p>Stream流把真正的函数式编程风格引入到ava中</p><p>Stream流的使用</p><p>生成流</p><p>通过数据源(集合,数组等)生成流    </p><p>list.stream()</p><p>中间操作</p><p>一个流后面可以跟随零个或多个中间操作，其目的主要是打开流，做出某种程度的数据过滤/映射，然后返回一个新的流,交给下一个操作使用</p><p>filter()</p><p>终结操作</p><p>一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作</p><p>forEach()</p><p>(2)Stream流的常见生成方式</p><p>1 : ColLection体系的集合可以使用默认方法stream()生成流</p><p>default Stream stream ()</p><p>2 : Map体系的集合间接的生成流</p><p>3∶数组可以通过stream接口的静态方法of (T… values )生成流</p><p>(3)Stream流的常见中间操作方法</p><p>Stream filter(Predicate predicate):用于对流中的数据进行过滤</p><p>Predicate接口中的方法        boolean test(T t):对给定的参数进行判断，返回—个布尔值</p><p>Stream limit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</p><p>Stream skip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流.</p><p>static  Stream concat(Stream a, Stream b):合并a和b两个流为一个流</p><p>Stream distinct():返回由该流的不同元素（根据Object equals(Object))组成的流，消除重复元素</p><p>Stream sorted():返回由此流的元素组成的流，根据自然顺序排序</p><p>Stream sorted(Comparator comparator):返回由该流的元素组成的流，根据提供的Comparator进行排序</p><p> Stream map(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</p><p>Function接口中的方法        R apply(Tt)</p><p>Intstream mapToInt(TolntFunction mapper):返回一个ntStream其中包含将给定函数应用于此流的元素的结果        sum()方法 求和  结束   流终止操作</p><p>lntStream:表示原始int流</p><p>TolntFunction接口中的方法    int applyAsInt(T value)</p><p>(4)Stream流的常见终结操作方法</p><p>void forEach(Consumer action):对此流的每个元素执行操作</p><p>Consumer接口中的方法            void accept(T t):对给定的参数执行此操作</p><p>long count():返回此流中的元素数</p><p>(5)Stream流的收集方法</p><p>R collect(Collector collector)        但是这个收集方法的参数是一个Collector接口</p><p>工具类Collectors提供了具体的收集方式</p><p>public static  Collector toList():把元素收集到List集合中</p><p>publicstatic  Collector toSet(:把元素收集到Set集合年</p><p>public static Collector toMap(Function keyMapper,Function valueMapper):把元素收集到Map集合中</p><h3 id="48-1-类加载类的初始化步骤"><a href="#48-1-类加载类的初始化步骤" class="headerlink" title="48.(1)类加载类的初始化步骤"></a>48.(1)类加载类的初始化步骤</h3><p>假如类还未被加载和连接，则程序先加载并连接该类</p><p>假如该类的直接父类还未被初始化。则先初始化其直接父类</p><p>假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>注意:在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3</p><p>类的初始化时机:</p><p>创建类的实例</p><p>调用类的类方法</p><p>访问类或者接口的类变量，或者为该类变量赋值</p><p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p><p>初始化某个类的子类</p><p>直接使用java.exe命苓来运行某个主类</p><p>(2)类加载器</p><p>ClassLoader:是负责加载类的对象</p><p>Java运行时具有以下内置类加载器</p><p>Bootstrap class loader:它是虚拟机的内置类加载器，通常表示为null，并且没有父null</p><p>Platform class loader:平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</p><p>System class loader:它也被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径,模块路径和JDK特定工具上的类</p><p>类加载器的继承关系:System的父加载器为Platform，而Platform的父加载器为Bootstrap</p><p>ClassLoader中的两个方法</p><p>static ClassLoader getSystemClassLoader():返回用于委派的系统类加载器</p><p>ClassLoader getParent():返回父类加载器进行委派</p><p>(3)反射概述</p><p>Java反射机制:是指在运行时去获取一个类的变呈和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p><p>这里我们提供三种方式获取Class类型的对象</p><p>使用类的class属性来获取该类对应的Class对象。举例: Studentclass将会返回Student类对应的Class对象</p><p>调用对象的getClass()方法，返回该对象所属类对应的Class对象        该方法是Object类中的方法，所有的Java对象都可以调用该方法</p><p>使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</p><p>(4)反射获取构造方法并使用</p><p>Class类中用于获取构造方法的方法</p><p>Constructor[]getConstructors():返回所有公共构造方法对象的数组</p><p>Constructor[]getDeclaredConstructors():返回所有构造方法对象的数组</p><p>Constructor getConstructor(Class… parameterTypes):返回单个公共构造方法对象</p><p>Constructor getDeclaredConstructor(Class… parameterTypes):返回单个构造方法对象</p><p>Constructor类中用于创建对象的方法</p><p>T newInstance(Object… initargs):根据指定的构造方法创建对象</p><p>暴力反射：</p><p>public void setAccessible(boolean flag):值为true，取消访问检查</p><p>(5)Class类中用于获取成员变量的方法</p><p>Field[] getFields():返回所有公共成员变量对象的数组</p><p>Field[] getDeclaredFields():返回所有成员变量对象的数组</p><p>Field getField(String name):返回单个公共成员变量对象</p><p>Field getDeclaredField(String name):返回单个成员变呈对象</p><p>Field类中用于给成员变量赋值的方法</p><p>void set(Object obj, Object value):给obj对象的成员变量赋值为value</p><p>(6)Class类中用于获取成员方法的方法</p><p>Method getMethods(:返回所有公共成员方法对象的数组，包括继承的</p><p>Method[]getDeclaredMethods(:返回所有成员方法对象的数组，不包括继承的</p><p>Method getMethod(String name, Class… parameterTypes):返回单个公共成员方法对象</p><p>Method getDeclaredMethod(String name, Class… parameterTypes):返回单个成员方法对象</p><p>Method类中用于调用成员方法的方法    执行方法</p><p>Object invoke(Object obj, Object…args):调用obj对象的成员方法，参数是args,返回值是Object类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;javaSE&quot;&gt;&lt;a href=&quot;#javaSE&quot; class=&quot;headerlink&quot; title=&quot;javaSE&quot;&gt;&lt;/a&gt;javaSE&lt;/h2&gt;&lt;h3 id=&quot;1-DOS命令：&quot;&gt;&lt;a href=&quot;#1-DOS命令：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="javaSE" scheme="http://putongl.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb</title>
    <link href="http://putongl.github.io/JavaWeb.html"/>
    <id>http://putongl.github.io/JavaWeb.html</id>
    <published>2023-10-18T08:20:25.322Z</published>
    <updated>2023-10-18T08:17:21.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-Junit使用-白盒测试"><a href="#1-Junit使用-白盒测试" class="headerlink" title="1.Junit使用:白盒测试"></a>1.Junit使用:白盒测试</h2><p>*步骤:</p><p>1．定义一个测试类(测试用例)</p><p>*建议∶</p><p>​    测试类名∶被测试的类名TestCalculatorTest</p><p>​    包名:xxx.xxx.xx.testcn.itcast.test</p><p>2．定义测试方法:可以独立运行</p><p>建议∶</p><p>​    *方法名: test测试的方法名testAdd()</p><p>​    *返回值: void</p><p>​    *参数列表:空参</p><p>3．给方法加@Test 独立运行 导包</p><p>4．导入junit依赖环境</p><p>​    *判定结果︰红色∶失败绿色∶成功</p><p>​    *—股我们会使用断言操作来处理结果</p><p>​    *Assert.assertEquals(期望的结果,运算的结果);</p><p>补充∶</p><p>​    @Before:修饰的方法会在测试方法之前被自动执行</p><p>​    @After:修饰的方法会在测试方法执行之后自动被执行。</p><h2 id="2-反射-框架设计的灵魂"><a href="#2-反射-框架设计的灵魂" class="headerlink" title="2.反射:框架设计的灵魂"></a>2.反射:框架设计的灵魂</h2><p>框架:半成品软件。可以在框架的基础上进行软件开发，简化编码</p><p>反射:将类的各个组成部分封装为其他对象，这就是反射机制</p><p>*好处:</p><p>​    1.可以在程序运行过程中，操作这些对象。</p><p>​    2.可以解耦,提高程序的可扩展性。</p><p>*获取class对象的方式:</p><p>​    1.Class.forName(“全类名”)∶将字节码文件加载进内存，返回class对象 全类名：包名.类名</p><p>​    *多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p><p>2.类名.class :通过类名的属性class获取</p><p>​    *多用于参数的传递</p><p>3，对象.getclass( : getclass()方法在object类中定义着。</p><p>​    *多用于对象的获取字节码的方式</p><p>​    结论:同一个字节码文件(* .class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。</p><p>class对象功能:</p><p>​    获取功能:</p><p>​        1,获取成员变量们</p><p>​        2,获取构造方法们</p><p>​        3,获取成员方法们</p><p>​        4.获取类名</p><p>Field:成员变量</p><p>操作:</p><p>​    1。设置值</p><p>​        void set(object obj, object value)</p><p>​    2．获取值</p><p>​        get(object obj)</p><p>​    3，忽略访问权限修饰符的安全检查</p><p>​        setAccessible(true):暴力反射</p><p>​        constructor:构造方法</p><p>​    创建对象∶</p><p>​        newInstance(object… initargs)</p><p>​    如果使用空参数构造方法创建对象，操作可以简化 : class对象的newInstance方法</p><h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h2><p>说明程序的，给计算机看的</p><p>作用分类:</p><p>​    编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</p><p>​    代码分析:通过代码里标识的注解对代码进行分析【使用反射】</p><p>​    编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】</p><p>(1).JDK中预定义的一些注解</p><p>​    @override:检测被该注解标注的方法是否是继承自父类(接口)的</p><p>​    @Deprecated :该注解标注的内容，表示已过时</p><p>​    @suppresswarnings :压制警告</p><p>​        —般传递参数all @suppresswarnings(“all”)</p><p>(2).自定义注解</p><p>格式∶</p><p>元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line"></span><br><span class="line">属性列表;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质:注解本质上就是一个接口，该接口默认继承Annotation接口</p><p>public interface MyAnno extends java.lang.annotation.Annotation {}</p><p>属性:接口中的抽象方法</p><p>要求∶</p><p>1．属性的返回值类型有下列取值</p><p>​    基本数据类型</p><p>​    String</p><p>​    枚举注解</p><p>​    以上类型的数组</p><p>2．定义了属性，在使用时需要给属性赋值</p><p>​    1，如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</p><p>​    2．如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</p><p>​    3．数组赋值时，值使用{ }包裹。如果数组中只有一个值，则省略</p><p>元注解:用于描述注解的注解</p><p>​    @Target :描述注解能够作用的位置</p><p>ElementType取值:</p><p>​    TYPE:可以作用于类上</p><p>​    METHOD:可以作用于方法上</p><p>​    FIELD:可以作用于成员变量上</p><p>@Retention:描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)︰当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</p><p>@Documented:描述注解是否被抽取到api文档中</p><p>@Inherited:描述注解是否被子类继承</p><p>(3).在程序使用(解析)注解:获取注解中定义的属性值</p><p>​    1，获取注解定义的位置的对象(class,Method,Field)</p><p>​    2．获取指定的注解</p><p>​        *getAnnotation(class)</p><p>​        //其实就是在内存中生成了一个该注解接口的子类实现对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProImpl</span> <span class="keyword">implements</span> <span class="title class_">Pro</span>&#123;</span><br><span class="line"><span class="keyword">public</span> string <span class="title function_">className</span><span class="params">(()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;cn.itcast.annotation.Demo1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">methodName</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">        return <span class="string">&quot;show&quot;</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p>​    3．调用注解中的抽象方法获取配置的属性值</p><h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h2><p>（1）数据库的基本概念</p><p>1，数据库的英文单词:DataBase简称: DB</p><p>2．什么数据库?</p><p>​    用于存储和管理数据的仓库。</p><p>3．数据库的特点:</p><p>​    1．持久化存储数据的。其实数据库就是一个文件系统</p><p>​    2．方便存储和管理数据</p><p>​    3．使用了统一的方式操作数据库— SQL</p><p>（2）MysQL服务启动</p><p>​    1. 手动。</p><p>​    2. cmd—&gt; services.msc打开服务的窗口</p><p>​    3. 使用管理员打开cmd</p><p>​        net start mysql :启动mysql的服务</p><p>​        net stop mysql:关闭mysql服务</p><p>MysQL登录</p><p>​    1.mysql -uroot -p密码</p><p>​    2.mysql -h IP地址 -uroot -p连接目标的密码</p><p>​    3.mysql —host=IP地址 —user=root —password=连接目标的密码</p><p>MysQL退出</p><p>​    1.exit</p><p>​    2.quit</p><p>Structured Query Language :结构化查询语言</p><p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”</p><p>（3）SQL通用语法</p><p>1.SQL语句可以单行或多行书写，以分号结尾。</p><p>2可使用空格和缩进来增强语句的可读性。</p><p>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><ol><li>3种注释</li></ol><p><em>单行注释: — 注释内容 或 # 注释内容 (mysql特有)</em></p><p>多行注释:/<em> 注释 </em>/</p><p>（4）SQL分类</p><p>1.DDL(Data Definition Language)数据定义语言</p><p>​    用来定义数据库对象:数据库，表，列等。关键字: create，drop,alter等</p><p>2.DML(Data Manipulation Language)数据操作语言</p><p>​    用来对数据库中表的数据进行增删改。关键字:insert，delete，update等</p><p>3.DQL(Data Query Language)数据查询语言</p><p>​    用来查询数据库中表的记录(敬据)。关键字: select，where 等</p><p>4.DCL(Data control Language)数据控制语言(了解)</p><p>​    用来定义数据库的访问权限和安全级别，及创建用户。关键字:GRANT,REVOKE等</p><ul><li>DDL:操作数据库、表</li></ul><p>1．操作数据库:CRUD</p><p>1.1 C(Create):创建</p><p>创建数据库:</p><p>​    create database 数据库名称;</p><p>创建数据库，判断不存在，再创建:</p><p>​    create database if not exists数据库名称;</p><p>创建数据库，并指定字符集</p><p>​    create database数据库名称character set字符集名;</p><p>练习:创建db4数据库，判断是否存在，并制定字符集为gbk</p><p>​    create database if not exists db4 character set gbk;</p><p>2．R(Retrieve):查询</p><p>查询所有数据库的名称:</p><p>​    show databases;</p><p>查询某个数据库的字符集:查询某个数据库的创建语句</p><p>​    show create database 数据库名称;</p><ol><li>U(Update):修改</li></ol><p>修改数据库的字符集</p><p>​    alter database 数据库名称 character set字符集名称;</p><ol><li>D(Delete):删除</li></ol><p>删除数据库</p><p>​    drop database数据库名称;</p><p>判断数据库存在，存在再删除</p><p>​    drop database if exists 数据库名称;</p><p>5．使用数据库</p><p>查询当前正在使用的数据库名称</p><p>​    select database();</p><p>使用数据库</p><p>​    use 数据库名称;</p><p>2．操作表</p><p>1.c(create):创建</p><p>1.1.语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">列名1数据类型1,</span><br><span class="line">列名2数据类型2，</span><br><span class="line">....</span><br><span class="line">列名n数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意∶最后一列，不需要加逗号(,)</p><p>*数据库类型:</p><p>1.int :整数类型</p><p>age int,</p><ol><li>double:小数类型</li></ol><p>​    score double(5,2)</p><ol><li><p>date:日期，只包含年月日, yyyy-MM-dd</p></li><li><p>datetime :日期，包含年月日时分秒yyyy-Mm-dd HH: mm : ss</p></li><li><p>timestamp:时间错类型 包含年月日时分秒yyyy-Mm-ddHH: mm: ss</p></li></ol><p>​        如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</p><ol><li>varchar:字符串</li></ol><p>name varchar(20):姓名最大20个字符</p><p>zhangsan 8个字符，张三2个字符</p><p>*创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">varchar</span>( <span class="number">32</span>),</span><br><span class="line">age <span class="type">int</span> ,</span><br><span class="line">score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">birthday <span class="type">date</span>,</span><br><span class="line">insert_time <span class="type">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>*复制表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 like 被复制的表名;</span><br></pre></td></tr></table></figure><ol><li>R(Retrieve):查询</li></ol><p>查询某个教据库中所有的表名称</p><p>​    show tables;</p><p>查询表结构</p><p>​    desc 表名;</p><ol><li>U(Update):修改</li></ol><p>3.1.修改表名</p><p>​    alter table 表名 rename to 新的表名;</p><p>3.2．修改表的字符集</p><p>​    alter table 表名 character set 字符集名称;</p><p>3.3．添加一列</p><p>​    alter tabie 表名 add 列名 数据类型;</p><p>3.4、修改列名称类型</p><p>​    alter table 表名 change 列名 新列名 新数据类型;</p><p>只改类型</p><p>​    alter table 表名 modify 列名 新数据类型;</p><p>3.5，删除列</p><p>​    alter tabie 表名 drop 列名;</p><p>DML:增制改表中数据</p><p>1．添加数据∶</p><p>语法︰</p><p>​    insert into 表名(列名1,列名2,…列名n) values(值1,值2,. ..值n);</p><p>*注意:</p><p>1.1.列名和值要一一对应。</p><p>1.2.如果表名后，不定义列名，则默认给所有列添加值</p><p>​    insert into 表名 values(值1,值2,…值n);</p><p>1.3．除了数字类型，其他类型需要使用引号(单双都可以)引起来</p><p>2．删除数据:|</p><p>语法∶[ ] 意思是可选可不选</p><p>​    delete from 表名 [where 条件];</p><p>*注意︰</p><p>​    1.如果不加冬件，则删除表中所有记录。</p><p>​    2.如果要删除所有记录</p><p>​        1.delete from 表名; —不推荐使用。有多少条记录就会执行多少次删除操作</p><p>​        2.TRUNCATE truncate table TABLE 表名; —推荐使用，效率更高先删除表，然后再创建一张一样的表。</p><p>​    3．修改数据︰</p><p>​        语法:</p><p>​        update 表名 set 列名1 =值1，列名2=值2,… [where条件];</p><p>​        *注意∶</p><p>​            1、如果不加任何条件，则会将表中所有记录全部修改。</p><ul><li>DQL:查询表中的记录</li></ul><p>select * from表名;</p><p>1．语法︰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by</span><br><span class="line">分组字段</span><br><span class="line">having</span><br><span class="line">分组之后的条件</span><br><span class="line">order by </span><br><span class="line">排序</span><br><span class="line">limit</span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure><p>2．基础查询</p><p>1，多个字段的查询</p><p>select 字段名1，字段名2… from表名;</p><p>*注意:</p><p>​    如果查询所有字段，则可以使用来替代字段列表。</p><p>2．去除重复:</p><p>​    distinct</p><p>3，计算列</p><p>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</p><p> ifnull(表达式1,表达式2) : null参与的运算，计算结果都为null</p><p>​    *表达式1:哪个字段需要判断是否为null</p><p>​    *表达式2:如果该字段为null后的替换值。</p><p>4．起别名︰</p><p>​    as : as也可以省咯</p><p>3．条件查询</p><p>​    3.1.where子句后跟条件</p><p>​    3.2．运算符 &gt;、&lt; 、 &lt;= 、 &gt;= 、= 、&lt;&gt;不等于</p><p>BETWEEN. ..AND</p><p>IN(集合)</p><p>LIKE模糊查询</p><p>占位符∶</p><p>_ 单个任意字符</p><p>% 多个任意字符</p><p>IS NULL</p><p>and或&amp;&amp;且</p><p>or 或 ||或</p><p>not 或 ！ </p><p>4.排序查询</p><p>*语法: order by 子句</p><p>order by 排序字段1 排序方式1 ，排序字段2 排序方式2.. .</p><p>*排序方式:</p><p>*ASC asc:升序，默认的。</p><p>*DESC desc:降序。</p><p>*注意︰</p><p>*如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p><p>2．聚合函数:将一列数据作为一个整体，进行纵向的计算。</p><p>count :计算个数</p><p> 1.一般选择非空的列:主键</p><p>  2.count(*) as total 设置列名为total计算个数与</p><p>max :计算最大值</p><p>min :计算最小值</p><p>sum :计算和</p><p>avg :计算平均值</p><p>*注意:聚合函数的计算，排除null值。</p><p>解决方案:</p><p>1.选择不包含非空的列进行计算</p><p>2.IF NULL if null函数</p><p>3.分组查询:</p><p>​    1.语法:group by 分组字段;</p><p>​    2．注意:</p><p>​        1.分组之后查询的字段:分组字段、聚合函数</p><p>​        2.where和having 的区别?</p><p>​            1.where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</p><p>​            2.where后不可以跟聚合函数，having可以进行聚合函数的判断。</p><p>4、分页查询</p><p>​    1．语法:limit开始的索引,每页查询的条数;</p><p>​    2．公式:开始的索引=(当前的页码-1)*每页显示的条数</p><p>—每页显示3条记录</p><p>SELECT *FROM student LIMIT 0,3;—第1页</p><p>SELECT * FROM student LIMIT 3,3; —第2页</p><p>SELECT * FROM student LIMIT 6,3; —第3页</p><p>3.limit是一个MySQL”方言”</p><p>约束</p><p>*概念:对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p><p>本分类:</p><p>1．主键约束:primary key</p><p>2．非空约束:not null</p><p>3．唯一约束: unique</p><p>4．外键约束:foreign key</p><p>*非空约束:not null某一列的值不能为null</p><p>1.创建表时添加约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT,</span><br><span class="line">NAME VARCHAR( 20) NOT NULL -- name为非空</span><br><span class="line">name varchar(20) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2．创建表完后，添加非空约束</p><p>​    ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</p><p>​    alter table stu modify name varchar(20) not null</p><p>3.删除name的非空约束</p><p>​    ALTER TABLE stu MODIFY NAME VARCHAR( 20);</p><p>​    *唯一约束:unique，某一列的值不能重复</p><p>1．注意:</p><p>唯一约束可以有NULL值，但是只能有一条记录为null</p><p>2．在创建表时，添加唯一约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT,</span><br><span class="line">phone_number VARCHAR(20) UNIQUE --手机号</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3.删除唯一约束</p><p>​    ALTER TABLE stu DROP INDEX phone_number;</p><p>4．在表创建完后，添加唯一约束</p><p>​    ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</p><p>主键约束: primary key。</p><p>1.注意∶</p><p>​    1.含义:非空且唯一</p><p>​    2.一张表只能有一个字段为主键</p><p>​    3.主键就是表中记录的唯一标识</p><p>2.在创建表时，添加主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">id int primary key ,--给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3．删除主键</p><p>​    错误alter table stu modify id int ;</p><p>​    ALTER TABLE stu DROP PRIMARY KEY;  drop primary</p><p>4．创建完表后,添加主键</p><p>​    ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p><p>5，自动增长:</p><p>​    1.概念∶如桌某一列是数值类型的，使用auto_increment可以来完成值得自动增长</p><p>​    2．在创建表时，添加主键约束，并且完成主键自增长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">id int primary key auto_increment,--给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3．删除自动增长</p><p>​    ALTER TABLE stu MODIFY id INT;</p><p>4．添加自动增长</p><p>​    ALTER TABLE stu MODIFY id INT AUTO_INCRENENT;</p><p>*外键约束:foreign key,让表于表产生关系，从而保证数据的准确性。</p><p>1．在创建表时，可以添加外键</p><p>*语法∶</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">.....</span><br><span class="line">外键列,</span><br><span class="line">constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2．删除外键</p><p>​    ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; foreign key</p><p>3，创建表之后，添加外键</p><p>​    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称 (主表列名称);</p><p>​    alter table 表名 ADD constraint 外键名称 foreign key references主表名称 (主表列名称);</p><p>4.级联操作</p><p>1。添加级联操作</p><p>语法:ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p><p>FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</p><p>foreign key (外键字段名称) references 主表名称 (主表列名称) on update cascade on delete cascade</p><p>2．分类:</p><p>1．级联更新:ON UPDATE CASCADE</p><p>2．级联删除:ON DELETE CASCADE </p><p>数据库的设计</p><p>1.多表之间的关系</p><p>1.分类:</p><p>1.一对一(了解)∶</p><p>​    *如∶人和身份证</p><p>​    *分析:—个人只有一个身份证，一个身份证只能对应一个人</p><p>2.一对多(多对一）:</p><p>​    *如∶部门和员工</p><p>​    *分析:—个部门有多个员工，一个员工只能对应一个部门</p><p>3．多对多∶</p><p>​    *如:学生和课程</p><p>​    *分析:—个学生可以选择很多门课程，一个课程也可以被很多学生选择</p><p>2．实现关系∶</p><p>​    1.一对多(多对一) :</p><p>​        *如∶部门和员工</p><p>​        *实现方式:在多的一方建立外键，指向一的一方的主键。</p><p>2，多对多∶</p><p>​    *如:学生和课程</p><p>​    实现方式∶多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</p><p>3.一对一(了解)∶</p><p>​    *如:人和身份证</p><p>​    *实现方式:一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</p><p>2．数据库设计的范式</p><p>​    *概念∶设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>​    设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p><p>​    目前关系数据库有六种范式∶第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。</p><p>*分类:</p><p>​    1，第一范式(1NF):每一列都是不可分割的原子数据项</p><p>​    2．第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖)</p><p>*几个概念:</p><p>​    1，函数依赖∶A—&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</p><p>​        例如:学号—&gt;姓名。(学号，课程名称)—&gt;分数</p><p>​    2．完全函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。例如:(学号，课程名称)—&gt;分数</p><p>​    3，部分函数依赖∶A—&gt;B，如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。例如:(学号，课程名称)—&gt;姓名</p><p>​    4，传递函数依赖∶A—&gt;8,B — &gt;c，如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组)的值可以确定唯一C属性的值，则称C传递函数依赖于A</p><p>​        例如:学号—&gt;系名，系名—&gt;系主任</p><p>​    5，码;如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</p><p>​        例如:该表中码为︰(学号，课程名称)可以确定唯一的其他属性</p><p>*主属性:码属性组中的所有属性</p><p>*非主属性:除过码属性组的属性</p><p>3．第三范式(3NF)︰在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖)</p><p>数据库的备份和还原</p><p>1，命令行:</p><p>*语法∶</p><p>​    备份: mysqldump -u用户名 -p密码 数据库的名称 &gt; 保存的路径</p><p>还原:</p><p>​    1．登录数据库</p><p>​    2．创建数据库</p><p>​    3．使用数据库</p><p>​    4。执行文件。source 文件路径</p><p>2．图形化工具︰</p><p>多表查询∶</p><p>查询语法∶</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">列名列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where.. .. 条件</span><br></pre></td></tr></table></figure><p>笛卡尔积∶</p><p>*有两个集合A,B .取这两个集合的所有组成情况。</p><p>*要完成多表查询，需要消除无用的数据</p><p>*多表查询的分类:</p><p>1.内连接查询:</p><p>1.隐式内连接:使用where条件消除无用数据</p><p>​    SELECT * FROM emp,dept WHERE emp. “ dept_id= dept. id ;</p><p>2．显式内连接:</p><p>​    语法: select 字段列表 from 表名1 [inner] join 表名2 on 条件</p><p>例如︰</p><p>SELECT * FROM emp INNER JOIN dept ON emp. dept_id = dept. id ;</p><p>SELECT * FROM emp JOIN dept ON emp. “ dept_id’= dept.’ id’;</p><p>3．内连接查询∶</p><p>​    1.从哪些表中查询数据</p><p>​    2.条件是什么</p><p>​    3.查询哪些字段</p><p>2.外链接查询:</p><p>1．左外连接:</p><p>​    *语法: select 字段列表 from 表1 left [outer] join 表2 on 条件;</p><p>​    *查询的是左表所有数据以及其交集部分。</p><p>2．右外连接:</p><p>​    语法: select 字段列表 from表1 right [outer] join 表2 on 条件;</p><p>​    *查询的是右表所有数据以及其交集部分。</p><p>3.子查询:</p><p>​    概念∶查询中嵌套查询，称嵌套查询为子查询。</p><p>​        —查询工资最高的员工信息</p><p>​        — 1查询最高的工资是多少 9000</p><p>​            SELECT MAX( salary) FROM emp;</p><p>​        —2查询员工信息，并且工资等于9008的</p><p>​            SELECT * FROM emp WHERE emp.”salary”= 9000;</p><p>​        —一条sql就完成这个操作。子查询</p><p>​            SELECT * FROM emp WHERE emp.’salary’ = (SELECT MAX( salary) FROM emp);</p><p>*子查询不同情况</p><p>1，子查询的结果是单行单列的∶</p><p>​    子查询可以作为条件，使用运算符去判断。运算符∶ &gt; &gt;= &lt; &lt;= =</p><p>​    —查询员工工资小于平均工资的人</p><p>​    SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</p><p>2．子查询的结果是多行单列的∶</p><p>​    子查询可以作为条件，使用运算符in来判断</p><p>​    —查询”财务部和’市场部”所有的员工信息</p><p>​    SELECT id FROM dept WHERE NAME =‘财务部’OR NAME = ‘巿场部”;</p><p>​    SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</p><p>—子查询</p><p>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept MHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</p><p>3，子查询的结果是多行多列的:</p><p>*子查询可以作为—张虚拟表参与查询</p><p>—查询员工入职日期是?2011-11-11日之后的员工信息和部门信息</p><p>—子查询</p><p>​    SELECT <em> FROM dept t1 ,(SELECT </em> FROM emp WHERE emp. join_date &gt; ‘2011-11-11’) t2 WHERE t1.id = t2.dept_id;</p><p>—普通内连接</p><p>​    SELECT FROM emp t1,dept t2 WHERE t1.’ dept_id’ = t2. id’ AND t1.” join_date’&gt; ‘2011-11-11’</p><p>事务</p><p>1，事务的基本介绍</p><p>​    1.概念∶</p><p>​        *如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p><p>​    2．操作:</p><p>​        1.开启事务:start transaction;</p><p>​        2.回滚:rollback;</p><p>​        3.提交:commit;</p><p>MysQL数据库中事务默认自动提交</p><p>*事务提交的两种方式:</p><p>自动提交∶</p><p>​    *mysql就是自动提交的</p><p>​    *一条DML(增删改语句会自动提交一次事务。</p><p>手动提交:</p><p>​    oracle数据库默认是手动提交事务需要先开后事务，再提交</p><p>*修改事务的默认提交方式∶</p><p>​    查看事务的默认提交方式:SELECT @autocommit; — 1代表自动提交0代表手动提交</p><p>​    修改默认提交方式:set @@autocommit = 0;</p><p>2．事务的四大特征:</p><p>​    1．原子性:是不可分割的最小操作单位，要么同时成功，要么同时失败。</p><p>​    2，持久性:当事务提交或回液后，数据库会持久化的保存数据。</p><p>​    3，隔离性:多个事务之间。相互独立。</p><p>​    4，一致性:事务操作前后，数据总量不变</p><p>3.事务的隔离级别(了解)</p><p>​    *概念∶多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题.</p><p>*存在问题:</p><p>​    1．脏读:一个事务，读取到另一个事务中没有提交的数据</p><p>​    2．不可重复读(虚读):在同一个事务中，两次读取到的数据不一样。</p><p>​    3．幻读:一个事务操作(DNL)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p><p>*隔离级别∶</p><p>​    1.read uncommitted : 读未提交</p><p>​        产生的问题:脏读、不可重复读．幻读</p><p>​    2.read committed :读已提交(oracle)</p><p>​        产生的问题:不可重复读、幻读</p><p>​    3.repeatable read:可重复读(rysQL默认)</p><p>​        产生的问题:幻读</p><p>​    4.serializable :串行化</p><p>​        可以解决所有的问题</p><p>注意:隔离级别从小到大安全性越来越高，但是效率越来越低</p><p>数据库查询隔离级别:</p><p>​    l select @atx_isolation;</p><p>​    l sellect @@transaction_isolation;</p><p>*数据库设置隔离级别:</p><p>​    l set global transaction isolation level 级别字符串;</p><p>DCL :</p><p>*SQL分类:</p><p>​    1.DDL:操作数据库和表</p><p>​    2.DML:增删改表中数据</p><p>​    3.DQL:查询表中数据</p><p>​    4.DCL:管理用户，授权</p><p>l DBA:数据库管理员</p><p>DCL:管理用户，授权</p><p>1．管理用户</p><p>​    1．添加用户:</p><p>​        *语法:CREATE USER ‘用户名”@’主机名’ IDENTIFIED identified BY ‘密码’;</p><p>​    2．删除用户:</p><p>​        *语法- DROP USER ‘用户名’@”主机名’;</p><p>​    3．修改用户密码:</p><p>​        UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’;</p><p>​        UPDATE USER SET PASSWORD = PASSWORD( ‘ abc ‘ ) WHERE USER = ‘lisi’;</p><p>​        SET PASSWORD FOR “用户名’@”主机名’= PASSWORD(“新密码”);</p><p>​        SET PASSWORD FOR “root’@’ localhost’ = PASSWORD( “123”);</p><p>mysq1中忘记了root用户的密码?</p><p>​    1.cmd — &gt;net stop mysql停止mysql服务</p><p>​        本需要管理员运行该cmd</p><p>​    2．使用无验证方式启动mysql服务: mysqld —skip-grant-tables</p><p>​    3．打开新的cmd窗口,直接输入mysql命今，敲回车。就可以登录成功</p><p>​    4.use mysql ;</p><p>​    5.update user set password = password(‘你的新密码’) where user = ‘root ‘;    </p><p>​    6.关闭两个窗口</p><p>​    7.打开任务管理器，手动结束mysqld.exe的进程</p><p>​    8.启动mysql服务</p><p>​    9.使用新密码登录。</p><p>4．查询用户:</p><p>​    — 1．切换到mysql数据库</p><p>​        USE myql;</p><p>​    — 2.查询user表</p><p>​        SELECT * FROM USER;</p><p>*通配符:%表示可以在任意主机使用用户登录数据库</p><p>2．权限管理:</p><p>1．查询权限:</p><p>—查询权限</p><p>​    SHOW GRANTS grants FOR “用户名’@”主机名”;</p><p>​    SHOW GRANTS FOR “lisi’@’ %”;</p><p>2．授予权限:</p><p>—授予权限</p><p>​    grant 权限列表 on 数据库名.表名 to ‘用户名”@’主机名”;</p><p>—给张三用户授予所有权限，在任意数据库任意表上</p><p>​    GRANT ALL ON <em>.</em> TO “ zhangsan’@” localhost “ ;</p><p>所以权限列表all所以数据库名和表名都是*</p><p>3．撤销权限:</p><p>—撤销权限:</p><p>​    revoke 权限列表 on 数据库名.表名 from `用户名’@”主机名’;</p><p>​    REVOKE UPDATE ON db3.” account“  FROM ‘lisi’@”%’;</p><h2 id="5-JDBC"><a href="#5-JDBC" class="headerlink" title="5.JDBC"></a>5.JDBC</h2><p>1．概念:Java DataBase Connectivity Java 数据库连接，Java语言操作数据库</p><p>JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我门可以使用这套接口(JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><p>2．快速入门:</p><p>*步骤:</p><p>1.导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p><p>​    1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</p><p>​    2.右键—&gt;add as Library</p><p>2．注册驱动</p><p>3。获取数据库连接对象connection</p><p>4．定义sql</p><p>5，获取执行sql语句的对象 statement</p><p>6．执行sql，接受返回结果</p><p>7．处理结果</p><p>8.释放资源</p><p>3．详解各个对象︰</p><p>1.DhiverManager :驱动管理对象</p><p>*功能∶</p><p>1。注册驱动:告诉程序该使用哪一个数据库驱动jar</p><p>static void registerDriver(Driver driver) :注册与给定的驱动程序DerverManger</p><p>写代码使用:class.forName( “ com.mysql .jdbc.Driver”);</p><p>通过查看源码发现:在com.mysqi.jdbc.Driver类中存在静态代码块 自动执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.sql. DriverMianager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;can&#x27;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: mysql5之后的驱动jar包可以省略注册驱动的步骤。</p><p>2．获取数据库连接:</p><p>方法:static connection getConnection(string url，string user，string password)</p><p>*参数︰</p><p>ur1:指定连接的路径</p><p>语法:jdbc : mysql://ip地址(域名):端口号/数据库名称</p><p>例子:jdbc : mysql:// localhost: 3306/db3</p><p>细节∶如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则ur1可以简写为: jdbc:mysq1://数据库名称</p><p>​    user :用户名</p><p>​    password :密码</p><p>2.Connectibn :数据库连接对象</p><p>1.功能∶</p><p>1.获取执行sql的对象</p><p>​    statement createstatement(</p><p>​    Preparedstatement preparestatement(string sql)</p><p>2.管理事务︰开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开后事务</p><p>​    提交事务: commit( )</p><p>​    回滚事务: rollback()</p><p>3.Statement :执行sql的对象</p><p>1。执行sql</p><p>​    1.boolean execute(string sql) :可以执行任意的sql了解</p><p>​    2.int executeupdate(string sql)︰执行DML (insert、update、delete)语句、DDL(create,alter、drop)语句</p><p>​        *返回值:影响的行数，可以通过这个影响的行数判断DNL语句是否执行成功 返回值&gt;o的则执行成功，反之，则失败。</p><p>​    3.Resultset executeQuery(string sql):执行DQL (select)语句</p><p>​    4.Resultset :结果集对象,封装查询结果</p><p>​        boolean next():游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p><p>​        getXxx(参数):获取数据[</p><p>​    Xxx:代表数据类型―如: int getInt() , string getstring()</p><p>​    参数:int : 代表列的编号,从1开始如: getstring(1)</p><p>​    string :代表列名称。如:getDouble(“balance”)</p><p>​    *注意:</p><p>​    使用步骤:</p><p>​        1。游标向下移动一行</p><p>​        2．判断是否有数据</p><p>​        3．获取数据</p><p>​    5.PreparedStatement :执行sql的对象</p><p>1，SQL注入问题∶在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><p>​    1．输人用户随便，输入密码:a’ or ‘a’ = ‘a</p><p>​    2.sql : select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</p><p>2．解决sql注入问题;使用Preparedstatement对象来解决</p><p>3。预编译的SQL:参数使用?作为占位符</p><p>4，步骤︰</p><p>​    1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar</p><p>​    2.注册驱动</p><p>​    3.获取数据库连接对象connection</p><p>​    4.定义sql</p><p>​        注意∶ sql的参数使用?作为占位符。</p><p>​        如: select * from user where username = ? and password = ?;</p><p>5．获取执行sql语句的对象Preparedstatement </p><p>​    Connection.preparestatement(string sql)</p><p>6．给?赋值</p><p>​    方法. setXxx(参数1，参数2)Xxx类型</p><p>​    参数1：?的位置编号 从1开始</p><p>​    参数2：?的值</p><p>7．执行sql，接受返回结果，不需要传递sql语句</p><p>8．处理结果</p><p>9．释放资源</p><p>注意︰后期都会使用Preparedstatement来完成增删改查的所有操作</p><p>1.可以防止SQL注入</p><p>2.效率更高:</p><p>​    抽取JDBC工具类:JDBCUtils</p><p>*目的:简化书写</p><p>*分析:</p><p>​    1.注册驱动也抽取</p><p>​    2.抽取一个方法获取连接对象</p><p>*需求:不想传递参数（麻烦)，还得保证工具类的通用性。</p><p>*解决:配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.properties</span><br><span class="line">url=</span><br><span class="line">user=</span><br><span class="line">password=</span><br></pre></td></tr></table></figure><p>3．抽取一个方法释放资源</p><p>JDBC控制事务:</p><p>1.事务:一个包含多个步骠的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p><p>2.操作:</p><p>​    1.开启事务</p><p>​    2.提交事务</p><p>​    3.回滚事务</p><p>3．使用connection对象来管理事务</p><p>开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</p><p>​    在执行sql之前开启事务</p><p>提交事务: commit()</p><p>​    当所有sql都执行完提交事务</p><p>回滚事务:roillback()</p><p>​    在catch中回滚事务</p><p>数据库连接池</p><p>1．概念:其实就是一个容器(集合)，存放数据库连接的容器。</p><p>​    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p><p>2．好处:</p><p>​    1.节约资源</p><p>​    2.用户访问高效</p><p>3．实现︰</p><p>​    1,标准接口:DataSource javax.sql包下的</p><p>​    1.方法︰</p><p>​        *获取连接:getConnection()</p><p>​        *归还连接:Connection.close()。如果连接对象connection是从连接池中获取的，那么调用connection.close()方法，则不会再关闭连接了。而是归还连接</p><p>​    2.—般我们不去实现它，有数据库厂商来实现</p><p>​        1.C3PO∶数据库连接池技术</p><p>​        2.Druid :数据库连接池实现技术，由阿里巴巴提供的</p><p>​        4.C3Pe:数据库连接池技术</p><p>*步骤∶</p><p>1．导入jar包（3个)c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ,</p><p>​    *不要忘记导入数据库驱动jar包</p><p>2．定义配置文件:</p><p>​    名称:c3po.properties或者c3pe-config.xml</p><p>​    路径︰直接将文件放在src目录下即可。</p><p>3．创建核心对象 数据库连接池对象ComboPooledDatasource</p><p>4．获取连接: getConnection</p><p>5.Druid :数据库连接池实现技术，由阿里巴巴提供的</p><p>本步骤∶</p><p>1.导入jar包druid-1.e.9.jar</p><p>2．定义配置文件;</p><p>​    是properties形式的</p><p>​    可以叫任意名称，可以放在任意目录下</p><p>3．加载配置文件。Properties</p><p>​     //获取src路径下的文件的方式—-&gt;ClassLoader类加载器，加载字节码文件进内存，获取src文件下资源的路径 类名.class.getClassLoader(); </p><p>​    ClassLoader classLoader = JDBCUtils.class.getClassLoader();</p><p>4．获取数据库连接池对象:通过工厂来来获取DruidDataSourceFactory</p><p>5．获取连接:getconnection</p><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><p>spring框架对JDBC的简单封装。提供了一个DBCTemplate对象简化JDBC的开发步骤︰</p><p>1．导入jar包</p><p>2．创建JdbcTemplate对象。依赖于数据源Datasource</p><p>​    JdbcTemplate template = new JdbcTemplate(ds) ;</p><p>3．调用JdbcTemplate的方法来完成CRUD的操作</p><p>​    update():执行DML语句。增、删、改语句</p><p>​    queryForMap() :查询结果将结果集封装为map集合，将列名作为key，将值作为value将这条记录封装为一个map集合</p><p>​        注意:这个方法查询的结果集长度只能是1</p><p>​    queryForList():查询结果将结果集封装为list集合</p><p>​        注意:将每一条记录封装为一个Map集合，再好Map集合装载到List集合中query():查询结果，将结果封装为JavaBean对象</p><p>​        query的参数:RowMapper</p><p>​        一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p><p>​        *new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><p>queryForObject :查询结果，将结果封装为对象</p><p>​        —般用于聚合函数的查询</p><p>web概念概述</p><p>Javaweb :</p><p>*使用ava语言开发基于互联网的项目</p><p>*软件架构:</p><p>1.C/S: client/server客户端/服务器端</p><p>*在用户本地有一个客户端程序，在远程有一个服务器端程序如:Qo，迅雷…</p><p>优点:T.1．用户体验好缺点∶</p><p>​    1.开发、安装，部署，维护麻烦</p><p>​    2.B/S: Browser/Server浏览器/服务器端</p><p>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序*优点:</p><p>1.开发、安装，部署，维护简单缺点︰</p><p>1，如果应用过大，用户的体验可能会受到影响2．对硬件要求过高</p><p>B/S架构详解</p><p>*资源分类:</p><p>1.静态资源:</p><p>​    本使用静态网页开发技术发布的资源。本特点:</p><p>​    所有用户访问，得到的结果是—样的。</p><p>​    本如:文本，图片，音频、视频,HTML ,css,javaScript</p><p>​    如果用户请求的是静态资源，那么服务器会直接将静右资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</p><p>2.动态资源:</p><p>​    使用动态网页及时发布的资源。*特点:</p><p>​    *所有用户访问，得到的结果可能不一样。如:jsp/servlet,php,asp…</p><p>​    *如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</p><p>​    *我们要学习动态资源，必须先学习静态资源!</p><p>​    *静态资源:</p><p>*HTML:用于搭建基础网页，展示页面的内容</p><p>CSS:用于美化页面，布局页面</p><p>JavaScript :控制页面的元素，让页面有一些动态的效果</p><h2 id="6-HTML"><a href="#6-HTML" class="headerlink" title="6.HTML"></a>6.HTML</h2><p>1、概念︰是最基础的网页开发语言</p><p>​    *Hyper Text Markup Language超文本标记语言</p><p>超文本:</p><p>​    *超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p><p>标记语言:</p><p>​    由标签构成的语言。&lt;标签名称&gt;如html, xml</p><p>​    标记语言不是编程语言</p><p>2．快速入门∶</p><p>​    *语法∶</p><p>​    1.html文档后缀名.html或者.htm</p><p>​    2．标签分为</p><p>​        1．围堵标签:有开始标签和结束标签。如<code>&lt;html&gt; &lt;/html&gt;</code></p><p>​        2。自闭和标签∶开始标签和结束标签在一起。如<code>&lt;br/&gt;</code> 换行标签</p><p>​        3．标签可以嵌套:</p><p>​            需要正确嵌套，不能你中有我，我中有你</p><p>​        错误∶<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></p><p>​        正确:<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></p><p>​        4．在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p><p>​        5.html的标签不区分大小写，但是建议使用小写。</p><p>​    3．标签学习:</p><p>​        1．文件标签:构成html最基本的标签</p><p>​        html : html文档的根标签</p><p>​        head :头标签。用于指定html文档的一些属性。引入外部的资源*</p><p>​        title:标题标签。</p><p>​        body :体标签</p><p>*&lt; I DOCTYPE html&gt; : html5中定义该文档是html文档.</p><p>2．文本标签:和文本有关的标签</p><p>注释:<l--注释内容-->*</p><p>标题标签</p><p>h1~h6:字体大小逐渐递减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;:段落标签</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt;:换行标签</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr&gt;:展示一条水平线 属性∶ color :颜色 width :宽度 size :高度</span><br></pre></td></tr></table></figure><p>align :对其方式center :居中 left :左对齐 right :右对齐</p><p>width :</p><p>​    1．数值: width=’20’,数值的单位，默认是px(像素)</p><p>​    2．数值%:占比相对于父元素的比例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;:字体加粗</span><br><span class="line">&lt;i&gt;:字体斜体</span><br><span class="line">&lt;font&gt;:字体标签</span><br><span class="line">&lt;center&gt; :文本居中</span><br></pre></td></tr></table></figure><p>属性:color :颜色<em> size :大小</em> face :字体</p><p>*属性定义∶color :</p><p>​    1.英文单词: red ,green, blue</p><p>​    2.rgb(值1，值2,值3):值的范国:0~255如rgb(0,0,255)</p><p>​    3.#值1值2值3:值的范国:00~FF之间。如:#FF00FF 16进制配比</p><p>3，图片标签:</p><p>img :展示图片</p><p>属性:</p><p>src :指定图片的位置</p><p>alt：加载不出来输出的 名字</p><p> 相对路径 </p><p>​    以.开头的路径 </p><p>​    ./ 代表当前目录 </p><p>​    ../ 后退 上一级目录</p><p>4.列表标签</p><p>有序列表</p><p>​    ol：列表<code>&lt;ol type=&quot;A&quot; start=&quot;5&quot;&gt;</code></p><p>​    li：列表的项</p><p>无序列表ul   li</p><p>5．链接标签∶</p><p>​    <code>&lt;a&gt;</code>:定义一个超链接</p><p>​    属性: href :指定访问资源的URL(统一资源定位符)为空在本页面跳转javascript:void(0);阻止他的返回</p><p>​    target :指定打开资源的方式</p><p>​    _self:默认值，在当前页面打开</p><p>​    _blank :在新建空白页面打开</p><p>6.div和span</p><p>​    div：每个div占满一整行，块级标签</p><p>​    span：文本信息在一行展示，行内标签 内联标签</p><p>7.语义化标签：html5中为了提高程序的可读性，提供的一些标签</p><p>1.<code>&lt;header&gt; &lt;/header&gt;</code>:定义一个文档的头部分</p><p>2.<code>&lt;footer&gt; &lt;/footer&gt;</code>：定义一个文章的低部</p><p>8.表格标签</p><p>​    table :定义表格</p><p>​    width :宽度</p><p>​    border :边框</p><p>​    cellpadding :定义内容和单元格的距离</p><p>​    cellspacing:定义单元格之间的距离。如果指定为0，则单元格的线会合为一条.</p><p>​    bgcolor :背景色</p><p>​    align :对齐方式</p><p>​    margin:指定外边距，auto水平居中</p><p>​    tr :定义行</p><p>​    bgcolor :背景色</p><p>​    align :对齐方式</p><p>​    td :定义单元格</p><p>​    colspan：合并列</p><p>​    rowspan：合并行</p><p>​    th :定义表头单元格</p><p>​    <code>&lt;caption&gt;</code> :表格标题</p><p>​    <code>&lt;thead&gt;</code> :表示表格的头部分</p><p>​    <code>&lt;tbody&gt;</code>:表示表格的体部分</p><p>​    <code>&lt;tfoot&gt;</code> :表示表格的脚部分</p><p>HTML标签∶</p><p>​    表单标签表单︰</p><p>​    *概念︰用于采集用户输入的数据的。用于和服务器进行交互。</p><p>​         form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><p>属性:</p><p>​    action :指定提交数据的URL</p><p>​    method:指定提交方式</p><p>​    分类:—共7种，2种比较常用</p><p>get :</p><p>​    1，请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。</p><p>​    2，请求参数大小是有限制的。</p><p>​    3，不太安全。</p><p>post :</p><p>​    1．请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)</p><p>​    2．请求参数的大小没有限制。</p><p>​    3．较为安全。</p><p>​        *表单项中的数据要想被提交︰必须指定其name属性</p><p>​        *表单项标签︰</p><p>input :可以通过type属性值，改变元素展示的样式</p><p>type属性:</p><p>​    *text:文本输入框，默认值</p><p>​    *placeholder :指定输人框的提示信息，当输入框的内容发生变化，会自动清空提示信息</p><p>password :密码输入框隐藏密码 变成圆点</p><p>radio:单选框</p><p>注意︰</p><p>​    1.要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p><p>​    2.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p><p>​    3.checked属性，可以指定默认值</p><p>​        checkbox :复选框</p><p>注意︰</p><p>​    1.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p><p>​    2.checked属性，可以指定默认值 默认被选中</p><p>​    file:文件选择框</p><p>​    hidden :隐藏域,用于提交一些信息，虽然看不到，但值会被提交</p><p>按钮:</p><p>​    submit:提交按钮。可以提交表单</p><p>​    button:普通按钮</p><p>​    image :图片提交按钮</p><p>​    src属性指定图片的路径</p><p>​    label :指定输入项的文字描进信息</p><p>*注意∶</p><p>​    label的for属性一般会和input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p><p>​    select:下拉列表</p><p>*子元素: option，指定列表项</p><p>​    textarea :文本域</p><p>​    cols :指定列数，每一行有多少个字符</p><p>​    rows :默认多少行。</p><p>​    css:页面美化和布局控制</p><p>1．概念: cascading style sheets 层叠样式表</p><p>​    *层叠:多个样式可以作用在同一个html的元秦上，同时生效</p><p>2．好处∶</p><p>​    1．功能强大</p><p>​    2．将内容展示和样式控制分离</p><p>​        降低耦合度。解耦</p><p>​        让分工协作更容易提高开发效率</p><p>​    3.css的使用:css与html结合方式</p><p>​    1。内联样式</p><p>​        在标签内使用style属性指定css代码</p><p>*如: <code>&lt;div style=&quot;color : red;&quot;&gt;hello css&lt;/div&gt;</code></p><p>2．内部样式</p><p>在head标签内，定义style标签，style标签的标签体内容就是css代码</p><p>如∶</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div&#123;</span><br><span class="line">color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>3．外部样式</p><p>1．定义css资源文件。</p><p>2．在head标签内，定义link标签，引入外部的资源文件</p><p>如：</p><p>a.css文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">color:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; herf=&quot;css/a.css&quot;&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>*注意:</p><p>1,2,3种方式css作用范围越来越大</p><p>1方式不常用，后期常用2,3</p><p>3种格式可以写为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@import &quot;css/a.css&quot;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>4.css语法∶</p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">属性名1:属性值1;</span><br><span class="line">属性名2:属性值2;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器:筛选具有相似特征的元素</p><p>注意︰</p><p>每—对属性需要使用;隔开，最后一对属性可以不加;</p><p>5．选择器︰筛选具有相似特征的元秦</p><p>​    *分类︰</p><p>​    1，基础选择器</p><p>​        1.id选择器∶选择具体的id属性值的元素.建议在一个html页面中id值唯一</p><p>​        语法: #id属性值{}</p><p>​        2．元素选择器:选择具有相同标签名称的元素</p><p>​        本语法︰标签名称{}</p><p>​        本注意:id选择器优先级高于元素选择器</p><p>​        3．类选择器:选择具有相同的class属性值的元素。</p><p>​        语法:.class属性值{}</p><p>​        本注意:类选择器选择器优先级高于元素选择器</p><p>​    2.扩展选择器</p><p>​        1.选择所有元秦:</p><p>​            语法︰*{}</p><p>​        2.并集选择器︰</p><p>​            语法：*选择器1,选择器2{}</p><p>​        3.子选择器∶筛选选择器1元素下的选择器2元素</p><p>​            语法;选择器1 选择器2{}</p><p>​        4.父选择器∵:筛选选择器2的父元素选择器1</p><p>​            语法:选择器1&gt;选择器2{}</p><p>​        5.属性选择器:选择元素名称，属性名-属性值的元素</p><p>​            多语法:元素名称[属性名=”属性值”]{ }</p><p>​        6.伪类选择器:选择一些元素具有的状态</p><p>​            *语法:元素:状态{ }</p><p>​    *如: <code>&lt;a&gt;</code></p><p>​        *状态︰</p><p>​            link :初始化的状态</p><p>​            visited :被访问过的状态</p><p>​            active : 正在访问状态</p><p>​            hover:鼠标悬浮状态</p><p>6．属性</p><p>1．字体、文本</p><p>​    font-size :字体大小</p><p>​    color :文本颜色</p><p>​    text-align :对其方式 </p><p>​    line-height :行高</p><p>2．背景</p><p>​    background :</p><p>3，边框</p><p>​    border :设置边框，符合属性</p><p>4．尺寸 width :宽度</p><p>​    height :高度</p><h2 id="7-Javascript"><a href="#7-Javascript" class="headerlink" title="7.Javascript"></a>7.Javascript</h2><p>概念:一门客户端本语营</p><p>​    运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p><p>​    脚本语言:不需要编译,直接就可以被浏览器解析执行了</p><p>功能:</p><p>​    可以来培强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</p><p>ECMAScript :客户端脚本语言的标准</p><p>1．基本语法:</p><p>1.与html结合方式</p><p>1．内部s :</p><p>*定义<code>&lt;script&gt;</code>，标签体内容就是js代码</p><p>2．外部s :</p><p>*定义<code>&lt;script&gt;</code>，通过src属性引入外部的js文件</p><p>*注意︰</p><p>1.<code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</p><p>2.<code>&lt;script&gt;</code>可以定义多个。</p><p>​    2．注释</p><p>​        1，单行注释://注释内容</p><p>​        2．多行注释∶/<em>注释内容</em>/</p><p>​        3．数据类型:</p><p>1．原始数据类型(基本数据类型):</p><p>​        1.number:数字。整数/小数/NaN(not a number 一个不是数字的数字类型)</p><p>​        2.string :字符串。字符串”abc” “a” “abc ‘ 无字符</p><p>2.boolean: true和false</p><p>3.null :一个对象为空的占位符</p><p>4.undefined :未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</p><p>2.引用数据类型:对象</p><p>4．变量</p><p>*变量:一小块存储数据的内存空间</p><p>Java语言是强类型语言，而Javascript是弱类型语言。</p><p>强类型︰在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p><p>弱类型:在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p><p>*语法∶</p><p>​    *var变量名=初始化值;</p><p>​    *typeof运算符:获取变量的类型。</p><p>注:null运算后得到的是object</p><p>5．运算符</p><p>1，—元运算符︰只有一个运算数的运算符</p><p>​    ++,— , +(正号),-(负号)</p><p>​    ++ —:自增(自减)++(—)在前，先自增(自减)，再运算++(—)在后，先运算，再自增(自减)</p><p>​    +(-):正负号</p><p>注意。在s中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p><p>其他类型转number:</p><p>​    string转number:按照字面值转换。如果字面值不是数字，则转为NaN(不是数字的数字)</p><p>​    boolean转number: true转为1,false转为-1</p><p>2．算数运算符</p><p>​    + - * / % …</p><p>3．赋值运算符</p><p>​    = += -+…</p><p>4．比较运算符</p><p>​    &lt; &gt; &gt;= &lt;= == ===(全等于)</p><p>比较方式</p><p>1．类型相同:直接比较</p><p>​    字符串,按照字典顺序比较。按位逐一比较，直到得出大小为止。</p><p>2．类型不同:先进行类型转换，再比较</p><p>​    *===:全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p><p>5．逻辑运算符</p><p>​     &amp;&amp; || !</p><p>​    逻辑运算符:&amp;&amp;:与（短路)</p><p>​    l|:或（短路)</p><p>​    !:非</p><p>*其他类型转boolean:</p><p>​    1.number:0或NaN为假，其他为真</p><p>​    2.string:除了空字符串(“”)，其他都是true</p><p>​    3.null&amp;undefined:都是false</p><p>​    4.对象:所有对象都为true</p><p>6．三元运算符</p><p>  ? : </p><p>6．流程控制语句</p><p>1.if…else. . .</p><p>2.switch:[</p><p>*在java中, switch语句可以接受的数据类型: byte int shor char,枚举(1.5) ,string(1.7)</p><p>​    switch(变量):</p><p>​    case 值:</p><p>​    *在JS中, switch语句可以接受任意的原始数据类型</p><p>​    3.while</p><p>​    4.do . ..while</p><p>​    5.for</p><p>7．特殊语法</p><p>1．语句以;结尾，如果一行只有一条语句则﹔可以省略(不建议)</p><p>2．变量的定义使用var关键字，也可以不使用</p><p>​    *用:定义的变量是局部变量</p><p>​    *不用:定义的变量是全局变量(不建议)</p><h3 id="1-Function-函数-方法-对象"><a href="#1-Function-函数-方法-对象" class="headerlink" title="1.Function:函数(方法)对象"></a>1.Function:函数(方法)对象</h3><p>1．创建:</p><p>1.var fun = new Function(形式参数列表,方法体);//忘掉吧</p><p>2.function 方法名称(形式参数列表){</p><p>​    方法体</p><p>}</p><p>3.var 方法名= function(形式参数列表){</p><p>​    方法体</p><p>}</p><p>2．方法:</p><p>3．属性:</p><p>​    length :代表形参的个数</p><p>4．特点:</p><p>​    1．方法定义是，形参的类型不用写,返回值类型也不写。</p><p>​    2．方法是一个对象，如果定义名称相同的方法，会覆盖</p><p>​    3．在JS中，方法的调用只与方法的名称有关，和参数列表无关</p><p>​    4．在方法声明中有一个隐藏的内置对象（数组）, arguments ,封装所有的实际参数</p><p>​    5．调用:</p><p>​        方法名称(实际参数列表);</p><p>​    Array:数组对象</p><p>1．创建:</p><p>​    1.var arr = new Array(元素列表);</p><p>​    2.var arr = new_Array(默认长度);</p><p>​    3.var arr =[元素列表];</p><p>2．方法</p><p>​    join(参数):将数组中的元素按照指定的分隔符拼接为字符串</p><p>​    push()向数组的末尾添加一或更多元素，并返回新的长度。</p><p>3．属性</p><p>​    length :数组的长度</p><p>4．特点:</p><p>​    1.Js中，数组元素的类型可变的。</p><p>​    2.Js中，数组长度可变的。</p><h3 id="2-Date-日期对象"><a href="#2-Date-日期对象" class="headerlink" title="2.Date:日期对象"></a>2.Date:日期对象</h3><p>​    1．创建:</p><p>​        var date =new Date( );</p><p>​    2．方法:</p><p>​        toLocalestring():返回当前date对象对应的时间本地字符串格式</p><p>​        getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p><p>​    Number</p><p>​    String</p><h3 id="3-RegExp-正则表达式对象"><a href="#3-RegExp-正则表达式对象" class="headerlink" title="3.RegExp:正则表达式对象"></a>3.RegExp:正则表达式对象</h3><p>1.正则表达式:定义字符串的组成规则。</p><p>1,单个字符:[ ]</p><p>​    如:[a][ab] [a-zA-Zo-9_]</p><p>​    特殊符号代表特殊含义的单个字符:</p><p>​        \d:单个数字字符[0-9]</p><p>​        \w:单个单词字符[a-zA-Z0-9_]</p><p>2．量词符号:</p><p>​    ?:表示出现0次或1次</p><p>​    *:表示出现0次或多次</p><p>​    +:出现1次或多次</p><p>​    {m,n}:表示m&lt;=数量&lt;=n</p><p>​    m如果缺省:{,n}:最多n次</p><p>​    n如果缺省:{m,}最少m次</p><p>3.开始结束符号</p><p>​    ^：开始</p><p>​    $：结束</p><p>2．正则对象:</p><p>1．创建</p><p>​    1.var reg =new_RegExp(”正则表达式”);</p><p>​    \2. var reg =/正则表达式/;</p><p>2．方法</p><p>​    1.test(参数):验证指定的字符串是否符合正则定义的规范</p><h3 id="4-Global"><a href="#4-Global" class="headerlink" title="4.Global"></a>4.Global</h3><p>1．特点:全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</p><p>2．方法:</p><p>​    encodeURI( ) : url编码</p><p>​    decodeURI(() : url解码</p><p>​    encodeURIComponent() : url编码,编码的字符更多</p><p>​    decodeURIComponent() : url解码</p><p>​    parseInt():将字符串转为数字</p><p>*逐—判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</p><p>isNaN():判断一个值是否是NaN</p><p>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false</p><p>eval():讲JavaScript字符串，并把它作为脚本代码来执行。</p><p> 3.URL编码</p><p>​    传智播客=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p><h2 id="8-BOM"><a href="#8-BOM" class="headerlink" title="8.BOM"></a>8.BOM</h2><p>1．概念︰Browser object Model 浏览器对象模型</p><p>​    将浏览器的各个组成部分封装成对象。</p><p>2．组成:window :窗口对象</p><p>​    Navigator :浏览器对象</p><p>​    screen :显示器屏幕对象</p><p>​    History : 历史记录对象</p><p>​    Location :地址栏对象</p><p>​    DOM简单学习:为了满足案例要求</p><p>*功能:控制html文档的内容</p><p>*代码∶获取页面标签(元秦)对象 Element</p><p>​    *document.getElementById(“id值”):通过元素的id获取元素对象</p><p>*操作Element对象︰</p><p>​    1.修改属性值∶</p><p>​        1.明确获取的对象是哪一个?</p><p>​        2.查看API文档，找其中有哪些属性可以设置</p><p>​    2．修改标签体内容︰</p><p>​    属性:innerHTML</p><p>​    事件简单学习</p><p>​    *功能:某些组件被执行了某些操作后，触发某些代码的执行。</p><p>​    *如何绑定事件</p><p>1．直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><p>​    1.事件:onclickl—单击事件</p><p>2．通过js获取元素对象，指定事件属性，设置一个函数</p><p>​    window:窗口对象</p><p>​    1、创建</p><p>​    2．方法</p><p>​        1．与弹出框有关的方法:</p><p>​        alert(）显示带有一段消,息和一个确认按钮的警告框。</p><p>​        confirm()  显示带有一段消息以及确认按钮和取消按钮的对话框。</p><p>​    如果用户点击确定按钮,则方法返回true</p><p>​    如果用户点击取消按钮，则方法返回false</p><p>​    prompt() 显示可提示用户输入的对话框。</p><p>​    返回值:获取用户输入的值</p><p>2．与打开关闭有关的方法:</p><p>​    close()关闭浏览器窗口。</p><p>​        谁调用我，我关谁</p><p>​    open()打开一个新的浏览器窗口</p><p>​        返回新的window对象</p><p>3．与定时器有关的方式</p><p>​    setTimeout()在指定的毫秒数后调用函数或计算表达式。</p><p>*参数:</p><p>​    1.js代码或者方法对象</p><p>​    2．毫秒值</p><p>​    *返回值:唯—标识，用于取消定时器</p><p>​        clearTimeout()取消由setTimeout()方法设置的 timeout。</p><p>​        setInterval()</p><p>​    按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><p>​        clearInterval()取消由setInterval()设置的timeout。</p><p>3．属性</p><p>4．特点</p><p>Window对象不需要创建可以直接使用window使用。window .方法名();</p><p>window引用可以省略。方法名();</p><p>Location对象 :地址栏对象</p><p>1．创建(获取)∶</p><p>1.window. location</p><p>\2. location</p><p>2．方法︰</p><p>​    reload(重新加载当前文档。刷新)</p><p>3。属性</p><p>​    href设置或返回完整的URL。跳转页面</p><p>​    History :历史记录对象</p><p>1．创建(获取)∶</p><p>​    1.window.history</p><p>​    2.history</p><p>2．方法:</p><p>​    back() 加载history列表中的前一个URL。</p><p>​    forward() 加载history列表中的下一个URL。</p><p>​    go(参数) 加载history列表中的某个具体页面。</p><p>参数:正数∶前进几个历史记录</p><p>​     负数:后退几个历史记录</p><p>3．属性∶</p><p>​    *length返回当前窗口历史列表中的URL数量。</p><h2 id="9-DOM"><a href="#9-DOM" class="headerlink" title="9.DOM"></a>9.DOM</h2><p>*概念: Document object Model文档对象模型</p><p>*将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p><p>W3C DOM 标准被分为3个不同的部分∶</p><p>核心DOM -针对任何结构化文档的标准模型</p><p>​    Document :文档对象</p><p>​    Eiement:元素对象</p><p>​    Attfibute :属性对象</p><p>​    Text :文本对象</p><p>​    Comment:注释对象</p><p>​    Node :节点对象，其他5个的父对象</p><p>​    XML DOM -针对XML文档的标准模型</p><p>​    HTML DOM -针对HTML文档的标准模型</p><p>核心DOM模型:</p><p>*Document :文档对象</p><p>1.创建(获取):在html dom模型中可以使用window对象来获取</p><p>​    1.window. document</p><p>​    2.document</p><p>2。方法:</p><p>​    1．获取Element对象︰ </p><p>​        1.getElementById() :根据id属性值获取元素对象。id属性值一般唯</p><p>​        2.getElementsByTagName():根据元素名称获取元素对象们。返回值是一个数组</p><p>​        3.getElementsByclassName( ) :根据class属性值获取元素对象们。返回值是一个数组</p><p>​        4.getElementsByName():根据name属性值获取元素对象们。返回值是一个数组</p><p>2．创建其他DOM对象:</p><p>​    createAttribute( name)：创建指定名称的属性节点，并返回新的attr对象</p><p>​    createcomment()：创建注释节点</p><p>​    createElement()：创建元素节点</p><p>​    createTextNode( )：创建文本节点</p><p>3．属性</p><p>Element :元素对象</p><p>1，获取/创建:通过document来获取和创建</p><p>2．方法:</p><p>​    1.removeAttribute() :删除属性</p><p>​    2.setAttribute(): 设置属性</p><p>Node :节点对象，其他5个的父对象</p><p>特点:所有dom对象都可以被认为是一个节点</p><p>方法:</p><p>CRUD dom树:︰</p><p>​    appendchild():向节点的子节点列表的结尾添加新的子节点。</p><p>​    removechild():删除(并返回)当前节点的指定子节点。</p><p>​    replacechild():用新节点替换一个子节点。</p><p>属性:</p><p>​    *parentNode返回节点的父节点。</p><p>HTML DOM</p><p>​    1．标签体的设置和获取: innerHTML</p><p>​    2．使用html元秦对象的属性</p><p>​    3．控制元素样式</p><p>1。使用元素的style属性来设置</p><p>如:</p><p>//修改样式方式1</p><p>​    div1.style.border = “1px solid red” ;</p><p>​    div1.style.width = “200px”;</p><p>​    font-size—&gt; fontsize//字体大小</p><p>​    div1.style.fontsize = “20px”;</p><p>2．提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p><h2 id="10-Bootstrap"><a href="#10-Bootstrap" class="headerlink" title="10.Bootstrap"></a>10.Bootstrap</h2><p>​    1．概念︰一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap是基于 HTML、JS、 Javascript 的，它简洁灵活，使得web开发更加快捷。</p><p><em>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</em>好处:</p><p>​        1，定义了很多的css毕式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</p><p>​        2．响应式布局。</p><p>​        同一套页面可以兼容不同分辨率的设备。</p><p>​    2．快速入门</p><p>​        1.下载Bootstrap</p><p>​        2．在项目中将这三个文件夹复制</p><p>​        3、创建html页面，引入必要的资源文件</p><p>响应式布局:</p><p>​    同一套页面可以兼容不同分辨率的设备。</p><p>​    实现∶依赖于棚格系统:将一行平均分成12个格子，可以指定元素占几个格子步骤∶</p><p>1，定义容器。相当于之前的table.</p><p>容器分类∶</p><p>​    1.container :两边留白  固定宽度</p><p>​    2.container-fluid :每一种设备都是100%的宽度</p><p>2．定义行。相当于之前的tr样式: row</p><p>3．定义元素。相当于之前的td样式指定该元素在不同的设备上，所占的格子数目。样式: col-设备代号-格子数目</p><p>设备代号︰</p><p>1.xs :超小屏幕手机(&lt;768px) : col-xs-12</p><p>2.sm :小屏蒂平板(≥768px)</p><p>3.md : 中等屏蒂桌面显示器(≥992px)</p><p>4.lg :大屏蒂大桌面显示器(≥1200px)</p><p>注意︰</p><p>​    1.一行中如果格子数目超过12，则超出部分自动换行。</p><p>​    2．栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</p><p>​    3．如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</p><p>css样式和js插件</p><p>1.全局CSS样式:</p><p>​    按钮:class=”btn btn-default”</p><p>图片:</p><p>​    class=”img-responsive”:图片在任意尺寸都占100%</p><p>图片形状:</p><pre><code> class=&quot;img-rounded&quot;:方形: </code></pre><p>​    class=”img-circle”:圆形 </p><p>​    class=”img-thumbnail”相框</p><p>表格</p><p>​    table 添加表格</p><p>​    table’- bordered 表格边框 </p><p>​    table- hover 鼠标悬停效果</p><p>表单</p><p>​    *给表单项添加: class=”form-control”</p><p>2.组件:</p><p>​    导航条</p><p>​    分页条</p><p>3.插件︰</p><p>​    轮播图</p><p>​    事件监听机制:</p><p>*概念:某些组件被执行了某些操作后，触发某些代码的执行。</p><p>​    事件:某些操作。如:单击，双击，键盘按下了，鼠标移动了</p><p>​    事件源:组件。如:按钮文本输入框…</p><p>​    监听器∶代码。</p><p>​    注册监听∶将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</p><p>*常见的事件︰</p><p>1．点击事件∶</p><p>​    1.onclick:单击事件</p><p>​    2.ondblclick :双击事件</p><p>2．焦点事件</p><p>​    1.onblur :失去焦点</p><p>​        一般用于表单校验</p><p>​    2.onfocus:元素获得焦点。</p><p>​    3．加载事件:</p><p>​        1.onload : —张页面或─幅图像完成加载。</p><p>​    4．鼠标事件︰</p><p>​        1.onmousedown 鼠标按钮被按下。</p><p>​            定义方法时，定义一个形参，接受event对象。</p><p>​            event对象的button属性可以获取鼠标哪个键被点击了 </p><p>​        2.onmouseup鼠标按键被松开。</p><p>​        3.onmousemove鼠标被移动。</p><p>​        4.onmouseover鼠标移到某元素之上。</p><p>​        5.onmouseout鼠标从某元素移开。</p><p>​    5.键盘事件:</p><p>​        1.onkeydown某个键盘按键被按下。</p><p>​        2.onkeyup某个键盘按键被松开。</p><p>​        3.onkeypress某个键盘按键被按下并松开。</p><p>​    6．选择和改变</p><p>​        1.onchange 域的内容被改变。</p><p>​        2.onselect文本被选中。</p><p>​    7.表单事件:</p><p>​        1.onsubmit确认按钮被点击。</p><p>​            可以阻止表单的提交</p><p>​        2.onreset重置按钮被点击。</p><h2 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h2><p>1。概念︰Extensible Markup Language 可扩展标记语言</p><p>*可扩展︰标签都是自定义的。<code>&lt;user&gt; &lt;student&gt;</code></p><p>*功能</p><p>*存储数据</p><p>1．配置文件</p><p>2．在网络中传输</p><p>xml与html的区别</p><p>​    1.xml标签都是自定义的，html标签是预定义。</p><p>​    2.xml的语法严格，html语法松散</p><p>​    3.xml是存储数据的，html是展示数据</p><p>2．语法︰</p><p>*基本语法︰</p><p>​    1.xml文档的后缀名.xml</p><p>​    2.xml第一行必须定义为文档声明</p><p>​    3.xml文档中有且仅有一个根标签</p><p>​    4.属性值必须使用引号(单双都可)引起来</p><p>​    5.标签必须正确关闭</p><p>​    6.xml标签名称区分大小写</p><p>*快速人门:</p><p>*组成部分∶</p><p>1，文档声明</p><p>​    1．格式:<code>&lt;?xml 属性列表 ?&gt;</code></p><p>2．属性列表:</p><p>​    version :版本号，必须的属性</p><p>​    encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值:ISO-8859-1</p><p>​    standalone :是否独立</p><p>取值:</p><p>​    yes :不依赖其他文件</p><p>​    no:依赖其他文件</p><p>2．指令(了解)∶结合css的</p><p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=fa.css&quot; ?&gt;</code></p><p>3．标签︰标签名称自定义的</p><p>规则: 名称可以包含字母、数字以及其他的字符名称</p><p>​     不能以数字或者标点符号开始</p><p>​     名称不能以字母xml(或者XML、 xml等等)开始</p><p>​     名称不能包含空格</p><p>4.属性:</p><p>​    id属性值唯一</p><p>5，文本:</p><p>CDATA区:在该区域中的数据会被原样展示</p><p>格式:&lt; ![CDATA[ 数据 ]]&gt;</p><p>约束:规定xml文档的书写规则</p><p>*作为框架的使用者(程序员)∶</p><p>​    1．能够在xml中引入约束文档</p><p>​    2．能够简单的读懂约束文档</p><p>*分类︰</p><p>​    1.DTD:—种简单的约束技术</p><p>​    2.schema :—种复杂的约束技术</p><p>DTD :</p><p>*引人dtd文档到xml文档中</p><p>*内部dtd :将约束规则定义在xml文档中I</p><p>*外部dtd:将约束的规则定义在外部的dtd文件中</p><p>*本地:<code>&lt;! DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></p><p>*网络:<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></p><p>schema :</p><p>引入:</p><p>​    1.填写xml文档的根元秦</p><p>​    2.引入xsi前缀， xmlns :xsi=”http: / /www . w3. org/2001/xNLSchema-instance”</p><p>​    3.引入xsd文件命名空间.  xsi:schemaLocation=”http : / / ww.itcast.cn/xml student.xsd”</p><p>​    4.为每一个xsd约束声明一个前缀,作为标识 xmlns=”http: / / www.itcast.cn/xml”</p><p>3．解析∶操作xml文档，将文档中的数据读取到内存中</p><p>*操作xml文档</p><p>1．解析(读取)∶将文档中的数据读取到内存中</p><p>2．写入:将内存中的数据保存到xml文档中。持久化的存储</p><p>*解析xml的方式:</p><p>1.DOM∶将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p><p>​    *优点:操作方便，可以对文档进行CRUD的所有操作</p><p>​    *缺点∶占内存</p><p>2.SAX:逐行读取，基于事件驱动的。</p><p>​    *优点:不占内存。</p><p>​    *缺点:只能读取，不能增删改</p><p>xml常见的解析器∶</p><p>​    1.JAXP : sun公司提供的解析器，支持dom和sax两种思想</p><p>​    2.DOM43 :一款非常优秀的解析器</p><p>​    3.Jsoup : jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容它提供了一套非常省力的API，可通过DOM,cSs以及类似于jQuery的操作方法来取出和操作数据。</p><p>​    4.PULL : Android操作系统内置的解析器，sax方式的。</p><p>对象的使用:</p><p>1.Jsoup :工具类，可以解析html或xml文档，返回Document</p><p>​    parse :解析html或xml文档，返回Document</p><p>​    parse(File in，string charsetName ):解析xml或html文件的。</p><p>​    parse(string html):解析xml或html字符出</p><p>​    parse(URL_url,int timeoutNillis):通过网络路径获取指定的html或xml的文档对象</p><p>2.Document :文档对象。代表内存中的dom树</p><h2 id="12-获取Element对象"><a href="#12-获取Element对象" class="headerlink" title="12.获取Element对象"></a>12.获取Element对象</h2><p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p><p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p><p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p><p>3.Elements :元素Element对象的集合。可以当做ArrayList<Element>来使用</p><p>4.Element :元素对象</p><p>1.获取子元素对象</p><p>​    getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p><p>​    getElementsByAttribute(string key):根据属性名称获取元素对象集合</p><p>​    getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p><p>2.获取属性值</p><p>​    string attr( string key):根据属性名称获取属性值</p><p>3.获取文本内容</p><p>​    string text():获取标签的纯文本内容</p><p>​    string html():获取标签体的所有内容(包括子标签的标签和文本内容)</p><p>5.Node :节点对象</p><p>是Document和Element的父类</p><p>快捷查询方式:</p><p>1.selector:选择器</p><p>​    使用的方法:Elementsselect(string cssQuery)</p><p>​    语法:参考selector类中定义的语法</p><p>2.XPath : XPath即为ML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p><p>​    *使用Jsoup的xpath需要额外导入jar包。</p><p>​    *查询w3cshool参考手册xml中，使用xpath的语法完成查询</p><p>web服务器软件∶</p><p>​    服务器︰安装了服务器软件的计算机</p><p>​    服务器软件∶接收用户的请求，处理请求，做出响应</p><p>​    web服务器软件:接收用户的请求，处理请求，做出响应。</p><p>​    在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 </p><p>web容器</p><p>常见的java相关的web服务器软件</p><p>​     webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p>​     websphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p>​    JBOSS :JBOSs公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p>​    Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的javaEE规范servlet/jsp。开源的，免费的。</p><p>​    JavaEE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p><p>​    Tomcat:web服务器软件</p><p>启动︰</p><p>bin/startup.bat ,双击运行该文件即可</p><p>​    访问:浏览器输入:localhost:8080回车访问自己</p><p><a href="http://别人的ip:8o80访问别人">http://别人的ip:8o80访问别人</a></p><p>​    可能遇到的问题: 1.黑窗口一闪而过: 原因:没有正确配置AVA_HOME环境变量</p><p>解决方案:正确配置JAvA_HOME环境变量</p><p>2．启动报错:</p><p>1．暴力∶找到占用的端口号，并目找到对应的进程，杀死该进程</p><p>   cmdnetstat -ano</p><p>2．温柔∶修效自身的端口号</p><p>​    conflserver.xml</p><p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p><p>好处∶在访问时，就不用输入端口号</p><p>5．关闭:</p><p>1．正常关闭:</p><p>​    bin/shutdown.bat</p><p>​    进入程序ctrl+c</p><p>2．强制关闭∶</p><p>​    点击启动窗口的×</p><p>6.配置:</p><p>部署项目的方式:</p><p>1.直接将项目放到webapps目录下即可。</p><p>​    localhost:8080/hello/hello.html</p><p>​    hello:项目的访问路径—&gt;虚拟目录</p><p>简化部署:将项目打成一个war包，再将war包放置到webapps目录下。</p><p>war包会自动解压缩</p><p>2.配置conf/server.xml文件在<code>&lt;Host&gt;</code>标签体中配置&lt;context docBase=”D: \hello” path=” /hehe” / &gt;</p><p>​    docBase:项目存放的路径</p><p>​    path :虚拟目录</p><p>3.在conf\catalina\localhost创建任意名称的xml文件。在文件中编写</p><p>&lt;context docBase=”D: \hello”/&gt;</p><p>虚拟目录:xml文件的名称</p><p>静态项目和动态项目:</p><p>​    目录结构</p><p>java动态项目的目录结构∶</p><p>​    —项目的根目录</p><p>​    — WEB-INF目录∶</p><p>​    — web.xml : web项目的核心配置文件</p><p>​    — classes目录:放置字节码文件的目录</p><p>​    — lib目录∶放置依赖的jar包</p><p>将Tomcat集成到IDEA中，并且创建avaEE的项目，部署项目。</p><h2 id="13-Servlet-server-applet"><a href="#13-Servlet-server-applet" class="headerlink" title="13.Servlet : server applet"></a>13.Servlet : server applet</h2><p>*概念:运行在服务器端的小程序</p><p>servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p><p>将来我们自定义一个类，实现servlet接口，复写方法。</p><p>快速入门:</p><p>1．创建JavaEE项目</p><p>2．定义一个类，实现servlet接口</p><p>*public class servletDemo1 implements servlet</p><p>3．实现接中的抽象方法</p><p>4．配置servlet</p><p>在web.xml中配置∶</p><p><code>&lt;!--配置servlet --&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;cn.itcast.web.servlet.servletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;/ servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>执行原理:</p><p>1，当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的servlet的资源路径</p><p>2．查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</p><p>3．如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</p><p>4 . tomcat会将字节码文件加载进内存，并且创建其对象</p><p>5．调用其方法</p><p>servlet中的生命周期方法:</p><p>1．被创建:执行init方法，只执行一次</p><p>servlet什么时候被创建?</p><p>​    默认情况下，第一次被访问时，servlet被创建</p><p>​    可以配置执行servlet的创建时机。</p><p>在<code>&lt;servlet&gt;</code>标签下配置</p><p>1．第一次被访问时，创建</p><p>*<code>&lt;load-on-startup&gt;</code>的值为负数</p><p>2．在服务器启动时，创建</p><p>*<code>&lt;load-on-startup&gt;</code>的值为0或正整数</p><p>​    Servlet的init方法，只执行一次，说明一个servlet在内存中只存在一个对象，Servlet是单例的</p><p>*多个用户同时访问时，可能存在线程安全问题。</p><p>*解决∶尽量不要在servlet中定义成员变量。应使用局部变量，即使定义了成员变量，也不要对修改值</p><p>2．提供服务:执行service方法，执行多次</p><p>​    每次访问servlet时, service方法都会被调用一次。</p><p>3．被销毁:执行destroy方法，只执行一次</p><p>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p><p>​    只有服务器正常关闭时，才会执行destroy方法。</p><p>destroy方法在servlet被销毁之前执行，一般用于释放资源</p><p>servlet3.0 :</p><p>*好处:</p><p>​    *支持注解配置。可以不需要web.xml了。</p><p>*步骤：</p><p>​    1．创建JavaEE项目，选择servlet的版本3.0以上，可以不创建web.xml</p><p>​    2．定义一个类，实现servlet接口</p><p>​    3，复写方法</p><p>​    4、在类上使用@WebServlet注解，进行配置</p><p>@WebServlet(”/资源路径”)  千万别少 / 不然服务器打不开</p><p>IDEA和tomcat的相关配置</p><p>1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件</p><p>​    查看控制台的log : using CATALINA_BASE: “C:\Users\liu.IntelliJIdea2019.3\system\tomcat_JavaWeb”</p><p>2．工作空间项目和tomcat部署的web项目tomcat真正访问的是“tomcat部署的web项目””，”tomcat部署的web项目””对应着”工作空间项目”的web目录下的所有资源</p><p>​    WEB-INF目录下的资源不能被浏览器百接访问。</p><p>3．断点调试:使用”小虫子”启动dubug启动</p><p>Servlet的体系结构</p><p>Servlet —接口===Genericservlet —抽象类===Httpservlet —抽象类</p><p>Genericservlet:将servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><p>将来定义servlet类时，可以继承Genericservlet，实现service()方法即可</p><p>Httpservlet : 对http协议的一种封装，简化操作</p><p>​    1。定义类继承Httpservlet</p><p>​    2。复写doGet/doPost方法</p><h2 id="14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议"><a href="#14-HTTP-概念-Hyper-Text-Transfer-Protocol超文本传输协议" class="headerlink" title="14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议"></a>14.HTTP :概念:Hyper Text Transfer Protocol超文本传输协议</h2><p>传输协议∶定义了，客户端和服务器端通信时，发送数据的格式</p><p>特点∶</p><p>​    1．基于TCP/IP的高级协议</p><p>​    2．默认端口号:80</p><p>​    3，基于请求/响应模型的:—次请求对应一次响应</p><p>​    4．无状态的:每次请求之间相互独立，不能交互数据</p><p>历史版本:</p><p>1.0:每一次请求响应都会建立新的连接</p><p>1.1:复用连接</p><p>​    请求消息数据格式</p><p>1.请求行</p><p>​    请求方式 请求ur1 请求协议/版本</p><p>GET /login.html HTTP/1.1</p><p>请求方式:</p><p>​    HTTP协议有7中请求方式,常用的有2种</p><p>GET:</p><p>​    1.请求参数在请求行中，在url后。</p><p>​    2．请求的url长度有限制的</p><p>​    3．不太安全</p><p>POST:</p><p>​    1.请求参数在请求体中</p><p>​    2．请求的url长度没有限制的</p><p>​    3。相对安全</p><p>2．请求头:客户端浏览器告诉服务器一些信息</p><p>请求头名称:请求头值</p><p>*常见的请求头︰</p><p>1.User-Agent :浏览器告诉服务器，我访问你使用的浏览器版本信息</p><p>​    可以在服务器端获取该头的信息，解决浏览器的兼容性问题</p><p>2.Referer : http: //localhost/login.html</p><p>​    告诉服务器，我(当前请求)从哪里来?</p><p>*作用:</p><p>​    1．防盗链:</p><p>​    2．统计工作:</p><p>​    3．请求空行</p><p>​        空行，就是用于分割POST请求的请求头，和请求体的。</p><p>​    4．请求体(正文)∶</p><p>​        本封装POST请求消息的请求参数的</p><h2 id="15-Request"><a href="#15-Request" class="headerlink" title="15.Request"></a>15.Request</h2><p>1.request对象和response对象的原理</p><p>​    1.request和response对象是由服务器创建的。我们来使用它们</p><p>​    2.request对象是来获取请求消息，response对象是来设置响应消息</p><p>2.request对象继承体系结构:</p><p>servletRequest—接口 </p><p>​    |  继承</p><p>HttpServletRequest —接口</p><p>​    |  实现</p><p>org.apache.catalina.connector.RequestFacade  类(tomcat)</p><p>3.request功能∶</p><p>1.获取请求消息数据</p><p>1.获取请求行数据</p><p>​    GET / day14/ demo1 ?name=zhangsan HTTP/1.1</p><p>方法∶</p><p>1．获取请求方式:GET</p><p>​    String getMethod()</p><p>2.(*)获取虚拟自录:/day14</p><p>​    String getcontextPath()</p><p>3，获取Servlet路径:/demo1</p><p>​    String getServletpath()</p><p>4、获取get方式请求参数: name=zhangsan</p><p>​    String getQuerystring()</p><p>5．(*)获取请求URI : / day14/ demo1</p><p>​    String getRequestURI():/day14/ demo1</p><p>​    StringBuffer getRequestURL():h<a href="http://localhost/day14/demo1">ttp:// localhost/day14/demo1</a></p><p>​    URL 统一资源定位符ht<a href="http://localhost/day14/RequestDemo1">tp://localhost/day14/RequestDemo1</a></p><p>​    URI  统一资源标识符/day14/RequestDemo1</p><p>6．获取协议及版本:HTTP/1.1</p><p>​    string getProtocol()</p><p>7．获取客户机的IP地址:</p><p>​    string getRemoteAddr( )</p><p>2．获取请求头数据</p><p>方法:</p><p>​    (*)string getHeadler (String name) :通过请求头的名称获取请求头的值</p><p>​    Enumerationcstring&gt; getHeaderwames():获取所有的请求头名称</p><p>3，获取请求体数据:</p><p>*请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p><p>步骤∶</p><p>1.获取流对象</p><p>​    BufferedReader getReader():获取字符输入流，只能操作字符数据</p><p>​    ServletInputstream getInputStream():获取字节输入流，可以操作所有类型数据</p><p>在文件止传知识点后讲解</p><p>2.再从流对象中拿数据</p><p>2．其他功能∶</p><p>1.获取请求参数通用方式∶不论get还是post请求方式都可以使用下列方法来获取请求参数</p><p>​    1.string getParameter(string name):根据参数名称获取参数值username=zs&amp;password=123</p><p>​    2.string[] getparametervalues(string name):根据参数名称获取参数值的数组hobby=xx8hobby-game</p><p>​    3.<code>Enumeration&lt;string&gt; getParameterNames()</code>:获取所有请求的参数名称</p><p>​    4.Map<string,string[]> getParameterMap():获取所有参数的map集合</p><p>中文乱码问题:</p><p>​    get方式:tomcat 8 已经将get方式乱码问题解决了</p><p>​    post方式:会乱码</p><p>*解决︰在获取参数前，设置request的编码 request.setCharacterEncoding(“UTF-8”);</p><p>2.请求转发:一种在服务器内部的资源跳转方式</p><p>1.步骤∶</p><p>​    1．通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(string path)</p><p>​    2．使用RequestDispatcher对象来进行转发∶forward(servletRequest request，ServletResponse response)</p><p>2.特点:</p><p>​    1。浏览器地址栏路径不发生变化</p><p>​    2．只能转发到当前服务器内部资源中。</p><p>​    3。转发是一次请求</p><p>登录跳转页面：开发步骤</p><p>​    1．创建项目，导入html页面，配置文件，jar包</p><p>​    2。创建数据库环境</p><p>​        driverClassName=com.mysql.cj.jdbc.Driver</p><p>​        数据库路径：url=jdbc:mysql:///day14?serverTimezone=GMT%2B8</p><p>​    3．创建包cn.itcast.domain,创建类User</p><p>​    4．创建包cn.itcast.util,创建类JDBCUtils，使用Druid连接池</p><p>​    5．创建包cn.itcast.dao,创建类UserDao,提供login方法</p><p>​    6．编写cn.itcast.web. servlet.Loginservlet类</p><p>​    8.login.html中form表单的action路径的写法</p><p>​        虚拟目录:Servlet的资源路径action=”/data14_text/LoginServlet”</p><p>​    9.Beanutils工具类，简化数据封装</p><p>​        *用于封装avaBean的</p><p>1.JavaBean ∶标准的ava类</p><p>1.要求:</p><p>​    1．类必须被public修饰</p><p>​    2．必须提供空参的构造器</p><p>​    3．成员变量必须使用private修饰</p><p>​    4。提供公共setter和getter方法</p><p>2．功能:封装数据</p><p>2．概念∶</p><p>成员变量:</p><p>属性: setter和getter方法截取后的产物</p><p>get和set方法里大多数是和成员变量一致</p><p>​    例如: getUsername() —&gt; Username—&gt; username</p><p>3．方法:</p><p>​    1.setProperty()操作属性，而不是成员变量 设置成员变量gender值为null 设置属性hehe才能改变gender</p><p>​    2.getProperty()</p><p>​    3.populate(object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</p><p>2．响应消息:服务器端发送给客户端的数据</p><p>*数据格式∶</p><p>1.响应行</p><p>1.组成︰协议/版本 响应状态码 状态码描述</p><p>​    HTTP/1.1 200 OK</p><p>2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。</p><p>​    1.状态码都是3位数字</p><p>​    2.分类︰</p><p>​        1.1xx∶服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p><p>​        2.2xx∶成功。代表:200</p><p>​        3.3xx︰重定向。代表:302(重定向),304(访问缓存)</p><p>​        4.4xx:客户端错误。</p><p>​            代表:404(请求路径没有对应的资源)</p><p>​             405:请求方式没有对应的doXxx方法</p><p>​        5.5xx:服务器端错误。代表:500(服务器内部出现异常)</p><p>2．响应头︰</p><p>1．格式:头名称:值</p><p>2．常见的响应头:</p><p>​    1.Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式</p><p>​    2.Content-disposition:服务器告诉客户端以什么格式打开响应体数据</p><p>​        值:in-line:默认值,在当前页面内打开</p><p>​           attachment;filename=xxx∶以附件形式打开响应体。文件下载</p><p>3．响应空行</p><p>4．响应体:传输的数据</p><h2 id="16-Response对象"><a href="#16-Response对象" class="headerlink" title="16.Response对象"></a>16.Response对象</h2><p>功能∶设置响应消息</p><p>1．设置响应行</p><p>​    1．格式:HTTP/1.1 200 ok</p><p>​    2．设置状态码: setStatus(int sc)</p><p>2．设置响应头: setHeader(string name，string value)</p><p>3．设置响应体︰</p><p>*使用步骤︰</p><p>1.获取输出流</p><p>​    字符输出流:Printwriter getwriter()</p><p>​    字节输出流: Servletoutputstream getoutputstream()</p><p>2.使用输出流，将数据输出到客户端浏览器</p><p>案例∶</p><p>1．完成重定向</p><p>重定向:资源跳转的方式</p><p>代码实现:</p><p>//1.设置状态码为302</p><p>​    response.setstatus( 302);</p><p>//2.设置响应头location</p><p>​    response.setHeader(“location”,” /day15/responseDemo2”);*/</p><p>//简单的重定向方法</p><p>​    response.sendRedirect(“ /day15/responseDemo2”);</p><p>重定向的特点: redirect</p><p>​    1．地址栏发生变化</p><p>​    2．重定向可以访问其他站点(服务器)的资源</p><p>​    3．重定向是两次请求。不能使用request对象来共享数据</p><p>转发的特点: forward</p><p>​    1．转发地址栏路径不变</p><p>​    2．转发只能访问当前服务器下的资源</p><p>​    3．转发是一次请求，可以使用request对象来共享数据 </p><h2 id="17-forward和redirect区别"><a href="#17-forward和redirect区别" class="headerlink" title="17.forward和redirect区别"></a>17.forward和redirect区别</h2><p>路径写法:</p><p>1，路径分类</p><p>1．相对路径:通过相对路径不可以确定唯一资源</p><p>如: ./index.html</p><p>不以/开头，以.开头的路径</p><p>规则∶找到当前资源和目标资源之间的相对位置关系</p><p>​    ./  当前目录</p><p>​    ../ 后退一级目录</p><p>2．绝对路径:通过绝对路径可以确定唯一资源</p><p>​    如: http: //localhost/day15/responseDemo2或 /day15/responseDemo2</p><p>以/开头的路径</p><p>​    规则:判断定义的路释是给谁用的?判断请求将来从哪儿发出</p><p>1.给客户端浏览器使用:需要加虚拟目录(项目的访问路径)</p><p>​    建议虚拟目录动态获取:request.getcontextpath()</p><p>​    <code>&lt;a&gt; ,&lt;form&gt;</code>,重定向…</p><p>2.给服务器使用:不需要加虚拟目录</p><p>​    转发路径</p><p>2．服务器输出字符数据到浏览器</p><p>本步骤︰</p><p>​    1。获取字符输出流</p><p>​    2．输出数据</p><p>注意:</p><p>乱码问题∶</p><p>​    1.Printwriter pw = response.getwriter();获取的流的默认编码是IS0-8859-1</p><p>​    2.设置该流的默认编码</p><p>​    3.告诉浏览器响应体使用的编码</p><p>​        //简单的形式，设置编码，是在获取流之前设置</p><p>​        response.setContentType( “text/html ;charset=utf-8”);</p><h2 id="18-ServletContext对象"><a href="#18-ServletContext对象" class="headerlink" title="18.ServletContext对象:"></a>18.ServletContext对象:</h2><p>1.概念∶代表整个web应用，可以和程序的容器(服务器)来通信</p><p>2.获取︰</p><p>1．通过request对象获取</p><p>​    request.getServletContext( );</p><p>2．通过Httpservlet获取</p><p>​    this.getServletContext();</p><p>3．功能∶</p><p>1．获取MIME类型:</p><p>​    MIME类型:在互联网通信过程中定义的一种文件数据类型</p><p>​    格式:大类型/小类型text/htmlimage/ jpeg</p><p>​    获取: string getMimeType(string file)</p><p>2．域对象︰共享数据</p><p>3．获取文件的真实(服务器)路径</p><p>案例:</p><p>文件下载需求:</p><p>​    1．页面显示超链接</p><p>​    2．点击超链接后弹出下载提示框</p><p>​    3，完成圈片文件下载</p><p>分析∶</p><p>​    1．超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求</p><p>​    2．任何资源都必须弹出下载提示框</p><p>​    3．使用响应头设置资源的打开方式∶</p><p>​        content-disposition:attachment;filename=xXX</p><p>步骤∶</p><p>1．定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</p><p>2．定义servlet</p><p>​    1．获取文件名称</p><p>​    2．使用字节输入流加载文件进内存</p><p>​    3，指定response的响应头: content-disposition:attachment;filename=xXX</p><p>​    4。将数据写出到response输出流</p><p>问题∶中文文件名问题</p><p>*解决思路︰</p><p>​    1．装取客户端使用的浏览器版本信息</p><p>​    2．根据不同的版本信息，设置filename的编码方式不同</p><h2 id="19-Cookie"><a href="#19-Cookie" class="headerlink" title="19.Cookie"></a>19.Cookie</h2><p>1.概念︰客户端会话技术，将数据保存到客户端</p><p>2.快速入门:</p><p>*使用步骤︰</p><p>1．创建cookie对象，绑定数据</p><p>​    new cookie(string name,string value)</p><p>2．发送cookie对象</p><p>​    response.addcookie(cookie cookie)</p><p>3．获取Cookie，拿到数据</p><p>​    cookie[] request.getcookies()</p><p>3.实现原理</p><p>​    基于响应头set-cookie和请求头cookie实现</p><p>4.cookie的细节</p><p>1.一次可不可以发送多个cookie?</p><p>​    *可以可以创建多个cookie对象，使用response调用多次addcookie方法发送cookie即可。</p><p>2.cookie在浏览器中保存多长时间?</p><p>​    1．默认情况下，当浏览器关闭后，Cookie数据被销毁</p><p>​    2．持久化存储∶</p><p>​        setMaxAge(int seconds)</p><p>​            1.正数∶将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p><p>​            2.负数∶默认值</p><p>​            3.零∶删除cookie信息</p><p>3.cookie能不能存中文?</p><p>在tomcat 8之前cookie中不能直接存储中文数据。</p><p>需要将中文数据转码—-一般采用URL编码(%E3)</p><p>在tomcat 8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p><p>4.cookie共享问题?</p><p>1.假设在一个tomcat服务器中，部署了多个web项目,那么在这些web项目中cookie能不能共享?</p><p>默认情况下cookie不能共享</p><p>​    setPath(String path):设固cookie的获取范围。默认情况下，设置当前的虚拟目录</p><p>​    如果要共享,则可以将path设置为”/”</p><p>2,不同的tomcat服务器间cookie共享问题?</p><p>​    setDomain(string path):如果设固一级域名相同，那么多个服务器之间cookie可以共享</p><p>​    setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p><p>5.cookie的特点和作用</p><p>​    1.cookie存储数据在客户端浏览器</p><p>​    2.浏览器对于单个cookie 的大小有限制(akb)以及对同一个域名下的总cookie数量也有限制(20个)</p><p>*作用:</p><p>​    1.cookie—般用于存出少量的不太敏感的数据</p><p>​    2．在不登录的情况下，完成服务器对客户端的身份识别</p><p>6.案例:记住上一次访问时间</p><p>1，需求∶</p><p>​    1．访问一个servlet，如果是第一次访问，则提示:您好，欢迎您首次访问。</p><p>​    2．如果不是第一次访问，则提示:欢迎回来，您上次访问时间为;显示时间字符串</p><p>2．分析∶</p><p>​    1．可以采用cookie来完成</p><p>​    2．在服务器中的servlet判断是否有一个名为lastTime的cookie</p><p>​        1.有:不是第一次访向</p><p>1.响应数据∶欢迎回来，您上次访问时间为:2018年6月10日11:50:20</p><p>2.写回cookie : lastTime=2018年6月1e日11:50:e1</p><p>2．没有∶是第一次访问</p><p>1．响应数据:您好，欢迎您首次访问</p><p>2．写回cookie : lastTime=2018年6月16日11: 50:01</p><h2 id="20-JSP-入门学习"><a href="#20-JSP-入门学习" class="headerlink" title="20.JSP:入门学习"></a>20.JSP:入门学习</h2><p>1.概念∶Java Server Pages : java服务器端页面</p><p>​    可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</p><p>​    用于简化书写!!!</p><p>2.原理</p><p>JSP本质上就是一个servlet</p><p>3.JSP的脚本:JSP定义ava代码的方式</p><p>​    1.&lt;% 代码 %&gt;:定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。成员变量范围小</p><p>​    2.&lt;%! 代码 %&gt;∶定义的java代码，在jsp转换后的java类的成员位置。成员变量范围大，全局。</p><p>​    3.&lt;%= 代码 %&gt;∶定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</p><p>4.JSP的内置对象</p><p>在jsp页面中不需要获取和创建，可以直接使用的对象</p><p>jsp一共有9个内置对象。</p><p>​    request</p><p>​    response</p><p>​    out:字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似</p><p>​    response. getwriter(和out.write()的区别:</p><p>​    在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</p><p>​    response.getwriter()数据输出永远在out.write()之前</p><h2 id="21-Session"><a href="#21-Session" class="headerlink" title="21.Session"></a>21.Session</h2><p>1．概念∶服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><p>2．快速入门:</p><p>1．获取Httpsession对象︰</p><p>​    Httpsession session = request.getsession();</p><p>2．使用Httpsession对象∶</p><p>​    object getAttribute(string name)</p><p>​    void setAttribute(string name，object value)</p><p>​    void removeAttribute(string name)</p><p>3．原理</p><p>​    session的实现是依赖于cookie的。</p><p>4。细节∶</p><p>1．当客户端关闭后，服务器不关闭，两次获取session是否为同一个?</p><p>默认情况下。不是。</p><p>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p><p>​    Cookie c = new Cookie(“SESSIONID” , session.getId());</p><p>​    c .setMaxAge(60*60);</p><p>​    response.addcookie(c);</p><p>2．客户端不关闭，服务器关闭后，两次获取的session是同一个吗?</p><p>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</p><p>session的钝化:</p><p>​    在服务器正常关闭之前，将Session对象序列化到硬盘上 </p><p>session的活化:</p><p>​    在服务器启动后，将session文件转化为内存中的session对象即可。</p><p>3.session什么时候被销毁?</p><p>​    1.服务器关闭</p><p>​    2.session对象调用invalidate() 。</p><p>​    3.session默认失效时间30分钟</p><p>​        选择性配置修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure><p>4.session的特点</p><p>1.session用于存储一次会话的多次请求的数据，存在服务器端</p><p>2.session可以存储任意类型，任意大小的数据</p><p>session与cookie的区别︰</p><p>​    1.session存储数据在服务器端，Cookie在客户端</p><p>​    2.session没有数据大小限制,Cookie有</p><p>​    3.session数据安全,cookie相对于不安全</p><h2 id="21JSP"><a href="#21JSP" class="headerlink" title="21JSP"></a>21JSP</h2><p>1.指令</p><p>作用:用于配置JSP页面，导入资源文件</p><p>格式∶&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;</p><p>分类∶</p><p>1.page:配置SP页面的</p><p>​    contentType :等同于response.setcontentType()</p><p>​    1．设置响应体的mime类型以及字符集</p><p>​    2．设置当前jsp页面的编码（只能是高级的IDE才能生效，</p><p>​        如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集)</p><p>​    import :导包</p><p>​    errorPage :当前页面发生异常后，会自动跳转到指定的错误页面</p><p>​    isErrorPage :标识当前页面是否是错误页面。</p><p>​        *true :是，可以使用内置对象exception.getMessage()</p><p>​        *false :否。默认值。不可以使用内置对象exception</p><p>2.include:页面包含的。导入页面的资源文件</p><p>*&lt;%@include file=”top.jsp”%&gt;</p><p>3.taglib:导入资源</p><p>​    *&lt;%taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p><p>​    *prefix:前缀，自定义的</p><p>2．注释:</p><p>1.html注释:</p><p>​    <!-- -->:只能注释html代码片段</p><p>\2. jsp注释∶推荐使用</p><p>​    &lt;%— —%&gt;∶可以注释所有</p><p>3．内置对象</p><p>​    在jsp页面中不需要创建，直接使用的对象</p><p>一共有9个:</p><p>变量名真实类型作用</p><p>​    pageContextPagecontext当前页面共享数据，还可以获取其他八个内置对象</p><p>​    requestHttpservletRequest一次请求访问的多个资源(转发)</p><p>​    sessionHttpSession一次会话的多个请求间</p><p>​    applicationServletContext所有用户间共享数据</p><p>​    responseHttpservletResponse响应对象</p><p>​    pageObject当前页面(Servlet)的对象this</p><p>​    outJspWriter输出对象，数据输出到页面上</p><p>​    configServletConfigservlet的配置对象</p><p>​    exceptionThrowable异常对象</p><h2 id="22-MVC-开发模式"><a href="#22-MVC-开发模式" class="headerlink" title="22.MVC:开发模式"></a>22.MVC:开发模式</h2><p>1.M : Model，模型。JavaBean</p><p>​    完成具体的业务操作，如:查询数据库，封装对象</p><p>2.V : View，视图。JSP</p><p>​    展示数据</p><p>3.C: Controller，控制器。Servlet</p><p>​    获取用户的输入</p><p>调用模型</p><p>将数据交给视图进行展示</p><p>*优缺点︰</p><p>1．优点:</p><p>​    1．耦合性低，方便维护，可以利于分工协作</p><p>​    2．重用性高</p><p>2．缺点∶</p><p>​    1．使得项目架构变得复杂，对开发人员要求高</p><h2 id="23-EL表达式"><a href="#23-EL表达式" class="headerlink" title="23.EL表达式"></a>23.EL表达式</h2><p>1.概念∶Expression Language表达式语言</p><p>2.作用:替换和简化jsp页面中java代码的编写</p><p>3.语法∶${表达式}</p><p>4.注意:</p><p>​    jsp默认支持el表达式的。如果要忽略el表达式</p><p>​    1.设置jsp中page指令中:isELIgnored=”true”忽略当前jsp页面中所有的el表达式</p><p>​    \2. ${表达式}∶忽略当前这个el表达式</p><p>5.使用∶</p><p>1.运算:</p><p>运算符:</p><p>​    1.算数运算符∶+ -  * /(div) %(mod)</p><p>​    2.比较运算符∶&gt; &lt; &gt;= &lt;= == !=</p><p>​    3.逻辑运算符:&amp;&amp;(and) ll(or)  !(not)</p><p>​    4.空运算符: empty</p><p>​        功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0</p><p>​        ${empty list}  list集合内是否为null</p><p>​           ${not empty str}判断字符串、集合、数组是否不为null并且长度大于0 </p><p>2.获取值</p><p>1.el表达式只能从域对象中获取值</p><p>2.语法:</p><p>​    1.${域名称.键名}∶从指定域中获取指定键的值</p><p>​    域名称:</p><p>​        1.pagescope—&gt; pagecontext小</p><p>​        2.requestScope—&gt; request</p><p>​        3.sessionscope—&gt; session</p><p>​        4.applicationscope —&gt; application(servletcontext)大</p><p>​        举例:在request域中存储了 name=张三</p><p>​        获取∶${requestScope. name}</p><p>2.$({键名}∶表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p><p>3.获取对象、List集合、 Map集合的值</p><p>​    1.对象∶${域名称.键名.属性名}</p><p>​      ${requestScope.u.birthday}</p><p>​    本质上会去调用对象的getter方法</p><p>2.List集合∶${域名称.键名[索引]}</p><p>3.Map集合:</p><p>​    1.$[域名称.键名.key名称}</p><p>​    2.$[域名称.键名[“key名称“]</p><p>​    3.隐式对象∶</p><p>​        el表达式中有11个隐式对象</p><p>​        pagecontext :获取jsp其他八个内置对象</p><p>​        ${pagecontext.request.contextPath} :动态获取虚拟目录</p><h2 id="24-JSTL"><a href="#24-JSTL" class="headerlink" title="24.JSTL"></a>24.JSTL</h2><p>1.概念:JavaServer Pages Tag Library  JSP标准标签库</p><p>​    是由Apache组织提供的开源的免费的jsp标签&lt;标签&gt;</p><p>2.作用:用于简化和替换jsp页面上的java代码</p><p>3.使用步骤:</p><p>​    1.导入jstl相关jar包</p><p>​    2.引入标签库:taglib指令:&lt;%@taglib %&gt;</p><p>​    3.使用标签</p><p>​    4.常用的JSTL标签</p><p>​        1.if:相当于java代码的if语句</p><p>​            1.属性:</p><p>​                test 必须属性，接受boolean表达式</p><p>​                    如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p><p>​                    一般情况下, test展性值会结合el表达式一起使用</p><p>​            2．注意∶</p><p>​                c :if标签没有else情况，想要else情况，则可以在定义一个c:if标签</p><p>​        2.choose:相当于java代码的switch语句</p><p>​            1.使用choose标签声明相当于switch声明</p><p>​            2.使用when标签做判断相当于case</p><p>​            3.使用otherwise标签做其他情况的声明相当于default</p><p>​        3.foreach:相当于java代码的for语句</p><p>​            1.完成重复的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt; 10; i ++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        属性:</p><p>​            begin:开始值</p><p>​            end:结束值</p><p>​            var:临时变量</p><p>​            step:步长</p><p>​            varStatus :循环状态对象</p><p>​            index:容器中元素的索引，从0开始</p><p>​            count:循环次数，从1开始</p><p>​    2.遍历容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list;</span><br><span class="line">for( User user : list)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    属性:</p><p>​        items:容器对象</p><p>​        var :容器中元素的临时变量</p><p>​        varStatus :循环状态对象</p><p>​        index:容器中元素的索引，从0开始</p><p>​        count:循环次数，从1开始</p><p>三层架构∶软件设计架构</p><p>1．界面层(表示层)∶用户看的得界面。用户可以通过界面上的组件和服务器进行交互cn.itcast.项目名.web</p><p>2．业务逻辑层∶处理业务逻辑的。cn.itcast.项目名.service</p><p>3．数据访问层:操作数据存储文件。cn.itcast.项目名.dao</p><h2 id="25-Filter-过滤器"><a href="#25-Filter-过滤器" class="headerlink" title="25.Filter:过滤器"></a>25.Filter:过滤器</h2><p>1.概念:</p><p>生活中的过滤器:净水器,空气净化器，士匪、</p><p>web中的过滤器﹔当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</p><p>过滤器的作用:</p><p>​    一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤…</p><p>2.快速入门:</p><p>1.步骤:</p><p>​    1.定义干个类，实现接口Filter</p><p>​    2.复写方法</p><p>​    3.配置拦截路释</p><p>​        1.web.xml</p><p>​        2.注解@WebFilter(“/*”) //访问所有资源之前，都会执行该过滤器</p><p>​        3.过滤器细节:</p><p>1.web.xml配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">&lt;!--拦截路径--&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/ url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>2.过滤器执行流程</p><p>​    1.执行过滤器</p><p>​    2.执行放行后的资源</p><p>​    3.回来执行过滤器放行代码下边的代码</p><p>3.过滤器生命周期对法</p><p>​    1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</p><p>​    2.doFilter:每一次请求被拦截资源时，会执行。执行多次</p><p>​    3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</p><p>4.过滤器配置详解</p><p>拦截路径配置:</p><p>​    1.具体资源路径: /index.jsp 只有访问index.jsp资源时，过滤器才会被执行</p><p>​    2.拦截目录: /user/ 访问/user下的所有资源时，过滤器都会被执行</p><p>​    3.后缀名拦截: *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行</p><p>​    4.拦截所有资源: /* 访问所有资源时，过滤器都会被执行</p><p>拦截方式配置:资源被访问的方式</p><p>注解配置∶</p><p>设置dispatcherTypes属性</p><p>​    1.REQUEST:默认值。浏览器直接请求资源</p><p>​    2.FORWARD∶转发访问资源</p><p>​    3.INCLUDE:包含访问资源</p><p>​    4.ERROR:错误跳转资源</p><p>​    5.ASYNC:异步访问资源</p><p>web.xml配置</p><p>*设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签即可</p><p>5.过滤器链(配置多个过滤器)</p><p>执行顺序:如果有两个过滤器∶过滤器1和过滤器2</p><p>​    1．过滤器1</p><p>​    2．过滤器2</p><p>​    3．资源执行</p><p>​    4．过滤器2</p><p>​    5．过滤器1</p><p>过滤器先后顺序问题:</p><p>1．注解配置:按照类名的字符串比较规则比较，值小的先执行</p><p>​    Demo6大于Demo176大于1</p><p>​    Demo6大于Demo76小于7</p><p>*如:AFilter和BFilter,AFilter就先执行了。</p><p>\2. web.xml配置: <code>&lt;filter-mapping&gt;</code>谁定义在上边，谁先执行</p><p>增强对象的功能:</p><p>设计模式:一些通用的解决固定问题的方式</p><p>​    1．装饰模式</p><p>​    2．代理模式</p><p>概念:</p><p>​    1．真实对象:被代理的对象</p><p>​    2．代理对象:</p><p>​    3．代理模式:代理对象代理真实对象，达到增强真实对象功能的目的</p><p>实现方式:</p><p>​    1．静态代理:有一个类文件描述代理模式</p><p>​    2．动态代理:在内存中形成代理类</p><p>*实现步骤:</p><p>​    1．代理对象和真实对象实现相同的接口</p><p>​    2．代理对象= Proxy.newInstance();</p><p>​    3，使用代理对象调用方法。</p><p>​    4．增强方法</p><p>增强方式:</p><p>​    1．增强参数列表</p><p>​    2．增强返回值类型</p><p>​    3，增强方法体执行逻辑</p><h2 id="26-Listener-监听器"><a href="#26-Listener-监听器" class="headerlink" title="26.Listener :监听器"></a>26.Listener :监听器</h2><p>*概念: web的三大组件之一。</p><p>事件监听机制</p><p>​    事件:一件事情</p><p>​    事件源:事件发生的地方</p><p>​    监听器:一个对象</p><p>​    注册监听︰将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码</p><p>ServletContextListener:监听servletcontext对象的创建和销毁</p><p>方法:</p><p>​    void contextDestroyed(servletContextEvent sce) : servletContext对象被销毁之前会调用该方法</p><p>​    void contextInitialized(ServletContextEvent sce) : servletContext对象创建后会调用该方法</p><p>步骤︰</p><p>​    1.定义一个类，实现servletcontextListener接口</p><p>​    2.复写方法</p><p>​    3.配置</p><p>1.web.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;cn.itcast.web.listener.contextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>*指定初始化参数<code>&lt;context-param&gt;</code></p><p>2.注解∶</p><p>@webListener</p><p>Query基础:</p><p>1.概念∶一个Javascript框架。简化js开发</p><p>​    JQuery是一个快速、简洁的Javascript框架，是继Prototype之后又一个优秀的Javascript代码库(或Javascript框架)。JQuery设计的宗旨是”Write Less，Do More””，即倡导写更少的代码，做更多的事情。它封装Javascript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p><p>​    Javascript框架:本质上就是一些js文件，封装了js的原生代码而已</p><p>2.快速入门：</p><p>1.步骤</p><p>1.下载JQuery</p><p>目前jQuery有三个大版本：</p><p>​    1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，</p><p>​        最终版本：1.12.4 (2016年5月20日)</p><p>​    2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，</p><p>​        最终版本：2.2.4 (2016年5月20日)</p><p>​    3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。</p><p>​        目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p><p>jquery-xxx.js与jquery-xxx.min.js区别:</p><p>​    1.jquery-xxx.js :开发版本。给程序员看的，有良好的缩进和注释。体积大一些</p><p>​    2.jquery-xxx.min.js :生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</p><p>2.导入JQuery的js文件:导入min.js文件</p><p>3.使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let div1 = $(&quot;#div1&quot;);</span><br><span class="line">alert(div1.html());</span><br></pre></td></tr></table></figure><p>3.JQuery对象和js对象区别与转换</p><p>​    1.JQuery对象在操作时，更加方便。</p><p>​    2.JQuery对象和js对象方法不通用．</p><p>3．两者相互转换</p><p>​    jq — &gt; js : jq对象[索引]或者jq对象.get(索引)</p><p>​    js — &gt; jq : $(js对象)</p><p>4.选择器：筛选具有相似特征的元素(标签)</p><p>1.基本操作学习：</p><p>1.事件绑定</p><p>​    //1.获取b1按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#b1&quot;).click(function()&#123; </span><br><span class="line">alert(&quot;abc&quot;); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>​    2.入口函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>window.onload 和 $(function) 区别</p><p>​         window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 </p><p>​         $(function)可以定义多次的。 </p><p>​    3.样式控制：css方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//$(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</span><br><span class="line">$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);</span><br></pre></td></tr></table></figure><p>2.分类</p><p>1.基本选择器</p><p>​    1.标签选择器（元素选择器）</p><p>​        * 语法： $(“html标签名”) 获得所有匹配标签名称的元素</p><p>​    2.id选择器</p><p>​        * 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</p><p>​    3.类选择器</p><p>​        * 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</p><p>​    4.并集选择器：</p><p>​        * 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</p><p>2.层级选择器</p><p>​    1.后代选择器</p><p>​        * 语法： $(“A B “) 选择A元素内部的所有B元素</p><p>​    2.子选择器</p><p>​        * 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</p><p>​    3.属性选择器</p><p>​        1.属性名称选择器</p><p>​        * 语法： $(“A[属性名]”) 包含指定属性的选择器</p><ol><li>属性选择器</li></ol><p>​    * 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</p><ol><li>复合属性选择器</li></ol><p>​    * 语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</p><ol><li>过滤选择器</li></ol><p>​    1. 首元素选择器</p><p>​        * 语法： :first 获得选择的元素中的第一个元素</p><ol><li>尾元素选择器</li></ol><p>​        * 语法： :last 获得选择的元素中的最后一个元素</p><p>​    3. 非元素选择器</p><p>​        * 语法： :not(selector) 不包括指定内容的元素</p><p>​    4. 偶数选择器</p><p>​        * 语法： :even 偶数，从 0 开始计数</p><p>​    5. 奇数选择器</p><p>​        * 语法： :odd 奇数，从 0 开始计数</p><p>​    6. 等于索引选择器</p><p>​        * 语法： :eq(index) 指定索引元素</p><p>​    7. 大于索引选择器</p><p>​        * 语法： :gt(index) 大于指定索引元素</p><p>​    8. 小于索引选择器</p><p>​        * 语法： :lt(index) 小于指定索引元素</p><p>​    9. 标题选择器</p><p>​        * 语法： :header 获得标题（h1~h6）元素，固定写法</p><ol><li>表单过滤选择器</li></ol><p>​    1. 可用元素选择器</p><p>​        * 语法： :enabled 获得可用元素</p><p>​    2. 不可用元素选择器</p><p>​        * 语法： :disabled 获得不可用元素</p><p>​    3. 选中选择器</p><p>​        * 语法： :checked 获得单选/复选框选中的元素</p><p>​    4. 选中选择器</p><p>​        * 语法： :selected 获得下拉框选中的元素</p><ol><li><p>DOM操作</p></li><li><p>内容操作</p></li></ol><p>​        1. html(): 获取/设置元素的标签体内容  <a><font>内容</font></a> —&gt; <font>内容</font></p><p>​        2. text(): 获取/设置元素的标签体纯文本内容  <a><font>内容</font></a> —&gt; 内容</p><p>​        3. val()： 获取/设置元素的value属性值</p><ol><li>属性操作</li></ol><p>​    1. 通用属性操作</p><p>​        1. attr(): 获取/设置元素的属性</p><p>​        2. removeAttr():删除属性</p><p>​        3. prop():获取/设置元素的属性</p><p>​        4. removeProp():删除属性</p><p>​        * attr和prop区别？</p><p>​            1. 如果操作的是元素的固有属性，则建议使用prop</p><p>​            2. 如果操作的是元素自定义的属性，则建议使用attr</p><p>​    2. 对class属性操作</p><p>​        1. addClass():添加class属性值</p><p>​        2. removeClass():删除class属性值</p><p>​        3. toggleClass():切换class属性切换样式</p><p>​            * toggleClass(“one”):</p><p>​            * 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加</p><ol><li>css():</li></ol><p>​    3. CRUD操作:</p><p>​    1. append():父元素将子元素追加到末尾</p><ul><li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li></ul><p>​    2. prepend():父元素将子元素追加到开头</p><ul><li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li></ul><ol><li>appendTo():</li></ol><ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li></ul><ol><li>prependTo()：</li></ol><ul><li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li></ul><ol><li>after():添加元素到元素后边</li></ol><ul><li>对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</li></ul><ol><li>before():添加元素到元素前边</li></ol><ul><li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li></ul><ol><li>insertAfter()</li></ol><ul><li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li></ul><ol><li>insertBefore()</li></ol><ul><li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li></ul><ol><li>remove():移除元素</li></ol><ul><li>对象.remove():将对象删除掉</li></ul><ol><li>empty():清空元素的所有后代元素。</li></ol><ul><li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点里面的东西没了  标签还在</li></ul><h2 id="27-JQuery-高级"><a href="#27-JQuery-高级" class="headerlink" title="27.JQuery 高级"></a>27.JQuery 高级</h2><ol><li>动画</li></ol><p>​    1.三种方式显示和隐藏元素</p><p>​        1.默认显示和隐藏方式</p><p>​            1.show([speed],[easing],[fn]])</p><p>​                1.参数：</p><p>​                    1.speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</p><p>​                    2.easing：用来指定切换效果，默认是”swing”，可用参数”linear”</p><p>​                        *swing：动画执行时效果是 先慢，中间快，最后又慢</p><p>​                        *linear：动画执行时速度是匀速的</p><p>​                    3.fn：在动画完成时执行的函数，每个元素执行一次。</p><p>​            2.hide([speed],[easing],[fn]])</p><p>​            3.toggle([speed],[easing],[fn])</p><p>​    2.滑动显示和隐藏方式</p><p>​        1.slideDown([speed],[easing],[fn])</p><p>​        2.slideUp([speed],[easing],[fn]])</p><p>​        3.slideToggle([speed],[easing],[fn])</p><p>​    3.淡入淡出显示和隐藏方式</p><p>​        1.fadeIn([speed],[easing],[fn])</p><p>​        2.fadeOut([speed],[easing],[fn])</p><p>​        3.fadeToggle([speed],[easing],[fn]])</p><p>2.遍历</p><p>1.js的遍历方式</p><p>​    * for(初始化值;循环结束条件;步长)</p><p>2.jq的遍历方式</p><p>​    1.jq对象.each(callback)</p><p>​        1.语法：</p><p>​            jquery对象.each(function(index,element){});</p><p>​                * index:就是元素在集合中的索引</p><p>​                * element：就是集合中的每一个元素对象</p><p>​                * this：集合中的每一个元素对象</p><p>​        2.回调函数返回值：</p><p>​            * true:如果当前function返回为false，则结束循环(break)。</p><p>​            * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</p><p>​    2.$.each(object, [callback])</p><p>​    3.for..of: jquery 3.0 版本之后提供的方式</p><p>​            for(元素对象 of 容器对象)</p><p>​    3. 事件绑定</p><p>​        1. jquery标准的绑定方式</p><p>​            * jq对象.事件方法(回调函数)；</p><p>​            * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。</p><p>​                * 表单对象.submit();//让表单提交</p><p>​        2. on绑定事件/off解除绑定</p><p>​            * jq对象.on(“事件名称”,回调函数)</p><p>​            * jq对象.off(“事件名称”)</p><p>​                * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</p><p>​        3. 事件切换：toggle</p><p>​            * jq对象.toggle(fn1,fn2…)</p><p>​                * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..     </p><p>​            * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p><p>​                 </p><p>​    4. 插件：增强JQuery的功能</p><p>​        1. 实现方式：</p><p>​            1. $.fn.extend(object) </p><p>​                * 增强通过Jquery获取的对象的功能  $(“#id”)</p><p>​            2. $.extend(object)</p><p>​                * 增强JQeury对象自身的功能  $/jQuery</p><h2 id="28-AJAX"><a href="#28-AJAX" class="headerlink" title="28.AJAX"></a>28.AJAX</h2><p>​    1. 概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p><p>​        1. 异步和同步：客户端和服务器端相互通信的基础上</p><p>​            * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</p><p>​            * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p><p>​            Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] </p><p>​            通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>​            传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p>​            提升用户的体验</p><p>​    2. 实现方式：</p><p>\1. 原生的JS实现方式（了解）</p><p>\2. JQeury实现方式</p><p>​            1. $.ajax()</p><p>​                * 语法：$.ajax({键值对});</p><p>​                 //使用$.ajax()发送异步请求</p><p>​            2. $.get()：发送get请求</p><p>​                * 语法：$.get(url, [data], [callback], [type])</p><p>​                    * 参数：</p><p>​                        * url：请求路径</p><p>​                        * data：请求参数</p><p>​                        * callback：回调函数</p><p>​                        * type：响应结果的类型</p><p>​            3. $.post()：发送post请求</p><p>​                * 语法：$.post(url, [data], [callback], [type])</p><p>​                    * 参数：</p><p>​                        * url：请求路径</p><p>​                        * data：请求参数</p><p>​                        * callback：回调函数</p><p>​                        * type：响应结果的类型</p><h2 id="29-JSON"><a href="#29-JSON" class="headerlink" title="29.JSON"></a>29.JSON</h2><p>​    1. 概念： JavaScript Object Notation        JavaScript对象表示法</p><p>​        * json现在多用于存储和交换文本信息的语法</p><p>​        * 进行数据的传输</p><p>​        * JSON 比 XML 更小、更快，更易解析。</p><p>​    2. 语法：</p><p>​        1. 基本规则</p><p>​            * 数据在名称/值对中：json数据是由键值对构成的</p><p>​                * 键用引号(单双都行)引起来，也可以不使用引号</p><p>​                * 值得取值类型：</p><p>​                    1. 数字（整数或浮点数）</p><p>​                    2. 字符串（在双引号中）</p><p>​                    3. 逻辑值（true 或 false）</p><p>​                    4. 数组（在方括号中）    {“persons”:[{},{}]}</p><p>​                    5. 对象（在花括号中） {“address”:{“province”：”陕西”….}}</p><p>​                    6. null</p><p>​            * 数据由逗号分隔：多个键值对由逗号分隔</p><p>​            * 花括号保存对象：使用{}定义json 格式</p><p>​            * 方括号保存数组：[]</p><p>​        2. 获取数据:</p><p>​            1. json对象.键名</p><p>​            2. json对象[“键名”]</p><p>​            3. 数组对象[索引]</p><p>​            4. 遍历</p><p>​    3. JSON数据和Java对象的相互转换</p><p>​        * JSON解析器：</p><p>​            * 常见的解析器：Jsonlib，Gson，fastjson，jackson</p><p>​        1. JSON转为Java对象</p><p>​            1. 导入jackson的相关jar包</p><p>​            2. 创建Jackson核心对象 ObjectMapper</p><p>​            3. 调用ObjectMapper的相关方法进行转换</p><p>​                1. readValue(json字符串数据,Class)</p><p>​        2. Java对象转换JSON</p><p>​            1. 使用步骤：</p><p>​                1. 导入jackson的相关jar包</p><p>​                2. 创建Jackson核心对象 ObjectMapper</p><p>​                3. 调用ObjectMapper的相关方法进行转换</p><p>​                    1. 转换方法：</p><p>​                        * writeValue(参数1，obj):</p><p>​                            参数1：</p><p>​                                File：将obj对象转换为JSON字符串，并保存到指定的文件中</p><p>​                                Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</p><p>​                                OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</p><p>​                        * writeValueAsString(obj):将对象转为json字符串</p><p>​                    2. 注解：</p><p>​                        1. @JsonIgnore：排除属性。</p><p>​                        2. @JsonFormat：属性值得格式化</p><p>​                            * @JsonFormat(pattern = “yyyy-MM-dd”)</p><p>​                    3. 复杂java对象转换</p><p>​                        1. List：数组</p><p>​                        2. Map：对象格式一致</p><p>校验用户名是否存在</p><p>​        1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：</p><p>​            1. $.get(type):将最后一个参数type指定为”json”</p><p>​            2. 在服务器端设置MIME类型</p><p>​                response.setContentType(“application/json;charset=utf-8”);</p><h2 id="30-Redis"><a href="#30-Redis" class="headerlink" title="30.Redis"></a>30.Redis</h2><p>​    1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库</p><p>1.1.什么是NOSQL</p><p>​            NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p><p>​            NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p><p>​            1.1.1.    NOSQL和关系型数据库比较</p><p>​                优点：</p><p>​                    1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</p><p>​                    2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</p><p>​                    3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</p><p>​                    4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p><p>​                缺点：</p><p>​                    1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</p><p>​                    2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</p><p>​                    3）不提供关系型数据库对事务的处理。</p><p>​            1.1.2.    非关系型数据库的优势：</p><p>​                1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p><p>​                2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p><p>​            1.1.3.    关系型数据库的优势：</p><p>​                1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p>​                2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>​            1.1.4.    总结</p><p>​                关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。</p><p>​                一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p><p>​        1.2.主流的NOSQL产品</p><p>​            •    键值(Key-Value)存储数据库</p><p>​                    相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p><p>​                    典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </p><p>​                    数据模型： 一系列键值对</p><p>​                    优势： 快速查询</p><p>​                    劣势： 存储的数据缺少结构化</p><p>​            •    列存储数据库</p><p>​                    相关产品：Cassandra, HBase, Riak</p><p>​                    典型应用：分布式的文件系统</p><p>​                    数据模型：以列簇式存储，将同一列数据存在一起</p><p>​                    优势：查找速度快，可扩展性强，更容易进行分布式扩展</p><p>​                    劣势：功能相对局限</p><p>​            •    文档型数据库</p><p>​                    相关产品：CouchDB、MongoDB</p><p>​                    典型应用：Web应用（与Key-Value类似，Value是结构化的）</p><p>​                    数据模型： 一系列键值对</p><p>​                    优势：数据结构要求不严格</p><p>​                    劣势： 查询性能不高，而且缺乏统一的查询语法</p><p>​            •    图形(Graph)数据库</p><p>​                    相关数据库：Neo4J、InfoGrid、Infinite Graph</p><p>​                    典型应用：社交网络</p><p>​                    数据模型：图结构</p><p>​                    优势：利用图结构相关算法。</p><p>​                    劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p><p>​        1.3 什么是Redis</p><p>​            Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p><p>​                1) 字符串类型 string</p><p>​                2) 哈希类型 hash</p><p>​                3) 列表类型 list</p><p>​                4) 集合类型 set</p><p>​                5) 有序集合类型 sortedset</p><p>​            1.3.1 redis的应用场景</p><p>​                •    缓存（数据查询、短连接、新闻内容、商品内容等等）</p><p>​                •    聊天室的在线好友列表</p><p>​                •    任务队列。（秒杀、抢购、12306等等）</p><p>​                •    应用排行榜</p><p>​                •    网站访问统计</p><p>​                •    数据过期处理（可以精确到毫秒</p><p>​                •    分布式集群架构中的session分离</p><p>​    2. 下载安装</p><p>​        1. 官网：<a href="https://redis.io">https://redis.io</a></p><p>​        2. 中文网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a></p><p>​        3. 解压直接可以使用：</p><p>​            * redis.windows.conf：配置文件</p><p>​            * redis-cli.exe：redis的客户端</p><p>​            * redis-server.exe：redis服务器端</p><p>​    3. 命令操作</p><p>​        1. redis的数据结构：</p><p>​            * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><p>​                * value的数据结构：</p><p>​                    1) 字符串类型 string</p><p>​                    2) 哈希类型 hash ： map格式  </p><p>​                    3) 列表类型 list ： linkedlist格式。支持重复元素</p><p>​                    4) 集合类型 set  ： 不允许重复元素</p><p>​                    5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><p>​        2. 字符串类型 string</p><p>​            1. 存储： set key value</p><p>​                127.0.0.1:6379&gt; set username zhangsan</p><p>​                OK</p><p>​            2. 获取： get key</p><p>​                127.0.0.1:6379&gt; get username</p><p>​                “zhangsan”</p><p>​            3. 删除： del key</p><p>​                127.0.0.1:6379&gt; del age</p><p>​                (integer) 1</p><p>​        3. 哈希类型 hash</p><p>​            1. 存储： hset key field value</p><p>​                127.0.0.1:6379&gt; hset myhash username lisi</p><p>​                (integer) 1</p><p>​                127.0.0.1:6379&gt; hset myhash password 123</p><p>​                (integer) 1</p><p>​            2. 获取： </p><p>​                * hget key field: 获取指定的field对应的值</p><p>​                    127.0.0.1:6379&gt; hgetall myhash</p><p>​                    1) “username”</p><p>​                    2) “lisi”</p><p>​                    3) “password”</p><p>​                    4) “123” </p><p>​            3. 删除： hdel key field</p><p>​                127.0.0.1:6379&gt; hdel myhash username</p><p>​                (integer) 1</p><p>​        4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>​            1. 添加：</p><p>​                1. lpush key value: 将元素加入列表左表</p><p>​                2. rpush key value：将元素加入列表右边</p><p>​                    127.0.0.1:6379&gt; lpush myList a</p><p>​                    (integer) 1</p><p>​                    127.0.0.1:6379&gt; lpush myList b</p><p>​                    (integer) 2</p><p>​                    127.0.0.1:6379&gt; rpush myList c</p><p>​                    (integer) 3</p><p>​            2. 获取：</p><p>​                * lrange key start end ：范围获取</p><p>​                    127.0.0.1:6379&gt; lrange myList 0 -1</p><p>​                    1) “b”</p><p>​                    2) “a”</p><p>​                    3) “c”</p><p>​            3. 删除：</p><p>​                * lpop key： 删除列表最左边的元素，并将元素返回</p><p>​                * rpop key： 删除列表最右边的元素，并将元素返回</p><p>​        5. 集合类型 set ： 不允许重复元素</p><p>​            1. 存储：sadd key value</p><p>​                127.0.0.1:6379&gt; sadd myset a</p><p>​                (integer) 1</p><p>​                127.0.0.1:6379&gt; sadd myset a</p><p>​                (integer) 0</p><p>​            2. 获取：smembers key:获取set集合中所有元素</p><p>​                127.0.0.1:6379&gt; smembers myset</p><p>​                1) “a”</p><p>​            3. 删除：srem key value:删除set集合中的某个元素    </p><p>​                127.0.0.1:6379&gt; srem myset a</p><p>​                (integer) 1</p><p>​        6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>​            1. 存储：zadd key score value</p><p>​                127.0.0.1:6379&gt; zadd mysort 60 zhangsan</p><p>​                (integer) 1</p><p>​                127.0.0.1:6379&gt; zadd mysort 50 lisi</p><p>​                (integer) 1</p><p>​                127.0.0.1:6379&gt; zadd mysort 80 wangwu</p><p>​                (integer) 1</p><p>​            2. 获取：zrange key start end [withscores]</p><p>​                127.0.0.1:6379&gt; zrange mysort 0 -1</p><p>​                1) “lisi”</p><p>​                2) “zhangsan”</p><p>​                3) “wangwu”</p><p>​                127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</p><p>​                1) “zhangsan”</p><p>​                2) “60”</p><p>​                3) “wangwu”</p><p>​                4) “80”</p><p>​                5) “lisi”</p><p>​                6) “500”</p><p>​            3. 删除：zrem key value</p><p>​                127.0.0.1:6379&gt; zrem mysort lisi</p><p>​                (integer) 1</p><p>​        7. 通用命令</p><p>​            1. keys * : 查询所有的键</p><p>​            2. type key ： 获取键对应的value的类型</p><p>​            3. del key：删除指定的key value</p><p>​    4. 持久化</p><p>​        1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p><p>​        2. redis持久化机制：</p><p>​            1. RDB：默认方式，不需要进行配置，默认就使用这种机制</p><p>​                * 在一定的间隔时间中，检测key的变化情况，然后持久化数据</p><p>​                1. 编辑redis.windwos.conf文件</p><p>​                    #   after 900 sec (15 min) if at least 1 key changed</p><p>​                    save 900 1</p><p>​                    #   after 300 sec (5 min) if at least 10 keys changed</p><p>​                    save 300 10</p><p>​                    #   after 60 sec if at least 10000 keys changed</p><p>​                    save 60 10000</p><p>​                    </p><p>​                2. 重新启动redis服务器，并指定配置文件名称</p><p>​                    D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf    </p><p>​                </p><p>​            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p><p>​                1. 编辑redis.windwos.conf文件</p><p>​                    appendonly no（关闭aof） —&gt; appendonly yes （开启aof）</p><p>​                    </p><p>​                    # appendfsync always ： 每一次操作都进行持久化</p><p>​                    appendfsync everysec ： 每隔一秒进行一次持久化</p><p>​                    # appendfsync no     ： 不进行持久化</p><h2 id="31-Java客户端-Jedis"><a href="#31-Java客户端-Jedis" class="headerlink" title="31.Java客户端 Jedis"></a>31.Java客户端 Jedis</h2><p>​        * Jedis: 一款java操作redis数据库的工具.</p><p>​        * 使用步骤：</p><p>​            1. 下载jedis的jar包</p><p>​            2. 使用</p><p>​                //1. 获取连接</p><p>​                Jedis jedis = new Jedis(“localhost”,6379);</p><p>​                   //2. 操作</p><p>​                   jedis.set(“username”,”zhangsan”);</p><p>​                //3. 关闭连接</p><p>​                jedis.close();</p><p>​        * Jedis操作各种redis中的数据结构</p><p>​            1) 字符串类型 string</p><p>​                set</p><p>​                get </p><p>​                  //可以使用setex()方法存储可以指定过期时间的 key value</p><p>​                jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</p><p>​            2) 哈希类型 hash ： map格式  </p><p>​                hset</p><p>​                hget</p><p>​                hgetAll</p><p>​               3) 列表类型 list ： linkedlist格式。支持重复元素</p><p>​                lpush / rpush</p><p>​                lpop / rpop</p><p>​                lrange start end : 范围获取</p><p>​    4) 集合类型 set  ： 不允许重复元素</p><p>​                sadd</p><p>​                smembers:获取所有元素</p><p>​            5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><p>​                zadd</p><p>​                zrange</p><p>注意：使用redis缓存一些不经常发生变化的数据。</p><p>​            * 数据库的数据一旦发生改变，则需要更新缓存。</p><p>​            * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</p><p>​            * 在service对应的增删改方法中，将redis数据删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaWeb&quot;&gt;&lt;a href=&quot;#JavaWeb&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb&quot;&gt;&lt;/a&gt;JavaWeb&lt;/h1&gt;&lt;h2 id=&quot;1-Junit使用-白盒测试&quot;&gt;&lt;a href=&quot;#1-Junit使用-白盒测试&quot; cla</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaWeb" scheme="http://putongl.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>javaWeb</title>
    <link href="http://putongl.github.io/javaWeb.html"/>
    <id>http://putongl.github.io/javaWeb.html</id>
    <published>2023-10-17T06:30:40.151Z</published>
    <updated>2023-10-17T06:31:34.710Z</updated>
    
    <content type="html"><![CDATA[<p><a id="3060-1621846615933"></a>JavaWeb</p><p><a id="9ey9-1660562873495"></a> 一.Junit使用:白盒测试</p><p><a id="1glU-1660563044783"></a>*步骤:</p><p><a id="eT9S-1660563044785"></a>1．定义一个测试类(测试用例)</p><p><a id="9Ca3-1660563044787"></a>*建议∶</p><p><a id="KxjW-1660563044789"></a>测试类名∶被测试的类名TestCalculatorTest</p><p><a id="5aWX-1660563044794"></a>包名:xxx.xxx.xx.testcn.itcast.test</p><p><a id="yOi3-1660563044798"></a>2．定义测试方法:可以独立运行</p><p><a id="rWoR-1660563044800"></a>建议∶</p><p><a id="xkoT-1660563044802"></a>*方法名: test测试的方法名testAdd()</p><p><a id="fjDq-1660563044806"></a>*返回值: void</p><p><a id="1ouM-1660563044808"></a>*参数列表:空参</p><p><a id="hgai-1660563044810"></a>3．给方法加@Test 独立运行  导包</p><p><a id="V5wD-1660563044812"></a>4．导入junit依赖环境</p><p><a id="BZLa-1660563044814"></a>*判定结果︰红色∶失败绿色∶成功</p><p><a id="i1z2-1660563044818"></a>*—股我们会使用断言操作来处理结果</p><p><a id="QNDg-1660563044820"></a>*Assert.assertEquals(期望的结果,运算的结果);</p><p><a id="n96V-1660563380528"></a>补充∶</p><p><a id="m4ew-1660563380799"></a>*@Before:修饰的方法会在测试方法之前被自动执行</p><p><a id="I7zm-1660563386048"></a>@After:*修饰的方法会在测试方法执行之后自动被执行。</p><p><a id="rQ31-1660578318293"></a>二.#反射:框架设计的灵魂</p><p><a id="RkBX-1660578318581"></a>框架:半成品软件。可以在框架的基础上进行软件开发，简化编码</p><p><a id="Ar6F-1660578323969"></a>反射:将类的各个组成部分封装为其他对象，这就是反射机制</p><p><a id="zHt9-1660578318583"></a>*好处:</p><p><a id="JJWC-1660578318585"></a>1.可以在程序运行过程中，操作这些对象。</p><p><a id="PfbI-1660578359263"></a>2.可以解耦,提高程序的可扩展性。</p><p><a id="jsmd-1660578318587"></a>*获取class对象的方式:</p><p><a id="ARmb-1660578318589"></a>1.Class.forName(“全类名”)∶将字节码文件加载进内存，返回class对象 全类名：包名.类名</p><p><a id="9gF6-1660578318591"></a>*多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p><p><a id="l54e-1660578318593"></a>2.类名.class :通过类名的属性class获取</p><p><a id="i7FU-1660578318595"></a>*多用于参数的传递</p><p><a id="mEjc-1660578318597"></a>3，对象.getclass( : getclass()方法在object类中定义着。</p><p><a id="R5Bz-1660578439462"></a>*多用于对象的获取字节码的方式</p><p><a id="zcm8-1660578318599"></a>结论:同一个字节码文件(* .class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。</p><p><a id="8ktG-1660623002050"></a>class对象功能:</p><p><a id="Hyj3-1660623002276"></a>获取功能:</p><p><a id="ghVS-1660623002278"></a>1,获取成员变量们</p><p><a id="mpEG-1660623006196"></a>2,获取构造方法们</p><p><a id="5LRt-1660623007488"></a>3,获取成员方法们</p><p><a id="WV8x-1660623008555"></a>4.获取类名</p><p><a id="thxD-1660626812710"></a>Field:成员变量</p><p><a id="YqAG-1660626813003"></a>操作:</p><p><a id="sibJ-1660626813005"></a>1。设置值</p><p><a id="CWU3-1660626813007"></a>void set(object obj, object value)</p><p><a id="iaWn-1660626824260"></a>2．获取值</p><p><a id="bEBJ-1660626813009"></a>get(object obj)</p><p><a id="zM2d-1660626813011"></a>3，忽略访问权限修饰符的安全检查</p><p><a id="hyy3-1660626813013"></a>setAccessible(true):暴力反射</p><p><a id="urM4-1660627285197"></a>constructor:构造方法</p><p><a id="SMpv-1660627293536"></a>创建对象∶</p><p><a id="L0A3-1660627285732"></a>newInstance(object... initargs)</p><p><a id="duUG-1660627285734"></a>如果使用空参数构造方法创建对象，操作可以简化 : class对象的newInstance方法</p><p><a id="kswF-1660646526602"></a>三：注解</p><p><a id="kdjy-1660646540807"></a>说明程序的，给计算机看的</p><p><a id="wmia-1660646587986"></a>作用分类:</p><p><a id="fAmY-1660646615046"></a>编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</p><p><a id="6Od1-1660646651465"></a>代码分析:通过代码里标识的注解对代码进行分析【使用反射】</p><p><a id="ckuP-1660646615048"></a>编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】</p><p><a id="S4KM-1660646615050"></a>(1).JDK中预定义的一些注解</p><p><a id="qIJM-1660646615052"></a>@override:检测被该注解标注的方法是否是继承自父类(接口)的</p><p><a id="e5us-1660646666335"></a>@Deprecated :该注解标注的内容，表示已过时</p><p><a id="SsE5-1660646615054"></a>@suppresswarnings :压制警告</p><p><a id="6zmG-1660646615056"></a>—般传递参数all  @suppresswarnings(“all”)</p><p><a id="3Om4-1660646876024"></a>(2).自定义注解</p><p><a id="8ReZ-1660648191554"></a>格式∶</p><p><a id="4CnA-1660648191556"></a>元注解</p><p><a id="bNw9-1660648191558"></a>public @interface注解名称{</p><p><a id="RXnj-1660648191560"></a>属性列表;</p><p><a id="1ws6-1660648207773"></a>}</p><p><a id="MJaf-1660648191562"></a>本质:注解本质上就是一个接口，该接口默认继承Annotation接口</p><p><a id="0fe2-1660648191564"></a>public interface MyAnno extends java.lang.annotation.Annotation [}</p><p><a id="2VmT-1660648191566"></a>属性:接口中的抽象方法</p><p><a id="bzNC-1660648191568"></a>要求∶</p><p><a id="ATWK-1660648226746"></a>1．属性的返回值类型有下列取值</p><p><a id="dcvW-1660648191572"></a>基本数据类型</p><p><a id="aMdk-1660648191574"></a>String</p><p><a id="b61L-1660648191576"></a>枚举注解</p><p><a id="ZOcE-1660648191578"></a>以上类型的数组</p><p><a id="rixN-1660648191580"></a>2．定义了属性，在使用时需要给属性赋值</p><p><a id="Q2Te-1660648191582"></a>1，如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</p><p><a id="T9ZX-1660648260286"></a>2．如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</p><p><a id="QEOg-1660648191584"></a>3．数组赋值时，值使用{ }包裹。如果数组中只有一个值，则省略</p><p><a id="8m5m-1660648272003"></a>元注解:用于描述注解的注解</p><p><a id="BuFX-1660650157386"></a>@Target :描述注解能够作用的位置</p><p><a id="Jl9M-1660650157388"></a>ElementType取值:</p><p><a id="Z9F7-1660650157390"></a>TYPE:可以作用于类上</p><p><a id="T4U0-1660650157392"></a>METHOD:可以作用于方法上</p><p><a id="s9rI-1660650242370"></a>FIELD:可以作用于成员变量上</p><p><a id="So0B-1660650157394"></a>@Retention:描述注解被保留的阶段<br>@Retention(RetentionPolicy.RUNTIME)︰当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</p><p><a id="sM5B-1660650263329"></a>@Documented:描述注解是否被抽取到api文档中</p><p><a id="fhTG-1660650157396"></a>@Inherited:描述注解是否被子类继承</p><p><a id="pYmQ-1660664159000"></a>(3).在程序使用(解析)注解:获取注解中定义的属性值</p><p><a id="CPFq-1660664159261"></a>1，获取注解定义的位置的对象(class,Method,Field)</p><p><a id="XoiO-1660664230707"></a>2．获取指定的注解</p><p><a id="TyCK-1660664159263"></a>*getAnnotation(class)</p><p><a id="LBY6-1660664159265"></a>//其实就是在内存中生成了一个该注解接口的子类实现对象</p><p><a id="M91N-1660664159267"></a>public class ProImpl implements Pro{</p><p><a id="ejai-1660664159269"></a>public string className((){</p><p><a id="WtNx-1660664159271"></a>return “cn.itcast.annotation.Demo1”;</p><p><a id="xAkz-1660664159273"></a>}</p><p><a id="cDW7-1660664159275"></a>public string methodName({</p><p><a id="Q7er-1660664159277"></a>return “show”;</p><p><a id="1nWE-1660664159279"></a>}</p><p><a id="AkXm-1660664159281"></a>}</p><p><a id="DFP5-1660664159283"></a>3．调用注解中的抽象方法获取配置的属性值 </p><p><a id="YS9M-1660666668632"></a>四：数据库</p><p><a id="KD0z-1660666685258"></a>（1）数据库的基本概念</p><p><a id="STH2-1660666685815"></a>1，数据库的英文单词:DataBase简称: DB</p><p><a id="Bmrl-1660666694646"></a>2．什么数据库?</p><p><a id="RdSR-1660666685817"></a>用于存储和管理数据的仓库。</p><p><a id="a1ZD-1660666685819"></a>3．数据库的特点:</p><p><a id="pivc-1660666685821"></a>1．持久化存储数据的。其实数据库就是一个文件系统</p><p><a id="m0WB-1660666766564"></a>2．方便存储和管理数据</p><p><a id="QJgb-1660666685823"></a>3．使用了统一的方式操作数据库-- SQL</p><p><a id="MfS5-1660706486307"></a>（2）MysQL服务启动</p><p><a id="5Pah-1660706486494"></a>1、手动。</p><p><a id="Sowd-1660706486496"></a>2. cmd--&gt; services.msc打开服务的窗口</p><p><a id="XIxR-1660706489620"></a>3．使用管理员打开cmd</p><p><a id="GmFd-1660706486498"></a>net start mysql :启动mysql的服务</p><p><a id="17V2-1660706492382"></a>net stop mysql:关闭mysql服务</p><p><a id="w68D-1660706824810"></a>MysQL登录</p><p><a id="7Ypf-1660706832921"></a>1.mysql -uroot -p密码</p><p><a id="HDoB-1660706832923"></a>2.mysql -h IP地址 -uroot -p连接目标的密码</p><p><a id="0lqT-1660706832925"></a>3.mysql --host=IP地址 --user=root --password=连接目标的密码</p><p><a id="u1QR-1660706902114"></a>MysQL退出</p><p><a id="n2PD-1660706832927"></a>1.exit</p><p><a id="ufuT-1660706911601"></a>2. quit</p><p><a id="IZ87-1660709835772"></a>SQL ?</p><p><a id="UyOi-1660709836106"></a>Structured Query Language :结构化查询语言</p><p><a id="D5md-1660709836108"></a>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”</p><p><a id="b5Id-1660710507826"></a>（3）SQL通用语法</p><p><a id="VXpI-1660710508059"></a>1.SQL语句可以单行或多行书写，以分号结尾。</p><p><a id="jAAe-1660710521593"></a>2可使用空格和缩进来增强语句的可读性。</p><p><a id="ROGY-1660710508061"></a>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><p><a id="E3g3-1660710537272"></a>4. 3种注释</p><p><a id="4TUT-1660710508063"></a>*单行注释: -- 注释内容 或 # 注释内容 (mysql特有)*</p><p><a id="xhfr-1660710557644"></a>多行注释:/* 注释 */</p><p><a id="pzaX-1660714318004"></a>（4）SQL分类</p><p><a id="E6I9-1660714318229"></a>1.DDL(Data Definition Language)数据定义语言</p><p><a id="UFfT-1660714318231"></a>用来定义数据库对象:数据库，表，列等。关键字: create，drop,alter等</p><p><a id="xoCv-1660714409328"></a>2.DML(Data Manipulation Language)数据操作语言</p><p><a id="wtRB-1660714318233"></a>用来对数据库中表的数据进行增删改。关键字:insert，delete，update等</p><p><a id="6eus-1660714416913"></a>3.DQL(Data Query Language)数据查询语言</p><p><a id="cIWS-1660714318235"></a>用来查询数据库中表的记录(敬据)。关键字: select，where 等</p><p><a id="MLiC-1660714425443"></a>4. DCL(Data control Language)数据控制语言(了解)</p><p><a id="NQcs-1660714318237"></a>用来定义数据库的访问权限和安全级别，及创建用户。关键字:GRANT,REVOKE等</p><p><a id="nKPQ-1660714931238"></a>##DDL:操作数据库、表</p><p><a id="OEmf-1660714933882"></a>1．操作数据库:CRUD</p><p><a id="KAUE-1660714933884"></a>1.1 C(Create):创建</p><p><a id="OKO8-1660714933886"></a>创建数据库:</p><p><a id="ww8M-1660714933888"></a>create database 数据库名称;</p><p><a id="H6tm-1660714933890"></a>创建数据库，判断不存在，再创建:</p><p><a id="dycQ-1660714933892"></a>create database if not exists数据库名称;</p><p><a id="OeE1-1660715007815"></a>创建数据库，并指定字符集</p><p><a id="5eED-1660714933894"></a>create database数据库名称character set字符集名;</p><p><a id="ePnW-1660714933896"></a>练习:创建db4数据库，判断是否存在，并制定字符集为gbk</p><p><a id="l3n4-1660714933898"></a>create database if not exists db4 character set gbk;</p><p><a id="g5LI-1660714933901"></a>2．R(Retrieve):查询</p><p><a id="d4n2-1660714933903"></a>查询所有数据库的名称:</p><p><a id="Ar2l-1660714933905"></a>show databases;</p><p><a id="JUVo-1660714933907"></a>查询某个数据库的字符集:查询某个数据库的创建语句</p><p><a id="Skx9-1660714933909"></a>show create database 数据库名称;</p><p><a id="QSfG-1660714933911"></a>3. U(Update):修改</p><p><a id="ztrz-1660726005535"></a>修改数据库的字符集</p><p><a id="2Vov-1660726005537"></a>alter database 数据库名称 character set字符集名称;</p><p><a id="szZX-1660726005539"></a>4. D(Delete):删除</p><p><a id="nLJE-1660726005541"></a>删除数据库</p><p><a id="qQDe-1660726005543"></a>drop database数据库名称;</p><p><a id="ArYS-1660726035320"></a>判断数据库存在，存在再删除</p><p><a id="PHSJ-1660726005545"></a>drop database if exists 数据库名称;</p><p><a id="bOUG-1660726005547"></a>5．使用数据库</p><p><a id="y83h-1660726005549"></a>查询当前正在使用的数据库名称</p><p><a id="r5Dp-1660726005551"></a>select database();</p><p><a id="Ix7l-1660726005553"></a>使用数据库</p><p><a id="WTF3-1660726005555"></a>use  数据库名称;</p><p><a id="teZN-1660727168714"></a>##2．操作表</p><p><a id="KyBe-1660727170140"></a>1.c(create):创建</p><p><a id="yyFs-1660727170142"></a>1.1.语法:</p><p><a id="CTv6-1660727170144"></a>create table表名(</p><p><a id="M189-1660727170146"></a>列名1数据类型1,</p><p><a id="snJW-1660727208538"></a>列名2数据类型2，</p><p><a id="ETly-1660727210971"></a>....</p><p><a id="j8jf-1660727170148"></a>列名n数据类型n</p><p><a id="SD4H-1660727226152"></a>);</p><p><a id="jVMM-1660727170150"></a>注意∶最后一列，不需要加逗号(,)</p><p><a id="9Ll1-1660727237654"></a>*数据库类型:</p><p><a id="NMsV-1660727170152"></a>1.int :整数类型</p><p><a id="iqNL-1660727170154"></a>age int,</p><p><a id="ac8v-1660727253263"></a>2. double:小数类型</p><p><a id="zGkr-1660727170156"></a>score double(5,2)</p><p><a id="uDva-1660727170158"></a>3. date:日期，只包含年月日, yyyy-MM-dd</p><p><a id="VggH-1660727170160"></a>4. datetime :日期，包含年月日时分秒yyyy-Mm-dd HH: mm : ss</p><p><a id="AV65-1660727285624"></a>5. timestamp:时间错类型 包含年月日时分秒yyyy-Mm-ddHH: mm: ss</p><p><a id="M9G1-1660727170162"></a>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</p><p><a id="gOeb-1660727170164"></a>6. varchar:字符串</p><p><a id="9WD4-1660727170166"></a>name varchar(20):姓名最大20个字符</p><p><a id="SWF4-1660727307903"></a>zhangsan 8个字符，张三2个字符</p><p><a id="sB2D-1660727454077"></a>*创建表</p><p><a id="BXEM-1660727454611"></a>create table student(</p><p><a id="ppNR-1660727454613"></a>id int,</p><p><a id="efss-1660727454615"></a>name varchar( 32),</p><p><a id="lPvB-1660727480259"></a>age int ,</p><p><a id="UNA2-1660727454617"></a>score double(4,1),</p><p><a id="zgnn-1660727483258"></a>birthday date,</p><p><a id="IPe3-1660727454619"></a>insert_time timestamp</p><p><a id="s8DK-1660727514389"></a>);</p><p><a id="dpyi-1660729380800"></a>*复制表:</p><p><a id="kCru-1660729381079"></a>create table表名 like 被复制的表名;</p><p><a id="QJnX-1660729381081"></a>2. R(Retrieve):查询</p><p><a id="EiT0-1660729381083"></a>查询某个教据库中所有的表名称</p><p><a id="GHU7-1660729381085"></a>show tables;</p><p><a id="Ufnq-1660729381087"></a>查询表结构</p><p><a id="9RUH-1660729381089"></a>desc 表名;</p><p><a id="LoP3-1660729381091"></a>3. U(Update):修改</p><p><a id="JEo6-1660729381093"></a>3.1.修改表名</p><p><a id="3n1D-1660729381095"></a>alter table表名 rename to 新的表名;</p><p><a id="u939-1660729415088"></a>3.2．修改表的字符集</p><p><a id="KoPo-1660729381097"></a>alter table 表名 character set 字符集名称;</p><p><a id="rRYE-1660729423086"></a>3.3．添加一列</p><p><a id="RX9D-1660729381099"></a>alter tabie 表名 add 列名 数据类型;</p><p><a id="OIAw-1660729429474"></a>3.4、修改列名称类型</p><p><a id="lQpw-1660729381101"></a>alter table 表名 change 列名 新列名 新数据类型;</p><p><a id="V3Lu-1660729795265"></a>只改类型</p><p><a id="Jycm-1660729473612"></a>alter table 表名 modify 列名 新数据类型;</p><p><a id="vrIe-1660729381103"></a>3.5，删除列</p><p><a id="ZgY9-1660729381105"></a>alter tabie 表名 drop 列名;</p><p><a id="u1mO-1660795871414"></a> </p><p><a id="7wjq-1660737421636"></a>##DML:增制改表中数据</p><p><a id="VQDz-1660737422451"></a>1．添加数据∶</p><p><a id="He1F-1660737422453"></a>语法︰</p><p><a id="aec2-1660737422455"></a>insert into 表名(列名1,列名2,...列名n) values(值1,值2,. ..值n);</p><p><a id="jcSg-1660737430042"></a>*注意:</p><p><a id="uah3-1660737422457"></a>1.1.列名和值要一一对应。</p><p><a id="3cmS-1660737422459"></a>1.2.如果表名后，不定义列名，则默认给所有列添加值</p><p><a id="667s-1660737422461"></a>insert into 表名 values(值1,值2,...值n);</p><p><a id="B79t-1660737422463"></a>1.3．除了数字类型，其他类型需要使用引号(单双都可以)引起来</p><p><a id="f2i4-1660737422465"></a>2．删除数据:|</p><p><a id="ArZd-1660737422467"></a>语法∶[ ] 意思是可选可不选</p><p><a id="Xs2G-1660737422469"></a>delete from 表名 [where 条件];</p><p><a id="N9to-1660737492426"></a>*注意︰</p><p><a id="3qWR-1660737422471"></a>1.如果不加冬件，则删除表中所有记录。</p><p><a id="EMea-1660737507530"></a>2.如果要删除所有记录</p><p><a id="g5oz-1660737422473"></a>1.delete from 表名; --不推荐使用。有多少条记录就会执行多少次删除操作</p><p><a id="3ZBk-1660737523058"></a>2. TRUNCATE truncate table TABLE 表名; --推荐使用，效率更高先删除表，然后再创建一张一样的表。</p><p><a id="VEP3-1660737422475"></a>3．修改数据︰</p><p><a id="4WX5-1660738057215"></a>语法:</p><p><a id="7MmI-1660738057217"></a>update 表名 set 列名1 =值1，列名2=值2,... [where条件];</p><p><a id="LYqy-1660738057219"></a>*注意∶</p><p><a id="5Zdn-1660738057221"></a>1、如果不加任何条件，则会将表中所有记录全部修改。</p><p><a id="1B0n-1660795981748"></a></p><p><a id="keRH-1660795352849"></a>##DQL:查询表中的记录</p><p><a id="XNjC-1660795959645"></a>select *  from表名;</p><p><a id="4oDP-1660795959647"></a>1．语法︰</p><p><a id="N1G5-1660795959649"></a>select</p><p><a id="Jb8s-1660796003121"></a>字段列表</p><p><a id="lQZO-1660796000247"></a>from</p><p><a id="nY3m-1660795959653"></a>表名列表</p><p><a id="dbfh-1660796007848"></a>where</p><p><a id="uYDo-1660795959655"></a>条件列表</p><p><a id="Ngd2-1660796012019"></a>group by</p><p><a id="dsNL-1660795959657"></a>分组字段</p><p><a id="ktsk-1660796016102"></a>having</p><p><a id="6u9T-1660795959659"></a>分组之后的条件</p><p><a id="cDqU-1660796023952"></a>order by </p><p><a id="gmRY-1660795959661"></a>排序</p><p><a id="FSPC-1660796031650"></a>limit</p><p><a id="PSGU-1660795959663"></a>分页限定</p><p><a id="iBWc-1660795357017"></a>2．基础查询</p><p><a id="753A-1660795353303"></a>1，多个字段的查询</p><p><a id="nJjv-1660795353305"></a>select 字段名1，字段名2... from表名;</p><p><a id="sgFV-1660795483396"></a>*注意:</p><p><a id="jKCe-1660795353307"></a>如果查询所有字段，则可以使用来替代字段列表。</p><p><a id="o6vY-1660795353309"></a>2．去除重复:</p><p><a id="e1fl-1660795353311"></a>distinct</p><p><a id="A7od-1660795446572"></a>3，计算列</p><p><a id="Og5t-1660795353313"></a>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</p><p><a id="fkH6-1660795461071"></a> ifnull(表达式1,表达式2) : null参与的运算，计算结果都为null</p><p><a id="m44R-1660795353315"></a>*表达式1:哪个字段需要判断是否为null</p><p><a id="2gsg-1660795353317"></a>*表达式2:如果该字段为null后的替换值。</p><p><a id="eCXG-1660795353319"></a>4．起别名︰</p><p><a id="oJ2h-1660795353321"></a>as : as也可以省咯</p><p><a id="NkWb-1660800844356"></a>3．条件查询</p><p><a id="Hcd0-1660800844905"></a>3.1.where子句后跟条件</p><p><a id="KaKf-1660800860089"></a>3.2．运算符</p><blockquote><p>、&lt; 、 &lt;= 、 &gt;= 、= 、&lt;&gt;不等于</p></blockquote><p><a id="IjgV-1660801299964"></a>BETWEEN. ..AND</p><p><a id="Y7mU-1660801221384"></a>IN(集合)</p><p><a id="DDLV-1660801238061"></a>LIKE模糊查询</p><p><a id="4xKA-1660802066636"></a>占位符∶</p><p><a id="4npc-1660802066640"></a>_  单个任意字符</p><p><a id="MSxo-1660802087146"></a>%  多个任意字符</p><p><a id="BSCw-1660800844910"></a>IS NULL</p><p><a id="md5r-1660801324150"></a>and或&amp;&amp;且</p><p><a id="rFw6-1660801328725"></a>or 或 ||或</p><p><a id="1WX8-1660801332733"></a>not 或 ！ </p><p><a id="cKrO-1660815240510"></a>4.排序查询</p><p><a id="NNbE-1660815242164"></a>*语法: order by 子句</p><p><a id="rw2y-1660815242166"></a>order by 排序字段1 排序方式1 ，排序字段2 排序方式2.. .</p><p><a id="rq6y-1660815242168"></a>*排序方式:</p><p><a id="gJJF-1660815242170"></a>*ASC asc:升序，默认的。</p><p><a id="6YmL-1660815266421"></a>*DESC desc:降序。</p><p><a id="mFT3-1660815242172"></a>*注意︰</p><p><a id="MwKK-1660815242174"></a>*如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p><p><a id="ELc5-1660815656199"></a>2．聚合函数:将一列数据作为一个整体，进行纵向的计算。</p><p><a id="gXVh-1660815656510"></a>count :计算个数</p><p><a id="GimR-1660815656512"></a> 1.一般选择非空的列:主键</p><p><a id="4uZF-1660815681930"></a>2. count(*) as total 设置列名为total计算个数与</p><p><a id="iTM3-1660815656514"></a>max :计算最大值</p><p><a id="hLmU-1660815701248"></a>min :计算最小值</p><p><a id="cDc1-1660815709172"></a>sum :计算和</p><p><a id="ABS7-1660815656516"></a>avg :计算平均值</p><p><a id="U990-1660815656518"></a>*注意:聚合函数的计算，排除null值。</p><p><a id="FFmd-1660815656520"></a>解决方案:</p><p><a id="QbDV-1660815656522"></a>1．选择不包含非空的列进行计算</p><p><a id="YLzs-1660815727397"></a>2.IF NULL if null函数</p><p><a id="oOhp-1660820870778"></a>3，分组查询:</p><p><a id="ZxEr-1660820871091"></a>1.语法:group by 分组字段;</p><p><a id="lK1x-1660822040115"></a>2．注意:</p><p><a id="G1wS-1660820871093"></a>1.分组之后查询的字段:分组字段、聚合函数</p><p><a id="qgIY-1660822090773"></a>2. where和having 的区别?</p><p><a id="Ixzm-1660820871095"></a>1.where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</p><p><a id="wpdN-1660822117649"></a>2. where后不可以跟聚合函数，having可以进行聚合函数的判断。</p><p><a id="FeZJ-1660822139648"></a>4、分页查询</p><p><a id="bs3O-1660822139882"></a>1．语法:limit开始的索引,每页查询的条数;</p><p><a id="rMrZ-1660822139884"></a>2．公式:开始的索引=(当前的页码-1)*每页显示的条数</p><p><a id="ntI2-1660822139886"></a>--每页显示3条记录</p><p><a id="ADLw-1660822139888"></a>SELECT *FROM student LIMIT 0,3;--第1页</p><p><a id="mWM2-1660822139890"></a>SELECT * FROM student LIMIT 3,3; --第2页</p><p><a id="KO9v-1660822139892"></a>SELECT * FROM student LIMIT 6,3; --第3页</p><p><a id="CT4w-1660822139894"></a>3. limit是一个MySQL”方言”</p><p><a id="LxXV-1660822139896"></a>##约束</p><p><a id="hJIH-1660827707842"></a>*概念:对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p><p><a id="d9L3-1660827719279"></a>本分类:</p><p><a id="tQto-1660827707844"></a>1．主键约束:primary key</p><p><a id="1eRr-1660827721430"></a>2．非空约束:not null</p><p><a id="pN9k-1660827722917"></a>3．唯一约束: unique</p><p><a id="wZlq-1660827707846"></a>4．外键约束:foreign key</p><p><a id="kgaS-1660827707848"></a>*非空约束:not null某一列的值不能为null</p><p><a id="3XxG-1660827707850"></a>1.创建表时添加约束</p><p><a id="rNo5-1660827707852"></a>CREATE TABLE stu(</p><p><a id="Dx9G-1660827707854"></a>id INT,</p><p><a id="0vJC-1660827707856"></a>NAME VARCHAR( 20) NOT NULL -- name为非空</p><p><a id="VOdK-1666184846598"></a>name varchar(20) not null</p><p><a id="EWmr-1660827707858"></a>);</p><p><a id="AnCy-1660827707860"></a>2．创建表完后，添加非空约束</p><p><a id="o3AT-1660827707862"></a>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</p><p><a id="Yqhr-1666184871002"></a>alter table stu modify name varchar(20) not null</p><p><a id="aW1k-1666184899859"></a>3.删除name的非空约束</p><p><a id="HVAh-1660827707866"></a>ALTER TABLE stu MODIFY NAME VARCHAR( 20);</p><p><a id="8A5d-1660829396001"></a>*唯一约束:unique，某一列的值不能重复</p><p><a id="xYDh-1660829396215"></a>1．注意:</p><p><a id="SuT3-1660829396217"></a>唯一约束可以有NULL值，但是只能有一条记录为null</p><p><a id="iKKp-1660829404194"></a>2．在创建表时，添加唯一约束</p><p><a id="FWf2-1660829396219"></a>CREATE TABLE stu(</p><p><a id="D5Ym-1660829396221"></a>id INT,</p><p><a id="8y3F-1660829396223"></a>phone_number VARCHAR(20) UNIQUE --手机号</p><p><a id="oq1E-1660829413206"></a>);</p><p><a id="mig4-1660829396225"></a>3.删除唯一约束</p><p><a id="y881-1660829396227"></a>ALTER TABLE stu DROP INDEX phone_number;</p><p><a id="NR52-1660829452306"></a>4．在表创建完后，添加唯一约束</p><p><a id="a63W-1660829396229"></a>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</p><p><a id="NFwB-1660829878284"></a>主键约束: primary key。</p><p><a id="1t4l-1660829879884"></a>1。注意∶</p><p><a id="GekM-1660829879886"></a>1.含义:非空且唯一</p><p><a id="eiM9-1660829879888"></a>2.一张表只能有一个字段为主键</p><p><a id="KAMM-1660829898915"></a>3，主键就是表中记录的唯一标识</p><p><a id="J5D1-1660829900378"></a>2．在创建表时，添加主键约束</p><p><a id="1ytT-1660829879890"></a>create table stu(</p><p><a id="JvEH-1660829879892"></a>id int primary key ,--给id添加主键约束</p><p><a id="QkrR-1660829912246"></a>name varchar(20)</p><p><a id="gEnY-1660829879894"></a>);</p><p><a id="D5yG-1660829879896"></a>3．删除主键</p><p><a id="aDbb-1660829879899"></a>错误alter table stu modify id int ;</p><p><a id="aSjd-1660829919385"></a>ALTER  TABLE stu DROP PRIMARY KEY;   drop primary</p><p><a id="InyB-1660829879901"></a>4．创建完表后,添加主键</p><p><a id="ZE1q-1660829879903"></a>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p><p><a id="zrJq-1660836945789"></a>5，自动增长:</p><p><a id="FqvF-1660836947118"></a>1.概念∶如桌某一列是数值类型的，使用auto_increment可以来完成值得自动增长</p><p><a id="UO6s-1660836956384"></a>2．在创建表时，添加主键约束，并且完成主键自增长</p><p><a id="WZtL-1660836947120"></a>create table stu(</p><p><a id="lXBq-1660836947122"></a>id int primary key auto_increment,--给id添加主键约束</p><p><a id="ayZD-1660836963396"></a>name varchar(20)</p><p><a id="q6CX-1660836947124"></a>);</p><p><a id="lOn4-1660836947126"></a>3．删除自动增长</p><p><a id="Hghn-1660836947128"></a>ALTER TABLE stu MODIFY id INT;</p><p><a id="LvbV-1660836973942"></a>4．添加自动增长</p><p><a id="3ehq-1660836947130"></a>ALTER TABLE stu MODIFY id INT AUTO_INCRENENT;</p><p><a id="QNHs-1660840593100"></a>*外键约束:foreign key,让表于表产生关系，从而保证数据的准确性。</p><p><a id="mOCw-1660840593343"></a>1．在创建表时，可以添加外键</p><p><a id="pZI8-1660840593345"></a>*语法∶</p><p><a id="Z1rq-1660840593347"></a>create table表名(</p><p><a id="KKfQ-1660840593349"></a>.....</p><p><a id="f4pe-1660840626725"></a>外键列,</p><p><a id="kaVe-1660840593351"></a>constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)</p><p><a id="29I3-1660840593353"></a>);</p><p><a id="mhrx-1660840593355"></a>2．删除外键</p><p><a id="B8os-1660840593357"></a>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; foreign key</p><p><a id="4NyH-1660840593359"></a>3，创建表之后，添加外键</p><p><a id="QKjz-1660840593361"></a>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称 (主表列名称);</p><p><a id="zRqM-1666185318513"></a>alter table 表名 ADD constraint 外键名称 foreign key references主表名称 (主表列名称);</p><p><a id="qE9f-1660840968522"></a>4，级联操作</p><p><a id="OqKr-1660840969324"></a>1。添加级联操作</p><p><a id="Iinu-1660840969326"></a>语法:ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p><p><a id="44Ky-1660840969328"></a>FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</p><p><a id="xElm-1666185699907"></a>foreign key  (外键字段名称) references 主表名称 (主表列名称) on update cascade on delete cascade</p><p><a id="r7q2-1660840969330"></a>2．分类:</p><p><a id="GdAa-1660840969332"></a>1．级联更新:ON UPDATE CASCADE</p><p><a id="C0JE-1660841273367"></a>2．级联删除:ON DELETE CASCADE </p><p><a id="DBow-1660841276927"></a>##数据库的设计</p><p><a id="5KVA-1660841277671"></a>1。多表之间的关系</p><p><a id="XqMX-1660841277673"></a>1.分类:</p><p><a id="DqhZ-1660841277675"></a>1.一对一(了解)∶</p><p><a id="7oCb-1660841277678"></a>*如∶人和身份证</p><p><a id="i5x9-1660841277680"></a>*分析:—个人只有一个身份证，一个身份证只能对应一个人</p><p><a id="QWYO-1660841297473"></a>2.一对多(多对一）:</p><p><a id="Kkgc-1660841277682"></a>*如∶部门和员工</p><p><a id="5N1D-1660841277684"></a>*分析:—个部门有多个员工，一个员工只能对应一个部门</p><p><a id="9hbZ-1660841300498"></a>3．多对多∶</p><p><a id="P6LD-1660841277686"></a>*如:学生和课程</p><p><a id="OgsW-1660841277688"></a>*分析:—个学生可以选择很多门课程，一个课程也可以被很多学生选择</p><p><a id="ltwz-1660841277690"></a>2．实现关系∶</p><p><a id="MuqW-1660841277692"></a>1。一对多(多对一) :</p><p><a id="BDph-1660841277694"></a>*如∶部门和员工</p><p><a id="wEem-1660841277696"></a>*实现方式:在多的一方建立外键，指向一的一方的主键。</p><p><a id="b0Ap-1660841710899"></a>2，多对多∶</p><p><a id="24z6-1660841711515"></a>*如:学生和课程</p><p><a id="7eht-1660841711517"></a>实现方式∶多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</p><p><a id="QTph-1660841720586"></a>3.一对一(了解)∶</p><p><a id="Dcu7-1660841711519"></a>*如:人和身份证</p><p><a id="1EDr-1660841711521"></a>*实现方式:一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</p><p><a id="CP2k-1660883869625"></a>2．数据库设计的范式</p><p><a id="NqDs-1660883871303"></a>*概念∶设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p><a id="fxgj-1660883871305"></a>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p><p><a id="F0It-1660883871307"></a>目前关系数据库有六种范式∶第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。</p><p><a id="mZ6u-1660884145350"></a>*分类:</p><p><a id="PJP8-1660884146127"></a>1，第一范式(1NF):每一列都是不可分割的原子数据项</p><p><a id="H5fA-1660884146129"></a>2．第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖)</p><p><a id="IYCZ-1660884146131"></a>*几个概念:</p><p><a id="SrIX-1660884146133"></a>1，函数依赖∶A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</p><p><a id="09qw-1660884146135"></a>例如:学号--&gt;姓名。(学号，课程名称)--&gt;分数</p><p><a id="gmRn-1660884146137"></a>2．完全函数依赖∶A--&gt;B，如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。例如:(学号，课程名称)--&gt;分数</p><p><a id="BbmE-1660884146139"></a>3，部分函数依赖∶A--&gt;B，如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。例如:(学号，课程名称)--&gt;姓名</p><p><a id="41zU-1660884146141"></a>4，传递函数依赖∶A--&gt;8,B -- &gt;c，如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组)的值可以确定唯一C属性的值，则称C传递函数依赖于A</p><p><a id="yqUl-1660884146143"></a>例如:学号--&gt;系名，系名--&gt;系主任</p><p><a id="oLiX-1660884146145"></a>5，码;如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</p><p><a id="OSpk-1660884146147"></a>例如:该表中码为︰(学号，课程名称)可以确定唯一的其他属性</p><p><a id="l5Tm-1660884146149"></a>*主属性:码属性组中的所有属性</p><p><a id="HiEX-1660884146151"></a>*非主属性:除过码属性组的属性</p><p><a id="6YZC-1660884146153"></a>3．第三范式(3NF)︰在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖)</p><p><a id="R1ej-1660884913926"></a>##数据库的备份和还原</p><p><a id="c4Q7-1660884915319"></a>1，命令行:</p><p><a id="xENx-1660884915321"></a>*语法∶</p><p><a id="MZKy-1660884915323"></a>备份: mysqldump  -u用户名 -p密码 数据库的名称 &gt; 保存的路径</p><p><a id="pBXM-1660885076535"></a>还原:</p><p><a id="gbwY-1660884915325"></a>1．登录数据库</p><p><a id="ZSJS-1660885078124"></a>2．创建数据库</p><p><a id="iyon-1660885079576"></a>3．使用数据库</p><p><a id="yd43-1660884915327"></a>4。执行文件。source 文件路径</p><p><a id="afBP-1660884915329"></a>2．图形化工具︰</p><p><a id="ZFXj-1660967799572"></a>##多表查询∶</p><p><a id="OEmy-1660967804735"></a>查询语法∶</p><p><a id="7ZTZ-1660967804737"></a>select</p><p><a id="ubcH-1660967804739"></a>列名列表</p><p><a id="OIOh-1660967834880"></a>from</p><p><a id="FSBJ-1660967804741"></a>表名列表</p><p><a id="t6iq-1660967839053"></a>where.. .. 条件</p><p><a id="LHFq-1660967847695"></a>笛卡尔积∶</p><p><a id="j7Fv-1660967880726"></a>*有两个集合A,B .取这两个集合的所有组成情况。</p><p><a id="63LS-1660967904416"></a>*要完成多表查询，需要消除无用的数据</p><p><a id="9dt0-1660967880729"></a>*多表查询的分类:</p><p><a id="2RL8-1660967880731"></a>1.内连接查询:</p><p><a id="eE5B-1660967912330"></a>1.隐式内连接:使用where条件消除无用数据</p><p><a id="D2PB-1660975329868"></a>SELECT * FROM emp,dept WHERE emp. “ dept_id= dept. id ;</p><p><a id="3rbd-1660975351679"></a>2．显式内连接:</p><p><a id="Vamv-1660975351895"></a>语法: select 字段列表 from 表名1  [inner]  join 表名2  on 条件</p><p><a id="U9rK-1660975377692"></a>例如︰</p><p><a id="4AxT-1660975351897"></a>SELECT * FROM emp INNER JOIN dept ON emp. dept_id = dept. id ;</p><p><a id="J136-1660975388106"></a>SELECT * FROM emp JOIN dept ON emp. “ dept_id’= dept.‘ id’;</p><p><a id="2T5f-1660975481780"></a>3．内连接查询∶</p><p><a id="PN4r-1660975482606"></a>1.从哪些表中查询数据</p><p><a id="vEFl-1660975499899"></a>2.条件是什么</p><p><a id="WtKW-1660975482608"></a>3.查询哪些字段</p><p><a id="t243-1660975292052"></a>2.外链接查询:</p><p><a id="0luq-1660982908787"></a>1．左外连接:</p><p><a id="uhx2-1660982908789"></a>*语法: select 字段列表 from 表1 left [outer] join 表2 on 条件;</p><p><a id="aIoi-1660982942826"></a>*查询的是左表所有数据以及其交集部分。</p><p><a id="di4V-1660982908791"></a>2．右外连接:</p><p><a id="KlKK-1660982908793"></a>语法: select 字段列表 from表1 right [outer] join 表2 on 条件;</p><p><a id="anpH-1660982941179"></a>*查询的是右表所有数据以及其交集部分。</p><p><a id="wgNc-1660967913995"></a>3.子查询:</p><p><a id="YZoo-1660983150042"></a>概念∶查询中嵌套查询，称嵌套查询为子查询。</p><p><a id="M5qC-1660983150044"></a>--查询工资最高的员工信息</p><p><a id="ShSB-1660983150046"></a>-- 1查询最高的工资是多少 9000</p><p><a id="1aEn-1660983170209"></a>SELECT MAX( salary)  FROM emp;</p><p><a id="33J9-1660983150048"></a>--2查询员工信息，并且工资等于9008的</p><p><a id="VUom-1660983150050"></a>SELECT * FROM emp WHERE emp.“salary”= 9000;</p><p><a id="Z7un-1660983150052"></a>--一条sql就完成这个操作。子查询</p><p><a id="zeqH-1660983150054"></a>SELECT * FROM emp WHERE emp.‘salary’ = (SELECT MAX( salary) FROM emp);</p><p><a id="2IDD-1660993693374"></a>*子查询不同情况</p><p><a id="TKWI-1660993693753"></a>1，子查询的结果是单行单列的∶</p><p><a id="rdja-1660993693755"></a>子查询可以作为条件，使用运算符去判断。运算符∶ &gt; &gt;= &lt; &lt;= =</p><p><a id="i7ev-1660993693757"></a>--查询员工工资小于平均工资的人</p><p><a id="UqoJ-1660993693759"></a>SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</p><p><a id="bIB3-1660993718029"></a>2．子查询的结果是多行单列的∶</p><p><a id="LHZO-1661011080419"></a>子查询可以作为条件，使用运算符in来判断</p><p><a id="94HD-1660993722094"></a>--查询”财务部和’市场部”所有的员工信息</p><p><a id="BoVR-1660993724616"></a>SELECT id FROM dept WHERE NAME =‘财务部’OR NAME = ‘巿场部”;</p><p><a id="N6dZ-1660993728357"></a>SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</p><p><a id="V4pL-1660993739394"></a>--子查询</p><p><a id="3zZh-1661010318055"></a>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept MHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</p><p><a id="Zm5C-1660993693761"></a>3，子查询的结果是多行多列的:</p><p><a id="3v8A-1660993693763"></a>*子查询可以作为—张虚拟表参与查询</p><p><a id="U7q0-1660993693765"></a>--查询员工入职日期是?2011-11-11日之后的员工信息和部门信息</p><p><a id="WaHa-1660993868899"></a>--子查询</p><p><a id="U46D-1660993693767"></a>SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp. join_date &gt; ‘2011-11-11’) t2 WHERE t1.id = t2.dept_id;</p><p><a id="fb8D-1660993896232"></a>--普通内连接</p><p><a id="rJnz-1660993899412"></a>SELECT FROM emp t1,dept t2 WHERE t1.‘ dept_id’ = t2. id’ AND t1.“ join_date’&gt; ‘2011-11-11’</p><p><a id="UiDi-1661047684868"></a>##事务</p><p><a id="rpDA-1661047694405"></a>1，事务的基本介绍</p><p><a id="PTZq-1661047694407"></a>1.概念∶</p><p><a id="bH9Z-1661047694409"></a>*如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p><p><a id="mozo-1661047706856"></a>2．操作:</p><p><a id="dq5L-1661047694411"></a>1.开启事务:start transaction;</p><p><a id="xDC6-1661047712446"></a>2.回滚:rollback;</p><p><a id="Rdsi-1661047694413"></a>3.提交:commit;</p><p><a id="FmqX-1661048634267"></a>MysQL数据库中事务默认自动提交</p><p><a id="ytIJ-1661048636429"></a>*事务提交的两种方式:</p><p><a id="vCfc-1661048636431"></a>自动提交∶</p><p><a id="AF0a-1661048636433"></a>*mysql就是自动提交的</p><p><a id="3vFR-1661048636435"></a>*一条DML(增删改语句会自动提交一次事务。</p><p><a id="jl09-1661048673111"></a>手动提交:</p><p><a id="rXCe-1661048679340"></a>oracle数据库默认是手动提交事务需要先开后事务，再提交</p><p><a id="pBXh-1661048636437"></a>*修改事务的默认提交方式∶</p><p><a id="jTaU-1661048636439"></a>查看事务的默认提交方式:SELECT @autocommit; -- 1代表自动提交0代表手动提交</p><p><a id="Pu2W-1661048691588"></a>修改默认提交方式:set @@autocommit = 0;</p><p><a id="cLKR-1661048778875"></a>2．事务的四大特征:</p><p><a id="vnpm-1661048779173"></a>1．原子性:是不可分割的最小操作单位，要么同时成功，要么同时失败。</p><p><a id="7hm5-1661048786231"></a>2，持久性:当事务提交或回液后，数据库会持久化的保存数据。</p><p><a id="RawT-1661048779175"></a>3，隔离性:多个事务之间。相互独立。</p><p><a id="5dGr-1661048779177"></a>4，一致性:事务操作前后，数据总量不变</p><p><a id="34Dn-1661047694417"></a>3.事务的隔离级别(了解)</p><p><a id="oGRr-1661051426007"></a>*概念∶多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题.</p><p><a id="xhUJ-1661051447934"></a>*存在问题:</p><p><a id="Dkdm-1661051426009"></a>1．脏读:一个事务，读取到另一个事务中没有提交的数据</p><p><a id="q2YZ-1661051426011"></a>2．不可重复读(虚读):在同一个事务中，两次读取到的数据不一样。</p><p><a id="GBBK-1661051426013"></a>3．幻读:一个事务操作(DNL)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p><p><a id="iPgL-1661051454784"></a>*隔离级别∶</p><p><a id="2g18-1661051426015"></a>1.read uncommitted : 读未提交</p><p><a id="m5dA-1661051426017"></a>产生的问题:脏读、不可重复读．幻读</p><p><a id="LH2t-1661051463502"></a>2. read committed :读已提交(oracle)</p><p><a id="3vhW-1661051466552"></a>产生的问题:不可重复读、幻读</p><p><a id="VPpC-1661051426019"></a>3. repeatable read:可重复读(rysQL默认)</p><p><a id="RTZn-1661051478504"></a>产生的问题:幻读</p><p><a id="AFqd-1661051480402"></a>4. serializable :串行化</p><p><a id="lULa-1661051482810"></a>可以解决所有的问题</p><p><a id="rlQZ-1661051426021"></a>注意:隔离级别从小到大安全性越来越高，但是效率越来越低</p><p><a id="uqfX-1661051500021"></a>数据库查询隔离级别:</p><p><a id="xZZp-1661051426023"></a>select @atx_isolation;</p><p><a id="rcvM-1661051532860"></a>sellect @@transaction_isolation;</p><p><a id="jnAh-1661051497353"></a>*数据库设置隔离级别:</p><p><a id="xbk3-1661051426025"></a>set global transaction isolation level 级别字符串;</p><p><a id="9IhT-1661062707806"></a>#DCL :</p><p><a id="CjNa-1661062708682"></a>*SQL分类:</p><p><a id="mVP6-1661062708684"></a>1.DDL:操作数据库和表</p><p><a id="gxTS-1661062751455"></a>2. DML:增删改表中数据</p><p><a id="qtjT-1661062752641"></a>3. DQL:查询表中数据</p><p><a id="scWM-1661062753802"></a>4. DCL:管理用户，授权</p><p><a id="eVu3-1661062708686"></a>DBA:数据库管理员</p><p><a id="OB0M-1661062708688"></a>DCL:管理用户，授权</p><p><a id="Thyr-1661062708690"></a>1．管理用户</p><p><a id="lKdQ-1661062708692"></a>1．添加用户:</p><p><a id="j3a1-1661062708694"></a>*语法:CREATE USER ‘用户名”@’主机名’  IDENTIFIED identified BY ‘密码’;</p><p><a id="Qnhk-1661062814165"></a>2．删除用户:</p><p><a id="eVwt-1661062708696"></a>*语法- DROP USER ‘用户名’@”主机名’;</p><p><a id="NqCr-1661062832041"></a>3．修改用户密码:</p><p><a id="SrOd-1661062907012"></a>UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’;</p><p><a id="kxyr-1661062937220"></a>UPDATE USER SET PASSWORD = PASSWORD( ‘ abc ‘ ) WHERE USER = ‘lisi’;</p><p><a id="rhpy-1661062907014"></a>SET PASSWORD FOR “用户名’@”主机名’= PASSWORD(“新密码”);</p><p><a id="N5YS-1661062907016"></a>SET PASSwORD FOR “root’@’ localhost’ = PASSWORD( “123”);</p><p><a id="grSa-1661062907018"></a>mysq1中忘记了root用户的密码?</p><p><a id="qCzy-1661062907020"></a>1.cmd -- &gt;net stop mysql停止mysql服务</p><p><a id="wsvM-1661062907022"></a>本需要管理员运行该cmd</p><p><a id="oyiV-1661062907026"></a>2．使用无验证方式启动mysql服务: mysqld --skip-grant-tables</p><p><a id="a4Oz-1661062973330"></a>3．打开新的cmd窗口,直接输入mysql命今，敲回车。就可以登录成功</p><p><a id="8ZOq-1661062975468"></a>4. use mysql ;</p><p><a id="HJ8v-1661062907028"></a>5. update user set password = password(‘你的新密码’) where user = ‘root ‘;</p><p><a id="jQlt-1661062979603"></a>6．关闭两个窗口</p><p><a id="T9H7-1661062907030"></a>7.打开任务管理器，手动结束mysqld.exe的进程</p><p><a id="5Vv5-1661062989168"></a>8。启动mysql服务</p><p><a id="GYFz-1661062907032"></a>9。使用新密码登录。</p><p><a id="J7bM-1661062708698"></a>4．查询用户:</p><p><a id="Hko9-1661062708700"></a>-- 1．切换到mysql数据库</p><p><a id="qBzf-1661062841961"></a>USE myql;</p><p><a id="q7hk-1661062708702"></a>-- 2.查询user表</p><p><a id="8eND-1661062845590"></a>SELECT * FROM USER;</p><p><a id="nD7e-1661047685943"></a>*通配符:%表示可以在任意主机使用用户登录数据库</p><p><a id="jN45-1661063100302"></a>2．权限管理:</p><p><a id="9vCp-1661063100554"></a>1．查询权限:</p><p><a id="Nl43-1661063100556"></a>--查询权限</p><p><a id="b09k-1661063100558"></a>SHOW GRANTS grants FOR “用户名’@”主机名”;</p><p><a id="C4Wi-1661063134499"></a>SHOW GRANTS FOR “lisi’@’ %”;</p><p><a id="sy87-1661063100560"></a>2．授予权限:</p><p><a id="zgHi-1661063100562"></a>--授予权限</p><p><a id="1JIH-1661063100564"></a>grant 权限列表 on 数据库名.表名 to ‘用户名”@’主机名”;</p><p><a id="peBc-1661063151074"></a>--给张三用户授予所有权限，在任意数据库任意表上</p><p><a id="fN0H-1661063100566"></a>GRANT ALL ON *.* TO “ zhangsan’@” localhost “ ;</p><p><a id="iz8b-1661063167075"></a>所以权限列表all所以数据库名和表名都是*</p><p><a id="RKFT-1661063153847"></a>3．撤销权限:</p><p><a id="jivW-1661063100568"></a>--撤销权限:</p><p><a id="9IZv-1661063100570"></a>revoke 权限列表 on 数据库名.表名 from `用户名’@”主机名’;</p><p><a id="7bPx-1661063303018"></a>REVOKE UPDATE ON db3.“ account“   FROM ‘lisi’@”%’;</p><p><a id="wwUX-1661179514062"></a>##JDBC :</p><p><a id="csR1-1661179514789"></a>1．概念:Java DataBase Connectivity Java 数据库连接，Java语言操作数据库</p><p><a id="2lL9-1661179514791"></a>JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我门可以使用这套接口(JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><p><a id="Bkb8-1661179514793"></a>2．快速入门:</p><p><a id="B3Ev-1661179514795"></a>*步骤:</p><p><a id="xhdr-1661179514797"></a>1，导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p><p><a id="pozF-1661179514799"></a>1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</p><p><a id="JV4E-1661179593584"></a>2.右键--&gt;add as Library</p><p><a id="nDpP-1661179514801"></a>2．注册驱动</p><p><a id="sdyL-1661179514803"></a>3。获取数据库连接对象connection</p><p><a id="WPMn-1661179614288"></a>4．定义sql</p><p><a id="6TYW-1661179514805"></a>5，获取执行sql语句的对象 statement</p><p><a id="qoN9-1661179620215"></a>6．执行sql，接受返回结果</p><p><a id="ojne-1661179514807"></a>7．处理结果</p><p><a id="WMye-1661179514809"></a>8.释放资源</p><p><a id="sAOz-1661179189509"></a>3．详解各个对象︰</p><p><a id="9m8b-1661179190175"></a>1.DhiverManager :驱动管理对象</p><p><a id="0mcG-1661179190177"></a>*功能∶</p><p><a id="gjux-1661179190179"></a>1。注册驱动:告诉程序该使用哪一个数据库驱动jar</p><p><a id="MQCF-1661179190181"></a>static void registerDriver(Driver driver) :注册与给定的驱动程序DerverManger</p><p><a id="mtQS-1661179267174"></a>写代码使用:class.forName( “ com.mysql .jdbc.Driver”);</p><p><a id="OaTj-1661179190183"></a>通过查看源码发现:在com.mysqi.jdbc.Driver类中存在静态代码块 自动执行</p><p><a id="RUxz-1661179399720"></a>static {</p><p><a id="Kk9v-1661179190185"></a>try {</p><p><a id="JvEE-1661179190187"></a>java.sql. DriverMianager.registerDriver(new Driver());</p><p><a id="ez2y-1661179409142"></a>} catch (SQLException E) {</p><p><a id="WtjR-1661179190189"></a>throw new RuntimeException(“can’t register driver!“);</p><p><a id="AUI1-1661179433259"></a>}</p><p><a id="YFz3-1661179437197"></a>}</p><p><a id="Tg2P-1661179190192"></a>注意: mysql5之后的驱动jar包可以省略注册驱动的步骤。</p><p><a id="2Npy-1661179869414"></a>2．获取数据库连接:</p><p><a id="ynD6-1661179869646"></a>*方法:static connection getConnection(string url，string user，string password)*参数︰</p><p><a id="6NaN-1661179869648"></a>ur1:指定连接的路径</p><p><a id="D7dA-1661179869650"></a>语法:jdbc : mysql://ip地址(域名):端口号/数据库名称</p><p><a id="2J4k-1661179913043"></a>例子:jdbc : mysql:// localhost: 3306/db3</p><p><a id="10eO-1661179869652"></a>细节∶如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则ur1可以简写为: jdbc:mysq1://数据库名称</p><p><a id="ICJ6-1661179936618"></a>user :用户名</p><p><a id="DGwf-1661179869654"></a>password :密码</p><p><a id="n0eI-1661063071030"></a>2.Connectibn :数据库连接对象</p><p><a id="wpbR-1661219964026"></a>1.功能∶</p><p><a id="Dlkm-1661219964028"></a>1.获取执行sql的对象</p><p><a id="sI5R-1661219964030"></a>statement createstatement(</p><p><a id="Xbol-1661219964032"></a>Preparedstatement preparestatement(string sql)</p><p><a id="NdhV-1661220009987"></a>2.管理事务︰开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开后事务</p><p><a id="JN71-1661220025227"></a>提交事务: commit( )</p><p><a id="KWSi-1661219964034"></a>回滚事务: rollback()</p><p><a id="0U1q-1661224546405"></a>3.Statement :执行sql的对象</p><p><a id="vnmD-1661224546640"></a>1。执行sql</p><p><a id="tc4D-1661224546642"></a>1.boolean execute(string sql) :可以执行任意的sql了解</p><p><a id="wu25-1661224546644"></a>2.int executeupdate(string sql)︰执行DML (insert、update、delete)语句、DDL(create,alter、drop)语句</p><p><a id="KkAi-1661224615211"></a>*返回值:影响的行数，可以通过这个影响的行数判断DNL语句是否执行成功 返回值&gt;o的则执行成功，反之，则失败。</p><p><a id="MR2k-1661224628849"></a>3. Resultset executeQuery(string sql):执行DQL (select)语句</p><p><a id="HJOO-1661226911452"></a>4.Resultset :结果集对象,封装查询结果</p><p><a id="9tfj-1661226912833"></a>boolean next():游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p><p><a id="0BTL-1661226912835"></a>getXxx(参数):获取数据[</p><p><a id="6NTp-1661226912837"></a>Xxx:代表数据类型―如: int getInt() , string getstring()</p><p><a id="6GgR-1661226964395"></a>参数:int : 代表列的编号,从1开始如: getstring(1)</p><p><a id="M2HL-1661226981060"></a>2. string :代表列名称。如:getDouble(“balance”)</p><p><a id="0rAn-1661228209993"></a>*注意:</p><p><a id="jJEb-1661228210208"></a>使用步骤:</p><p><a id="3zHF-1661228210210"></a>1。游标向下移动一行</p><p><a id="i1qZ-1661228220827"></a>2．判断是否有数据</p><p><a id="cD4Z-1661228219794"></a>3．获取数据</p><p><a id="TDbt-1661392496161"></a>5.PreparedStatement :执行sql的对象</p><p><a id="LVzc-1661411865478"></a>1，SQL注入问题∶在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><p><a id="EnBN-1661411865480"></a>1．输人用户随便，输入密码:a’ or ‘a’ = ‘a</p><p><a id="uZHN-1661411865482"></a>2. sql : select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</p><p><a id="KoM4-1661411865484"></a>2．解决sql注入问题;使用Preparedstatement对象来解决</p><p><a id="C9mk-1661411865486"></a>3。预编译的SQL:参数使用?作为占位符</p><p><a id="anpD-1661411865488"></a>4，步骤︰</p><p><a id="a1Sb-1661411865490"></a>1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar</p><p><a id="tq3h-1661411936040"></a>2.注册驱动</p><p><a id="5OwA-1661411865492"></a>3.获取数据库连接对象connection</p><p><a id="B3Am-1661411944425"></a>4.定义sql</p><p><a id="V7gB-1661411865494"></a>注意∶ sql的参数使用?作为占位符。</p><p><a id="mEkF-1661411957766"></a>如: select * from user where username = ? and password = ?;</p><p><a id="YwP0-1661411956366"></a>5．获取执行sql语句的对象Preparedstatement </p><p><a id="LeXp-1661411986954"></a>Connection.preparestatement(string sql)</p><p><a id="U1Od-1661411865496"></a>6．给?赋值</p><p><a id="XtOC-1661412040111"></a>方法. setXxx(参数1，参数2)Xxx类型</p><p><a id="WGHu-1661412040113"></a>参数1：?的位置编号  从1开始</p><p><a id="ZPZl-1661412098221"></a>参数2：?的值</p><p><a id="MvXS-1661412040115"></a>7．执行sql，接受返回结果，不需要传递sql语句</p><p><a id="Umim-1661412320991"></a>8．处理结果</p><p><a id="X2PW-1661412040117"></a>9．释放资源</p><p><a id="07Uf-1661412040121"></a>注意︰后期都会使用Preparedstatement来完成增删改查的所有操作</p><p><a id="ZBGR-1661412040123"></a>1。可以防止SQL注入</p><p><a id="qczX-1661412040125"></a>2．效率更高:</p><p><a id="BQMD-1661392547721"></a>##抽取JDBC工具类:JDBCUtils</p><p><a id="DlTE-1661392547723"></a>*目的:简化书写</p><p><a id="CnFT-1661392547725"></a>*分析:</p><p><a id="eVls-1661392547727"></a>1。注册驱动也抽取</p><p><a id="vQs3-1661392547731"></a>2．抽取一个方法获取连接对象</p><p><a id="Wxoc-1661392547733"></a>*需求:不想传递参数（麻烦)，还得保证工具类的通用性。</p><p><a id="43t0-1661392585119"></a>*解决:配置文件</p><p><a id="DuLM-1661392547735"></a>jdbc.properties</p><p><a id="EN35-1661392547737"></a>url=</p><p><a id="mp8e-1661392547739"></a>user=</p><p><a id="C8hX-1661392547741"></a>password=</p><p><a id="Pwuz-1661392547743"></a>3．抽取一个方法释放资源</p><p><a id="hJpP-1661416050990"></a>##JDBC控制事务:</p><p><a id="KGHB-1661416051415"></a>1，事务:一个包含多个步骠的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p><p><a id="vDN4-1661416063702"></a>2。操作:</p><p><a id="oIvy-1661416051417"></a>1。开启事务</p><p><a id="zSLb-1661416070659"></a>2。提交事务</p><p><a id="WuXw-1661416075094"></a>3．回滚事务</p><p><a id="y2Nm-1661416051419"></a>3．使用connection对象来管理事务</p><p><a id="DsCx-1661416051421"></a>*开启事务: setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</p><p><a id="pQJd-1661416051423"></a>在执行sql之前开启事务</p><p><a id="zO7f-1661416051425"></a>*提交事务: commit()</p><p><a id="KgUm-1661416051427"></a>当所有sql都执行完提交事务</p><p><a id="4hQz-1661416121314"></a>回滚事务:roillback()</p><p><a id="F0y1-1661416051429"></a>在catch中回滚事务</p><p><a id="qBzl-1661485603395"></a>##数据库连接池</p><p><a id="iR8H-1661485603658"></a>1．概念:其实就是一个容器(集合)，存放数据库连接的容器。</p><p><a id="2PCr-1661485603660"></a>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p><p><a id="vNmv-1661485603662"></a>2．好处:</p><p><a id="39m7-1661485603664"></a>1.节约资源</p><p><a id="H6c9-1661485603666"></a>2.用户访问高效</p><p><a id="CuMw-1661485603669"></a>3．实现︰</p><p><a id="6VlV-1661485603671"></a>1,标准接口:DataSource javax.sql包下的</p><p><a id="1kui-1661485603673"></a>1.方法︰</p><p><a id="OfdW-1661485603675"></a>*获取连接:getConnection()</p><p><a id="yyYq-1661485603677"></a>*归还连接:Connection.close()。如果连接对象connection是从连接池中获取的，那么调用connection.close()方法，则不会再关闭连接了。而是归还连接</p><p><a id="PYX3-1661485603679"></a>2.—般我们不去实现它，有数据库厂商来实现</p><p><a id="PwLm-1661485603681"></a>1.C3PO∶数据库连接池技术</p><p><a id="Ufyr-1661485603683"></a>2.Druid :数据库连接池实现技术，由阿里巴巴提供的</p><p><a id="CU7F-1661485603685"></a>4.C3Pe:数据库连接池技术</p><p><a id="d0GI-1661492229011"></a>*步骤∶</p><p><a id="Bxh7-1661492229013"></a>1．导入jar包（3个)c3p0-0.9.5.2.jar  mchange-commons-java-0.2.12.jar ,</p><p><a id="dKuf-1661492229015"></a>*不要忘记导入数据库驱动jar包</p><p><a id="Wj7h-1661492229017"></a>2．定义配置文件:</p><p><a id="bncX-1661492229019"></a>名称:c3po.properties或者c3pe-config.xml</p><p><a id="TSe0-1661492280517"></a>路径︰直接将文件放在src目录下即可。</p><p><a id="uxEj-1661492229021"></a>3．创建核心对象 数据库连接池对象ComboPooledDatasource</p><p><a id="jlpM-1661492284057"></a>4．获取连接: getConnection</p><p><a id="FuC6-1661498187549"></a>5.Druid :数据库连接池实现技术，由阿里巴巴提供的</p><p><a id="VvUp-1661498187769"></a>本步骤∶</p><p><a id="BsJL-1661498187771"></a>1.导入jar包druid-1.e.9.jar</p><p><a id="EQT3-1661498204883"></a>2．定义配置文件;</p><p><a id="eXX1-1661498187773"></a>是properties形式的</p><p><a id="pMGe-1661498187775"></a>可以叫任意名称，可以放在任意目录下</p><p><a id="fTcA-1661498219835"></a>3．加载配置文件。Properties</p><p><a id="ZXxP-1661498698757"></a> //获取src路径下的文件的方式---&gt;ClassLoader类加载器，加载字节码文件进内存，获取src文件下资源的路径 类名.class.getClassLoader();</p><p><a id="eLQO-1661498698759"></a>ClassLoader classLoader = JDBCUtils.class.getClassLoader();</p><p><a id="AU3U-1661498187777"></a>4．获取数据库连接池对象:通过工厂来来获取DruidDataSourceFactory</p><p><a id="b85g-1661498230720"></a>5．获取连接:getconnection</p><p><a id="LUT0-1661571612894"></a>##Spring JDBC</p><p><a id="C062-1661571613120"></a>spring框架对JDBC的简单封装。提供了一个DBCTemplate对象简化JDBC的开发步骤︰</p><p><a id="CulC-1661571613122"></a>1．导入jar包</p><p><a id="AIhj-1661571613124"></a>2．创建JdbcTemplate对象。依赖于数据源Datasource</p><p><a id="OW4s-1661571613127"></a>JdbcTemplate template = new JdbcTemplate(ds) ;</p><p><a id="F5N5-1661571613129"></a>3．调用JdbcTemplate的方法来完成CRUD的操作</p><p><a id="MKLg-1661571682793"></a>update():执行DML语句。增、删、改语句</p><p><a id="KBjT-1661616636374"></a>queryForMap() :查询结果将结果集封装为map集合，将列名作为key，将值作为value将这条记录封装为一个map集合</p><p><a id="Bo7m-1661616659747"></a>注意:这个方法查询的结果集长度只能是1</p><p><a id="mJLU-1661616636376"></a>queryForList():查询结果将结果集封装为list集合</p><p><a id="mOTd-1661616636378"></a>注意:将每一条记录封装为一个Map集合，再好Map集合装载到List集合中query():查询结果，将结果封装为JavaBean对象</p><p><a id="KTq2-1661616636380"></a>query的参数:RowMapper</p><p><a id="2ved-1661616636382"></a>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p><p><a id="TkVt-1661616698568"></a>*new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><p><a id="jnG1-1661616636384"></a>queryForObject :查询结果，将结果封装为对象</p><p><a id="DDqZ-1661616636386"></a>—般用于聚合函数的查询</p><p><a id="Ns2i-1666261221821"></a>web概念概述</p><p><a id="cm6f-1666261217318"></a>Javaweb :</p><p><a id="YwpV-1666261217320"></a>*使用ava语言开发基于互联网的项目</p><p><a id="Acqa-1666261217322"></a>*软件架构:</p><p><a id="h1L1-1666261217324"></a>1.C/S: client/server客户端/服务器端</p><p><a id="Cn44-1666261217326"></a>*在用户本地有一个客户端程序，在远程有一个服务器端程序如:Qo，迅雷...</p><p><a id="7Nou-1666261217328"></a><strong>优点:T.1．用户体验好</strong>缺点∶</p><p><a id="y3Pa-1666261217330"></a>1，开发、安装，部署，维护麻烦</p><p><a id="UA6U-1666261217332"></a>2. B/S: Browser/Server浏览器/服务器端</p><p><a id="iwtj-1666518569072"></a>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序*优点:</p><p><a id="EIbD-1666261217336"></a>1.开发、安装，部署，维护简单缺点︰</p><p><a id="uBxd-1666261217338"></a>1，如果应用过大，用户的体验可能会受到影响2．对硬件要求过高</p><p><a id="MKiQ-1666261088871"></a>B/S架构详解</p><p><a id="5gUr-1666261089247"></a>*资源分类:</p><p><a id="sRUS-1666261089249"></a>1。静态资源:</p><p><a id="tqyl-1666261089251"></a>本使用静态网页开发技术发布的资源。本特点:</p><p><a id="jf3y-1666261089253"></a>所有用户访问，得到的结果是—样的。</p><p><a id="p9DB-1666261089255"></a>本如:文本，图片，音频、视频,HTML ,css,javaScript</p><p><a id="aZtK-1666261089257"></a>如果用户请求的是静态资源，那么服务器会直接将静右资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</p><p><a id="uF8a-1666261089259"></a>2．动态资源:</p><p><a id="aUCI-1666261089261"></a>使用动态网页及时发布的资源。*特点:</p><p><a id="cB6A-1666261089264"></a>*所有用户访问，得到的结果可能不一样。如:jsp/servlet,php,asp...</p><p><a id="SYpG-1666261089266"></a>*如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</p><p><a id="eBgL-1666261089268"></a>*我们要学习动态资源，必须先学习静态资源!</p><p><a id="e8Xu-1666261089272"></a>*静态资源:</p><p><a id="RHyq-1666261134924"></a>*HTML:用于搭建基础网页，展示页面的内容</p><p><a id="M6hS-1666261134926"></a>CSS:用于美化页面，布局页面</p><p><a id="gfM9-1666261134928"></a>JavaScript :控制页面的元素，让页面有一些动态的效果</p><p><a id="QGCQ-1666261512060"></a>HTML</p><p><a id="fAbg-1666261512301"></a>1、概念︰是最基础的网页开发语言</p><p><a id="GnFX-1666261512303"></a>*Hyper Text Markup Language超文本标记语言</p><p><a id="fKiZ-1666261512305"></a>超文本:</p><p><a id="k8eZ-1666261512307"></a>*超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p><p><a id="FFdh-1666261534450"></a><strong>标记语言:</strong></p><p><a id="zHrR-1666261559336"></a><strong>由标签构成的语言。&lt;标签名称&gt;如html, xml</strong></p><p><a id="1gy9-1666261554370"></a>标记语言不是编程语言</p><p><a id="cOI5-1666262572139"></a>2．快速入门∶</p><p><a id="KD8k-1666262572374"></a>*语法∶</p><p><a id="hP81-1666262572376"></a>1.html文档后缀名.html或者.htm</p><p><a id="AI87-1666262582072"></a>2．标签分为</p><p><a id="lSgf-1666262572378"></a>1．围堵标签:有开始标签和结束标签。如<html> </html></p><p><a id="527w-1666262602905"></a>2。自闭和标签∶开始标签和结束标签在一起。如<br/>  换行标签</p><p><a id="xfhG-1666262572380"></a>3．标签可以嵌套:</p><p><a id="bPqz-1666262572382"></a>需要正确嵌套，不能你中有我，我中有你</p><p><a id="24hX-1666262620933"></a>错误∶<a><b>&lt;/ a&gt;</b></p><p><a id="IUX0-1666262572384"></a>正确:<a><b></b>&lt;/ a&gt;</p><p><a id="so2g-1666262572386"></a>4．在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p><p><a id="8SVh-1666262625748"></a>5. html的标签不区分大小写，但是建议使用小写。</p><p><a id="Zck5-1666263793529"></a>3．标签学习:</p><p><a id="zk43-1666263794541"></a>1．文件标签:构成html最基本的标签</p><p><a id="IBGL-1666263794543"></a>html : html文档的根标签</p><p><a id="KfkK-1666263794545"></a>head :头标签。用于指定html文档的一些属性。引入外部的资源*</p><p><a id="Bkq7-1666263809213"></a>title:标题标签。</p><p><a id="WiUK-1666263794547"></a>body :体标签</p><p><a id="kMNX-1666263794549"></a>*&lt; I DOCTYPE html&gt; : html5中定义该文档是html文档.</p><p><a id="KAIV-1666265663619"></a>2．文本标签:和文本有关的标签</p><p><a id="aPa5-1666265663863"></a>注释:<l\-\-注释内容\-\->*</p><p><a id="i2W1-1666265672438"></a><h1> to <h6> ∶标题标签</p><p><a id="lqXP-1666265663865"></a>h1~h6:字体大小逐渐递减</p><p><a id="mYkC-1666265678690"></a><p>:段落标签</p><p><a id="9lrh-1666265663867"></a><br>:换行标签</p><p><a id="cweZ-1666265663869"></a><hr>:展示一条水平线<br>属性∶<br>color :颜色 width :宽度 size :高度</p><p><a id="MGDZ-1666265810327"></a>align :对其方式center :居中  left :左对齐 right :右对齐</p><p><a id="YGAx-1666267447727"></a>width :</p><p><a id="SnmE-1666267448061"></a>1．数值: width=’20’,数值的单位，默认是px(像素)</p><p><a id="50zA-1666267448064"></a>2．数值%:占比相对于父元素的比例</p><p><a id="fU4l-1666266313686"></a><b>:字体加粗</p><p><a id="u5bR-1666266341199"></a><i> :字体斜体</p><p><a id="ewp4-1666266342637"></a><font> :字体标签</p><p><a id="5mKF-1666266357293"></a><center> :文本居中</p><p><a id="DO4b-1666266334140"></a>属性:color :颜色* size :大小* face :字体</p><p><a id="Csvb-1666266334144"></a>*属性定义∶color :</p><p><a id="aLIt-1666266334148"></a>1．英文单词: red ,green, blue</p><p><a id="D7Iq-1666266334150"></a>2. rgb(值1，值2,值3):值的范国:0~255如rgb(0,0,255)</p><p><a id="ouvC-1666266400019"></a>3．#值1值2值3:值的范国:00~FF之间。如:#FF00FF 16进制配比</p><p><a id="2T3R-1666271080059"></a>3，图片标签:</p><p><a id="IHpa-1666271080687"></a>img :展示图片</p><p><a id="3j68-1666271080691"></a>属性:</p><p><a id="sxg5-1666271080693"></a>src :指定图片的位置</p><p><a id="C1F6-1666350275759"></a>alt：加载不出来输出的 名字</p><p><a id="1o5u-1666266334152"></a> 相对路径</p><p><a id="4vWE-1666271105360"></a>        以.开头的路径</p><p><a id="Q12m-1666271105362"></a>        ./  代表当前目录</p><p><a id="pDGG-1666271105364"></a>        ../ 后退 上一级目录</p><p><a id="q3dH-1666271680333"></a>4.列表标签</p><p><a id="qE9v-1666271694559"></a>有序列表</p><p><a id="qMqs-1666271720950"></a>ol：列表<ol type="A" start="5"></p><p><a id="wAVi-1666271724280"></a>li：列表的项</p><p><a id="EBYh-1666271710165"></a>无序列表ul     li</p><p><a id="rM7a-1666273057832"></a>5．链接标签∶</p><p><a id="R01L-1666273059038"></a><a>:定义一个超链接</p><p><a id="xETu-1666273059040"></a>属性:<br>href :指定访问资源的URL(统一资源定位符)为空在本页面跳转javascript:void(0);阻止他的返回</p><p><a id="bUj8-1666273072543"></a>target :指定打开资源的方式</p><p><a id="HXWF-1666273059042"></a>_self:默认值，在当前页面打开</p><p><a id="bjFi-1666273080329"></a>_blank :在新建空白页面打开</p><p><a id="lciH-1666274294109"></a>6.div和span</p><p><a id="7z4Z-1666274249111"></a>div：每个div占满一整行，块级标签</p><p><a id="09FB-1666274257390"></a>span：文本信息在一行展示，行内标签 内联标签</p><p><a id="8Pta-1666346714870"></a>7.语义化标签：html5中为了提高程序的可读性，提供的一些标签</p><p><a id="S9VX-1666346784604"></a>1.<header> </header>:定义一个文档的头部分</p><p><a id="CcIW-1666346744815"></a>2.<footer> </footer>：定义一个文章的低部</p><p><a id="5k2z-1666346722104"></a>8.表格标签</p><p><a id="RFzf-1666347414961"></a>table :定义表格</p><p><a id="moB3-1666347414963"></a>width :宽度</p><p><a id="JMFH-1666347426424"></a>border :边框</p><p><a id="JyvI-1666347414965"></a>cellpadding :定义内容和单元格的距离</p><p><a id="OBmb-1666347414967"></a>cellspacing:定义单元格之间的距离。如果指定为0，则单元格的线会合为一条.</p><p><a id="BBjq-1666347451425"></a>bgcolor :背景色</p><p><a id="FgUX-1666347414969"></a>align :对齐方式</p><p><a id="D9Mh-1667821393533"></a>margin:指定外边距，auto水平居中</p><p><a id="HgqA-1666347464591"></a>tr :定义行</p><p><a id="izB9-1666348786037"></a>bgcolor :背景色</p><p><a id="eaNF-1666348792012"></a>align :对齐方式</p><p><a id="gfZO-1666347499964"></a>td :定义单元格</p><p><a id="A4cQ-1666348900478"></a>colspan：合并列</p><p><a id="FFsd-1666348912682"></a>rowspan：合并行</p><p><a id="ZaVG-1666347414971"></a>th :定义表头单元格</p><p><a id="xuIp-1666348487495"></a><caption> :表格标题</p><p><a id="tbGe-1666348487696"></a><thead> :表示表格的头部分</p><p><a id="2HLF-1666348491109"></a><tbody> :表示表格的体部分</p><p><a id="lm3A-1666348493140"></a><tfoot> :表示表格的脚部分</p><p><a id="mLVm-1666349823633"></a>HTML标签∶</p><p><a id="AZ5o-1666353972546"></a>表单标签表单︰</p><p><a id="rERv-1666353967062"></a>*概念︰用于采集用户输入的数据的。用于和服务器进行交互。</p><p><a id="hmhI-1666353967064"></a> form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><p><a id="rDjV-1666353967066"></a>属性:</p><p><a id="2hpX-1666353967068"></a>action :指定提交数据的URL</p><p><a id="mF3Z-1666353984413"></a>method:指定提交方式</p><p><a id="kzL0-1666353967070"></a>分类:—共7种，2种比较常用</p><p><a id="iSDc-1666353967072"></a>get :</p><p><a id="EcbU-1666353967074"></a>1，请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。</p><p><a id="307F-1666353999959"></a>2，请求参数大小是有限制的。</p><p><a id="5ZFP-1666353967076"></a>3，不太安全。</p><p><a id="TiLZ-1666353967078"></a>post :</p><p><a id="FHSK-1666353967080"></a>1．请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)</p><p><a id="60pv-1666354005632"></a>2．请求参数的大小没有限制。</p><p><a id="flDG-1666353967082"></a>3．较为安全。</p><p><a id="rOm1-1666353967084"></a>*表单项中的数据要想被提交︰必须指定其name属性</p><p><a id="XUEf-1666354989416"></a>*表单项标签︰</p><p><a id="wDD6-1666354989632"></a>input :可以通过type属性值，改变元素展示的样式</p><p><a id="AYZR-1666354989634"></a>type属性:</p><p><a id="BEk4-1666354989636"></a>*text:文本输入框，默认值</p><p><a id="TCaF-1666354989638"></a>*placeholder :指定输人框的提示信息，当输入框的内容发生变化，会自动清空提示信息</p><p><a id="fJWC-1666355078427"></a>password :密码输入框隐藏密码  变成圆点</p><p><a id="2Ijj-1666354989640"></a>radio:单选框</p><p><a id="hfS4-1666354989642"></a>注意︰</p><p><a id="zB69-1666354989644"></a>1，要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p><p><a id="NBmJ-1666355091851"></a>2，一般会给每一个单选框提供value属性，指定其被选中后提交的值</p><p><a id="y12k-1666354989646"></a>3. checked属性，可以指定默认值</p><p><a id="mlsV-1666354989648"></a>checkbox :复选框</p><p><a id="Ssw4-1666354989650"></a>注意︰</p><p><a id="4rAK-1666354989652"></a>1.一般会给每一个单选框提供value属性，指定其被选中后提交的值</p><p><a id="P5f9-1666355101079"></a>2. checked属性，可以指定默认值  默认被选中</p><p><a id="48oR-1666357704079"></a>file:文件选择框</p><p><a id="guxN-1666358672423"></a>hidden :隐藏域,用于提交一些信息，虽然看不到，但值会被提交</p><p><a id="A3Wi-1666358678699"></a>按钮:</p><p><a id="7B7Y-1666358672425"></a>submit:提交按钮。可以提交表单</p><p><a id="K0l2-1666358704125"></a>button:普通按钮</p><p><a id="sfr1-1666358672427"></a>image :图片提交按钮</p><p><a id="DVSu-1666358672429"></a>src属性指定图片的路径</p><p><a id="vuAE-1666354989654"></a>label :指定输入项的文字描进信息</p><p><a id="dh11-1666354989656"></a>*注意∶</p><p><a id="LCeV-1666354989658"></a>label的for属性一般会和input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p><p><a id="wxVi-1666354989660"></a>select:下拉列表</p><p><a id="bKfl-1666359204293"></a>*子元素: option，指定列表项</p><p><a id="oobS-1666359204295"></a>textarea :文本域</p><p><a id="qhEa-1666359204297"></a>cols :指定列数，每一行有多少个字符</p><p><a id="WADy-1666359231368"></a>rows :默认多少行。</p><p><a id="oyKv-1666512626710"></a>css:页面美化和布局控制</p><p><a id="cwlz-1666512626910"></a>1．概念: cascading style sheets 层叠样式表</p><p><a id="497g-1666512626912"></a>*层叠:多个样式可以作用在同一个html的元秦上，同时生效</p><p><a id="XENV-1666512626914"></a>2．好处∶</p><p><a id="U45e-1666512626916"></a>1．功能强大</p><p><a id="82tQ-1666512626918"></a>2．将内容展示和样式控制分离</p><p><a id="mAxw-1666512626921"></a>降低耦合度。解耦</p><p><a id="6l72-1666512626923"></a>让分工协作更容易提高开发效率</p><p><a id="fPtx-1666513908294"></a>3.css的使用:css与html结合方式</p><p><a id="na8L-1666513908506"></a>1。内联样式</p><p><a id="LUpR-1666513908508"></a>在标签内使用style属性指定css代码</p><p><a id="8ddV-1666513908510"></a>*如: <div style="color : red; ">hello css</div></p><p><a id="ji4V-1666513946055"></a>2．内部样式</p><p><a id="kmWw-1666513908512"></a>在head标签内，定义style标签，style标签的标签体内容就是css代码</p><p><a id="AHy4-1666513964709"></a>如∶</p><p><a id="4tw1-1666513908514"></a><style></p><p><a id="hS3k-1666513908516"></a>div{</p><p><a id="AOlv-1666513908518"></a>color: blue;</p><p><a id="zrnh-1666513908520"></a>}</p><p><a id="qjg9-1666513908522"></a>&lt;/ style&gt;</p><p><a id="jv13-1666513908524"></a><div>hello css</div></p><p><a id="VeVC-1666513908526"></a>3．外部样式</p><p><a id="h0Lp-1666513908528"></a>1．定义css资源文件。</p><p><a id="qKoJ-1666513908530"></a>2．在head标签内，定义link标签，引入外部的资源文件</p><p><a id="yqhj-1666513999261"></a>如：</p><p><a id="4Dt5-1666514006271"></a>a.css文件：</p><p><a id="JmZK-1666514012510"></a>div{</p><p><a id="E2ID-1666514021761"></a>color:green;</p><p><a id="3uq0-1666514023627"></a>}</p><p><a id="UA5z-1666514034116"></a><link rel="stylesheet" herf="css/a\.css"></p><p><a id="VCAs-1666514098015"></a><div>hello css</div></p><p><a id="c1hU-1666514114277"></a><div>hello css</div></p><p><a id="2XEe-1666514127696"></a>*注意:</p><p><a id="W669-1666514215412"></a>1,2,3种方式css作用范围越来越大</p><p><a id="a8uE-1666514227213"></a>1方式不常用，后期常用2,3</p><p><a id="LCHm-1666514215415"></a>3种格式可以写为:</p><p><a id="2MxE-1666514215417"></a><style></p><p><a id="hbNt-1666514215419"></a>@import “css/a.css”;</p><p><a id="e8I5-1666514234294"></a>&lt;/style&gt;</p><p><a id="UyhX-1666514813504"></a>4.css语法∶</p><p><a id="M12d-1666514814525"></a>格式:</p><p><a id="AXb0-1666514814527"></a>选择器{</p><p><a id="xbhQ-1666514814529"></a>属性名1:属性值1;</p><p><a id="Rye0-1666514837620"></a>属性名2:属性值2;</p><p><a id="qv1L-1666514840941"></a>....</p><p><a id="9s3Z-1666514814531"></a>}</p><p><a id="ruad-1666514851113"></a>选择器:筛选具有相似特征的元素</p><p><a id="z4Eu-1666514863194"></a>注意︰</p><p><a id="B53v-1666514814533"></a>每—对属性需要使用;隔开，最后一对属性可以不加;</p><p><a id="hub8-1666515623675"></a>5．选择器︰筛选具有相似特征的元秦</p><p><a id="hrim-1666515623947"></a>*分类︰</p><p><a id="vGqb-1666515623949"></a>1，基础选择器</p><p><a id="mzXk-1666515623951"></a>1.id选择器∶选择具体的id属性值的元素.建议在一个html页面中id值唯一</p><p><a id="Q9yh-1666515623953"></a>语法: #id属性值{}</p><p><a id="Q7k9-1666515623955"></a>2．元素选择器:选择具有相同标签名称的元素</p><p><a id="q8u4-1666515623957"></a>本语法︰标签名称{}</p><p><a id="Gh5X-1666515623959"></a>本注意:id选择器优先级高于元素选择器</p><p><a id="jBia-1666515623961"></a>3．类选择器:选择具有相同的class属性值的元素。</p><p><a id="p9eF-1666515623963"></a>语法:.class属性值{}</p><p><a id="roFV-1666515623965"></a>本注意:类选择器选择器优先级高于元素选择器</p><p><a id="BG9e-1666515719817"></a>2.扩展选择器</p><p><a id="XtJX-1666517432996"></a>1．选择所有元秦:</p><p><a id="ueZk-1666517432998"></a>语法︰*{}</p><p><a id="OLva-1666517444501"></a>2．并集选择器︰</p><p><a id="lv6t-1666517433000"></a>语法：*选择器1,选择器2{}</p><p><a id="qUhK-1666517433002"></a>3，子选择器∶筛选选择器1元素下的选择器2元素</p><p><a id="wktT-1666517433004"></a>语法;选择器1 选择器2{}</p><p><a id="cXmy-1666517433006"></a>4，父选择器∵:筛选选择器2的父元素选择器1</p><p><a id="GoEB-1666517433008"></a>语法:选择器1&gt;选择器2{}</p><p><a id="HaVj-1666517433010"></a>5属性选择器:选择元素名称，属性名-属性值的元素</p><p><a id="WR0u-1666517433012"></a>多语法:元素名称[属性名=”属性值”]{ }</p><p><a id="t4tW-1666517433014"></a>6．伪类选择器:选择一些元素具有的状态</p><p><a id="XJpD-1666517433016"></a>*语法:元素:状态{ }</p><p><a id="Fco4-1666517433018"></a>*如: <a></p><p><a id="MIQ5-1666517433020"></a>*状态︰</p><p><a id="6EKL-1666517433022"></a>link :初始化的状态</p><p><a id="yZnp-1666517433024"></a>visited :被访问过的状态</p><p><a id="Z1jz-1666517542724"></a>active : 正在访问状态</p><p><a id="pck2-1666517543871"></a>hover:鼠标悬浮状态</p><p><a id="vHqd-1666522574206"></a>6．属性</p><p><a id="XR4Q-1666522574476"></a>1．字体、文本</p><p><a id="52Ow-1666522574478"></a>font-size :字体大小</p><p><a id="l9rA-1666522586983"></a>color :文本颜色</p><p><a id="nKoR-1666522574481"></a>text-align :对其方式 </p><p><a id="i4eY-1666522594607"></a>line-height :行高</p><p><a id="dy6l-1666522598565"></a>2．背景</p><p><a id="f4nV-1666522574483"></a>background :</p><p><a id="iI7w-1666522603531"></a>3，边框</p><p><a id="ONMe-1666522654924"></a>border :设置边框，符合属性</p><p><a id="Vnha-1666522610739"></a>4．尺寸<br>width :宽度</p><p><a id="54g6-1666522618529"></a>height :高度</p><p><a id="Txtr-1666532813606"></a>Javascript :</p><p><a id="R1uD-1666532813835"></a>概念:一门客户端本语营</p><p><a id="i1f8-1666532813837"></a>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p><p><a id="2khm-1666532823439"></a>脚本语言:不需要编译,直接就可以被浏览器解析执行了</p><p><a id="cTJa-1666532813839"></a>功能:</p><p><a id="UzIx-1666532813841"></a>可以来培强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</p><p><a id="S84W-1666609242377"></a>ECMAScript :客户端脚本语言的标准</p><p><a id="OqbH-1666609242586"></a>1．基本语法:</p><p><a id="K7fB-1666609242588"></a>1.与html结合方式</p><p><a id="LqrI-1666609242590"></a>1．内部s :</p><p><a id="JBJU-1666609242592"></a>*定义<script>，标签体内容就是js代码</p><p><a id="3DXm-1666609265636"></a>2．外部s :</p><p><a id="tEqN-1666609242595"></a>*定义<script>，通过src属性引入外部的js文件</p><p><a id="ieus-1666609242597"></a>*注意︰</p><p><a id="QowP-1666609242599"></a>1.<script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</p><p><a id="KVir-1666609257287"></a>2. <script>可以定义多个。</p><p><a id="VRqE-1666612769485"></a>2．注释</p><p><a id="BZhK-1666612769797"></a>1，单行注释://注释内容</p><p><a id="q4nS-1666612836553"></a>2．多行注释∶/*注释内容*/</p><p><a id="i1PA-1666612823512"></a>3．数据类型:</p><p><a id="aMCB-1666612769799"></a>1．原始数据类型(基本数据类型):</p><p><a id="owFg-1666612769801"></a>1.number:数字。整数/小数/NaN(not a number 一个不是数字的数字类型)</p><p><a id="oQhd-1666612879498"></a>2. string :字符串。字符串”abc” “a” “abc ‘  无字符</p><p><a id="TFAu-1666612769803"></a>2.boolean: true和false</p><p><a id="kiab-1666612769805"></a>3.null :一个对象为空的占位符</p><p><a id="EDKA-1666612769807"></a>4.undefined :未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</p><p><a id="NEh7-1666612798402"></a>2.引用数据类型:对象</p><p><a id="aAKR-1666617272844"></a>4．变量</p><p><a id="o7eJ-1666617273406"></a>*变量:一小块存储数据的内存空间</p><p><a id="fpfP-1666617273408"></a>Java语言是强类型语言，而Javascript是弱类型语言。</p><p><a id="p62T-1666617273410"></a>强类型︰在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p><p><a id="OCsd-1666617330030"></a>弱类型:在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p><p><a id="nMkS-1666617273412"></a>*语法∶</p><p><a id="Ea8O-1666617273415"></a>*var变量名=初始化值;</p><p><a id="FqMy-1666617273417"></a>*typeof运算符:获取变量的类型。</p><p><a id="XOMI-1666617273419"></a>注:null运算后得到的是object</p><p><a id="YVcI-1666618485289"></a>5．运算符</p><p><a id="MyZV-1666618504243"></a>1，—元运算符︰只有一个运算数的运算符</p><p><a id="7ZNM-1666618504245"></a>++,-- , +(正号),-(负号)</p><p><a id="YGSm-1666618504247"></a>++ --:自增(自减)++(--)在前，先自增(自减)，再运算++(--)在后，先运算，再自增(自减)</p><p><a id="koDa-1666619374964"></a>+(-):正负号</p><p><a id="zPQZ-1666619375199"></a>注意。在s中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p><p><a id="IyWO-1666619385564"></a>其他类型转number:</p><p><a id="infB-1666619375201"></a>string转number:按照字面值转换。如果字面值不是数字，则转为NaN(不是数字的数字)</p><p><a id="GPKV-1666619405687"></a>boolean转number: true转为1,false转为-1</p><p><a id="YLyB-1666618529773"></a>2．算数运算符</p><p><a id="Llhi-1666618533605"></a>+ - * / %  ...</p><p><a id="AHhk-1666618504249"></a>3．赋值运算符</p><p><a id="6A4V-1666618504251"></a>= += -+...</p><p><a id="LKuy-1666618504253"></a>4．比较运算符</p><p><a id="4nzA-1666618603414"></a>&lt; &gt; &gt;= &lt;= == ===(全等于)</p><p><a id="22nA-1667127053253"></a>比较方式</p><p><a id="P2rU-1667127053255"></a>1．类型相同:直接比较</p><p><a id="4Lsb-1667127053257"></a>字符串,按照字典顺序比较。按位逐一比较，直到得出大小为止。</p><p><a id="n0R4-1667127063429"></a>2．类型不同:先进行类型转换，再比较</p><p><a id="yBAb-1667127053259"></a>*===:全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p><p><a id="acQC-1666618582744"></a>5．逻辑运算符</p><p><a id="sYPI-1666618582746"></a> &amp;&amp;  ||  !</p><p><a id="eaz1-1667129490455"></a>逻辑运算符:&amp;&amp;:与（短路)</p><p><a id="3FDf-1667129537680"></a>l|:或（短路)</p><p><a id="z1Fr-1667129541216"></a>!:非</p><p><a id="oSgL-1667129515585"></a>*其他类型转boolean:</p><p><a id="NID8-1667129515587"></a>1.number:0或NaN为假，其他为真</p><p><a id="OE4Y-1667129515589"></a>2.string:除了空字符串(“”)，其他都是true</p><p><a id="VNxm-1667129560618"></a>3. null&amp;undefined:都是false</p><p><a id="m7ck-1667129515591"></a>4．对象:所有对象都为true</p><p><a id="0izZ-1666618582748"></a>6．三元运算符</p><p><a id="CST0-1666618582750"></a>   ?  :</p><p><a id="J6Ux-1666612769813"></a>6．流程控制语句</p><p><a id="HwxB-1667130637881"></a>1.if...else. . .</p><p><a id="50Ri-1667131023885"></a>2. switch:[</p><p><a id="WWer-1667131017415"></a>*在java中, switch语句可以接受的数据类型: byte int shor char,枚举(1.5) ,string(1.7)</p><p><a id="bh6H-1667131017417"></a>switch(变量):</p><p><a id="Crfa-1667131017419"></a>case 值:</p><p><a id="Riy6-1667131017421"></a>*在JS中, switch语句可以接受任意的原始数据类型</p><p><a id="b3o5-1667131057595"></a>3. while</p><p><a id="U2zp-1667131017423"></a>4. do . ..while</p><p><a id="gI6M-1667131061865"></a>5. for</p><p><a id="rRfE-1667130586535"></a>7．特殊语法</p><p><a id="fIPh-1667130613776"></a>1．语句以;结尾，如果一行只有一条语句则﹔可以省略(不建议)</p><p><a id="TC7L-1667130611448"></a>2．变量的定义使用var关键字，也可以不使用</p><p><a id="jYCj-1667130629041"></a>        *用:定义的变量是局部变量</p><p><a id="mk8y-1667130629043"></a>        *不用:定义的变量是全局变量(不建议)</p><p><a id="Wa4q-1667222314957"></a>Function:函数(方法)对象</p><p><a id="96ll-1667222315239"></a>1．创建:</p><p><a id="K8im-1667222315241"></a>1. var fun = new Function(形式参数列表,方法体);//忘掉吧</p><p><a id="1xRH-1667222348012"></a>2. function方法名称(形式参数列表){</p><p><a id="3p8y-1667222315243"></a>方法体</p><p><a id="c4zi-1667222352233"></a>}</p><p><a id="WKJD-1667222315245"></a>3. var 方法名= function(形式参数列表){</p><p><a id="KDGM-1667222315247"></a>方法体</p><p><a id="CEy7-1667222315249"></a>}</p><p><a id="jXAG-1667222315251"></a>2．方法:</p><p><a id="19eT-1667222315253"></a>3．属性:</p><p><a id="mKck-1667222315255"></a>length :代表形参的个数</p><p><a id="3I3N-1667222377753"></a>4．特点:</p><p><a id="Y07z-1667222315257"></a>1．方法定义是，形参的类型不用写,返回值类型也不写。</p><p><a id="v2pH-1667222391860"></a>2．方法是一个对象，如果定义名称相同的方法，会覆盖</p><p><a id="9VlT-1667222315259"></a>3．在JS中，方法的调用只与方法的名称有关，和参数列表无关</p><p><a id="BLoF-1667222315261"></a>4．在方法声明中有一个隐藏的内置对象（数组）, arguments ,封装所有的实际参数</p><p><a id="JzTA-1667222420084"></a>5．调用:</p><p><a id="MAGR-1667222315263"></a>方法名称(实际参数列表);</p><p><a id="Hmmv-1667224681748"></a>Array:数组对象</p><p><a id="Z0cF-1667224681954"></a>1．创建:</p><p><a id="wtEK-1667224681956"></a>1.var arr = new Array(元素列表);</p><p><a id="Yja8-1667224688864"></a>2. var arr = new_Array(默认长度);</p><p><a id="PMEJ-1667224691436"></a>3. var arr =[元素列表];</p><p><a id="Ijqe-1667224681958"></a>2．方法</p><p><a id="DlJ1-1667224681960"></a>join(参数):将数组中的元素按照指定的分隔符拼接为字符串</p><p><a id="D1H9-1667224701539"></a>push()向数组的末尾添加一或更多元素，并返回新的长度。</p><p><a id="uXsa-1667224697756"></a>3．属性</p><p><a id="7vPp-1667224681962"></a>length :数组的长度</p><p><a id="BU17-1667224708493"></a>4．特点:</p><p><a id="hZhT-1667224681964"></a>1.Js中，数组元素的类型可变的。</p><p><a id="EpzC-1667224712627"></a>2.Js中，数组长度可变的。</p><p><a id="PX2X-1667300354646"></a>Date:日期对象</p><p><a id="v7bV-1667300354920"></a>1．创建:</p><p><a id="Bzol-1667300354922"></a>var date =new Date( );</p><p><a id="d5Zp-1667300354926"></a>2．方法:</p><p><a id="ycaW-1667300354928"></a>toLocalestring():返回当前date对象对应的时间本地字符串格式</p><p><a id="R9GH-1667300354930"></a>getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p><p><a id="K02J-1667304404731"></a>Number</p><p><a id="qKKu-1667304410434"></a>String</p><p><a id="JlyV-1667304404958"></a>RegExp:正则表达式对象</p><p><a id="3pAQ-1667304404960"></a>1.正则表达式:定义字符串的组成规则。</p><p><a id="pGNP-1667304404963"></a>1,单个字符:[ ]</p><p><a id="2T3e-1667304404965"></a>如:[a][ab] [a-zA-Zo-9_]</p><p><a id="iRiE-1667304404967"></a>特殊符号代表特殊含义的单个字符:</p><p><a id="TnzQ-1667304471318"></a>\d:单个数字字符[0-9]</p><p><a id="ngR8-1667304477380"></a>\w:单个单词字符[a-zA-Z0-9_]</p><p><a id="xFgj-1667304481389"></a>2．量词符号:</p><p><a id="TJks-1667304486618"></a>?:表示出现0次或1次</p><p><a id="mGuX-1667304493626"></a>*:表示出现0次或多次</p><p><a id="T6i5-1667304504386"></a>+:出现1次或多次</p><p><a id="Qttj-1667304404969"></a>{m,n}:表示m&lt;=数量&lt;=n</p><p><a id="Jtu3-1667304404971"></a>m如果缺省:{,n}:最多n次</p><p><a id="v469-1667304596575"></a>n如果缺省:{m,}最少m次</p><p><a id="tWJp-1667308733380"></a>3.开始结束符号</p><p><a id="Gxb6-1667308744077"></a>^：开始</p><p><a id="tNm5-1667308757195"></a>$：结束</p><p><a id="ebhc-1667304404973"></a>2．正则对象:</p><p><a id="IaoH-1667304404975"></a>1．创建</p><p><a id="iZAH-1667308944680"></a>1.var reg =new_RegExp(”正则表达式”);</p><p><a id="HYVn-1667308953188"></a>2. var reg =/正则表达式/;</p><p><a id="94cX-1667304611078"></a>2．方法</p><p><a id="0jjw-1667308966687"></a>1.test(参数):验证指定的字符串是否符合正则定义的规范</p><p><a id="DtfC-1667304404977"></a>Global</p><p><a id="6Uth-1667309516996"></a>1．特点:全局对象，这个Global中封装的方法不需要对象就可以直接调用。   方法名();</p><p><a id="mGgu-1667309524379"></a>2．方法:</p><p><a id="vWJN-1667309516998"></a>encodeURI( ) : url编码</p><p><a id="lm50-1667309530352"></a>decodeURI(() : url解码</p><p><a id="o3rQ-1667309517000"></a>encodeURIComponent() : url编码,编码的字符更多</p><p><a id="qbNG-1667309538267"></a>decodeURIComponent() : url解码</p><p><a id="sUwE-1667310643301"></a>parseInt():将字符串转为数字</p><p><a id="2Agj-1667310643528"></a>*逐—判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</p><p><a id="tv7G-1667310656774"></a>isNaN():判断一个值是否是NaN</p><p><a id="cMdQ-1667310643530"></a>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false</p><p><a id="Q3zJ-1667310643532"></a>eval():讲JavaScript字符串，并把它作为脚本代码来执行。</p><p><a id="oN3E-1667309517002"></a> 3.URL编码</p><p><a id="WXme-1667309517004"></a>传智播客=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p><p><a id="1HjO-1667648888619"></a>BOM:</p><p><a id="tKNN-1667648896217"></a>1．概念︰Browser object Model 浏览器对象模型</p><p><a id="Ul6S-1667648896219"></a>将浏览器的各个组成部分封装成对象。</p><p><a id="uoHY-1667648907383"></a>2．组成:window :窗口对象</p><p><a id="jMFN-1667648911895"></a>Navigator :浏览器对象</p><p><a id="TMrk-1667648916596"></a>screen :显示器屏幕对象</p><p><a id="A6pW-1667648920606"></a>History : 历史记录对象</p><p><a id="mATV-1667648923710"></a>Location :地址栏对象</p><p><a id="UXrW-1667645022510"></a>DOM简单学习:为了满足案例要求</p><p><a id="OyuR-1667645044828"></a>*功能:控制html文档的内容</p><p><a id="dtWN-1667645018979"></a>*代码∶获取页面标签(元秦)对象 Element</p><p><a id="2AFa-1667645018981"></a>*document.getElementById(“id值”):通过元素的id获取元素对象</p><p><a id="sqoD-1667645018983"></a>*操作Element对象︰</p><p><a id="PbES-1667645018985"></a>1.修改属性值∶</p><p><a id="0yO6-1667645018987"></a>1.明确获取的对象是哪一个?</p><p><a id="eQIo-1667645018989"></a>2.查看API文档，找其中有哪些属性可以设置</p><p><a id="oY5Y-1667645080565"></a>2．修改标签体内容︰</p><p><a id="KIoY-1667645018991"></a>属性:innerHTML</p><p><a id="cwG6-1667647882542"></a>事件简单学习</p><p><a id="fk3R-1667647883002"></a>*功能:某些组件被执行了某些操作后，触发某些代码的执行。</p><p><a id="eVrK-1667647883009"></a>*如何绑定事件</p><p><a id="i5mJ-1667647883011"></a>1．直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><p><a id="3JrQ-1667647883013"></a>1.事件:onclickl--单击事件</p><p><a id="u2ok-1667647883015"></a>2．通过js获取元素对象，指定事件属性，设置一个函数</p><p><a id="7FUm-1667649468621"></a>window:窗口对象</p><p><a id="l9bG-1667649468807"></a>1、创建</p><p><a id="IGiC-1667649468809"></a>2．方法</p><p><a id="n73X-1667649468811"></a>1．与弹出框有关的方法:</p><p><a id="mg7X-1667649468813"></a>alert(）显示带有一段消,息和一个确认按钮的警告框。</p><p><a id="4Kdo-1667649468815"></a>confirm()   显示带有一段消息以及确认按钮和取消按钮的对话框。</p><p><a id="fTri-1667649468817"></a>如果用户点击确定按钮,则方法返回true</p><p><a id="5CTd-1667649468819"></a>如果用户点击取消按钮，则方法返回false</p><p><a id="K3oc-1667649490393"></a>prompt()  显示可提示用户输入的对话框。</p><p><a id="nfXR-1667649468821"></a>返回值:获取用户输入的值</p><p><a id="h37u-1667652113030"></a>2．与打开关闭有关的方法:</p><p><a id="hoR5-1667652113438"></a>close()关闭浏览器窗口。</p><p><a id="DVjc-1667652113440"></a>谁调用我，我关谁</p><p><a id="tg4i-1667652113442"></a>open()打开一个新的浏览器窗口</p><p><a id="y9M7-1667652113444"></a>返回新的window对象</p><p><a id="LwWJ-1667652113446"></a>3．与定时器有关的方式</p><p><a id="Zo7v-1667652113448"></a>setTimeout()在指定的毫秒数后调用函数或计算表达式。</p><p><a id="bVLI-1667652113450"></a>*参数:</p><p><a id="nJiY-1667652113452"></a>1.js代码或者方法对象</p><p><a id="RvQb-1667652126445"></a>2．毫秒值</p><p><a id="ZIr0-1667652113454"></a>*返回值:唯—标识，用于取消定时器</p><p><a id="HcAm-1667652113456"></a>clearTimeout()取消由setTimeout()方法设置的 timeout。</p><p><a id="8iMe-1667652113458"></a>setInterval()</p><p><a id="ZMXL-1667652113460"></a>按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><p><a id="ASRi-1667652113462"></a>clearInterval()取消由setInterval()设置的timeout。</p><p><a id="SIBM-1667649468823"></a>3．属性</p><p><a id="1RR4-1667649468825"></a>4．特点</p><p><a id="35Lj-1667649468827"></a>Window对象不需要创建可以直接使用window使用。window .方法名();</p><p><a id="f7Af-1667649737325"></a>window引用可以省略。方法名（);</p><p><a id="gHHG-1667735529397"></a>Location对象 :地址栏对象</p><p><a id="hWy6-1667735529612"></a>1．创建(获取)∶</p><p><a id="rIKb-1667735529614"></a>1.window. location</p><p><a id="smVK-1667735657146"></a>2. location</p><p><a id="CM2d-1667735529616"></a>2．方法︰</p><p><a id="PHe0-1667735529618"></a>reload(重新加载当前文档。刷新)</p><p><a id="SWCL-1667735620686"></a>3。属性</p><p><a id="u7nW-1667735529620"></a>href设置或返回完整的URL。跳转页面</p><p><a id="THIQ-1667736774627"></a>History :历史记录对象</p><p><a id="Ukpq-1667736774863"></a>1．创建(获取)∶</p><p><a id="4vD0-1667736774865"></a>1.window.history</p><p><a id="lE2v-1667736784011"></a>2. history</p><p><a id="sWt8-1667736774867"></a>2．方法:</p><p><a id="2yJC-1667736774869"></a>back()  加载history列表中的前一个URL。</p><p><a id="uyYF-1667736792734"></a>forward() 加载history列表中的下一个URL。</p><p><a id="Tcee-1667736794927"></a>go(参数) 加载history列表中的某个具体页面。</p><p><a id="HLVA-1667736774871"></a>参数:正数∶前进几个历史记录</p><p><a id="4Reo-1667736809628"></a> 负数:后退几个历史记录</p><p><a id="7NIg-1667736774875"></a>3．属性∶</p><p><a id="clpp-1667736774877"></a>*length返回当前窗口历史列表中的URL数量。</p><p><a id="9dWi-1667737660306"></a>DOM :</p><p><a id="UTpl-1667737660537"></a>*概念: Document object Model文档对象模型</p><p><a id="5wzD-1667737660539"></a>*将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p><p><a id="XX7c-1667737660541"></a>W3C DOM 标准被分为3个不同的部分∶</p><p><a id="odbz-1667737749437"></a>核心DOM -针对任何结构化文档的标准模型</p><p><a id="tz8P-1667737753831"></a>Document :文档对象</p><p><a id="wfMI-1667737785349"></a>Eiement:元素对象</p><p><a id="Epn9-1667737781434"></a>Attfibute :属性对象</p><p><a id="57N3-1667737789434"></a>Text :文本对象</p><p><a id="20hc-1667737660543"></a>Comment:注释对象</p><p><a id="g8Cz-1667737809124"></a></p><p><a id="Z0LB-1667737660545"></a>Node :节点对象，其他5个的父对象</p><p><a id="5fQZ-1667737814184"></a>XML DOM -针对XML文档的标准模型</p><p><a id="AsnM-1667737829105"></a>HTML DOM -针对HTML文档的标准模型</p><p><a id="GBV1-1667739787410"></a>核心DOM模型:</p><p><a id="QnOS-1667739787771"></a>*Document :文档对象</p><p><a id="qxex-1667739787773"></a>1.创建(获取):在html dom模型中可以使用window对象来获取</p><p><a id="3cIO-1667739787775"></a>1.window. document</p><p><a id="7pes-1667739787777"></a>2.document</p><p><a id="mBs1-1667739787779"></a>2。方法:</p><p><a id="TPDB-1667739787781"></a>1．获取Element对象︰ </p><p><a id="NUoz-1667739787783"></a>1.getElementById() :根据id属性值获取元素对象。id属性值一般唯</p><p><a id="gUBx-1667739787785"></a>2.getElementsByTagName():根据元素名称获取元素对象们。返回值是一个数组</p><p><a id="SdVA-1667739787787"></a>3.getElementsByclassName( ) :根据class属性值获取元素对象们。返回值是一个数组</p><p><a id="ffyC-1667739863893"></a>4. getElementsByName():根据name属性值获取元素对象们。返回值是一个数组</p><p><a id="BIpK-1667739787789"></a>2．创建其他DOM对象:</p><p><a id="WPBv-1667739787791"></a>createAttribute( name)：创建指定名称的属性节点，并返回新的attr对象</p><p><a id="sJCi-1667739881859"></a>createcomment()：创建注释节点</p><p><a id="EmKv-1667739787793"></a>createElement()：创建元素节点</p><p><a id="kWZq-1667739884707"></a>createTextNode( )：创建文本节点</p><p><a id="4iuF-1667739787795"></a>3．属性</p><p><a id="ii70-1667739787797"></a>Element :元素对象</p><p><a id="gMeK-1667739919434"></a>1，获取/创建:通过document来获取和创建</p><p><a id="b18x-1667739935903"></a>2．方法:</p><p><a id="BamO-1667739919436"></a>1.removeAttribute() :删除属性</p><p><a id="AOz8-1667739952682"></a>2. setAttribute(): 设置属性</p><p><a id="Y2Lb-1667739787799"></a>Node :节点对象，其他5个的父对象</p><p><a id="qE4b-1667822742416"></a>特点:所有dom对象都可以被认为是一个节点</p><p><a id="LkVV-1667822757735"></a>方法:</p><p><a id="Eqrr-1667822742830"></a>CRUD dom树:︰</p><p><a id="bZSv-1667822742832"></a>appendchild():向节点的子节点列表的结尾添加新的子节点。</p><p><a id="UP2K-1667822763586"></a>removechild():删除(并返回)当前节点的指定子节点。</p><p><a id="Lx0D-1667822792306"></a>replacechild():用新节点替换一个子节点。</p><p><a id="PUTX-1667822742834"></a>属性:</p><p><a id="LnlG-1667822742836"></a>*parentNode返回节点的父节点。</p><p><a id="wqgK-1667820899495"></a>HTML DOM</p><p><a id="hhwE-1667829020824"></a>1．标签体的设置和获取: innerHTML</p><p><a id="afHJ-1667829026152"></a>2．使用html元秦对象的属性</p><p><a id="5FHd-1667829020826"></a>3．控制元素样式</p><p><a id="tUy0-1667829020828"></a>1。使用元素的style属性来设置</p><p><a id="rET4-1667829020830"></a>如:</p><p><a id="ySrU-1667829020832"></a>//修改样式方式1</p><p><a id="0Yux-1667829020834"></a>div1.style.border = “1px solid red” ;</p><p><a id="J5so-1667829045732"></a>div1.style.width = “200px”;</p><p><a id="SDEX-1667829020836"></a>l/font-size--&gt; fontsize//字体大小</p><p><a id="6cuG-1667829020838"></a>div1.style.fontsize = “20px”;</p><p><a id="BRFs-1667829020840"></a>2．提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p><p><a id="WIjq-1668166003108"></a>Bootstrap :</p><p><a id="Gfzr-1668166003329"></a>1．概念︰一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap是基于 HTML、JS、 Javascript 的，它简洁灵活，使得web开发更加快捷。</p><p><a id="MzrA-1668166003331"></a>*框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。*好处:</p><p><a id="JOa0-1668166003333"></a>1，定义了很多的css毕式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</p><p><a id="4S0J-1668166025219"></a>2．响应式布局。</p><p><a id="gQoU-1668166003335"></a>同一套页面可以兼容不同分辨率的设备。</p><p><a id="Iuau-1668166003337"></a>2．快速入门</p><p><a id="H71S-1668166003339"></a>1.下载Bootstrap</p><p><a id="b52Z-1668166003341"></a>2．在项目中将这三个文件夹复制</p><p><a id="Z25N-1668166003343"></a>3、创建html页面，引入必要的资源文件</p><p><a id="f9xm-1667652097031"></a>响应式布局:</p><p><a id="Sq6S-1668167298316"></a>同一套页面可以兼容不同分辨率的设备。</p><p><a id="lIXW-1668167269211"></a>实现∶依赖于棚格系统:将一行平均分成12个格子，可以指定元素占几个格子步骤∶</p><p><a id="qjaD-1668167269213"></a>1，定义容器。相当于之前的table.</p><p><a id="bjsR-1668167269215"></a>容器分类∶</p><p><a id="C9wv-1668167269217"></a>1.container :两边留白   固定宽度</p><p><a id="5DHS-1668167269219"></a>2.container-fluid :每一种设备都是100%的宽度</p><p><a id="TaEu-1668167269221"></a>2．定义行。相当于之前的tr样式: row</p><p><a id="Bltu-1668167269223"></a>3．定义元素。相当于之前的td样式指定该元素在不同的设备上，所占的格子数目。样式: col-设备代号-格子数目</p><p><a id="pGB5-1668167269225"></a>设备代号︰</p><p><a id="qLm1-1668167269227"></a>1.xs :超小屏幕手机(&lt;768px) : col-xs-12</p><p><a id="o6dH-1668167384269"></a>2. sm :小屏蒂平板(≥768px)</p><p><a id="yI8C-1668167269229"></a>3.md : 中等屏蒂桌面显示器(≥992px)</p><p><a id="NWNK-1668167395290"></a>4.lg :大屏蒂大桌面显示器(≥1200px)</p><p><a id="wd9V-1667648882024"></a>注意︰</p><p><a id="39tj-1668167885271"></a>1.一行中如果格子数目超过12，则超出部分自动换行。</p><p><a id="vNHd-1668167885273"></a>2．栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</p><p><a id="JdiJ-1668167885275"></a>3．如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</p><p><a id="H7XW-1668170166002"></a>css样式和js插件</p><p><a id="OHwW-1668170317473"></a>1.全局CSS样式:</p><p><a id="c83H-1668170166297"></a>按钮:class=”btn btn-default”</p><p><a id="6yyq-1668170326188"></a>图片:</p><p><a id="BwpX-1668170367580"></a>class=”img-responsive”:图片在任意尺寸都占100%</p><p><a id="Hhu9-1668170332831"></a>图片形状:</p><p><a id="tGxj-1668170372848"></a><img src="\.\.\." alt="\.\.\." class="img\-rounded"> :方形: </p><p><a id="l5WS-1668170342613"></a><img src="\.\.\." alt\-"\.\.\." class="img\-circle">:圆形 </p><p><a id="Ua4H-1668170346294"></a><img src="\.\.\." alt="\.\.\." class="img\-thumbnail">:相框</p><p><a id="9Dl5-1668170974005"></a>表格</p><p><a id="FM9x-1668170349282"></a>table 添加表格</p><p><a id="VXBP-1668170978694"></a>table’- bordered 表格边框 </p><p><a id="Olkw-1668170983699"></a>table- hover 鼠标悬停效果</p><p><a id="pj2f-1668170987154"></a>表单</p><p><a id="0azD-1668170166299"></a>*给表单项添加: class=”form-control”</p><p><a id="Iyuf-1668170166301"></a>2.组件:</p><p><a id="xEfq-1668170166303"></a>导航条</p><p><a id="dMR8-1668171019723"></a>分页条</p><p><a id="sQ8F-1668171012782"></a>3.插件︰</p><p><a id="HChG-1668170166305"></a>轮播图</p><p><a id="HZAW-1668339683915"></a>事件监听机制:</p><p><a id="qwMA-1668339684146"></a>*概念:某些组件被执行了某些操作后，触发某些代码的执行。</p><p><a id="T68H-1668339684148"></a>事件:某些操作。如:单击，双击，键盘按下了，鼠标移动了</p><p><a id="DIYn-1668339730803"></a>事件源:组件。如:按钮文本输入框...</p><p><a id="Qqie-1668339684150"></a>监听器∶代码。</p><p><a id="yORz-1668339684152"></a>注册监听∶将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</p><p><a id="gtMi-1668339775543"></a>*常见的事件︰</p><p><a id="J6Tb-1668339775859"></a>1．点击事件∶</p><p><a id="jI7q-1668339775861"></a>1.onclick:单击事件</p><p><a id="dyGt-1668339787341"></a>2.ondblclick :双击事件</p><p><a id="Y99G-1668339807478"></a>2．焦点事件</p><p><a id="ZXiB-1668339775863"></a>1.onblur :失去焦点</p><p><a id="xK2O-1668340082835"></a>一般用于表单校验</p><p><a id="fwmU-1668339775865"></a>2.onfocus:元素获得焦点。</p><p><a id="27yo-1668339775867"></a>3．加载事件:</p><p><a id="LjGY-1668339775869"></a>1.onload : —张页面或─幅图像完成加载。</p><p><a id="1Ju6-1668339775871"></a>4．鼠标事件︰</p><p><a id="NaF6-1668339775873"></a>1.onmousedown 鼠标按钮被按下。</p><p><a id="wzln-1668341852600"></a>定义方法时，定义一个形参，接受event对象。</p><p><a id="uGmP-1668341895590"></a>event对象的button属性可以获取鼠标哪个键被点击了  </p><p><a id="yCZw-1668339775877"></a>2.onmouseup鼠标按键被松开。</p><p><a id="gp7t-1668339775881"></a>3.onmousemove鼠标被移动。</p><p><a id="lDyS-1668339775883"></a>4.onmouseover鼠标移到某元素之上。</p><p><a id="2OBn-1668339856401"></a>5.onmouseout鼠标从某元素移开。</p><p><a id="csnr-1668339775887"></a>5．键盘事件:</p><p><a id="DXsm-1668339775889"></a>1.onkeydown某个键盘按键被按下。</p><p><a id="eKKn-1668339775893"></a>2.onkeyup某个键盘按键被松开。</p><p><a id="ITJr-1668339775897"></a>3. onkeypress某个键盘按键被按下并松开。</p><p><a id="bLkM-1668339970034"></a>6．选择和改变</p><p><a id="EnD9-1668339970318"></a>1.onchange 域的内容被改变。</p><p><a id="ptCx-1668339976624"></a>2. onselect文本被选中。</p><p><a id="Grp6-1668339970320"></a>7.表单事件:</p><p><a id="j1xy-1668339970322"></a>1.onsubmit确认按钮被点击。</p><p><a id="00VO-1668342897457"></a>可以阻止表单的提交</p><p><a id="6eEx-1668339987916"></a>2.onreset重置按钮被点击。</p><p><a id="CCwL-1668424851696"></a>XML:</p><p><a id="Ah4a-1668424852108"></a>1。概念︰Extensible Markup Language 可扩展标记语言</p><p><a id="meeN-1668424852110"></a>*可扩展︰标签都是自定义的。<user> <student></p><p><a id="TeSN-1668424852112"></a>*功能</p><p><a id="frso-1668424852114"></a>*存储数据</p><p><a id="n3da-1668424852116"></a>1．配置文件</p><p><a id="jjKW-1668424865437"></a>2．在网络中传输</p><p><a id="GdcY-1668424852118"></a>xml与html的区别</p><p><a id="hibg-1668424852120"></a>1.xml标签都是自定义的，html标签是预定义。</p><p><a id="ryzl-1668424907491"></a>2. xml的语法严格，html语法松散</p><p><a id="FI3Q-1668424852122"></a>3.xml是存储数据的，html是展示数据</p><p><a id="nVEc-1668424852126"></a>2．语法︰</p><p><a id="K5mi-1668424852128"></a>*基本语法︰</p><p><a id="7V4G-1668425451069"></a>1.xml文档的后缀名.xml</p><p><a id="zQjo-1668425451424"></a>2.xml第一行必须定义为文档声明</p><p><a id="NbMV-1668425464319"></a>3. xml文档中有且仅有一个根标签</p><p><a id="XKgk-1668425451426"></a>4. 属性值必须使用引号(单双都可)引起来</p><p><a id="NHRL-1668425480364"></a>5. 标签必须正确关闭</p><p><a id="WpVQ-1668425451428"></a>6. xml标签名称区分大小写</p><p><a id="dyxd-1668425029294"></a>*快速人门:</p><p><a id="USJK-1668425026343"></a>*组成部分∶</p><p><a id="d0qN-1668427068782"></a>1，文档声明</p><p><a id="pB8f-1668427068784"></a>1．格式:&lt;?xml  属性列表  ?&gt;</p><p><a id="IKoa-1668427102192"></a>2．属性列表:</p><p><a id="ZKHo-1668427068786"></a>version :版本号，必须的属性</p><p><a id="kjbc-1668427068788"></a>encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值:ISO-8859-1</p><p><a id="tDQz-1668427116666"></a>standalone :是否独立</p><p><a id="d6pP-1668427068791"></a>取值:</p><p><a id="OtTD-1668427068793"></a>yes :不依赖其他文件</p><p><a id="JiG3-1668427131099"></a>no:依赖其他文件</p><p><a id="Iode-1668427068795"></a>2．指令(了解)∶结合css的</p><p><a id="uBuS-1668427068797"></a>&lt;?xml-stylesheet type=”text/css” href=fa.css” ?&gt;</p><p><a id="DR8Y-1668427162418"></a>3．标签︰标签名称自定义的</p><p><a id="fJRt-1668427068799"></a>规则:<br> 名称可以包含字母、数字以及其他的字符名称</p><p><a id="wxo5-1668427185631"></a>  不能以数字或者标点符号开始</p><p><a id="yTKd-1668427068801"></a>  名称不能以字母xml(或者XML、 xml等等)开始</p><p><a id="5RaI-1668427202789"></a>   名称不能包含空格</p><p><a id="6oX9-1668427068803"></a>4.属性:</p><p><a id="m8Up-1668427068805"></a>id属性值唯一</p><p><a id="4mxs-1668427229153"></a>5，文本:</p><p><a id="fqTo-1668427229399"></a>CDATA区:在该区域中的数据会被原样展示</p><p><a id="cYvm-1668427229401"></a>格式:&lt; ![CDATA[ 数据 ]]&gt;</p><p><a id="gZZs-1668431052508"></a>约束:规定xml文档的书写规则</p><p><a id="nqrB-1668431085573"></a>*作为框架的使用者(程序员)∶</p><p><a id="4onv-1668431052908"></a>1．能够在xml中引入约束文档</p><p><a id="NXte-1668431091106"></a>2．能够简单的读懂约束文档</p><p><a id="r1y6-1668431052910"></a>*分类︰</p><p><a id="2FQa-1668431052912"></a>1.DTD:—种简单的约束技术</p><p><a id="2O2d-1668431099084"></a>2. schema :—种复杂的约束技术</p><p><a id="pwYd-1668431052914"></a>DTD :</p><p><a id="wfrR-1668431052916"></a>*引人dtd文档到xml文档中</p><p><a id="IAYw-1668431052918"></a>*内部dtd :将约束规则定义在xml文档中I</p><p><a id="MunG-1668431052920"></a>*外部dtd:将约束的规则定义在外部的dtd文件中</p><p><a id="TQKj-1668431052922"></a>*本地:&lt;! DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt;</p><p><a id="BrUD-1668431052924"></a>*网络:&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字”  “dtd文件的位置URL”&gt;</p><p><a id="MtX6-1668431212178"></a>schema :</p><p><a id="xJ8L-1668431212423"></a>引入:</p><p><a id="mP1Y-1668431212425"></a>1.填写xml文档的根元秦</p><p><a id="7jkM-1668431212427"></a>2.引入xsi前缀，  xmlns :xsi=”http: / /www . w3. org/2001/xNLSchema-instance”</p><p><a id="dCn0-1668431212429"></a>3.引入xsd文件命名空间.    xsi:schemaLocation=”http : / / ww.itcast.cn/xml student.xsd”</p><p><a id="xBBa-1668431245941"></a>4.为每一个xsd约束声明一个前缀,作为标识 xmlns=”http: / / www.itcast.cn/xml”</p><p><a id="2SiG-1668431768628"></a>3．解析∶操作xml文档，将文档中的数据读取到内存中</p><p><a id="1alT-1668431768939"></a>*操作xml文档</p><p><a id="fM4S-1668431768941"></a>1．解析(读取)∶将文档中的数据读取到内存中</p><p><a id="eev1-1668431768943"></a>2．写入:将内存中的数据保存到xml文档中。持久化的存储</p><p><a id="6tw1-1668431768945"></a>*解析xml的方式:</p><p><a id="Ua9E-1668431768947"></a>1.DOM∶将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p><p><a id="7Fne-1668431768949"></a>*优点:操作方便，可以对文档进行CRUD的所有操作</p><p><a id="SmXo-1668431768951"></a>*缺点∶占内存</p><p><a id="iu1j-1668431768953"></a>2. SAX:逐行读取，基于事件驱动的。</p><p><a id="pX7T-1668431768955"></a>*优点:不占内存。</p><p><a id="9hJv-1668431768957"></a>*缺点:只能读取，不能增删改</p><p><a id="J6yL-1668432050498"></a>xml常见的解析器∶</p><p><a id="Qlh4-1668432050745"></a>1.JAXP : sun公司提供的解析器，支持dom和sax两种思想</p><p><a id="ntS2-1668432055588"></a>2. DOM43 :一款非常优秀的解析器</p><p><a id="ybfI-1668432050747"></a>3. Jsoup : jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容它提供了一套非常省力的API，可通过DOM,cSs以及类似于jQuery的操作方法来取出和操作数据。</p><p><a id="CX5H-1668432050753"></a>4.PULL : Android操作系统内置的解析器，sax方式的。</p><p><a id="0PiN-1670158134310"></a>对象的使用:</p><p><a id="vS48-1670158139592"></a>1.Jsoup :工具类，可以解析html或xml文档，返回Document</p><p><a id="juyy-1670158134571"></a>parse :解析html或xml文档，返回Document</p><p><a id="n1Dx-1670158134573"></a>parse(File in，string charsetName ):解析xml或html文件的。</p><p><a id="1Ddh-1670158161943"></a>parse(string html):解析xml或html字符出</p><p><a id="IDOE-1670158134575"></a>parse(URL_url,int timeoutNillis):通过网络路径获取指定的html或xml的文档对象</p><p><a id="ZbZE-1670159082437"></a>2.Document :文档对象。代表内存中的dom树</p><p><a id="lPmq-1670159082672"></a>获取Element对象</p><p><a id="ug8O-1670159082674"></a>getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p><p><a id="dnnJ-1670159098677"></a>getElementsByAttribute(string key):根据属性名称获取元素对象集合</p><p><a id="mWNR-1670159082676"></a>getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p><p><a id="RjTT-1670159082678"></a>3. Elements :元素Element对象的集合。可以当做ArrayList<Element>来使用</p><p><a id="RvMj-1670159082680"></a>4. Element :元素对象</p><p><a id="jOUd-1670159082682"></a>1.获取子元素对象</p><p><a id="LlO4-1670159082684"></a>getElementById(string id):根据id属性值获取唯一的element对象getElementsByTag(string tagName):根据标签名称获取元素对象集合</p><p><a id="so0w-1670159179914"></a>getElementsByAttribute(string key):根据属性名称获取元素对象集合</p><p><a id="nTZu-1670159179918"></a>getElementsByAttributevalue(string key，string value):根据对应的属性名和属性值获取元素对象集合</p><p><a id="lPSm-1670159201228"></a>2.获取属性值</p><p><a id="QE5I-1670159575985"></a>string attr( string key):根据属性名称获取属性值</p><p><a id="rsfC-1670159588249"></a>3.获取文本内容</p><p><a id="L3vE-1670159575987"></a>string text():获取标签的纯文本内容</p><p><a id="TO0x-1670159575989"></a>string html():获取标签体的所有内容(包括子标签的标签和文本内容)</p><p><a id="IYpO-1670158134581"></a>5. Node :节点对象</p><p><a id="lD9j-1670161405774"></a>是Document和Element的父类</p><p><a id="e4nK-1670165701576"></a>快捷查询方式:</p><p><a id="xz1A-1670165702199"></a>1.selector:选择器</p><p><a id="rUVu-1670165702201"></a>使用的方法:Elementsselect(string cssQuery)</p><p><a id="SqIl-1670165702203"></a>语法:参考selector类中定义的语法</p><p><a id="66ZX-1670165702205"></a>2. XPath : XPath即为ML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p><p><a id="xDln-1670165702207"></a>*使用Jsoup的xpath需要额外导入jar包。</p><p><a id="lBCv-1670165702209"></a>*查询w3cshool参考手册xml中，使用xpath的语法完成查询</p><p><a id="dCtP-1670236163779"></a>web服务器软件∶</p><p><a id="IJgK-1670236164042"></a>服务器︰安装了服务器软件的计算机</p><p><a id="kwIS-1670236164044"></a>服务器软件∶接收用户的请求，处理请求，做出响应</p><p><a id="6XU4-1670236164046"></a>web服务器软件:接收用户的请求，处理请求，做出响应。</p><p><a id="EWtq-1670236164048"></a>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 </p><p><a id="eYO2-1670236173621"></a>web容器</p><p><a id="Rh1b-1670236164050"></a>常见的java相关的web服务器软件</p><p><a id="Ihwk-1670236164052"></a> webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p><a id="Q1A7-1670236200720"></a> websphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p><a id="q9sP-1670236203677"></a>JBOSS :JBOSs公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</p><p><a id="gLnm-1670236164054"></a>Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的javaEE规范servlet/jsp。开源的，免费的。</p><p><a id="2duL-1670236164056"></a>JavaEE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p><p><a id="5WCZ-1670305189962"></a>Tomcat:web服务器软件</p><p><a id="ByXl-1670305196771"></a>启动︰</p><p><a id="yseT-1670305190222"></a>bin/startup.bat ,双击运行该文件即可</p><p><a id="ghEj-1670305190224"></a>访问:浏览器输入:localhost:8080回车访问自己</p><p><a id="Fmnk-1670305190226"></a><a href="http://别人的ip:8o80访问别人">http://别人的ip:8o80访问别人</a></p><p><a id="lamb-1670305190228"></a>可能遇到的问题:<br>1.黑窗口一闪而过:<br>原因:没有正确配置AVA_HOME环境变量</p><p><a id="5Srn-1670305304385"></a>解决方案:正确配置JAvA_HOME环境变量</p><p><a id="MOoH-1670305190230"></a>2．启动报错:</p><p><a id="yECY-1670305190232"></a>1．暴力∶找到占用的端口号，并目找到对应的进程，杀死该进程</p><p><a id="Zngq-1670305364753"></a>     cmdnetstat -ano</p><p><a id="EA8Z-1670305190236"></a>2．温柔∶修效自身的端口号</p><p><a id="Vrpt-1670305190238"></a>conflserver.xml</p><p><a id="uQv3-1670305190246"></a>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p><p><a id="GEzG-1670305190248"></a>好处∶在访问时，就不用输入端口号</p><p><a id="cexW-1670305817430"></a>5．关闭:</p><p><a id="L9SE-1670305819581"></a>1．正常关闭:</p><p><a id="9UKn-1670305819583"></a>bin/shutdown.bat</p><p><a id="jpcE-1670305834221"></a>进入程序ctrl+c</p><p><a id="zIuo-1670305819587"></a>2．强制关闭∶</p><p><a id="edR2-1670305819589"></a>点击启动窗口的×</p><p><a id="Otjn-1670306438500"></a>6.配置:</p><p><a id="3fcn-1670306439092"></a>部署项目的方式:</p><p><a id="3Jxt-1670306439094"></a>1.直接将项目放到webapps目录下即可。</p><p><a id="NouI-1670306481083"></a>localhost:8080/hello/hello.html</p><p><a id="icc3-1670306439096"></a>/hello:项目的访问路径--&gt;虚拟目录</p><p><a id="WHNI-1670306439098"></a>简化部署:将项目打成一个war包，再将war包放置到webapps目录下。</p><p><a id="eqMV-1670306514709"></a>war包会自动解压缩</p><p><a id="0yPS-1670306505323"></a>2.配置conf/server.xml文件在<Host>标签体中配置&lt;context docBase=”D: \hello” path=” /hehe” / &gt;</p><p><a id="Vpp6-1670306559210"></a>docBase:项目存放的路径</p><p><a id="5Owc-1670306439100"></a>path :虚拟目录</p><p><a id="haNW-1670306439102"></a>3.在conf\catalina\localhost创建任意名称的xml文件。在文件中编写</p><p><a id="y2hA-1670306439104"></a>&lt;context docBase=”D: \hello”/&gt;</p><p><a id="EVyY-1670306439106"></a>虚拟目录:xml文件的名称</p><p><a id="kKG5-1670559441640"></a>静态项目和动态项目:</p><p><a id="zxAu-1670559441951"></a>目录结构</p><p><a id="q3E6-1670559441953"></a>java动态项目的目录结构∶</p><p><a id="vNVJ-1670559441955"></a>--项目的根目录</p><p><a id="ZYXf-1670559441957"></a>-- WEB-INF目录∶</p><p><a id="PrSX-1670559441959"></a>-- web.xml : web项目的核心配置文件</p><p><a id="jzng-1670561018487"></a>-- classes目录:放置字节码文件的目录</p><p><a id="rTpl-1670561020103"></a>-- lib目录∶放置依赖的jar包</p><p><a id="9ZBB-1670559441961"></a>将Tomcat集成到IDEA中，并且创建avaEE的项目，部署项目。</p><p><a id="TXpo-1670560964510"></a>Servlet : server applet</p><p><a id="Q2ih-1670560965144"></a>*概念:运行在服务器端的小程序</p><p><a id="WwTc-1670560965146"></a>servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p><p><a id="AO6K-1670561699871"></a>将来我们自定义一个类，实现servlet接口，复写方法。</p><p><a id="JlxV-1670560965148"></a>快速入门:</p><p><a id="zGSx-1670560965150"></a>1．创建JavaEE项目</p><p><a id="lW9U-1670560965152"></a>2．定义一个类，实现servlet接口</p><p><a id="GoN5-1670560965154"></a>*public class servletDemo1 implements servlet</p><p><a id="c8Ng-1670561716728"></a>3．实现接中的抽象方法</p><p><a id="latE-1670560965156"></a>4．配置servlet</p><p><a id="6E7D-1670560965158"></a>在web.xml中配置∶</p><p><a id="aZ3V-1670561733257"></a>&lt;!--配置servlet --&gt;</p><p><a id="sfI5-1670561754240"></a><servlet></p><p><a id="aV92-1670560965160"></a><servlet\-name>demo1&lt;/servlet-name&gt;</p><p><a id="BsRB-1670560965162"></a><servlet\-class>cn.itcast.web.servlet.servletDemo1&lt;/servlet-class&gt;</p><p><a id="8CFX-1670561760806"></a>&lt;/servlet&gt;</p><p><a id="ozBR-1670560965164"></a><servlet\-mapping></p><p><a id="CP7Q-1670560965166"></a><servlet\-name>demo1&lt;/ servlet-name&gt;</p><p><a id="Y10N-1670562326809"></a><url\-pattern>/demo1&lt;/url-pattern&gt;</p><p><a id="DvUG-1670561746750"></a>&lt;/servlet-mapping&gt;</p><p><a id="9RMj-1670562296627"></a>执行原理:</p><p><a id="Itsz-1670562297131"></a>1，当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的servlet的资源路径</p><p><a id="fn3c-1670562302498"></a>2．查找web.xml文件，是否有对应的<url\-pattern>标签体内容。</p><p><a id="ViHt-1670562297133"></a>3．如果有，则在找到对应的<servlet\-class>全类名</p><p><a id="K3pH-1670562297135"></a>4. tomcat会将字节码文件加载进内存，并且创建其对象</p><p><a id="yEk1-1670562304832"></a>5．调用其方法</p><p><a id="nf4C-1670563111635"></a>servlet中的生命周期方法:</p><p><a id="Fhyx-1670563111911"></a>1．被创建:执行init方法，只执行一次</p><p><a id="FR2C-1670913366149"></a>servlet什么时候被创建?</p><p><a id="1ruW-1670913368140"></a>默认情况下，第一次被访问时，servlet被创建</p><p><a id="vt38-1670913432338"></a>可以配置执行servlet的创建时机。</p><p><a id="33CZ-1670913368142"></a>在<servlet>标签下配置</p><p><a id="wqZD-1670913368144"></a>1．第一次被访问时，创建</p><p><a id="3Ggr-1670913368146"></a>*<load\-on\-startup>的值为负数</p><p><a id="W33Q-1670913449536"></a>2．在服务器启动时，创建</p><p><a id="WQN3-1670913368148"></a>*<load\-on\-startup>的值为0或正整数</p><p><a id="86MY-1670913368150"></a>Servlet的init方法，只执行一次，说明一个servlet在内存中只存在一个对象，Servlet是单例的</p><p><a id="mM6T-1670913368152"></a>*多个用户同时访问时，可能存在线程安全问题。</p><p><a id="pSHl-1670913368154"></a>*解决∶尽量不要在servlet中定义成员变量。应使用局部变量，即使定义了成员变量，也不要对修改值</p><p><a id="ep9D-1670563116813"></a>2．提供服务:执行service方法，执行多次</p><p><a id="L2IQ-1670913387642"></a>每次访问servlet时, service方法都会被调用一次。</p><p><a id="MSKy-1670563119385"></a>3．被销毁:执行destroy方法，只执行一次</p><p><a id="4nXF-1670913406151"></a>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p><p><a id="ivog-1670913534415"></a>只有服务器正常关闭时，才会执行destroy方法。</p><p><a id="jZnr-1670913406538"></a>destroy方法在servlet被销毁之前执行，一般用于释放资源</p><p><a id="YEQd-1670917688945"></a>servlet3.0 :</p><p><a id="ZnoY-1670917705958"></a>*好处:</p><p><a id="SDNi-1670917689318"></a>*支持注解配置。可以不需要web.xml了。</p><p><a id="S2c6-1670917689320"></a>*步骤：</p><p><a id="R68R-1670917689322"></a>1．创建JavaEE项目，选择servlet的版本3.0以上，可以不创建web.xml</p><p><a id="fXnO-1670917737631"></a>2．定义一个类，实现servlet接口</p><p><a id="h8ar-1670917689324"></a>3，复写方法</p><p><a id="IXNC-1670917689326"></a>4、在类上使用@WebServlet注解，进行配置</p><p><a id="UP5j-1670917689328"></a>@WebServlet(”/资源路径”)   千万别少 /  不然服务器打不开</p><p><a id="F4Vn-1670918746653"></a>IDEA和tomcat的相关配置</p><p><a id="PKif-1670918785216"></a>1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件</p><p><a id="wufE-1670918746946"></a>查看控制台的log : using CATALINA_BASE: “C:\Users\liu.IntelliJIdea2019.3\system\tomcat_JavaWeb”</p><p><a id="BXBz-1670918771384"></a>2．工作空间项目和tomcat部署的web项目tomcat真正访问的是“tomcat部署的web项目””，”tomcat部署的web项目””对应着”工作空间项目”的web目录下的所有资源</p><p><a id="8dHD-1670918805610"></a>WEB-INF目录下的资源不能被浏览器百接访问。</p><p><a id="ZB3i-1670918746949"></a>3．断点调试:使用”小虫子”启动dubug启动</p><p><a id="qbCI-1670921691872"></a>Servlet的体系结构</p><p><a id="DVLV-1670921692749"></a>Servlet --接口===Genericservlet --抽象类===Httpservlet --抽象类</p><p><a id="oGyp-1670921692753"></a>Genericservlet:将servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><p><a id="8GSZ-1670921692755"></a>将来定义servlet类时，可以继承Genericservlet，实现service()方法即可</p><p><a id="VxdU-1670921692757"></a>Httpservlet : 对http协议的一种封装，简化操作</p><p><a id="wsqG-1670921692759"></a>1。定义类继承Httpservlet</p><p><a id="B22F-1670921692761"></a>2。复写doGet/doPost方法</p><p><a id="vqZP-1670935751194"></a>HTTP :概念:Hyper Text Transfer Protocol超文本传输协议</p><p><a id="ApZj-1670935751485"></a>传输协议∶定义了，客户端和服务器端通信时，发送数据的格式</p><p><a id="FBtj-1670998952817"></a>特点∶</p><p><a id="xKbg-1670935751487"></a>1．基于TCP/IP的高级协议</p><p><a id="4Lmz-1670998957362"></a>2．默认端口号:80</p><p><a id="lHUo-1670935751489"></a>3，基于请求/响应模型的:—次请求对应一次响应</p><p><a id="HKZJ-1670998963075"></a>4．无状态的:每次请求之间相互独立，不能交互数据</p><p><a id="SrS3-1670935751491"></a>历史版本:</p><p><a id="XUGD-1670935751493"></a>1.0:每一次请求响应都会建立新的连接</p><p><a id="8YWk-1670998968092"></a>1.1:复用连接</p><p><a id="jae8-1670998970640"></a>请求消息数据格式</p><p><a id="kTNW-1670998997111"></a>1.请求行</p><p><a id="gmkl-1670998997113"></a>请求方式 请求ur1 请求协议/版本</p><p><a id="ZUEi-1670999035731"></a>GET  /login.html  HTTP/1.1</p><p><a id="3FLy-1670998997115"></a>请求方式:</p><p><a id="KlC7-1670998997117"></a>HTTP协议有7中请求方式,常用的有2种</p><p><a id="Y6kd-1670998997119"></a>GET:</p><p><a id="EWnt-1670998997121"></a>1.请求参数在请求行中，在url后。</p><p><a id="2hWB-1670999067089"></a>2．请求的url长度有限制的</p><p><a id="qqV4-1670998997123"></a>3．不太安全</p><p><a id="dRBX-1670998997125"></a>POST:</p><p><a id="iKn2-1670998997127"></a>1.请求参数在请求体中</p><p><a id="98Wk-1670998997129"></a>2．请求的url长度没有限制的</p><p><a id="EKih-1670999084206"></a>3。相对安全</p><p><a id="mZ4U-1670998997131"></a>2．请求头:客户端浏览器告诉服务器一些信息</p><p><a id="vhQ3-1671000993137"></a>请求头名称:请求头值</p><p><a id="6bbU-1671000993139"></a>*常见的请求头︰</p><p><a id="NXut-1671000993141"></a>1.User-Agent :浏览器告诉服务器，我访问你使用的浏览器版本信息</p><p><a id="m880-1671000993143"></a>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</p><p><a id="qHwA-1671000993145"></a>2. Referer : http: //localhost/login.html</p><p><a id="ycZH-1671000993147"></a>告诉服务器，我(当前请求)从哪里来?</p><p><a id="MH9o-1671000993149"></a>*作用:</p><p><a id="4Ran-1671000993152"></a>1．防盗链:</p><p><a id="4509-1671001057511"></a>2．统计工作:</p><p><a id="ZmKu-1671000993154"></a>3．请求空行</p><p><a id="vFYM-1671000993156"></a>空行，就是用于分割POST请求的请求头，和请求体的。</p><p><a id="RMPT-1671001074758"></a>4．请求体(正文)∶</p><p><a id="rMao-1671000993158"></a>本封装POST请求消息的请求参数的</p><p><a id="I2zy-1670998997135"></a>Request :</p><p><a id="g7Xb-1671105661965"></a>1.request对象和response对象的原理</p><p><a id="nGjh-1671105661967"></a>1..request和response对象是由服务器创建的。我们来使用它们</p><p><a id="swUz-1671105687895"></a>2. request对象是来获取请求消息，response对象是来设置响应消息</p><p><a id="9uRS-1671105661969"></a>2.request对象继承体系结构:</p><p><a id="lAvQ-1671105661971"></a>servletRequest--接口  </p><p><a id="PNc6-1671105730025"></a>|    继承</p><p><a id="TlLW-1671105661973"></a>HttpServletRequest --接口</p><p><a id="buMD-1671105661975"></a>|    实现</p><p><a id="WKXG-1671105739572"></a>org.apache.catalina.connector.RequestFacade   类(tomcat)</p><p><a id="s1zy-1671105795918"></a>3.request功能∶</p><p><a id="m4sJ-1671105796598"></a>1.获取请求消息数据</p><p><a id="41cq-1671105796600"></a>1.获取请求行数据</p><p><a id="MbAi-1671105796602"></a>GET / day14/ demo1 ?name=zhangsan HTTP/1.1</p><p><a id="6cpT-1671105833236"></a>方法∶</p><p><a id="89yI-1671105796604"></a>1．获取请求方式:GET</p><p><a id="qRVb-1671105796606"></a>String getMethod()</p><p><a id="SvEC-1671105853449"></a>2.(*)获取虚拟自录:/day14</p><p><a id="7Tmr-1671105890709"></a>String getcontextPath()</p><p><a id="Yudu-1671105902783"></a>3，获取Servlet路径:/demo1</p><p><a id="SUqm-1671105796608"></a>String getServletpath()</p><p><a id="sJ4r-1671105796610"></a>4、获取get方式请求参数: name=zhangsan</p><p><a id="Skc7-1671105796612"></a>String getQuerystring()</p><p><a id="4QzX-1671105796614"></a>5．(*)获取请求URI : / day14/ demo1</p><p><a id="iqX9-1671105796616"></a>String getRequestURI():/day14/ demo1</p><p><a id="pSzt-1671105796620"></a>StringBuffer getRequestURL():h<a href="http://localhost/day14/demo1">ttp:// localhost/day14/demo1</a></p><p><a id="K0t4-1671107324242"></a>URL  统一资源定位符ht<a href="http://localhost/day14/RequestDemo1">tp://localhost/day14/RequestDemo1</a></p><p><a id="KIb1-1671107359237"></a>URI   统一资源标识符/day14/RequestDemo1</p><p><a id="tlbn-1671106040995"></a>6．获取协议及版本:HTTP/1.1</p><p><a id="IiLZ-1671105796622"></a>string getProtocol()</p><p><a id="coYK-1671105796624"></a>7．获取客户机的IP地址:</p><p><a id="Afgr-1671106074021"></a>string getRemoteAddr( )</p><p><a id="FqYq-1671107498261"></a>2．获取请求头数据</p><p><a id="gAjg-1671165897814"></a>方法:</p><p><a id="UvOd-1671165897816"></a>(*)string getHeadler (String name) :通过请求头的名称获取请求头的值</p><p><a id="3RmV-1671165909358"></a>Enumerationcstring&gt; getHeaderwames():获取所有的请求头名称</p><p><a id="haJw-1671165897818"></a>3，获取请求体数据:</p><p><a id="KG7h-1671165897820"></a>*请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p><p><a id="x4WZ-1671165931887"></a>步骤∶</p><p><a id="IyRV-1671165897822"></a>1.获取流对象</p><p><a id="HoHz-1671165897824"></a>BufferedReader getReader():获取字符输入流，只能操作字符数据</p><p><a id="WWbL-1671165897826"></a>ServletInputstream getInputStream():获取字节输入流，可以操作所有类型数据</p><p><a id="iMUJ-1671165897828"></a>在文件止传知识点后讲解</p><p><a id="1HaZ-1671165897830"></a>2.再从流对象中拿数据</p><p><a id="0VuH-1671105765122"></a>2．其他功能∶</p><p><a id="fYoj-1671193833939"></a>1.获取请求参数通用方式∶不论get还是post请求方式都可以使用下列方法来获取请求参数</p><p><a id="Gdh5-1671193833941"></a>1.string getParameter(string name):根据参数名称获取参数值username=zs&amp;password=123</p><p><a id="yL54-1671193833943"></a>2.string[] getparametervalues(string name):根据参数名称获取参数值的数组hobby=xx8hobby-game</p><p><a id="GYta-1671193865646"></a>3.Enumeration<string> getParameterNames():获取所有请求的参数名称</p><p><a id="VPNy-1671193833945"></a>4.Map<string,string\[\]>  getParameterMap():获取所有参数的map集合</p><p><a id="1Qyr-1671193887190"></a>中文乱码问题:</p><p><a id="LDKP-1671193833947"></a>get方式:tomcat 8 已经将get方式乱码问题解决了</p><p><a id="C4XV-1671193923180"></a>post方式:会乱码</p><p><a id="mXMG-1671193833949"></a>*解决︰在获取参数前，设置request的编码  request.setCharacterEncoding(“UTF-8”);</p><p><a id="Vui7-1671195020481"></a>2.请求转发:一种在服务器内部的资源跳转方式</p><p><a id="hku3-1671195050203"></a>1.步骤∶</p><p><a id="3yvz-1671195050205"></a>1．通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(string path)</p><p><a id="W8eR-1671195050207"></a>2．使用RequestDispatcher对象来进行转发∶forward(servletRequest request，ServletResponse response)</p><p><a id="j2bO-1671195050209"></a>2.特点:</p><p><a id="6bMC-1671195050211"></a>1。浏览器地址栏路径不发生变化</p><p><a id="kEI3-1671195050213"></a>2．只能转发到当前服务器内部资源中。</p><p><a id="o74s-1671195101495"></a>3。转发是一次请求</p><p><a id="GfSq-1671371733898"></a>登录跳转页面：开发步骤</p><p><a id="v4GG-1671371734414"></a>1．创建项目，导入html页面，配置文件，jar包</p><p><a id="OGQ6-1671371756698"></a>2。创建数据库环境</p><p><a id="EIiR-1671372282860"></a>driverClassName=com.mysql.cj.jdbc.Driver</p><p><a id="sbEN-1671372282862"></a>数据库路径：url=jdbc:mysql:///day14?serverTimezone=GMT%2B8</p><p><a id="lcTY-1671371734424"></a>3．创建包cn.itcast.domain,创建类User</p><p><a id="m5F9-1671371987471"></a>4．创建包cn.itcast.util,创建类JDBCUtils，使用Druid连接池</p><p><a id="CNwF-1671371792695"></a>5．创建包cn.itcast.dao,创建类UserDao,提供login方法</p><p><a id="e67d-1671372123251"></a>6．编写cn.itcast.web. servlet.Loginservlet类</p><p><a id="IRgG-1671372127167"></a>8.login.html中form表单的action路径的写法</p><p><a id="Vr6v-1671372189256"></a>虚拟目录:Servlet的资源路径action=”/data14_text/LoginServlet” </p><p><a id="gPor-1671372189258"></a>9. Beanutils工具类，简化数据封装</p><p><a id="I7Zn-1671372189260"></a>*用于封装avaBean的</p><p><a id="Gdgx-1671372189262"></a>1.JavaBean ∶标准的ava类</p><p><a id="zsMJ-1671372189264"></a>1.要求:</p><p><a id="XTPF-1671372189266"></a>1．类必须被public修饰</p><p><a id="RNGS-1671372313487"></a>2．必须提供空参的构造器</p><p><a id="CB6m-1671372189268"></a>3．成员变量必须使用private修饰</p><p><a id="3Xgy-1671372320331"></a>4。提供公共setter和getter方法</p><p><a id="5eWy-1671372324820"></a>2．功能:封装数据</p><p><a id="5jAk-1671372189270"></a>2．概念∶</p><p><a id="AeIp-1671372189272"></a>成员变量:</p><p><a id="rIUC-1671372189274"></a>属性: setter和getter方法截取后的产物</p><p><a id="L9zM-1671372468499"></a>get和set方法里大多数是和成员变量一致</p><p><a id="hzVa-1671372189276"></a>例如: getUsername() --&gt; Username--&gt; username</p><p><a id="4mm0-1671372377692"></a>3．方法:</p><p><a id="Tlxv-1671372377943"></a>1.setProperty()操作属性，而不是成员变量 设置成员变量gender值为null  设置属性hehe才能改变gender</p><p><a id="ldIW-1671372406583"></a>2.getProperty()</p><p><a id="Lnek-1671372377945"></a>3.populate(object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</p><p><a id="X4lP-1671424166238"></a>2．响应消息:服务器端发送给客户端的数据</p><p><a id="YIwC-1671424166603"></a>*数据格式∶</p><p><a id="MxW5-1671424166605"></a>1.响应行</p><p><a id="cgLM-1671424166607"></a>1.组成︰协议/版本  响应状态码  状态码描述</p><p><a id="cIlT-1671424281272"></a>HTTP/1.1 200  OK</p><p><a id="wnma-1671424166609"></a>2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。</p><p><a id="gZa8-1671424166611"></a>1.状态码都是3位数字</p><p><a id="086P-1671424166613"></a>2.分类︰</p><p><a id="PgsL-1671424166615"></a>1.1xx∶服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p><p><a id="UCwW-1671424221681"></a>2.2xx∶成功。代表:200</p><p><a id="Tau4-1671424166617"></a>3.3xx︰重定向。代表:302(重定向),304(访问缓存)</p><p><a id="i21t-1671424234096"></a>4.4xx:客户端错误。</p><p><a id="pWqZ-1671424166619"></a>代表:404(请求路径没有对应的资源)</p><p><a id="oJ62-1671424166623"></a> 405:请求方式没有对应的doXxx方法</p><p><a id="p2qW-1671424166625"></a>5.5xx:服务器端错误。代表:500(服务器内部出现异常)</p><p><a id="N4rU-1671424547000"></a>2．响应头︰</p><p><a id="amyq-1671424547346"></a>1．格式:头名称:值</p><p><a id="Ij3P-1671424557723"></a>2．常见的响应头:</p><p><a id="c3j2-1671424547348"></a>1.Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式</p><p><a id="bay2-1671424565143"></a>2.Content-disposition:服务器告诉客户端以什么格式打开响应体数据</p><p><a id="6qLg-1671424547350"></a>值:in-line:默认值,在当前页面内打开</p><p><a id="bbie-1671424547354"></a>     attachment;filename=xxx∶以附件形式打开响应体。文件下载</p><p><a id="klUU-1671424547356"></a>3．响应空行</p><p><a id="H05A-1671424547358"></a>4．响应体:传输的数据</p><p><a id="vDrn-1671425361432"></a>Response对象</p><p><a id="9hBe-1671425361762"></a>功能∶设置响应消息</p><p><a id="0ZBe-1671425361764"></a>1．设置响应行</p><p><a id="aoMK-1671425361766"></a>1．格式:HTTP/1.1 200 ok</p><p><a id="4shl-1671425361768"></a>2．设置状态码: setStatus(int sc)</p><p><a id="Ghg7-1671425361770"></a>2．设置响应头: setHeader(string name，string value)</p><p><a id="1Qx4-1671425361772"></a>3．设置响应体︰</p><p><a id="D26n-1671425361775"></a>*使用步骤︰</p><p><a id="iQAE-1671425361777"></a>1.获取输出流</p><p><a id="kwBN-1671425361779"></a>字符输出流:Printwriter getwriter()</p><p><a id="UBfn-1671425361781"></a>字节输出流: Servletoutputstream getoutputstream()</p><p><a id="YJ4t-1671425361783"></a>2.使用输出流，将数据输出到客户端浏览器</p><p><a id="6tsz-1671435466994"></a>案例∶</p><p><a id="YINA-1671435467604"></a>1．完成重定向</p><p><a id="mK9Z-1671435467606"></a>重定向:资源跳转的方式</p><p><a id="mTFn-1671435489110"></a>代码实现:</p><p><a id="WMVO-1671435467608"></a>//1.设置状态码为302</p><p><a id="Al6x-1671435467610"></a>response.setstatus( 302);</p><p><a id="ONuH-1671435501293"></a>//2.设置响应头location</p><p><a id="oXoA-1671435467612"></a>response.setHeader(“location”,” /day15/responseDemo2”);*/</p><p><a id="yM7J-1671435467614"></a></p><p><a id="wxf2-1671435514888"></a>//简单的重定向方法</p><p><a id="UH9q-1671435467616"></a>response.sendRedirect(“ /day15/responseDemo2”);</p><p><a id="lzBy-1671510343886"></a>重定向的特点: redirect</p><p><a id="HWAf-1671510344221"></a>1．地址栏发生变化</p><p><a id="onUb-1671510344223"></a>2．重定向可以访问其他站点(服务器)的资源</p><p><a id="YXjO-1671510344226"></a>3．重定向是两次请求。不能使用request对象来共享数据</p><p><a id="QvNh-1671510352434"></a>转发的特点: forward</p><p><a id="0RLr-1671510359768"></a>1．转发地址栏路径不变</p><p><a id="50n3-1671510361989"></a>2．转发只能访问当前服务器下的资源</p><p><a id="v5S2-1671510363012"></a>3．转发是一次请求，可以使用request对象来共享数据 </p><p><a id="SNqK-1671510366833"></a>forward和redirect区别</p><p><a id="9dob-1671513962648"></a>路径写法:</p><p><a id="xq4F-1671513963016"></a>1，路径分类</p><p><a id="QGYu-1671513963018"></a>1．相对路径:通过相对路径不可以确定唯一资源</p><p><a id="BDtZ-1671513963020"></a>如: ./index.html</p><p><a id="ZCor-1671513963022"></a>不以/开头，以.开头的路径</p><p><a id="rGwb-1671513963024"></a>规则∶找到当前资源和目标资源之间的相对位置关系</p><p><a id="OHzD-1671513963026"></a>./   当前目录</p><p><a id="1NpT-1671513963028"></a>../  后退一级目录</p><p><a id="eMeC-1671513963030"></a>2．绝对路径:通过绝对路径可以确定唯一资源</p><p><a id="jFH9-1671513963032"></a>如: http: //localhost/day15/responseDemo2或 /day15/responseDemo2</p><p><a id="8o16-1671513963036"></a>以/开头的路径</p><p><a id="1cL6-1671514216484"></a>规则:判断定义的路释是给谁用的?判断请求将来从哪儿发出</p><p><a id="zzWz-1671514216704"></a>1.给客户端浏览器使用:需要加虚拟目录(项目的访问路径)</p><p><a id="WvqC-1671514216706"></a>建议虚拟目录动态获取:request.getcontextpath()</p><p><a id="2tre-1671514245759"></a><a> ,<form>,重定向...</p><p><a id="DoMQ-1671514216708"></a>2.给服务器使用:不需要加虚拟目录</p><p><a id="KgLX-1671514216710"></a>转发路径</p><p><a id="Ypmz-1671520042337"></a>2．服务器输出字符数据到浏览器</p><p><a id="wL3D-1671520042802"></a>本步骤︰</p><p><a id="qoWj-1671520042805"></a>1。获取字符输出流</p><p><a id="zHkj-1671520103250"></a>2．输出数据</p><p><a id="LXJ2-1671520042809"></a>注意:</p><p><a id="cKsN-1671520042811"></a>乱码问题∶</p><p><a id="S4BZ-1671520042813"></a>1.Printwriter pw = response.getwriter();获取的流的默认编码是IS0-8859-1</p><p><a id="vQxr-1671520059531"></a>2.设置该流的默认编码</p><p><a id="flKk-1671520042815"></a>3.告诉浏览器响应体使用的编码</p><p><a id="6Obg-1671520042817"></a>//简单的形式，设置编码，是在获取流之前设置</p><p><a id="xTwh-1671520042819"></a>response.setContentType( “text/html ;charset=utf-8”);</p><p><a id="7bZF-1671520128360"></a>ServletContext对象:</p><p><a id="AvDJ-1671624122052"></a>1.概念∶代表整个web应用，可以和程序的容器(服务器)来通信</p><p><a id="TomT-1671624135301"></a>2.获取︰</p><p><a id="uPeN-1671624122054"></a>1．通过request对象获取</p><p><a id="tspp-1671624122056"></a>request.getServletContext( );</p><p><a id="ryLp-1671624154281"></a>2．通过Httpservlet获取</p><p><a id="Z2iO-1671624122058"></a>this.getServletContext();</p><p><a id="MoJC-1671624122060"></a>3．功能∶</p><p><a id="xJyM-1671624122062"></a>1．获取MIME类型:</p><p><a id="ouzk-1671624122064"></a>MIME类型:在互联网通信过程中定义的一种文件数据类型</p><p><a id="hEGr-1671624122066"></a>格式:大类型/小类型text/htmlimage/ jpeg</p><p><a id="cR8F-1671624122070"></a>获取: string getMimeType(string file)</p><p><a id="Jek2-1671624122072"></a>2．域对象︰共享数据</p><p><a id="QRe9-1671624122076"></a>3．获取文件的真实(服务器)路径</p><p><a id="PMeg-1671855488984"></a>案例:</p><p><a id="cey7-1671855489293"></a>文件下载需求:</p><p><a id="ieDM-1671855489295"></a>1．页面显示超链接</p><p><a id="z9FA-1671855489297"></a>2．点击超链接后弹出下载提示框</p><p><a id="ZroC-1671855500412"></a>3，完成圈片文件下载</p><p><a id="7YM7-1671855489299"></a>分析∶</p><p><a id="1KNc-1671855489301"></a>1．超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求</p><p><a id="JnEV-1671855506563"></a>2．任何资源都必须弹出下载提示框</p><p><a id="fYcg-1671855489303"></a>3．使用响应头设置资源的打开方式∶</p><p><a id="tjda-1671855489305"></a>content-disposition:attachment;filename=xXX</p><p><a id="mVzC-1671855521638"></a>步骤∶</p><p><a id="2IoX-1671855521985"></a>1．定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</p><p><a id="6hlg-1671855545892"></a>2．定义servlet</p><p><a id="FwXF-1671855521987"></a>1．获取文件名称</p><p><a id="Ywc5-1671855521989"></a>2．使用字节输入流加载文件进内存</p><p><a id="bfFU-1671855521991"></a>3，指定response的响应头: content-disposition:attachment;filename=xXX</p><p><a id="47sy-1671855551409"></a>4。将数据写出到response输出流</p><p><a id="7Z4L-1671855521993"></a>问题∶中文文件名问题</p><p><a id="cjTC-1671855521997"></a>*解决思路︰</p><p><a id="C30s-1671855521999"></a>1．装取客户端使用的浏览器版本信息</p><p><a id="UYYM-1671855522001"></a>2．根据不同的版本信息，设置filename的编码方式不同</p><p><a id="KcqE-1671939442517"></a>Cookie :</p><p><a id="kp16-1671939465588"></a>1.概念︰客户端会话技术，将数据保存到客户端</p><p><a id="64MZ-1671939465590"></a>2.快速入门:</p><p><a id="wCIP-1671939465592"></a>*使用步骤︰</p><p><a id="riq4-1671939465594"></a>1．创建cookie对象，绑定数据</p><p><a id="FP2T-1671939465596"></a>new cookie(string name,string value)</p><p><a id="wQOz-1671939496091"></a>2．发送cookie对象</p><p><a id="6v8A-1671939465598"></a>response.addcookie(cookie cookie)</p><p><a id="HRT9-1671939495316"></a>3．获取Cookie，拿到数据</p><p><a id="nFKU-1671939465600"></a>cookie[]  request.getcookies()</p><p><a id="osE4-1671939464867"></a>3.实现原理</p><p><a id="QrDn-1671939442861"></a>基于响应头set-cookie和请求头cookie实现</p><p><a id="pQjy-1671939442863"></a>4. cookie的细节</p><p><a id="bEzP-1671939442865"></a>1.一次可不可以发送多个cookie?</p><p><a id="nPpV-1671939442867"></a>*可以可以创建多个cookie对象，使用response调用多次addcookie方法发送cookie即可。</p><p><a id="HpR6-1671939517163"></a>2. cookie在浏览器中保存多长时间?</p><p><a id="yby0-1671939442871"></a>1．默认情况下，当浏览器关闭后，Cookie数据被销毁</p><p><a id="oNrJ-1671939528583"></a>2．持久化存储∶</p><p><a id="1ycJ-1671939442873"></a>setMaxAge(int seconds)</p><p><a id="tfCz-1671939442875"></a>1.正数∶将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p><p><a id="jkBw-1671939543748"></a>2.负数∶默认值</p><p><a id="QKb4-1671939442877"></a>3.零∶删除cookie信息</p><p><a id="Kwl3-1671939442879"></a>3.cookie能不能存中文?</p><p><a id="lFJT-1671944477223"></a>在tomcat 8之前cookie中不能直接存储中文数据。</p><p><a id="H6iV-1671944477225"></a>需要将中文数据转码---一般采用URL编码(%E3)</p><p><a id="JiYV-1671944523100"></a>在tomcat 8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p><p><a id="99Wc-1671944477227"></a>4. cookie共享问题?</p><p><a id="JJen-1671944477229"></a>1.假设在一个tomcat服务器中，部署了多个web项目,那么在这些web项目中cookie能不能共享?</p><p><a id="oN9j-1671944477231"></a>默认情况下cookie不能共享</p><p><a id="XobW-1671944477233"></a>setPath(String path):设固cookie的获取范围。默认情况下，设置当前的虚拟目录</p><p><a id="X7em-1671944477235"></a>如果要共享,则可以将path设置为”/”</p><p><a id="4zeD-1671944477237"></a>2,不同的tomcat服务器间cookie共享问题?</p><p><a id="LBsG-1671944477239"></a>setDomain(string path):如果设固一级域名相同，那么多个服务器之间cookie可以共享</p><p><a id="3UuO-1671944477241"></a>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p><p><a id="Btw3-1671944989772"></a>5.cookie的特点和作用</p><p><a id="CTdA-1671944987982"></a>1.cookie存储数据在客户端浏览器</p><p><a id="Br7S-1671944987984"></a>2.浏览器对于单个cookie 的大小有限制(akb)以及对同一个域名下的总cookie数量也有限制(20个)</p><p><a id="VJdN-1671944987986"></a>*作用:</p><p><a id="hUsU-1671944987988"></a>1.cookie—般用于存出少量的不太敏感的数据</p><p><a id="Bpaq-1671944987990"></a>2．在不登录的情况下，完成服务器对客户端的身份识别</p><p><a id="RobH-1671945780111"></a>6.案例:记住上一次访问时间</p><p><a id="tUWi-1671945780375"></a>1，需求∶</p><p><a id="ZIwB-1671945780377"></a>1．访问一个servlet，如果是第一次访问，则提示:您好，欢迎您首次访问。</p><p><a id="9vqH-1671945803300"></a>2．如果不是第一次访问，则提示:欢迎回来，您上次访问时间为;显示时间字符串</p><p><a id="yyu2-1671945780379"></a>2．分析∶</p><p><a id="mSIr-1671945780381"></a>1．可以采用cookie来完成</p><p><a id="hJVI-1671945780383"></a>2．在服务器中的servlet判断是否有一个名为lastTime的cookie</p><p><a id="pkaP-1671945780385"></a>1.有:不是第一次访向</p><p><a id="OMm8-1671945780387"></a>1.响应数据∶欢迎回来，您上次访问时间为:2018年6月10日11:50:20</p><p><a id="oTyi-1671945844591"></a>2.写回cookie : lastTime=2018年6月1e日11:50:e1</p><p><a id="CWdB-1671945780389"></a>2．没有∶是第一次访问</p><p><a id="OLwf-1671945780391"></a>1．响应数据:您好，欢迎您首次访问</p><p><a id="L99w-1671945780393"></a>2．写回cookie : lastTime=2018年6月16日11: 50:01</p><p><a id="NhBS-1671971119934"></a>JSP:入门学习</p><p><a id="V0CS-1671971125662"></a>1.概念∶Java Server Pages : java服务器端页面</p><p><a id="0vZC-1671971120212"></a>可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</p><p><a id="hZr4-1671971143742"></a>用于简化书写!!!</p><p><a id="b6JR-1671971120214"></a>2.原理</p><p><a id="ccC7-1671971120216"></a>JSP本质上就是一个servlet</p><p><a id="bHrM-1671971120218"></a>3. JSP的脚本:JSP定义ava代码的方式</p><p><a id="eT2z-1671971120220"></a>1.&lt;%  代码  %&gt;:定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。成员变量范围小</p><p><a id="TmHt-1671971168198"></a>2.&lt;%!  代码  %&gt;∶定义的java代码，在jsp转换后的java类的成员位置。成员变量范围大，全局。</p><p><a id="otKE-1671971120222"></a>3.&lt;%=  代码  %&gt;∶定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</p><p><a id="lUkM-1671971120224"></a>4. JSP的内置对象</p><p><a id="kBtb-1671972293322"></a>在jsp页面中不需要获取和创建，可以直接使用的对象</p><p><a id="Zj0z-1671972306130"></a>jsp一共有9个内置对象。</p><p><a id="Z2dL-1671972293326"></a>request</p><p><a id="ALhh-1671972293328"></a>response</p><p><a id="XKdf-1671972293330"></a>out:字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似</p><p><a id="WoMB-1671972293332"></a>response. getwriter(和out.write()的区别:</p><p><a id="5Hkz-1671972293334"></a>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</p><p><a id="6iv2-1671972341216"></a>response.getwriter()数据输出永远在out.write()之前</p><p><a id="CdYT-1672038681305"></a>Session :</p><p><a id="kWBV-1672038681589"></a>1．概念∶服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><p><a id="2vEC-1672039539500"></a>2．快速入门:</p><p><a id="Fr0I-1672038681591"></a>1．获取Httpsession对象︰</p><p><a id="XygZ-1672038681593"></a>Httpsession session = request.getsession();</p><p><a id="wrC1-1672039544531"></a>2．使用Httpsession对象∶</p><p><a id="K3wQ-1672038681595"></a>object getAttribute(string name)</p><p><a id="32G3-1672038681597"></a>void setAttribute(string name，object value)</p><p><a id="sY76-1672039549182"></a>void removeAttribute(string name)</p><p><a id="Fr7z-1672045299773"></a>3．原理</p><p><a id="kfoW-1672045300052"></a>session的实现是依赖于cookie的。</p><p><a id="rDFk-1672045300054"></a>4。细节∶</p><p><a id="Rsdu-1672045300056"></a>1．当客户端关闭后，服务器不关闭，两次获取session是否为同一个?</p><p><a id="TOnT-1672045300058"></a>默认情况下。不是。</p><p><a id="PSoY-1672045300060"></a>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p><p><a id="fjtr-1672045300062"></a>Cookie c = new Cookie(“SESSIONID” , session.getId());</p><p><a id="4uRr-1672045300064"></a>c .setMaxAge(60*60);</p><p><a id="q6a4-1672045300066"></a>response.addcookie(c);</p><p><a id="Vqp4-1672045300070"></a>2．客户端不关闭，服务器关闭后，两次获取的session是同一个吗?</p><p><a id="LM8E-1672045300072"></a>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</p><p><a id="quWY-1672045376390"></a>session的钝化:</p><p><a id="srxO-1672045380619"></a>在服务器正常关闭之前，将Session对象序列化到硬盘上 </p><p><a id="iihk-1672045382639"></a>session的活化:</p><p><a id="YPmY-1672045300074"></a>在服务器启动后，将session文件转化为内存中的session对象即可。</p><p><a id="p8ax-1672045482421"></a>3.session什么时候被销毁?</p><p><a id="yQkg-1672045500819"></a>1.服务器关闭</p><p><a id="zM7N-1672045500821"></a>2. session对象调用invalidate() 。</p><p><a id="3xyC-1672045522659"></a>3. session默认失效时间30分钟</p><p><a id="N8pA-1672045500823"></a>选择性配置修改</p><p><a id="qQXm-1672045500825"></a><session\-config></p><p><a id="8f3l-1672045500827"></a><session\-timeout>30&lt;/session-timeout&gt;</p><p><a id="3D3c-1672045536807"></a>&lt;/session-config&gt;</p><p><a id="cHyr-1672045555574"></a>4.session的特点</p><p><a id="ZRCZ-1672045671898"></a>1.session用于存储一次会话的多次请求的数据，存在服务器端</p><p><a id="SJV7-1672045685938"></a>2. session可以存储任意类型，任意大小的数据</p><p><a id="XXxx-1672045671900"></a>session与cookie的区别︰</p><p><a id="9z5W-1672045671902"></a>1.session存储数据在服务器端，Cookie在客户端</p><p><a id="M5sD-1672045709076"></a>2. session没有数据大小限制,Cookie有</p><p><a id="UNrp-1672045671904"></a>3.session数据安全,cookie相对于不安全</p><p><a id="U29G-1672285231635"></a>JSP:</p><p><a id="Wpry-1672285232297"></a>1.指令</p><p><a id="xZaG-1672285232299"></a>作用:用于配置JSP页面，导入资源文件</p><p><a id="fQQO-1672285277779"></a>格式∶&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</p><p><a id="7UvM-1672285327252"></a>分类∶</p><p><a id="fCqS-1672285232303"></a>1.page:配置SP页面的</p><p><a id="RbJs-1672285232307"></a>contentType :等同于response.setcontentType()</p><p><a id="4wyP-1672285232309"></a>1．设置响应体的mime类型以及字符集</p><p><a id="19lL-1672285232311"></a>2．设置当前jsp页面的编码（只能是高级的IDE才能生效，</p><p><a id="P6OP-1672285449662"></a>如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集)</p><p><a id="wGNR-1672285371853"></a>import :导包</p><p><a id="IGac-1672285232313"></a>errorPage :当前页面发生异常后，会自动跳转到指定的错误页面</p><p><a id="HYg8-1672285383969"></a>isErrorPage :标识当前页面是否是错误页面。</p><p><a id="pC8a-1672285232315"></a>*true :是，可以使用内置对象exception.getMessage()</p><p><a id="Bo2W-1672285232317"></a>*false :否。默认值。不可以使用内置对象exception</p><p><a id="bPPV-1672286909972"></a>2.include:页面包含的。导入页面的资源文件</p><p><a id="wnWC-1672286910237"></a>*&lt;%@include file=”top.jsp”%&gt;</p><p><a id="48pb-1672286910239"></a>3. taglib:导入资源</p><p><a id="n0aW-1672286910241"></a>*&lt;%taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p><p><a id="x9Fa-1672286910243"></a>*prefix:前缀，自定义的</p><p><a id="Exfx-1672286951512"></a>2．注释:</p><p><a id="xRut-1672286951746"></a>1.html注释:</p><p><a id="w7oS-1672286972115"></a>&lt;!--  --&gt;:只能注释html代码片段</p><p><a id="yPu5-1672286969229"></a>2. jsp注释∶推荐使用</p><p><a id="s6vX-1672286951750"></a>&lt;%--  --%&gt;∶可以注释所有</p><p><a id="LRsY-1672287024430"></a>3．内置对象</p><p><a id="bOnK-1672287024728"></a>在jsp页面中不需要创建，直接使用的对象</p><p><a id="lTBV-1672287037977"></a>一共有9个:</p><p><a id="4HQm-1672287024730"></a>变量名真实类型作用</p><p><a id="QUBk-1672287024736"></a>pageContextPagecontext当前页面共享数据，还可以获取其他八个内置对象</p><p><a id="BdKa-1672287024742"></a>requestHttpservletRequest一次请求访问的多个资源(转发)</p><p><a id="iIy6-1672287024748"></a>sessionHttpSession一次会话的多个请求间</p><p><a id="X6r1-1672287024754"></a>applicationServletContext所有用户间共享数据</p><p><a id="l938-1672287024760"></a>responseHttpservletResponse响应对象</p><p><a id="GVQ6-1672287024766"></a>pageObject当前页面(Servlet)的对象this</p><p><a id="3g7g-1672287024772"></a>outJspWriter输出对象，数据输出到页面上</p><p><a id="etol-1672287024778"></a>configServletConfigservlet的配置对象</p><p><a id="woP2-1672287024784"></a>exceptionThrowable异常对象</p><p><a id="ozqP-1672293999041"></a>MVC:开发模式</p><p><a id="h3H7-1672293999331"></a>1.M : Model，模型。JavaBean</p><p><a id="sL9O-1672293999333"></a>完成具体的业务操作，如:查询数据库，封装对象</p><p><a id="O1aH-1672294014000"></a>2.V : View，视图。JSP</p><p><a id="807Y-1672293999335"></a>展示数据</p><p><a id="Pf2k-1672293999337"></a>3.C: Controller，控制器。Servlet</p><p><a id="NWtZ-1672293999339"></a>获取用户的输入</p><p><a id="Omf9-1672293999341"></a>调用模型</p><p><a id="Nxny-1672293999343"></a>将数据交给视图进行展示</p><p><a id="IaCB-1672293999345"></a>*优缺点︰</p><p><a id="GWQ4-1672293999347"></a>1．优点:</p><p><a id="97B4-1672293999349"></a>1．耦合性低，方便维护，可以利于分工协作</p><p><a id="AtCI-1672294064667"></a>2．重用性高</p><p><a id="UaF9-1672293999351"></a>2．缺点∶</p><p><a id="Fqb2-1672293999353"></a>1．使得项目架构变得复杂，对开发人员要求高</p><p><a id="KHvq-1672410157736"></a>EL表达式</p><p><a id="d3RV-1672410158010"></a>1.概念∶Expression Language表达式语言</p><p><a id="DILi-1672410162410"></a>2.作用:替换和简化jsp页面中java代码的编写</p><p><a id="Evhx-1672410166156"></a>3.语法∶${表达式}</p><p><a id="ta07-1672410158012"></a>4.注意:</p><p><a id="WFEy-1672410158014"></a>jsp默认支持el表达式的。如果要忽略el表达式</p><p><a id="zZoD-1672410158016"></a>1.设置jsp中page指令中:isELIgnored=”true”忽略当前jsp页面中所有的el表达式</p><p><a id="D1LW-1672410205866"></a>2.  \${表达式}∶忽略当前这个el表达式</p><p><a id="7Mie-1672410282526"></a>5.使用∶</p><p><a id="w9lH-1672410282770"></a>1.运算:</p><p><a id="Jmai-1672410282772"></a>运算符:</p><p><a id="CKNl-1672410282774"></a>1.算数运算符∶+  -   *  /(div)  %(mod)</p><p><a id="wMWU-1672410319472"></a>2.比较运算符∶&gt;  &lt;  &gt;=  &lt;=  ==  !=</p><p><a id="PwAv-1672410282776"></a>3.逻辑运算符:&amp;&amp;(and)  ll(or)   !(not)</p><p><a id="fdiJ-1672410357199"></a>4.空运算符: empty</p><p><a id="aIbE-1672410282778"></a>功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0</p><p><a id="PwRC-1672410369924"></a>${empty list}   list集合内是否为null</p><p><a id="fRm0-1672413135751"></a>     ${not empty str}判断字符串、集合、数组是否不为null并且长度大于0</p><p><a id="Sq05-1672413141285"></a></p><p><a id="dXLh-1672410282780"></a>2.获取值</p><p><a id="8Oz9-1672410282782"></a>1.el表达式只能从域对象中获取值</p><p><a id="XBoD-1672410415744"></a>2.语法:</p><p><a id="HEOV-1672410423205"></a>1.${域名称.键名}∶从指定域中获取指定键的值</p><p><a id="OQxw-1672410282786"></a>域名称:</p><p><a id="9ggH-1672410282788"></a>1.pagescope--&gt; pagecontext小</p><p><a id="6kEd-1672410282792"></a>2. requestScope--&gt; request</p><p><a id="y6lf-1672410282795"></a>3.sessionscope--&gt; session</p><p><a id="EXGd-1672410282797"></a>4.applicationscope --&gt; application(servletcontext)大</p><p><a id="a9Gc-1672410490137"></a>举例:在request域中存储了 name=张三</p><p><a id="2HZQ-1672410282799"></a>获取∶${requestScope. name}</p><p><a id="Cz8u-1672410282801"></a>2.$({键名}∶表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p><p><a id="GoQ9-1672412665138"></a>3.获取对象、List集合、 Map集合的值</p><p><a id="IASl-1672412665140"></a>1.对象∶${域名称.键名.属性名}</p><p><a id="sL6o-1672412791051"></a>    ${requestScope.u.birthday}</p><p><a id="vbk0-1672412665142"></a>本质上会去调用对象的getter方法</p><p><a id="0O4a-1672412665144"></a>2.List集合∶${域名称.键名[索引]}</p><p><a id="dHq8-1672412665146"></a>3.Map集合:</p><p><a id="2MEo-1672412665149"></a>1.$[域名称.键名.key名称}</p><p><a id="Q7kH-1672412821141"></a>2.$[域名称.键名[“key名称“]</p><p><a id="UAtU-1672413675862"></a>3.隐式对象∶</p><p><a id="W2OD-1672413676084"></a>el表达式中有11个隐式对象</p><p><a id="KYMj-1672413693829"></a>pagecontext :获取jsp其他八个内置对象</p><p><a id="Akfk-1672413676088"></a>${pagecontext.request.contextPath} :动态获取虚拟目录</p><p><a id="dCMD-1672463202855"></a>JSTL</p><p><a id="0zzw-1672463203076"></a>1.概念:JavaServer Pages Tag Library   JSP标准标签库</p><p><a id="EZgz-1672463203078"></a>是由Apache组织提供的开源的免费的jsp标签&lt;标签&gt;</p><p><a id="pHQU-1672463203082"></a>2.作用:用于简化和替换jsp页面上的java代码</p><p><a id="BWHO-1672463203084"></a>3.使用步骤:</p><p><a id="cOou-1672463203086"></a>1.导入jstl相关jar包</p><p><a id="ommk-1672463203088"></a>2.引入标签库:taglib指令:&lt;%@taglib %&gt;</p><p><a id="DNts-1672463245186"></a>3.使用标签</p><p><a id="KL53-1672494991611"></a>4.常用的JSTL标签</p><p><a id="53hy-1672494992070"></a>1.if:相当于java代码的if语句</p><p><a id="qWxx-1672494992072"></a>1.属性:</p><p><a id="YUrh-1672494992074"></a>test 必须属性，接受boolean表达式</p><p><a id="KwvW-1672494992076"></a>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p><p><a id="BMU0-1672495045256"></a>一般情况下, test展性值会结合el表达式一起使用</p><p><a id="mkVI-1672494992078"></a>2．注意∶</p><p><a id="rgl1-1672494992080"></a>c :if标签没有else情况，想要else情况，则可以在定义一个c:if标签</p><p><a id="r1jS-1672494992082"></a>2. choose:相当于java代码的switch语句</p><p><a id="XT6Q-1672494992084"></a>1.使用choose标签声明相当于switch声明</p><p><a id="Z2gR-1672494992088"></a>2.使用when标签做判断相当于case</p><p><a id="EveQ-1672494992092"></a>3.使用otherwise标签做其他情况的声明相当于default</p><p><a id="B8RW-1672495120443"></a>3.foreach:相当于java代码的for语句</p><p><a id="2uZk-1672495248912"></a>1.完成重复的操作</p><p><a id="JcXI-1672495248914"></a>for(int i = 1; i &lt; 10; i ++){</p><p><a id="cl3g-1672495248916"></a>}</p><p><a id="OhTm-1672495248918"></a>属性:</p><p><a id="hADX-1672495248920"></a>begin:开始值</p><p><a id="brTa-1672495294695"></a>end:结束值</p><p><a id="Z5Jt-1672495300751"></a>var:临时变量</p><p><a id="0Pnl-1672495303135"></a>step:步长</p><p><a id="uH3c-1672495248923"></a>varStatus :循环状态对象</p><p><a id="gjeQ-1672495248925"></a>index:容器中元素的索引，从0开始</p><p><a id="W3eF-1672495318473"></a>count:循环次数，从1开始</p><p><a id="EETv-1672495361170"></a>2.遍历容器</p><p><a id="tjYN-1672495361499"></a>List<User> list;</p><p><a id="RuqO-1672495361501"></a>for( User user : list){</p><p><a id="HcPx-1672495371745"></a>}</p><p><a id="NsVO-1672495361503"></a>属性:</p><p><a id="Dnct-1672495361505"></a>items:容器对象</p><p><a id="1gHv-1672495361507"></a>var :容器中元素的临时变量</p><p><a id="U9AK-1672495389985"></a>varStatus :循环状态对象</p><p><a id="tdaM-1672495395706"></a>index:容器中元素的索引，从0开始</p><p><a id="ptjV-1672495395711"></a>count:循环次数，从1开始</p><p><a id="jXyq-1672497117289"></a>三层架构∶软件设计架构</p><p><a id="ZVzk-1672497117653"></a>1．界面层(表示层)∶用户看的得界面。用户可以通过界面上的组件和服务器进行交互cn.itcast.项目名.web</p><p><a id="9PZB-1672497122505"></a>2．业务逻辑层∶处理业务逻辑的。cn.itcast.项目名.service</p><p><a id="0aJN-1672497117655"></a>3．数据访问层:操作数据存储文件。cn.itcast.项目名.dao</p><p><a id="UnYD-1672896814538"></a>Filter:过滤器</p><p><a id="86eR-1672896819346"></a>1.概念:</p><p><a id="GvwT-1672896814796"></a>生活中的过滤器:净水器,空气净化器，士匪、</p><p><a id="PAq8-1672896814798"></a>web中的过滤器﹔当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</p><p><a id="rjT2-1672896837519"></a>过滤器的作用:</p><p><a id="J45B-1672896814800"></a>一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤...</p><p><a id="1Nvf-1672896814802"></a>2.快速入门:</p><p><a id="0lFR-1672896814804"></a>1.步骤:</p><p><a id="hO7Y-1672896814806"></a>1.定义干个类，实现接口Filter</p><p><a id="Q2CU-1672896861689"></a>2.复写方法</p><p><a id="IbCT-1672896814808"></a>3.配置拦截路释</p><p><a id="19Nh-1672896814810"></a>1.web.xml</p><p><a id="HiPT-1672896875598"></a>2.注解@WebFilter(“/*“)  //访问所有资源之前，都会执行该过滤器</p><p><a id="xc9a-1672899842506"></a>3.过滤器细节:</p><p><a id="VQm7-1672899843002"></a>1.web.xml配置</p><p><a id="2pgJ-1672899843004"></a><filter></p><p><a id="YNGE-1672899843006"></a><filter\-name>demo1&lt;/filter-name&gt;</p><p><a id="0IEp-1672899843008"></a><filter\-class>cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;</p><p><a id="Ikro-1672899874889"></a>&lt;/filter&gt;</p><p><a id="ATVZ-1672899843010"></a><filter\-mapping></p><p><a id="opLV-1672899843012"></a><filter\-name>demo1&lt;/filter-name&gt;</p><p><a id="324C-1672899857734"></a>&lt;!--拦截路径--&gt;</p><p><a id="fYvg-1672899843014"></a><url\-pattern>/*&lt;/ url-pattern&gt;</p><p><a id="TGJq-1672899863495"></a>&lt;/filter-mapping&gt;</p><p><a id="xxZv-1672899843016"></a>2.过滤器执行流程</p><p><a id="ZyzM-1672899843018"></a>1.执行过滤器</p><p><a id="CliD-1672899843020"></a>2.执行放行后的资源</p><p><a id="bAAd-1672899843022"></a>3.回来执行过滤器放行代码下边的代码</p><p><a id="Qp4q-1672899908234"></a>3.过滤器生命周期对法</p><p><a id="G0CN-1672899843024"></a>1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</p><p><a id="Xvxb-1672899972161"></a>2.doFilter:每一次请求被拦截资源时，会执行。执行多次</p><p><a id="teH7-1672899843026"></a>3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</p><p><a id="Enjf-1672899986633"></a>4.过滤器配置详解</p><p><a id="XGYT-1672930116413"></a>拦截路径配置:</p><p><a id="FOG1-1672930116415"></a>1.具体资源路径:  /index.jsp 只有访问index.jsp资源时，过滤器才会被执行</p><p><a id="5LZl-1672930144087"></a>2.拦截目录:  /user/  访问/user下的所有资源时，过滤器都会被执行</p><p><a id="aReV-1672930170078"></a>3.后缀名拦截:  *.jsp  访问所有后缀名为jsp资源时，过滤器都会被执行</p><p><a id="asbd-1672930192255"></a>4.拦截所有资源:  /*  访问所有资源时，过滤器都会被执行</p><p><a id="7JpJ-1672930116417"></a>拦截方式配置:资源被访问的方式</p><p><a id="cT92-1672930116419"></a>注解配置∶</p><p><a id="mwds-1672930116421"></a>设置dispatcherTypes属性</p><p><a id="JKEq-1672930116423"></a>1.REQUEST:默认值。浏览器直接请求资源</p><p><a id="h2UI-1672930254713"></a>2.FORWARD∶转发访问资源</p><p><a id="RPZf-1672930116425"></a>3.INCLUDE:包含访问资源</p><p><a id="XYz4-1672930267392"></a>4.ERROR:错误跳转资源</p><p><a id="MQQ3-1672930268806"></a>5. ASYNC:异步访问资源</p><p><a id="QrBE-1672930116427"></a>web.xml配置</p><p><a id="2fzG-1672930116429"></a>*设置<dispatcher></dispatcher>标签即可</p><p><a id="lg7p-1672899843028"></a>5.过滤器链(配置多个过滤器)</p><p><a id="g8aT-1673151423063"></a>执行顺序:如果有两个过滤器∶过滤器1和过滤器2</p><p><a id="UA0d-1673151423065"></a>1．过滤器1</p><p><a id="B0xg-1673151423067"></a>2．过滤器2</p><p><a id="vRMW-1673151440227"></a>3．资源执行</p><p><a id="TDf8-1673151441961"></a>4．过滤器2</p><p><a id="hlbh-1673151443878"></a>5．过滤器1</p><p><a id="O3BI-1673151423069"></a>过滤器先后顺序问题:</p><p><a id="hzDG-1673151423071"></a>1．注解配置:按照类名的字符串比较规则比较，值小的先执行</p><p><a id="obWo-1673151486339"></a>Demo6大于Demo176大于1</p><p><a id="v1Kl-1673151516307"></a>Demo6大于Demo76小于7</p><p><a id="dUWG-1673151423073"></a>*如:AFilter和BFilter,AFilter就先执行了。</p><p><a id="FZ61-1673151423075"></a>2. web.xml配置: <filter\-mapping>谁定义在上边，谁先执行</p><p><a id="Hm2E-1673265854790"></a>增强对象的功能:</p><p><a id="ABrM-1673265855026"></a>设计模式:一些通用的解决固定问题的方式</p><p><a id="3nDp-1673265899107"></a>1．装饰模式</p><p><a id="XYte-1673265933378"></a>2．代理模式</p><p><a id="Rxwq-1673265934989"></a>概念:</p><p><a id="2Nd8-1673265940585"></a>1．真实对象:被代理的对象</p><p><a id="L7Hq-1673265942224"></a>2．代理对象:</p><p><a id="L7Qb-1673265943273"></a>3．代理模式:代理对象代理真实对象，达到增强真实对象功能的目的</p><p><a id="AsCx-1673265950495"></a>实现方式:</p><p><a id="N7rb-1673265855028"></a>1．静态代理:有一个类文件描述代理模式</p><p><a id="a2po-1673265966790"></a>2．动态代理:在内存中形成代理类</p><p><a id="cF8F-1673265855030"></a>*实现步骤:</p><p><a id="wHYx-1673265855032"></a>1．代理对象和真实对象实现相同的接口</p><p><a id="8Trv-1673265977819"></a>2．代理对象= Proxy.newInstance();</p><p><a id="6CIC-1673265982018"></a>3，使用代理对象调用方法。</p><p><a id="PoAj-1673265855034"></a>4．增强方法</p><p><a id="NYZd-1673275806056"></a>增强方式:</p><p><a id="Nezj-1673275806394"></a>1．增强参数列表</p><p><a id="Mvla-1673275815491"></a>2．增强返回值类型</p><p><a id="Ew53-1673275816601"></a>3，增强方法体执行逻辑</p><p><a id="5JTo-1673276637690"></a>Listener :监听器</p><p><a id="yQu7-1673276637980"></a>*概念: web的三大组件之一。</p><p><a id="IRJe-1673276637982"></a>事件监听机制</p><p><a id="pwMO-1673276637984"></a>事件:一件事情</p><p><a id="255v-1673276637986"></a>事件源:事件发生的地方</p><p><a id="4azM-1673276670190"></a>监听器:一个对象</p><p><a id="yX0N-1673276637988"></a>注册监听︰将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码</p><p><a id="Oxuf-1673276704950"></a>ServletContextListener:监听servletcontext对象的创建和销毁</p><p><a id="rY6P-1673276637992"></a>方法:</p><p><a id="x4Oi-1673276637994"></a>void contextDestroyed(servletContextEvent sce) : servletContext对象被销毁之前会调用该方法 </p><p><a id="Ymor-1673276724383"></a>void contextInitialized(ServletContextEvent sce) : servletContext对象创建后会调用该方法</p><p><a id="srxi-1673277985494"></a>步骤︰</p><p><a id="0qdI-1673277985496"></a>1.定义一个类，实现servletcontextListener接口</p><p><a id="4fiX-1673278025825"></a>2.复写方法</p><p><a id="3OgG-1673277985498"></a>3.配置</p><p><a id="NN5r-1673277985500"></a>1.web.xml</p><p><a id="tqFE-1673277985502"></a><listener></p><p><a id="Wulg-1673277985504"></a><listener\-class>cn.itcast.web.listener.contextLoaderListener&lt;/listener-class&gt;</p><p><a id="T4lo-1673278037157"></a>&lt; /listener&gt;</p><p><a id="t3Vz-1673277985506"></a>*指定初始化参数<context\-param></p><p><a id="jmXc-1673277985508"></a>2.注解∶</p><p><a id="lkvc-1673277985510"></a>@webListener</p><p><a id="h8Vj-1673448284087"></a>Query基础:</p><p><a id="3MxI-1673448337306"></a>1.概念∶一个Javascript框架。简化js开发</p><p><a id="ayEU-1673448337308"></a>JQuery是一个快速、简洁的Javascript框架，是继Prototype之后又一个优秀的Javascript代码库(或Javascript框架)。JQuery设计的宗旨是”Write Less，Do More””，即倡导写更少的代码，做更多的事情。它封装Javascript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p><p><a id="TwHH-1673448337312"></a>Javascript框架:本质上就是一些js文件，封装了js的原生代码而已</p><p><a id="aUQC-1673448441868"></a>2.快速入门：</p><p><a id="zAZU-1673448452625"></a>1.步骤</p><p><a id="0W3g-1673448471995"></a>1.下载JQuery</p><p><a id="mw89-1673448492840"></a>目前jQuery有三个大版本：</p><p><a id="AA0t-1673448512769"></a>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，</p><p><a id="cVtL-1673448512773"></a>最终版本：1.12.4 (2016年5月20日)</p><p><a id="2X0r-1673448512775"></a>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，</p><p><a id="UeDC-1673448512779"></a>最终版本：2.2.4 (2016年5月20日)</p><p><a id="vSFc-1673448512781"></a>3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。</p><p><a id="7NE3-1673448512785"></a>目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p><p><a id="LEc7-1673448604285"></a>jquery-xxx.js与jquery-xxx.min.js区别:</p><p><a id="iVvz-1673448604649"></a>1.jquery-xxx.js :开发版本。给程序员看的，有良好的缩进和注释。体积大一些</p><p><a id="RCJe-1673448604651"></a>2.jquery-xxx.min.js :生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</p><p><a id="jOnU-1673448604653"></a>2.导入JQuery的js文件:导入min.js文件</p><p><a id="9BJo-1673448604655"></a>3.使用</p><p><a id="x5YJ-1673528064401"></a>let div1 = $(“#div1”);</p><p><a id="LoU4-1673528076006"></a>       alert(div1.html());</p><p><a id="kZp5-1673530205702"></a>3.JQuery对象和js对象区别与转换</p><p><a id="1YKQ-1673530211153"></a>1. JQuery对象在操作时，更加方便。</p><p><a id="kvAq-1673530241323"></a>2. JQuery对象和js对象方法不通用．</p><p><a id="KgA9-1673530248862"></a>3．两者相互转换</p><p><a id="APNN-1673530211155"></a>jq -- &gt; js : jq对象[索引]或者jq对象.get(索引)</p><p><a id="bEd4-1673530258530"></a>js -- &gt; jq : $(js对象)</p><p><a id="J9eG-1673533261068"></a>4. 选择器：筛选具有相似特征的元素(标签)</p><p><a id="kt2S-1673533268178"></a><br>1. 基本操作学习：</p><p><a id="lD8g-1673533268182"></a>1. 事件绑定</p><p><a id="PVNl-1673533268184"></a>//1.获取b1按钮</p><p><a id="c8vw-1673533268186"></a>          $(“#b1”).click(function(){</p><p><a id="bUoF-1673533268188"></a>                alert(“abc”);</p><p><a id="4qvu-1673533268190"></a>           });</p><p><a id="XGfj-1673533268192"></a>2. 入口函数</p><p><a id="OCs6-1673533268194"></a> $(function () {</p><p><a id="1F5V-1673533268198"></a>        });</p><p><a id="2Vx8-1673533268200"></a>window.onload  和 $(function) 区别</p><p><a id="wfD8-1673533268202"></a>                 window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉</p><p><a id="Or8a-1673533268204"></a>                 $(function)可以定义多次的。</p><p><a id="NrEe-1673533268206"></a>3. 样式控制：css方法</p><p><a id="jhRc-1673533268208"></a> //$(“#div1”).css(“background-color”,”red”);</p><p><a id="LLXw-1673533268210"></a>          $(“#div1”).css(“backgroundColor”,”pink”);</p><p><a id="XkgT-1673667346369"></a></p><p><a id="7o8w-1673533268212"></a></p><p><a id="5Pvf-1673533268214"></a>2. 分类</p><p><a id="qzgW-1673667350139"></a>1. 基本选择器</p><p><a id="aVEZ-1673667350141"></a>1. 标签选择器（元素选择器）</p><p><a id="IWIy-1673667350143"></a>* 语法： $(“html标签名”) 获得所有匹配标签名称的元素</p><p><a id="fjlz-1673667350145"></a>2. id选择器 </p><p><a id="G3Oh-1673667350147"></a>* 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</p><p><a id="E7re-1673667350149"></a>3. 类选择器</p><p><a id="18Mv-1673667350151"></a>* 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</p><p><a id="Epo3-1673667350153"></a>4. 并集选择器：</p><p><a id="deEb-1673667350156"></a>* 语法： $(“选择器1,选择器2....“) 获取多个选择器选中的所有元素</p><p><a id="4TlN-1673667350158"></a>2. 层级选择器</p><p><a id="zsJ5-1673667350160"></a>1. 后代选择器</p><p><a id="FRcw-1673667350162"></a>* 语法： $(“A B “) 选择A元素内部的所有B元素</p><p><a id="QKKP-1673667350164"></a>2. 子选择器</p><p><a id="qc17-1673667350166"></a>* 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</p><p><a id="JArN-1673667350168"></a>3. 属性选择器</p><p><a id="zjys-1673667350170"></a>1. 属性名称选择器 </p><p><a id="fiW4-1673667350172"></a>* 语法： $(“A[属性名]“) 包含指定属性的选择器</p><p><a id="TqaF-1673667350174"></a>2. 属性选择器</p><p><a id="1FZ6-1673667350176"></a>* 语法： $(“A[属性名=’值’]“) 包含指定属性等于指定值的选择器</p><p><a id="NJ9D-1673667350178"></a>3. 复合属性选择器</p><p><a id="2zFF-1673667350180"></a>* 语法： $(“A[属性名=’值’][]...“) 包含多个属性条件的选择器</p><p><a id="JGwJ-1673704142730"></a>4. 过滤选择器</p><p><a id="Fefk-1673704146011"></a>1. 首元素选择器 </p><p><a id="SuXW-1673704146013"></a>* 语法： :first 获得选择的元素中的第一个元素</p><p><a id="ZGir-1673704146015"></a>2. 尾元素选择器 </p><p><a id="odcC-1673704146017"></a>* 语法： :last 获得选择的元素中的最后一个元素</p><p><a id="OI1Y-1673704146019"></a>3. 非元素选择器</p><p><a id="pCCX-1673704146021"></a>* 语法： :not(selector) 不包括指定内容的元素</p><p><a id="g0P9-1673704146023"></a>4. 偶数选择器</p><p><a id="KNUc-1673704146025"></a>* 语法： :even 偶数，从 0 开始计数</p><p><a id="8CBN-1673704146027"></a>5. 奇数选择器</p><p><a id="w3hl-1673704146029"></a>* 语法： :odd 奇数，从 0 开始计数</p><p><a id="2Y1U-1673704146031"></a>6. 等于索引选择器</p><p><a id="AgDT-1673704146033"></a>* 语法： :eq(index) 指定索引元素</p><p><a id="jyXv-1673704146035"></a>7. 大于索引选择器 </p><p><a id="67t1-1673704146037"></a>* 语法： :gt(index) 大于指定索引元素</p><p><a id="EU6Y-1673704146039"></a>8. 小于索引选择器 </p><p><a id="2FlX-1673704146041"></a>* 语法： :lt(index) 小于指定索引元素</p><p><a id="Ss4Z-1673704146043"></a>9. 标题选择器</p><p><a id="GOjA-1673704146045"></a>* 语法： :header 获得标题（h1~h6）元素，固定写法</p><p><a id="RSR9-1673704146047"></a>5. 表单过滤选择器</p><p><a id="fBsH-1673704146049"></a>1. 可用元素选择器 </p><p><a id="CPky-1673704146051"></a>* 语法： :enabled 获得可用元素</p><p><a id="2i3c-1673704146053"></a>2. 不可用元素选择器 </p><p><a id="2hZb-1673704146055"></a>* 语法： :disabled 获得不可用元素</p><p><a id="ZVqQ-1673704146057"></a>3. 选中选择器 </p><p><a id="TBdP-1673704146059"></a>* 语法： :checked 获得单选/复选框选中的元素</p><p><a id="t19X-1673704146061"></a>4. 选中选择器 </p><p><a id="m28i-1673704146063"></a>* 语法： :selected 获得下拉框选中的元素</p><p><a id="yIec-1674897966074"></a></p><p><a id="ezpa-1673704146065"></a>5. DOM操作</p><p><a id="CT1x-1674897970827"></a>1. 内容操作</p><p><a id="NBPk-1674897970829"></a></p><p><a id="UoLR-1674897970831">&lt;/a&gt;2. text(): 获取/设置元素的标签体纯文本内容   <a><font>内容</font></a> --&gt; 内容</p><p><a id="XIk4-1674897970833"></a>3. val()： 获取/设置元素的value属性值</p><p><a id="HGpG-1674897970835"></a>2. 属性操作</p><p><a id="Yypj-1674897970837"></a>1. 通用属性操作</p><p><a id="BJDX-1674897970839"></a>1. attr(): 获取/设置元素的属性</p><p><a id="wD2x-1674897970841"></a>2. removeAttr():删除属性</p><p><a id="sJQh-1674897970843"></a>3. prop():获取/设置元素的属性</p><p><a id="5i87-1674897970845"></a>4. removeProp():删除属性</p><p><a id="LBe8-1674897970847"></a></p><p><a id="phN8-1674897970849"></a>* attr和prop区别？</p><p><a id="GkBY-1674897970851"></a>1. 如果操作的是元素的固有属性，则建议使用prop</p><p><a id="CkmW-1674897970853"></a>2. 如果操作的是元素自定义的属性，则建议使用attr</p><p><a id="cdMN-1674897970856"></a>2. 对class属性操作</p><p><a id="wyz2-1674897970858"></a>1. addClass():添加class属性值</p><p><a id="IM4U-1674897970860"></a>2. removeClass():删除class属性值</p><p><a id="e5Fl-1674897970862"></a>3. toggleClass():切换class属性切换样式</p><p><a id="aAXW-1674897970864"></a>* toggleClass(“one”): </p><p><a id="mlXy-1674897970866"></a>* 判断如果元素对象上存在class=”one”，则将属性值one删除掉。  如果元素对象上不存在class=”one”，则添加</p><p><a id="qVxG-1674897970868"></a>4. css():</p><p><a id="FLmD-1674899419743"></a>3. CRUD操作:</p><p><a id="9G9f-1674899423139"></a>1. append():父元素将子元素追加到末尾</p><p><a id="UHdK-1674899423141"></a>* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</p><p><a id="SQTo-1674899423143"></a>2. prepend():父元素将子元素追加到开头</p><p><a id="9yuq-1674899423145"></a>* 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</p><p><a id="nkwJ-1674899423147"></a>3. appendTo():</p><p><a id="loCB-1674899423149"></a>* 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</p><p><a id="4we2-1674899423151"></a>4. prependTo()：</p><p><a id="hbfd-1674899423153"></a>* 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</p><p><a id="SygU-1674899423155"></a></p><p><a id="dQ8f-1674899423157"></a></p><p><a id="SHUd-1674899423159"></a>5. after():添加元素到元素后边</p><p><a id="RLUe-1674899423161"></a>* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</p><p><a id="ou1L-1674899423163"></a>6. before():添加元素到元素前边</p><p><a id="5P4G-1674899423165"></a>* 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</p><p><a id="dT5m-1674899423167"></a>7. insertAfter()</p><p><a id="fQI0-1674899423169"></a>* 对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</p><p><a id="QUyv-1674899423171"></a>8. insertBefore()</p><p><a id="rEz0-1674899423173"></a>* 对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</p><p><a id="fSHn-1674899423175"></a></p><p><a id="frhQ-1674899423177"></a>9. remove():移除元素</p><p><a id="VS30-1674899423179"></a>* 对象.remove():将对象删除掉</p><p><a id="hxn2-1674899423181"></a>10. empty():清空元素的所有后代元素。</p><p><a id="3aTL-1674899423183"></a>* 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点里面的东西没了   标签还在</p><p><a id="d7z1-1674911742760"></a></p><p><a id="4PSJ-1674899423185"></a>JQuery 高级</p><p><a id="EpFn-1674911746476"></a>1. 动画</p><p><a id="mSZv-1674911746478"></a>1. 三种方式显示和隐藏元素</p><p><a id="HHKZ-1674911746480"></a>1. 默认显示和隐藏方式</p><p><a id="mqSm-1674911746482"></a>1. show([speed],[easing],[fn]])</p><p><a id="aI2z-1674911746484"></a>1. 参数：</p><p><a id="xqGy-1674911746486"></a>1. speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</p><p><a id="mFU0-1674911746488"></a>2. easing：用来指定切换效果，默认是”swing”，可用参数”linear”</p><p><a id="stgc-1674911746490"></a>* swing：动画执行时效果是 先慢，中间快，最后又慢</p><p><a id="nddn-1674911746492"></a>* linear：动画执行时速度是匀速的</p><p><a id="5skg-1674911746494"></a>3. fn：在动画完成时执行的函数，每个元素执行一次。</p><p><a id="ozpm-1674911746496"></a></p><p><a id="Xw6u-1674911746498"></a>2. hide([speed],[easing],[fn]])</p><p><a id="DLLk-1674911746500"></a>3. toggle([speed],[easing],[fn])</p><p><a id="imYa-1674911746502"></a></p><p><a id="j69k-1674911746504"></a>2. 滑动显示和隐藏方式</p><p><a id="Yh7M-1674911746506"></a>1. slideDown([speed],[easing],[fn])</p><p><a id="Xyj7-1674911746508"></a>2. slideUp([speed],[easing],[fn]])</p><p><a id="mfjh-1674911746510"></a>3. slideToggle([speed],[easing],[fn])</p><p><a id="fuLO-1674911746512"></a></p><p><a id="Lyu0-1674911746514"></a>3. 淡入淡出显示和隐藏方式</p><p><a id="S4Zj-1674911746516"></a>1. fadeIn([speed],[easing],[fn])</p><p><a id="KJ1r-1674911746518"></a>2. fadeOut([speed],[easing],[fn])</p><p><a id="UoF7-1674911746520"></a>3. fadeToggle([speed],[easing],[fn]])</p><p><a id="P3fJ-1674917428974"></a>2. 遍历</p><p><a id="pNwf-1674917432494"></a>1. js的遍历方式</p><p><a id="LhdP-1674917432496"></a>* for(初始化值;循环结束条件;步长)</p><p><a id="zQGW-1674917432498"></a>2. jq的遍历方式</p><p><a id="MKO1-1674917432501"></a>1. jq对象.each(callback)</p><p><a id="2qXH-1674917432503"></a>1. 语法：</p><p><a id="LJ69-1674917432505"></a>jquery对象.each(function(index,element){});</p><p><a id="wiBD-1674917432507"></a>* index:就是元素在集合中的索引</p><p><a id="SUsx-1674917432509"></a>* element：就是集合中的每一个元素对象</p><p><a id="MgUj-1674917432513"></a>* this：集合中的每一个元素对象</p><p><a id="gVVx-1674917432515"></a>2. 回调函数返回值：</p><p><a id="kAws-1674917432517"></a>* true:如果当前function返回为false，则结束循环(break)。</p><p><a id="D2LL-1674917432519"></a>* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</p><p><a id="vl12-1674917432521"></a>2. $.each(object, [callback])</p><p><a id="QqPy-1674917432523"></a>3. for..of: jquery 3.0 版本之后提供的方式</p><p><a id="cApz-1674917432525"></a>for(元素对象 of 容器对象)</p><p><a id="rCKc-1674984025827"></a>3. 事件绑定</p><p><a id="cioW-1674984032040"></a>1. jquery标准的绑定方式</p><p><a id="et33-1674984032042"></a>* jq对象.事件方法(回调函数)；</p><p><a id="rYF8-1674984032044"></a>* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。</p><p><a id="X8Fp-1674984032046"></a>* 表单对象.submit();//让表单提交</p><p><a id="1Esk-1674984032048"></a>2. on绑定事件/off解除绑定</p><p><a id="iQQ4-1674984032050"></a>* jq对象.on(“事件名称”,回调函数)</p><p><a id="TmnR-1674984032052"></a>* jq对象.off(“事件名称”)</p><p><a id="vKzI-1674984032054"></a>* 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</p><p><a id="CKf3-1674984032056"></a>3. 事件切换：toggle</p><p><a id="KdMc-1674984032058"></a>* jq对象.toggle(fn1,fn2...)</p><p><a id="6hDo-1674984032060"></a>* 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....</p><p><a id="pCTw-1674984032064"></a>* 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p><p><a id="YaLt-1674984032066"></a> <script src="\.\./js/jquery\-migrate\-1\.0\.0\.js" type="text/javascript" charset="utf\-8"></script></p><p><a id="lI40-1675003506995"></a>4. 插件：增强JQuery的功能</p><p><a id="rlmR-1675003511331"></a>1. 实现方式：</p><p><a id="n4Ba-1675003511333"></a>1. $.fn.extend(object) </p><p><a id="BLfP-1675003511335"></a>* 增强通过Jquery获取的对象的功能  $(“#id”)</p><p><a id="gSoO-1675003511337"></a>2. $.extend(object)</p><p><a id="uqim-1675003511339"></a>* 增强JQeury对象自身的功能  $/jQuery</p><p><a id="kb3D-1675003511341"></a>AJAX：</p><p><a id="OabW-1675173699506"></a>1. 概念： ASynchronous JavaScript And XML异步的JavaScript 和 XML</p><p><a id="XNf5-1675173699508"></a>1. 异步和同步：客户端和服务器端相互通信的基础上</p><p><a id="lVhg-1675173699510"></a>* 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</p><p><a id="sv05-1675173699512"></a>* 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p><p><a id="Gl3p-1675173699514"></a></p><p><a id="FY7i-1675173699516"></a>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] </p><p><a id="GG9l-1675173699518"></a>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p><a id="oHaW-1675173699520"></a>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p><a id="HgYT-1675173699523"></a></p><p><a id="ilup-1675173699525"></a>提升用户的体验</p><p><a id="ARAS-1675173699527"></a></p><p><a id="Ybvx-1675173699529"></a>2. 实现方式：</p><p><a id="Jtso-1675175751894"></a>1. 原生的JS实现方式（了解）</p><p><a id="JIZZ-1675175737422"></a>2. JQeury实现方式</p><p><a id="Xt16-1675175706080"></a>1. $.ajax()</p><p><a id="slk9-1675175706082"></a>* 语法：$.ajax({键值对});</p><p><a id="wcbs-1675175706084"></a> //使用$.ajax()发送异步请求</p><p><a id="bLiH-1675175706114"></a>2. $.get()：发送get请求</p><p><a id="lU4y-1675175706116"></a>* 语法：$.get(url, [data], [callback], [type])</p><p><a id="b1HF-1675175706118"></a>* 参数：</p><p><a id="oYnW-1675175706120"></a>* url：请求路径</p><p><a id="8d9p-1675175706122"></a>* data：请求参数</p><p><a id="LL2E-1675175706124"></a>* callback：回调函数</p><p><a id="Swte-1675175706126"></a>* type：响应结果的类型</p><p><a id="setz-1675175706128"></a></p><p><a id="N5Ux-1675175706130"></a>3. $.post()：发送post请求</p><p><a id="3GPT-1675175706132"></a>* 语法：$.post(url, [data], [callback], [type])</p><p><a id="kD2y-1675175706134"></a>* 参数：</p><p><a id="eZaj-1675175706136"></a>* url：请求路径</p><p><a id="KbfK-1675175706138"></a>* data：请求参数</p><p><a id="uP2g-1675175706140"></a>* callback：回调函数</p><p><a id="Nk1e-1675175706142"></a>* type：响应结果的类型</p><p><a id="HKaK-1675175706144"></a>JSON：</p><p><a id="7lSI-1675226827751"></a>1. 概念： JavaScript Object NotationJavaScript对象表示法</p><p><a id="tbBU-1675226827767"></a>* json现在多用于存储和交换文本信息的语法</p><p><a id="Bj1b-1675226827769"></a>* 进行数据的传输</p><p><a id="3jmb-1675226827771"></a>* JSON 比 XML 更小、更快，更易解析。</p><p><a id="ZU5j-1675226827775"></a>2. 语法：</p><p><a id="lobe-1675226827777"></a>1. 基本规则</p><p><a id="lemz-1675226827779"></a>* 数据在名称/值对中：json数据是由键值对构成的</p><p><a id="1sHm-1675226827781"></a>* 键用引号(单双都行)引起来，也可以不使用引号</p><p><a id="tOTb-1675226827783"></a>* 值得取值类型：</p><p><a id="7gHZ-1675226827785"></a>1. 数字（整数或浮点数）</p><p><a id="ERcE-1675226827787"></a>2. 字符串（在双引号中）</p><p><a id="bAtB-1675226827789"></a>3. 逻辑值（true 或 false）</p><p><a id="6ZP6-1675226827791"></a>4. 数组（在方括号中）{“persons”:[{},{}]}</p><p><a id="qgsL-1675226827793"></a>5. 对象（在花括号中） {“address”:{“province”：”陕西”....}}</p><p><a id="nBUS-1675226827795"></a>6. null</p><p><a id="Wnto-1675226827797"></a>* 数据由逗号分隔：多个键值对由逗号分隔</p><p><a id="YetI-1675226827799"></a>* 花括号保存对象：使用{}定义json 格式</p><p><a id="WuQX-1675226827801"></a>* 方括号保存数组：[]</p><p><a id="0ht4-1675226827803"></a>2. 获取数据:</p><p><a id="JU3f-1675226827805"></a>1. json对象.键名</p><p><a id="MMHj-1675226827807"></a>2. json对象[“键名”]</p><p><a id="6flm-1675226827809"></a>3. 数组对象[索引]</p><p><a id="lPDC-1675226827811"></a>4. 遍历</p><p><a id="JWki-1675342491612"></a>3. JSON数据和Java对象的相互转换</p><p><a id="gYi3-1675342494795"></a></p><p><a id="Eev2-1675342494797"></a>* JSON解析器：</p><p><a id="jygu-1675342494799"></a>* 常见的解析器：Jsonlib，Gson，fastjson，jackson</p><p><a id="2hEJ-1675342494801"></a></p><p><a id="kaME-1675342494803"></a>1. JSON转为Java对象</p><p><a id="proV-1675342494806"></a>1. 导入jackson的相关jar包</p><p><a id="zaNA-1675342494808"></a>2. 创建Jackson核心对象 ObjectMapper</p><p><a id="zLuP-1675342494810"></a>3. 调用ObjectMapper的相关方法进行转换</p><p><a id="FqSV-1675342494812"></a>1. readValue(json字符串数据,Class)</p><p><a id="NiNj-1675342494814"></a>2. Java对象转换JSON</p><p><a id="3eOq-1675342494816"></a>1. 使用步骤：</p><p><a id="ajKc-1675342494818"></a>1. 导入jackson的相关jar包</p><p><a id="KHXk-1675342494820"></a>2. 创建Jackson核心对象 ObjectMapper</p><p><a id="HnZ8-1675342494822"></a>3. 调用ObjectMapper的相关方法进行转换</p><p><a id="tVGO-1675342494824"></a>1. 转换方法：</p><p><a id="KxfV-1675342494826"></a>* writeValue(参数1，obj):</p><p><a id="eF1D-1675342494828"></a>                    参数1：</p><p><a id="RrHq-1675342494830"></a>                        File：将obj对象转换为JSON字符串，并保存到指定的文件中</p><p><a id="dxod-1675342494832"></a>                        Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</p><p><a id="UZFK-1675342494834"></a>                        OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</p><p><a id="BKjd-1675342494836"></a>                * writeValueAsString(obj):将对象转为json字符串</p><p><a id="YIm3-1675342494838"></a></p><p><a id="bVyr-1675342494840"></a>2. 注解：</p><p><a id="a7za-1675342494842"></a>1. @JsonIgnore：排除属性。</p><p><a id="uLHs-1675342494844"></a>2. @JsonFormat：属性值得格式化</p><p><a id="Hn2R-1675342494846"></a>* @JsonFormat(pattern = “yyyy-MM-dd”)</p><p><a id="4n49-1675342494848"></a></p><p><a id="k6CW-1675342494850"></a>3. 复杂java对象转换</p><p><a id="I2sz-1675342494852"></a>1. List：数组</p><p><a id="xeiF-1675342494854"></a>2. Map：对象格式一致</p><p><a id="tBoT-1675345679608"></a></p><p><a id="6Ybm-1675342494856"></a>校验用户名是否存在</p><p><a id="Sm7D-1675345682162"></a>1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：</p><p><a id="SwIs-1675345682164"></a>1. $.get(type):将最后一个参数type指定为”json”</p><p><a id="RKlS-1675345682166"></a>2. 在服务器端设置MIME类型</p><p><a id="C2Qd-1675345682168"></a>response.setContentType(“application/json;charset=utf-8”);</p><p><a id="1aVQ-1675429212129"></a>Redis</p><p><a id="1C0b-1675429215340"></a>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库</p><p><a id="bTE2-1675429225410"></a>1.1.什么是NOSQL</p><p><a id="Aeaj-1675429215348"></a>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p><p><a id="Hl5z-1675429215350"></a>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p><p><a id="YcmI-1675429215352"></a>1.1.1.NOSQL和关系型数据库比较</p><p><a id="f5Nf-1675429389223"></a>优点：</p><p><a id="sdSm-1675429389225"></a>1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</p><p><a id="SKes-1675429389227"></a>2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</p><p><a id="x9LP-1675429389229"></a>3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</p><p><a id="JKNC-1675429389231"></a>4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p><p><a id="RU5q-1675429389233"></a></p><p><a id="1CIB-1675429389235"></a>缺点：</p><p><a id="Ihzr-1675429389237"></a>1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</p><p><a id="HYXn-1675429389239"></a>2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</p><p><a id="enpp-1675429389241"></a>3）不提供关系型数据库对事务的处理。</p><p><a id="qJbw-1675429389243"></a></p><p><a id="mxm3-1675429389245"></a>1.1.2.非关系型数据库的优势：</p><p><a id="arD3-1675429389247"></a>1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p><p><a id="aZLS-1675429389249"></a>2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p><p><a id="RUYm-1675429389251"></a></p><p><a id="fRyF-1675429389253"></a>1.1.3.关系型数据库的优势：</p><p><a id="b1g7-1675429389255"></a>1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p><a id="jrWZ-1675429389257"></a>2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p><a id="ggfH-1675429389259"></a></p><p><a id="sFmg-1675429389261"></a>1.1.4.总结</p><p><a id="N0gB-1675429389263"></a>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>让NoSQL数据库对关系型数据库的不足进行弥补。</p><p><a id="CQUn-1675429389267"></a>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p><p><a id="cua2-1675429389269"></a></p><p><a id="91OK-1675429389271"></a>1.2.主流的NOSQL产品</p><p><a id="0N78-1675429389273"></a>•键值(Key-Value)存储数据库</p><p><a id="QIES-1675429389275"></a>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p><p><a id="pkyG-1675429389277"></a>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </p><p><a id="vLVs-1675429389279"></a>数据模型： 一系列键值对</p><p><a id="6EdF-1675429389281"></a>优势： 快速查询</p><p><a id="rXqh-1675429389283"></a>劣势： 存储的数据缺少结构化</p><p><a id="yLTB-1675429389285"></a>•列存储数据库</p><p><a id="fTbT-1675429389287"></a>相关产品：Cassandra, HBase, Riak</p><p><a id="lE0u-1675429389289"></a>典型应用：分布式的文件系统</p><p><a id="xseB-1675429389291"></a>数据模型：以列簇式存储，将同一列数据存在一起</p><p><a id="pvzS-1675429389294"></a>优势：查找速度快，可扩展性强，更容易进行分布式扩展</p><p><a id="fCVL-1675429389296"></a>劣势：功能相对局限</p><p><a id="vQEC-1675429389298"></a>•文档型数据库</p><p><a id="OHZg-1675429389300"></a>相关产品：CouchDB、MongoDB</p><p><a id="Wfrz-1675429389302"></a>典型应用：Web应用（与Key-Value类似，Value是结构化的）</p><p><a id="J9ok-1675429389304"></a>数据模型： 一系列键值对</p><p><a id="ap1o-1675429389306"></a>优势：数据结构要求不严格</p><p><a id="3Zpx-1675429389308"></a>劣势： 查询性能不高，而且缺乏统一的查询语法</p><p><a id="XnsW-1675429389310"></a>•图形(Graph)数据库</p><p><a id="acgF-1675429389312"></a>相关数据库：Neo4J、InfoGrid、Infinite Graph</p><p><a id="r4wO-1675429389314"></a>典型应用：社交网络</p><p><a id="fwCr-1675429389316"></a>数据模型：图结构</p><p><a id="u8PE-1675429389318"></a>优势：利用图结构相关算法。</p><p><a id="xYks-1675429389320"></a>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p><p><a id="eyIv-1675429389322"></a>1.3 什么是Redis</p><p><a id="VoWU-1675429389324"></a>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p><p><a id="4LyZ-1675429389326"></a>1) 字符串类型 string</p><p><a id="dHdg-1675429389328"></a>2) 哈希类型 hash</p><p><a id="y2NL-1675429389330"></a>3) 列表类型 list</p><p><a id="6e2w-1675429389332"></a>4) 集合类型 set</p><p><a id="6WMy-1675429389334"></a>5) 有序集合类型 sortedset</p><p><a id="wtQK-1675429389336"></a>1.3.1 redis的应用场景</p><p><a id="xuHP-1675429389338"></a>•缓存（数据查询、短连接、新闻内容、商品内容等等）</p><p><a id="E65T-1675429389340"></a>•聊天室的在线好友列表</p><p><a id="93Ew-1675429389342"></a>•任务队列。（秒杀、抢购、12306等等）</p><p><a id="Yz82-1675429389344"></a>•应用排行榜</p><p><a id="siGu-1675429389346"></a>•网站访问统计</p><p><a id="kjJj-1675429389348"></a>•数据过期处理（可以精确到毫秒</p><p><a id="P2Mz-1675429389350"></a>•分布式集群架构中的session分离</p><p><a id="3BMM-1675429389352"></a></p><p><a id="LYDH-1675429389354"></a></p><p><a id="p1bq-1675429389356"></a>2. 下载安装</p><p><a id="cqfe-1675429389358"></a>1. 官网：ht<a href="https://redis.io">tps://redis.io</a></p><p><a id="OUc5-1675429389360"></a>2. 中文网：ht<a href="http://www.redis.net.cn/">tp://www.redis.net.cn/</a></p><p><a id="q5U3-1675429389362"></a>3. 解压直接可以使用：</p><p><a id="Jlpf-1675429389364"></a>* redis.windows.conf：配置文件</p><p><a id="BK3T-1675429389366"></a>* redis-cli.exe：redis的客户端</p><p><a id="u2cC-1675429389368"></a>* redis-server.exe：redis服务器端</p><p><a id="vu33-1675429389370"></a></p><p><a id="nfwZ-1675429389372"></a>3. 命令操作</p><p><a id="E4mZ-1675429389374"></a>1. redis的数据结构：</p><p><a id="BO7G-1675429389376"></a>* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><p><a id="RBnX-1675429389378"></a>* value的数据结构：</p><p><a id="Tpa1-1675429389380"></a>1) 字符串类型 string</p><p><a id="8qo0-1675429389382"></a>2) 哈希类型 hash ： map格式  </p><p><a id="vodc-1675429389384"></a>3) 列表类型 list ： linkedlist格式。支持重复元素</p><p><a id="gq0w-1675429389386"></a>4) 集合类型 set  ： 不允许重复元素</p><p><a id="0iI8-1675429389388"></a>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><p><a id="b2Dg-1675429389390"></a></p><p><a id="JrhW-1675429389392"></a>2. 字符串类型 string</p><p><a id="8Bns-1675429389394"></a>1. 存储： set key value</p><p><a id="MNp4-1675429389396"></a>127.0.0.1:6379&gt; set username zhangsan</p><p><a id="xuDk-1675429389398"></a>OK</p><p><a id="2Nbv-1675429389400"></a>2. 获取： get key</p><p><a id="vMDr-1675429389402"></a>127.0.0.1:6379&gt; get username</p><p><a id="6jaG-1675429389404"></a>“zhangsan”</p><p><a id="Tnhh-1675429389406"></a>3. 删除： del key</p><p><a id="8DAM-1675429389408"></a>127.0.0.1:6379&gt; del age</p><p><a id="J9C5-1675429389410"></a>(integer) 1</p><p><a id="Uzce-1675429389412"></a>3. 哈希类型 hash</p><p><a id="0EoT-1675429389415"></a>1. 存储： hset key field value</p><p><a id="umnQ-1675429389417"></a>127.0.0.1:6379&gt; hset myhash username lisi</p><p><a id="Ag1n-1675429389419"></a>(integer) 1</p><p><a id="ZXWv-1675429389421"></a>127.0.0.1:6379&gt; hset myhash password 123</p><p><a id="4bNE-1675429389423"></a>(integer) 1</p><p><a id="wCw1-1675429389425"></a>2. 获取： </p><p><a id="RyhY-1675429389427"></a>* hget key field: 获取指定的field对应的值</p><p><a id="X1Bb-1675429389429"></a>127.0.0.1:6379&gt; hget myhash username</p><p><a id="SBvb-1675429389431"></a>“lisi”</p><p><a id="cmzm-1675429389433"></a>* hgetall key：获取所有的field和value</p><p><a id="DHVF-1675429389435"></a>127.0.0.1:6379&gt; hgetall myhash</p><p><a id="Lpix-1675429389437"></a>1) “username”</p><p><a id="dHzv-1675429389439"></a>2) “lisi”</p><p><a id="s03x-1675429389441"></a>3) “password”</p><p><a id="bqIu-1675429389443"></a>4) “123”</p><p><a id="xiwy-1675429389447"></a>3. 删除： hdel key field</p><p><a id="xLko-1675429389449"></a>127.0.0.1:6379&gt; hdel myhash username</p><p><a id="IlFu-1675429389451"></a>(integer) 1</p><p><a id="zYqp-1675429389453"></a></p><p><a id="8uCf-1675429389455"></a>4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p><a id="BoLn-1675429389457"></a>1. 添加：</p><p><a id="rE5x-1675429389459"></a>1. lpush key value: 将元素加入列表左表</p><p><a id="XfYr-1675429389461"></a></p><p><a id="j3Au-1675429389463"></a>2. rpush key value：将元素加入列表右边</p><p><a id="OqhV-1675429389465"></a></p><p><a id="oYby-1675429389467"></a>127.0.0.1:6379&gt; lpush myList a</p><p><a id="wpYE-1675429389469"></a>(integer) 1</p><p><a id="ihMs-1675429389471"></a>127.0.0.1:6379&gt; lpush myList b</p><p><a id="ECWq-1675429389473"></a>(integer) 2</p><p><a id="83TR-1675429389475"></a>127.0.0.1:6379&gt; rpush myList c</p><p><a id="a9FK-1675429389477"></a>(integer) 3</p><p><a id="pGQZ-1675429389479"></a>2. 获取：</p><p><a id="CKmS-1675429389481"></a>* lrange key start end ：范围获取</p><p><a id="K739-1675429389483"></a>127.0.0.1:6379&gt; lrange myList 0 -1</p><p><a id="ptoq-1675429389485"></a>1) “b”</p><p><a id="HdDn-1675429389487"></a>2) “a”</p><p><a id="vdxV-1675429389489"></a>3) “c”</p><p><a id="fjSJ-1675429389491"></a>3. 删除：</p><p><a id="AUXa-1675429389493"></a>* lpop key： 删除列表最左边的元素，并将元素返回</p><p><a id="mmn6-1675429389495"></a>* rpop key： 删除列表最右边的元素，并将元素返回</p><p><a id="P0MP-1675429389497"></a></p><p><a id="tUF8-1675429389499"></a></p><p><a id="4iZE-1675429389501"></a>5. 集合类型 set ： 不允许重复元素</p><p><a id="NUio-1675429389503"></a>1. 存储：sadd key value</p><p><a id="8fGD-1675429389505"></a>127.0.0.1:6379&gt; sadd myset a</p><p><a id="mogm-1675429389507"></a>(integer) 1</p><p><a id="gCwi-1675429389509"></a>127.0.0.1:6379&gt; sadd myset a</p><p><a id="N4dB-1675429389511"></a>(integer) 0</p><p><a id="3VAL-1675429389513"></a>2. 获取：smembers key:获取set集合中所有元素</p><p><a id="LygS-1675429389515"></a>127.0.0.1:6379&gt; smembers myset</p><p><a id="9hJR-1675429389517"></a>1) “a”</p><p><a id="uSXE-1675429389519"></a>3. 删除：srem key value:删除set集合中的某个元素</p><p><a id="zwOU-1675429389521"></a>127.0.0.1:6379&gt; srem myset a</p><p><a id="82jT-1675429389523"></a>(integer) 1</p><p><a id="2vF0-1675429389525"></a>6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p><a id="hazc-1675429389527"></a></p><p><a id="Hpi8-1675429389529"></a>1. 存储：zadd key score value</p><p><a id="rscO-1675429389531"></a>127.0.0.1:6379&gt; zadd mysort 60 zhangsan</p><p><a id="ZZjE-1675429389533"></a>(integer) 1</p><p><a id="vMAY-1675429389535"></a>127.0.0.1:6379&gt; zadd mysort 50 lisi</p><p><a id="AxCi-1675429389538"></a>(integer) 1</p><p><a id="oUIg-1675429389540"></a>127.0.0.1:6379&gt; zadd mysort 80 wangwu</p><p><a id="D3ZI-1675429389542"></a>(integer) 1</p><p><a id="IAoj-1675429389544"></a>2. 获取：zrange key start end [withscores]</p><p><a id="tGQZ-1675429389546"></a>127.0.0.1:6379&gt; zrange mysort 0 -1</p><p><a id="3zem-1675429389548"></a>1) “lisi”</p><p><a id="n18f-1675429389550"></a>2) “zhangsan”</p><p><a id="eWmk-1675429389552"></a>3) “wangwu”</p><p><a id="g4d5-1675429389554"></a></p><p><a id="lQL2-1675429389556"></a>127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</p><p><a id="XLMu-1675429389558"></a>1) “zhangsan”</p><p><a id="O12R-1675429389560"></a>2) “60”</p><p><a id="hRh4-1675429389562"></a>3) “wangwu”</p><p><a id="4NSR-1675429389564"></a>4) “80”</p><p><a id="JjC4-1675429389566"></a>5) “lisi”</p><p><a id="P51R-1675429389568"></a>6) “500”</p><p><a id="hLPp-1675429389570"></a>3. 删除：zrem key value</p><p><a id="FCdT-1675429389572"></a>127.0.0.1:6379&gt; zrem mysort lisi</p><p><a id="vdXh-1675429389574"></a>(integer) 1</p><p><a id="Xsp8-1675429389576"></a></p><p><a id="PSNR-1675429389578"></a>7. 通用命令</p><p><a id="nOwo-1675429389580"></a>1. keys * : 查询所有的键</p><p><a id="Fv6h-1675429389582"></a>2. type key ： 获取键对应的value的类型</p><p><a id="kYhv-1675429389584"></a>3. del key：删除指定的key value</p><p><a id="WjWx-1675429389586"></a></p><p><a id="zCmz-1675429389588"></a><br>4. 持久化</p><p><a id="K5BI-1675429389592"></a>1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p><p><a id="UpTT-1675429389594"></a>2. redis持久化机制：</p><p><a id="KxOW-1675429389596"></a>1. RDB：默认方式，不需要进行配置，默认就使用这种机制</p><p><a id="al8Z-1675429389598"></a>* 在一定的间隔时间中，检测key的变化情况，然后持久化数据</p><p><a id="H4sO-1675429389600"></a>1. 编辑redis.windwos.conf文件</p><p><a id="Z4Yk-1675429389603"></a>#   after 900 sec (15 min) if at least 1 key changed</p><p><a id="FJ69-1675429389605"></a>save 900 1</p><p><a id="YGQh-1675429389607"></a>#   after 300 sec (5 min) if at least 10 keys changed</p><p><a id="wuO9-1675429389609"></a>save 300 10</p><p><a id="YYSt-1675429389611"></a>#   after 60 sec if at least 10000 keys changed</p><p><a id="GHGB-1675429389613"></a>save 60 10000</p><p><a id="6XDd-1675429389615"></a></p><p><a id="J3lt-1675429389617"></a>2. 重新启动redis服务器，并指定配置文件名称</p><p><a id="vQmX-1675429389619"></a>D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf</p><p><a id="DGsU-1675429389621"></a></p><p><a id="LNv2-1675429389623"></a>2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p><p><a id="EBFF-1675429389625"></a>1. 编辑redis.windwos.conf文件</p><p><a id="S8yQ-1675429389627"></a>appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</p><p><a id="FlQ3-1675429389629"></a></p><p><a id="GXrq-1675429389631"></a># appendfsync always ： 每一次操作都进行持久化</p><p><a id="8w7J-1675429389633"></a>appendfsync everysec ： 每隔一秒进行一次持久化</p><p><a id="HytV-1675429389635"></a># appendfsync no ： 不进行持久化</p><p><a id="M9Gm-1675429389637"></a>5. Java客户端 Jedis</p><p><a id="sms3-1675434555959"></a>* Jedis: 一款java操作redis数据库的工具.</p><p><a id="I7tj-1675434555961"></a>* 使用步骤：</p><p><a id="8pAt-1675434555963"></a>1. 下载jedis的jar包</p><p><a id="JcaW-1675434555965"></a>2. 使用</p><p><a id="yWXh-1675434555967"></a>//1. 获取连接</p><p><a id="T2H7-1675434555969"></a>        Jedis jedis = new Jedis(“localhost”,6379);</p><p><a id="iPvk-1675434555971"></a>       //2. 操作</p><p><a id="8K68-1675434555973"></a>       jedis.set(“username”,”zhangsan”);</p><p><a id="PTU0-1675434555975"></a>        //3. 关闭连接</p><p><a id="JEI7-1675434555978"></a>        jedis.close();</p><p><a id="C9tN-1675434555980"></a></p><p><a id="8WSJ-1675434555984"></a>* Jedis操作各种redis中的数据结构</p><p><a id="6GGE-1675434555986"></a>1) 字符串类型 string</p><p><a id="pdyT-1675434555988"></a>set</p><p><a id="Zqya-1675434555990"></a>get</p><p><a id="Z697-1675434555994"></a></p><p><a id="Tfd3-1675434556012"></a>      //可以使用setex()方法存储可以指定过期时间的 key value</p><p><a id="pnVv-1675434556014"></a>        jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</p><p><a id="glSI-1675434556022"></a></p><p><a id="5mYg-1675434556024"></a>2) 哈希类型 hash ： map格式  </p><p><a id="PiBb-1675434556026"></a>hset</p><p><a id="jaGR-1675434556028"></a>hget</p><p><a id="NpuF-1675434556030"></a>hgetAll</p><p><a id="wFG1-1675434556059"></a><br>3) 列表类型 list ： linkedlist格式。支持重复元素</p><p><a id="TJRs-1675434556091"></a>lpush / rpush</p><p><a id="7Y7V-1675434556093"></a>lpop / rpop</p><p><a id="3BWh-1675434556095"></a>lrange start end : 范围获取</p><p><a id="rlJd-1675434674990"></a>4) 集合类型 set  ： 不允许重复元素</p><p><a id="NprX-1675434556153"></a>sadd</p><p><a id="GZD4-1675434556155"></a>smembers:获取所有元素</p><p><a id="5lFd-1675434556188"></a>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><p><a id="LJX3-1675434556190"></a>zadd</p><p><a id="3lDL-1675434556192"></a>zrange</p><p><a id="ImhF-1675577539742"></a>注意：使用redis缓存一些不经常发生变化的数据。</p><p><a id="J0Qt-1675577547490"></a>* 数据库的数据一旦发生改变，则需要更新缓存。</p><p><a id="UQEF-1675577547492"></a>* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</p><p><a id="HCdB-1675577547494"></a>* 在service对应的增删改方法中，将redis数据删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a id=&quot;3060-1621846615933&quot;&gt;&lt;/a&gt;JavaWeb&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;9ey9-1660562873495&quot;&gt;&lt;/a&gt; 一.Junit使用:白盒测试&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;1glU-1660563044783&quot;&gt;&lt;/a&gt;*步骤:&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="javaWeb" scheme="http://putongl.github.io/tags/javaWeb/"/>
    
  </entry>
  
  <entry>
    <title>centos7开放及查看端口</title>
    <link href="http://putongl.github.io/linux.html"/>
    <id>http://putongl.github.io/linux.html</id>
    <published>2023-10-17T06:29:42.671Z</published>
    <updated>2023-10-17T06:29:36.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos7开放及查看端口"><a href="#centos7开放及查看端口" class="headerlink" title="centos7开放及查看端口"></a>centos7开放及查看端口</h1><p>1、开放端口</p><p><strong>firewall-cmd —zone=public —add-port=5672/tcp —permanent</strong>  # 开放5672端口</p><p><strong>firewall-cmd —zone=public —remove-port=5672/tcp —permanent</strong> #关闭5672端口</p><p><strong>firewall-cmd —reload</strong>  # 配置立即生效</p><ul><li>解释上面命令</li></ul><p>—zone=public：表示作用域为公共的；</p><p>—add-port=8080/tcp：添加tcp协议的端口8080；</p><p>—permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；</p><p>2、查看防火墙所有开放的端口</p><p><strong>firewall-cmd —zone=public —list-ports</strong></p><p>3.、关闭防火墙</p><p>如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估</p><p><strong>systemctl stop firewalld.service</strong></p><p>4、查看防火墙状态</p><p> <strong>firewall-cmd —state</strong></p><p>5、查看监听的端口</p><p><strong>netstat -lnpt</strong></p><p><img src="https://s2.loli.net/2023/10/11/6zbD2mlQsS9v5J1.png" alt="img"></p><p><em>PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</em></p><p>6、检查端口被哪个进程占用</p><p><strong>netstat -lnpt |grep 5672</strong></p><p><img src="https://s2.loli.net/2023/10/11/hcFqVa3iBAodZ94.png" alt="img"></p><p>7、查看进程的详细信息</p><p><strong>ps 6832</strong></p><p><img src="https://s2.loli.net/2023/10/11/XWMqx6gLJrIjFSA.png" alt="img"></p><p>8、中止进程</p><p><strong>kill -9 6832</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;centos7开放及查看端口&quot;&gt;&lt;a href=&quot;#centos7开放及查看端口&quot; class=&quot;headerlink&quot; title=&quot;centos7开放及查看端口&quot;&gt;&lt;/a&gt;centos7开放及查看端口&lt;/h1&gt;&lt;p&gt;1、开放端口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="http://putongl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker常见命令</title>
    <link href="http://putongl.github.io/Docker.html"/>
    <id>http://putongl.github.io/Docker.html</id>
    <published>2023-10-17T06:28:59.896Z</published>
    <updated>2023-10-17T09:03:34.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h3 id="docker常见命令"><a href="#docker常见命令" class="headerlink" title="docker常见命令"></a>docker常见命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td style="text-align:center">docker pull</td><td style="text-align:center">拉取镜像</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td style="text-align:center">docker push</td><td style="text-align:center">推送镜像到DockerRegistry</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td style="text-align:center">docker images</td><td style="text-align:center">查看本地镜像</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td style="text-align:center">docker rmi</td><td style="text-align:center">删除本地镜像</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td style="text-align:center">docker run</td><td style="text-align:center">创建并运行容器（不能重复创建）</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td style="text-align:center">docker stop</td><td style="text-align:center">停止指定容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td style="text-align:center">docker start</td><td style="text-align:center">启动指定容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td style="text-align:center">docker restart</td><td style="text-align:center">重新启动容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td style="text-align:center">docker rm</td><td style="text-align:center">删除指定容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td style="text-align:center">docker ps</td><td style="text-align:center">查看容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td style="text-align:center">docker logs</td><td style="text-align:center">查看容器运行日志</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td style="text-align:center">docker exec</td><td style="text-align:center">进入容器</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td style="text-align:center">docker save</td><td style="text-align:center">保存镜像到本地压缩文件</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td style="text-align:center">docker load</td><td style="text-align:center">加载本地压缩文件到镜像</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td style="text-align:center">docker inspect</td><td style="text-align:center">查看容器详细信息</td><td style="text-align:center"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table></div><p><img src="https://s2.loli.net/2023/10/17/7LFkJWiEtCzfSuK.png" alt="image-20231017170327214"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h3 id=&quot;docker常见命令&quot;&gt;&lt;a href=&quot;#docker常见命令&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="http://putongl.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://putongl.github.io/Python.html"/>
    <id>http://putongl.github.io/Python.html</id>
    <published>2023-09-13T09:22:35.062Z</published>
    <updated>2023-09-18T09:22:08.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-python基础"><a href="#1-python基础" class="headerlink" title="1 . python基础"></a>1 . python基础</h1><p>print()可以输出多份内容，多份内容可以用”,”隔开</p><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1 . 注释"></a>1 . 注释</h2><p>单行注释：以 # 开头，# 右边的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用</p><p>注意,#号和注释内容一般建议以一个空格隔开</p><p>多行注释： 以 一对三个双引号 引起来 (“”” “””)来解释说明一段代码的作用使用方法</p><h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2 . 类型转换"></a>2 . 类型转换</h2><p>type()查看数据的类型</p><div class="table-container"><table><thead><tr><th>语句（函数）</th><th>说明</th></tr></thead><tbody><tr><td>int(x)</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换为一个浮点数</td></tr><tr><td>str(x)</td><td>将对象x转换为一个字符数</td></tr></tbody></table></div><h2 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3 . 字符串格式化"></a>3 . 字符串格式化</h2><div class="table-container"><table><thead><tr><th>格式符号</th><th>转化</th></tr></thead><tbody><tr><td>%s</td><td>将内容转化为字符串，放入占位位置</td></tr><tr><td>%d</td><td>将内容转化为整数，放入占位位置</td></tr><tr><td>%f</td><td>将内容转化为浮点型，放入占位位置</td></tr></tbody></table></div><ul><li>数字精度控制</li></ul><p>我们可以使用辅助符号”m.n”来控制数据的宽度和精度</p><ul><li><p>m，控制宽度，要求是数字（很少使用),设置的宽度小于数字自身，不生效</p></li><li><p>.n，控制小数点精度，要求是数字，会进行小数的四舍五入</p><p>示例:</p></li><li><p>%5d:表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成   11，用三个空格补足宽度。</p></li><li><p>.%5.2f:表示将宽度控制为5，将小数点精度设置为2</p></li><li><p>小数点和小数部分也算入宽度计算。</p></li></ul><p>快速格式化</p><ul><li>f”内容{变量}”</li></ul><p>例子</p><ul><li>print(f”我是{name}”)</li></ul><h2 id="4-if语句"><a href="#4-if语句" class="headerlink" title="4 . if语句"></a>4 . if语句</h2><ol><li>if elif else语句的作用是?<br>可以完成多个条件的判断</li><li>使用if elif else的注意点有:<br>elif可以写多个<br>判断是互斥且有序的，上一个满足后面的就不会判断了<br>可以在条件判断中，直接写input语句，节省代码量</li></ol><h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5 . 循环语句"></a>5 . 循环语句</h2><ol><li><p>whlie循环</p><p>while 条件：</p><p>​        条件满足时，做的事情</p></li><li><p>for循环</p><p>语法格式是:<br>for 临时变量 in 待处理数据集(序列）:</p><pre><code>    循环满足条件时执行的代码</code></pre></li><li><p>while循环和for循环，都是循环语句，但细节不同:。</p><ul><li>在循环控制上:</li></ul><p>while循环可以自定循环条件﹐并自行控制<br>for循环不可以自定循环条件，只可以一个个从容器内取出数据。</p><ul><li>在无限循环上:</li></ul><p>while循环可以通过条件控制做到无限循环<br>for循环理论上不可以，因为被遍历的容器容量不是无限的</p><ul><li>在使用场景上:</li></ul><p>while循环适用于任何想要循环的场景<br>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</p></li></ol><h2 id="6-range语句"><a href="#6-range语句" class="headerlink" title="6 . range语句"></a>6 . range语句</h2><ul><li><p>语法1:</p></li><li><p>range(num)</p></li></ul><p>获取一个从0开始，到num结束的数字序列（不含num本身)</p><p>如range(5)取得的数据是:[0,1,2,3,4]</p><ul><li><p>语法2:</p></li><li><p>range(num1,num2)</p></li></ul><p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p><p>如,range(5,10)取得的数据是:[5,6,7,8,9]</p><ul><li><p>语法3:</p></li><li><p>range(num1, num2, step)</p></li></ul><p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p><p>数字之间的步长，以step为准(step默认为1)</p><p>如，range(5,10,2)取得的数据是:[5,7,9]</p><h2 id="7-循环中断"><a href="#7-循环中断" class="headerlink" title="7 . 循环中断"></a>7 . 循环中断</h2><ul><li>continue：中断本次循环，直接进入下一次循环</li><li>break：直接结束整个循环</li></ul><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8 . 函数"></a>8 . 函数</h2><ul><li>函数的定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">函数名</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure><ul><li>函数的返回值：函数执行完之后，返回给调用者的结果</li></ul><p>函数体遇到return后就结束了，卸载return后面的代码不执行</p><p>1.什么是None</p><p>None是类型’NoneType’的字面量，用于表示:空的、无意义的</p><p>2.函数如何返回None</p><p>不使用return语句即返回None</p><p>主动return None</p><p>3.使用场景<br>函数返回值<br>if判断<br>变量定义(赋值为None，表示暂时不提供值)</p><h2 id="9-变量"><a href="#9-变量" class="headerlink" title="9 . 变量"></a>9 . 变量</h2><p>1.什么是局部变量<br>    作用范围在函数内部，在函数外部无法使用<br>2.什么是全局变量<br>    在函数内部和外部均可使用<br>3.如何将函数内定义的变量声明为全局变量<br>    使用global关键字，global变量</p><h2 id="10-数据容器"><a href="#10-数据容器" class="headerlink" title="10 . 数据容器"></a>10 . 数据容器</h2><h3 id="1-列表list"><a href="#1-列表list" class="headerlink" title="1 . 列表list"></a>1 . 列表list</h3><ul><li>list() 空列表</li><li>列表排序<ul><li>列表.sort(key=选择排序依据的函数，reverse=True l False)<ul><li>参数key，是要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排序的依据。</li><li>参数reverse，是否反转排序结果，True表示降序，False表示升序</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2023/09/06/uPUwFhj6o5lM1ds.png" alt="QQ图片20230906211908"></p><h3 id="2-元组tuple"><a href="#2-元组tuple" class="headerlink" title="2 . 元组tuple"></a>2 . 元组tuple</h3><ul><li>空元组( )，tuple()</li><li>注意：不可修改内容（可以修改内部list的内部元素）</li></ul><p><img src="https://s2.loli.net/2023/09/06/ezOmdgCiJI2XH3D.png" alt="QQ图片20230906215231"></p><ul><li>zip(列表1, 列表2, …..)将多个列表对应的位置的元素组合成元组，并返回这个zip对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">b = [<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">c = [<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line"><span class="built_in">print</span>(d) //&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000026C1B719300</span>&gt;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d))   //[(<span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>), (<span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>), (<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>)]</span><br></pre></td></tr></table></figure><h3 id="3-字符串str"><a href="#3-字符串str" class="headerlink" title="3 . 字符串str"></a>3 . 字符串str</h3><ul><li><p>“ “</p></li><li><p>字符串的比较大小，基于数字的ASCII码表的码值来进行比较</p></li></ul><p><img src="https://s2.loli.net/2023/09/06/DJMGCRn1gNdcjBH.png" alt="QQ图片20230906221041"></p><h3 id="4-序列的切片"><a href="#4-序列的切片" class="headerlink" title="4 . 序列的切片"></a>4 . 序列的切片</h3><ul><li><p>序列：列表，元组，字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列[起始:结束:步长]</span><br></pre></td></tr></table></figure></li></ul><p>​    起始可以省略，省略从头开始<br>​    结束可以省略，省略到尾结束（不包含尾）<br>​    步长可以省略，省略步长为1（可以为负数，表示倒序执行，负一表示反转)</p><h3 id="5-集合str"><a href="#5-集合str" class="headerlink" title="5 . 集合str"></a>5 . 集合str</h3><ul><li>set( )，定义空集合</li><li>无序，去重</li><li>不支持下标索引访问</li></ul><p><img src="https://s2.loli.net/2023/09/07/dCvGrIDVcf2A1QF.png" alt="QQ图片20230907103350"></p><h3 id="6-字典dict"><a href="#6-字典dict" class="headerlink" title="6 . 字典dict"></a>6 . 字典dict</h3><ul><li><p>字典{key:value,key:value}</p></li><li><p>空字典{}，dict()</p></li><li>不可以使用下标索引</li><li>获取value：字典[key]</li></ul><p><img src="https://s2.loli.net/2023/09/07/s89whRZQWfMGYtN.png" alt="QQ图片20230907115521"></p><p>直接对字典进行遍历，每一次循环得到的是key</p><p><img src="https://s2.loli.net/2023/09/07/t5ZQukl1ymvacRg.png" alt="QQ图片20230907191822"></p><ul><li>容器的通用操作</li></ul><p><img src="https://s2.loli.net/2023/09/07/nHgRM8pNySkIYja.png" alt="QQ图片20230907193354"></p><h2 id="11-函数进阶"><a href="#11-函数进阶" class="headerlink" title="11 . 函数进阶"></a>11 . 函数进阶</h2><ul><li>一个函数有多个返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">x,y,z = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><ul><li>函数多种传参方式</li></ul><p>1.掌握位置参数<br>    根据参数位置来传递参数<br>2.掌握关键字参数<br>    通过“键=值”形式传递参数,可以不限参数顺序·可以和位置参数混用，位置参数需在前<br>3.掌握缺省参数<br>    不传递参数值时会使用默认的参数值-默认值的参数必须定义在最后<br>4.掌握不定长参数<br>    位置不定长传递以<em>号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args<br>    关键字不定长传递以*</em>号标记一个形式参数，以字典的形式接受参数,形式参数一般命名为kwargs</p><ul><li>函数作为参数传递</li></ul><ol><li>函数本身是可以作为参数，传入另一个函数中进行使用</li><li>将函数传入的作用在于：传入计算逻辑，而非传入数据</li></ol><ul><li>lambda匿名函数</li></ul><p>函数的定义中</p><ul><li><p>def关键字，可以定义带有名称的函数</p></li><li><p>lambda关键字，可以定义匿名函数（无名称)</p></li></ul><p>有名称的函数，可以基于名称重复使用。</p><p>无名称的匿名函数，只可临时使用一次。</p><ul><li>匿名函数定义语法:</li><li>lambda传入参数:函数体(一行代码)</li></ul><p>lambda是关键字，表示定义匿名函数</p><p>传入参数表示匿名函数的形式参数，如:x, y表示接收2个形式参数</p><p>函数体，就是函数的执行逻辑，要注意:只能写一行，无法写多行代码</p><h2 id="12-python文件操作"><a href="#12-python文件操作" class="headerlink" title="12 . python文件操作"></a>12 . python文件操作</h2><h3 id="1-文件的读取操作"><a href="#1-文件的读取操作" class="headerlink" title="1 . 文件的读取操作"></a>1 . 文件的读取操作</h3><p><img src="https://s2.loli.net/2023/09/08/OoH3e9LfnGXuQCY.png" alt="QQ图片20230908194004"></p><ul><li>open中的encoding是“编码格式”</li><li>encoding顺序不是第三位，所以不能用位置参数，使用关键字参数直接指定</li><li>mode有三种访问文件模式</li></ul><p><img src="https://s2.loli.net/2023/09/08/LgqxHhYFp1leCN6.png" alt="QQ图片20230908194729"></p><h3 id="2-文件的写入操作"><a href="#2-文件的写入操作" class="headerlink" title="2 . 文件的写入操作"></a>2 . 文件的写入操作</h3><ul><li>w和a都可以进行写入操作</li><li>flush()，刷新内容到硬盘</li><li>close()，带有flush()的功能</li><li>可以用”\n”来写出换行符</li></ul><h2 id="13-异常，模块，包"><a href="#13-异常，模块，包" class="headerlink" title="13 . 异常，模块，包"></a>13 . 异常，模块，包</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1 . 异常"></a>1 . 异常</h3><p>1.为什么要捕获异常?</p><p>在可能发生异常的地方，进行捕获。当异常出现的时候，提供解决方式，而不是任由其导致程序无法运行。</p><p>2.捕获异常的语法?</p><p>[ ]表示可选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">可能要发生异常的语句</span><br><span class="line"><span class="keyword">except</span>[异常 <span class="keyword">as</span> 别名:]</span><br><span class="line">出现异常的准备手段</span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">未出现异常时应做的事情</span><br><span class="line">[<span class="keyword">finally</span>:]</span><br><span class="line">不管出不出现异常都会做的事情</span><br></pre></td></tr></table></figure><p>3.如何捕获所有异常?</p><p>异常的种类多种多样，如果想要不管什么类型的异常都能捕获到，那么<br>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">except</span>:</span><br><span class="line"><span class="number">2.</span><span class="keyword">except</span> Exception:</span><br></pre></td></tr></table></figure><p>4.异常的传递性</p><p>想要捕获异常，并不需要真正的深入的最底层的代码中进行捕获，只有你的函数有调用关系，我们在最顶级的可以调用直接捕获异常，因为会传递</p><h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2 . 模块"></a>2 . 模块</h3><ul><li><p>模块就是一个Python代码文件，内含类、函数、变量等，我们可以导入进行使用。</p></li><li><p>模块的导入</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块 | 类 | 变量 | 函数 | *] [<span class="keyword">as</span> 别名]</span><br></pre></td></tr></table></figure><p>常用的组合形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类、变量、方法等</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure><ul><li>自定义模块</li></ul><p><img src="https://s2.loli.net/2023/09/09/Hg7KDxnuBieq29r.png" alt="QQ图片20230909144743"></p><h3 id="3-包"><a href="#3-包" class="headerlink" title="3 . 包"></a>3 . 包</h3><p><img src="https://s2.loli.net/2023/09/09/KqxtFfP3z96Gl7o.png" alt="QQ图片20230909144743"></p><ul><li>导入包的方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">import</span> 包名.模块名</span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure><h2 id="14-json"><a href="#14-json" class="headerlink" title="14 . json"></a>14 . json</h2><ol><li><p>json:是一种轻量级的数据交互格式,采用完全独立于编程语言的文本格式来存储和表示数据（就是字符串)<br> Python语言使用JSON有很大优势，因为:JSON无非就是python的一个单独的字典或一个内部元素都是字典的列表<br> 所以JSON可以直接和Python的字典或列表进行无缝转换。</p></li><li><p>json格式数据转化<br> 通过json. dumps (data)方法把python数据转化为了json数据</p><p>​    data = json. dumps (data)</p><p>​    如果有中文可以带上: ensure_ascii=False参数来确保中文正常转换</p><p>通过json.loads (data)方法把josn数据转化为了python列表或字典</p></li><li><p><code>loads</code>操作的是字符串</p></li><li><p><code>load</code>操作的是文件流</p><p>​    data = json.loads(data)</p></li></ol><h1 id="2-python面向对象"><a href="#2-python面向对象" class="headerlink" title="2 . python面向对象"></a>2 . python面向对象</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 . 对象"></a>1 . 对象</h2><ul><li>函数：类外面的函数叫函数</li><li>方法：类内部的函数叫方法</li></ul><p>1.在程序中设计表格，我们称之为:设计类(class)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="comment">#class是关键字，表示要定义类了</span></span><br><span class="line">name = <span class="literal">None</span><span class="comment">#记录学生姓名</span></span><br><span class="line">    <span class="comment">#类的属性，即在类中定义的成员变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hi大家好,我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#类的行为，即定义在类中的成员方法</span></span><br></pre></td></tr></table></figure><p>2.在程序中打印生产表格，我们称之为:创建对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于类创建对象的语法</span></span><br><span class="line">对象 = 类名称()</span><br><span class="line"></span><br><span class="line">stu_1 = Student()</span><br><span class="line">stu_2 = Student()</span><br></pre></td></tr></table></figure><p>3.在程序中填写表格，我们称之为:对象属性赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu_1.name = <span class="string">&quot;周杰轮&quot;</span><span class="comment"># 为学生1对象赋予名称属性值</span></span><br><span class="line">stu_2.name = <span class="string">&quot;林军杰&quot;</span><span class="comment"># 为学生2对象赋予名称属性值</span></span><br><span class="line">stu_1.name.say_hi()<span class="comment"># 输出：Hi大家好,我是周杰轮</span></span><br></pre></td></tr></table></figure><p>4.类和对象的关系是什么?</p><p>类是程序中的“设计图纸”<br>对象是基于图纸生产的具体实体</p><p>5.什么是面向对象编程?</p><p>面向对象编程就是,使用对象进行编程。<br>即，设计一个类，基于类创建对象，并使用对象来完成具体的工作</p><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 . 构造方法"></a>2 . 构造方法</h2><p>1．构造方法的名称是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__，注意init前后的2个下划线符号</span><br></pre></td></tr></table></figure><p>2.构造方法的作用:</p><p>构建类对象的时候，会自动运行<br>构建类对象的传参，会传递给构造方法，借此特性可以给成员变量赋值</p><p>3.注意事项:</p><p>构造方法不要忘记self关键字<br>在方法内使用成员变量需要使用self</p><ul><li>魔术方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__str__用于实现类对象转字符串的行为</span><br><span class="line">__lt__用于2个类对象进行小于或大于比较</span><br><span class="line">__le__用于2个类对象进行小于等于或大于等于比较</span><br><span class="line">__eq__用于2个类对象进行相等比较</span><br></pre></td></tr></table></figure><h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3 . 封装"></a>3 . 封装</h2><p>1.封装的概念是指?</p><p>​    将现实世界事物在类中描述为属性和方法，即为封装。</p><p>2.什么是私有成员?为什么需要私有成员?</p><p>​    现实事物有部分属性和行为是不公开对使用者开放的。同样在类中描述属性和方法的时候也需要达到这个要求，就需要定义私有成员了</p><p>3.如何定义私有成员?</p><p>​    成员变量和成员方法的命名均以__(两个下划线)作为开头即可</p><p>4.私有成员的访问限制?</p><p>​    类对象无法访问私有成员<br>​    类中的其它成员可以访问私有成员</p><p>5.封装的实际的意义</p><p>​    在类中提供仅供内部使用的属性和方法，而不对外开放（类对象无法使用)</p><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4 . 继承"></a>4 . 继承</h2><h3 id="1-继承的基础语法"><a href="#1-继承的基础语法" class="headerlink" title="1 . 继承的基础语法"></a>1 . 继承的基础语法</h3><ul><li><p>继承表示:将从父类那里继承(复制)来成员变量和成员方法(不含私有)</p></li><li><p>单继承——一个子类继承一个父类</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>)∶</span><br><span class="line">类内容体</span><br></pre></td></tr></table></figure><ul><li>多继承——一个子类继承多个父类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>,父类<span class="number">2</span>,....., 父类N)∶</span><br><span class="line">类内容体</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 空占位语句，类功能够用了，不想再添加新功能了</span></span><br></pre></td></tr></table></figure><ul><li>如果多继承中，父类有同名的方法或属性，先继承的优先级高于后继承</li></ul><h3 id="2-复写和使用父类成员"><a href="#2-复写和使用父类成员" class="headerlink" title="2 . 复写和使用父类成员"></a>2 . 复写和使用父类成员</h3><p>1.复写表示:</p><p>对父类的成员属性或成员方法进行重新定义</p><p>2.复写的语法:</p><p>在子类中重新实现同名成员方法或成员属性即可</p><p>3.在子类中，如何调用父类成员</p><ul><li>方式1:调用父类成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用成员变量:父类名.成员变量</span><br><span class="line">使用成员方法:父类名.成员方法(self)</span><br></pre></td></tr></table></figure><ul><li>方式2:使用super()调用父类成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用成员变量: super().成员变量</span><br><span class="line">使用成员方法: super().成员方法()</span><br></pre></td></tr></table></figure><ul><li>注意:只可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的</li></ul><h2 id="5-类型注解"><a href="#5-类型注解" class="headerlink" title="5 . 类型注解"></a>5 . 类型注解</h2><p>1.什么是类型注解，有什么作用?</p><p>​    在代码中涉及数据交互之时，对数据类型进行显式的说明，可以帮助:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+p查看类型</span><br></pre></td></tr></table></figure><p>​        PyCharm等开发工具对代码做类型推断协助做代码提示</p><p>​        开发者自身做类型的备注</p><p>2.类型注解支持:</p><p>​    变量的类型注解</p><p>​    函数（方法）的形参和返回值的类型注解</p><p>3.变量的类型注解</p><p>类对象也行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法1:变量:类型</span><br><span class="line">语法2:在注释中，# type:类型</span><br></pre></td></tr></table></figure><ul><li>容器类型的详细注解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量:容器类型[类型1，类型2....]</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>元组类型设置类型详细注解，需要将每一个元素都标记出来</li><li>字典类型设置类型详细注解，需要两个类型，第一个是key第二个是value</li></ul><p>4.函数(方法)的注解</p><ul><li>形参的类型注解</li><li>返回值的类型注解</li><li>语法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>(<span class="params">形参: 类型 , ...... , 形参: 类型</span>) -&gt; 返回值类型:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>5.注意事项</p><p>类型注解只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致错误</p><p>6.Union类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导包: <span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line">使用: <span class="built_in">dict</span> [<span class="built_in">str</span>,<span class="type">Union</span>[类型, ..... , 类型]]</span><br><span class="line">可以定义联合类型注解</span><br></pre></td></tr></table></figure><h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6 . 多态"></a>6 . 多态</h2><ul><li><p>多态，指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态</p></li><li><p>抽象类（接口)</p><ul><li>包含抽象方法的类，称之为抽象类。</li><li>抽象方法是指:没有具体实现的方法(只有pass)称之为抽象方法</li></ul></li><li><p>抽象类的作用</p><ul><li>多用于做顶层设计（设计标准)，以便子类做具体实现。<br>也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法<br>并配合多态使用，获得不同的工作状态。</li></ul></li></ul><h2 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7 . 数据库"></a>7 . 数据库</h2><ul><li>导入数据库pymysql</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line">Connection(主机,端口,账户,密码)即可得到连接对象</span><br><span class="line">连接对象.close()关闭和MySQL数据库的连接</span><br></pre></td></tr></table></figure><ul><li>执行sql</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过连接对象调用cursor()方法，得到游标对象</span><br><span class="line">游标对象.execute()执行sql语句</span><br><span class="line">游标对象.fetchall()可以得到全部的查询结果封装进元组</span><br></pre></td></tr></table></figure><ul><li>确认代码提交</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：手动提交：连接对象.commit()</span><br><span class="line">方法2：自动提交：在Connection()中加入autocommit=True</span><br></pre></td></tr></table></figure><hr><h1 id="3-Python进阶"><a href="#3-Python进阶" class="headerlink" title="3 . Python进阶"></a>3 . Python进阶</h1><h2 id="1-PySpark"><a href="#1-PySpark" class="headerlink" title="1.PySpark"></a>1.PySpark</h2><p>1.什么是Spark、什么是PySpark</p><p>​    Spark是Apache基金会旗下的顶级开源项目，用于对海量数据进行大规模分布式计算。</p><p>​    PySpark是Spark的Python实现，是Spark为Python开发者提供的编程入口，用于以Python代码完成Spark任务的开发</p><p>​    PySpark不仅可以作为Python第三方库使用，也可以将程序提交的Spark集群环境中,调度大规模集群进行执行。</p><p>2.为什么要学习PySpark?</p><p>​    大数据开发是Python众多就业方向中的明星赛道,薪资高岗位多，Spark(PySpark)又是大数据开发中的核心技术</p><ul><li>PySpark的功能都是从SparkContext对象作为执行入口</li></ul><h3 id="1-数据输入"><a href="#1-数据输入" class="headerlink" title="1.数据输入"></a>1.数据输入</h3><p>1.RDD对象是什么?为什么要使用它?</p><p>​    RDD对象称之为分布式弹性数据集，是PySpark中数据计算的载体，它可以:<br>​        提供数据存储<br>​        提供数据计算的各类方法<br>​        数据计算的方法,返回值依旧是RDD (RDD迭代计算)<br>​    后续对数据进行各类计算,都是基于RDD对象进行</p><p>2.如何输入数据到Spark(即得到RDD对象)1</p><p>​    通过SparkContext的parallelize()成员方法，将Python数据容器转换为RDD对象<br>​    通过SparkContext的textFile()成员方法，读取文本文件得到RDD对象</p><h3 id="2-数据计算"><a href="#2-数据计算" class="headerlink" title="2.数据计算"></a>2.数据计算</h3><p>1.map算子(成员方法)</p><ul><li>​    接受一个处理函数，可用lambda表达式快速编写</li><li>​    对RDD内的元素逐个处理，并返回一个新的RDD</li></ul><p>2.链式调用</p><p>​    对于返回值是新RDD的算子，可以通过链式调用的方式多次调用算子。</p><p>3.flatMap算子</p><ul><li>计算逻辑和map一样</li><li>可以比map多出“解除一层嵌套”的功能</li></ul><p>4.reduceByKey算子</p><ul><li>接收一个处理函数，对数据进行两两计算</li><li>自动对key分组，然后对value进行聚合逻辑计算</li></ul><p><img src="https://s2.loli.net/2023/09/13/WYBhn923zEK8Svx.png" alt="QQ图片20230913193510"></p><p>5.filter()算子</p><p>功能：过滤想要的数据进行保留</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd.filter(func)</span><br><span class="line">func返回时True保留，False丢弃</span><br></pre></td></tr></table></figure><p>6.distinct算子</p><p>功能:对RDD数据进行去重,返回新RDD</p><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.distinct()无需传参</span><br></pre></td></tr></table></figure><p>7.sortBy算子</p><p>功能:对RDD数据进行排序,基于你指定的排序依据.</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdd.sortBy(func, ascending=<span class="literal">False</span>,numPartitions=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func: (T) →U:告知按照rdd中的哪个数据进行排序，比如lambda x: x[1] 表示按照rdd中的第二列元素进行排序</span></span><br><span class="line"><span class="comment"># ascending True升序 False降序</span></span><br><span class="line"><span class="comment"># numPartitions:用多少分区排序</span></span><br></pre></td></tr></table></figure><h3 id="3-数据输出"><a href="#3-数据输出" class="headerlink" title="3.数据输出"></a>3.数据输出</h3><ul><li>输出为Python对象</li></ul><p>1.collect算子</p><p>功能:将RDD各个分区内的数据,统一收集到Driver中,形成一个List对象</p><p>用法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.collect()<span class="comment"># 返回值是一个list</span></span><br></pre></td></tr></table></figure><p>2.reduce算子</p><p>功能:对RDD数据集按照你传入的逻辑进行聚合</p><p>语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdd .reduce(func)</span><br><span class="line"><span class="comment"># func: (T,T) →T</span></span><br><span class="line"><span class="comment"># 2参数传入1个返回值,返回值和参数要求类型一致</span></span><br><span class="line"><span class="comment"># 返回值等同于计算函数的返回值</span></span><br></pre></td></tr></table></figure><p>3.take算子</p><p>功能：取RDD的前N个元素，组成list返回给你</p><p>4.count算子</p><p>功能：计算RDD有多少条数据，返回值是一个数字</p><ul><li>输出到文件</li></ul><p>1.saveAsTextFile算子</p><p>功能:将RDD的数据写入文本文件中</p><p>支持本地写出, hdfs等文件系统</p><p>2.修改rdd分区为1</p><p>方法1：SparkConf对象设置属性全局并行度为1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf = SparkConf().setNaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;test_spark&quot;</span>)</span><br><span class="line">conf.<span class="built_in">set</span>(<span class="string">&#x27;spark.default.parallelism&quot;, 1)</span></span><br><span class="line"><span class="string">sc = SparkContext(conf=conf)</span></span><br></pre></td></tr></table></figure><p>方式2：创建RDD的时候设置(parallelize方法传入numSlices参数为1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize([<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>], numSlices=<span class="number">1</span>)</span><br><span class="line">rdd1 = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>]，<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h2><p>1.什么是闭包</p><p>​    定义双层嵌套函数，内层函数可以访问外层函数的变量<br>​    将内存函数作为外层函数的返回，此内层函数就是闭包函数</p><p>2.闭包的好处和缺点</p><ul><li>优点:不定义全局变量,也可以让函数持续访问和修改一个外部变量</li><li>优点:闭包函数引用的外部变量,是外层函数的内部变量。作用域封闭难以被误操作修改</li><li>缺点:额外的内存占用</li></ul><p>3.nonlocal关键字的作用</p><p>​    在闭包函数(内部函数中)想要修改外部函数的变量值<br>​    需要用nonlocal声明这个外部变量</p><h2 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3.装饰器"></a>3.装饰器</h2><ul><li>装饰器就是使用创建一个闭包函数,在闭包函数内调用目标函数，可以达到不改动目标函数的同时，增加额外的功能。</li></ul><p>装饰器的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span> (func):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要睡觉了&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我起床了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@Outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>():</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;睡觉中......&quot;</span>)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">sleep()</span><br></pre></td></tr></table></figure><h2 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4.设计模式"></a>4.设计模式</h2><p>1.什么是设计模式</p><p>设计模式就是一种编程套路。<br>使用特定的套路得到特定的效果</p><p>2.单例设计模式</p><p>单例模式就是对一个类，只获取其唯一的类实例对象，持续复用它</p><ul><li>节省内存</li><li>节省创建对象的开销中</li></ul><p>3.工厂模式</p><p>将对象的创建由使用原生类本身创建<br>转换到由特定的工厂方法来创建</p><p>好处：</p><p>大批量创建对象的时候有统一的入口,易于代码维护</p><p>当发生修改,仅修改工厂类的创建方法即可</p><p>符合现实世界的模式,即由工厂来制作产品(对象)</p><h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5.多线程"></a>5.多线程</h2><h3 id="1-进程、线程"><a href="#1-进程、线程" class="headerlink" title="1.进程、线程"></a>1.进程、线程</h3><p>进程:就是一个程序，运行在系统之上，那么便称之这个程序为一个运行进程，并分配进程ID方便系统管理。</p><p>线程:线程是归属于进程的，一个进程可以开启多个线程,执行不同的工作,是进程的实际工作最小单位。</p><ul><li>进程就好比一家公司，是操作系统对程序进行运行管理的单位</li><li>线程就好比公司的员工,进程可以有多个线程(员工)，是进程实际的工作者</li></ul><p>操作系统中可以运行多个进程，即多任务运行</p><p>一个进程内可以运行多个线程，即多线程运行</p><ul><li>注意点：</li></ul><p>进程之间是内存隔离的，即不同的进程拥有各自的内存空间。这就类似于不同的公司拥有不同的办公场所。</p><p>线程之间是内存共享的,线程是属于进程的，一个进程内的多个线程之间是共享这个进程所拥有的内存空间的。这就好比,公司员工之间是共享公司的办公场所。</p><ul><li>并行执行</li></ul><p>并行执行的意思指的是同一时间做不同的工作。</p><p>进程之间就是并行执行的,操作系统可以同时运行好多程序,这些程序都是在并行执行。我们就称之为:多任务并行执行</p><p>除了进程外，线程其实也是可以并行执行的。</p><p>也就是比如一个Python程序,其实是完全可以做到:</p><blockquote><p>一个线程在输出:你好<br>一个线程在输出: Hello</p></blockquote><p>像这样一个程序在同一时间做两件乃至多件不同的事情，我们就称之为:多线程并行执行</p><h3 id="2-多线程编程"><a href="#2-多线程编程" class="headerlink" title="2.多线程编程"></a>2.多线程编程</h3><p>绝大多数编程语言,都允许多线程编程,Pyhton也不例外。</p><p>Python的多线程可以通过threading模块来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">thread_obj = threading.Thread([group [, target [， name [, args [，kwargs]]]]])</span><br><span class="line">- group:暂时无用，未来功能的预留参数</span><br><span class="line">- target:执行的目标任务名</span><br><span class="line">- args:以元组的方式给执行任务传参</span><br><span class="line">- kwargs:以字典方式给执行任务传参</span><br><span class="line">- name:线程名，一般不用设置</span><br></pre></td></tr></table></figure><ul><li>threading模块的使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">threading_obj = threading.Thread(target=func) 创建线程对象</span><br><span class="line">threading_obj.start()启动线程执行</span><br></pre></td></tr></table></figure><ul><li>如何传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;多线程运行模式&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 方式1：元组</span></span><br><span class="line">sing_thread = threading.Thread(target=sing)</span><br><span class="line">dance_thread = threading.Thread(target=dance，args=(<span class="string">&quot;我在跳舞，哈哈哈&quot;</span>，)</span><br><span class="line">sing_thread.start()</span><br><span class="line">dance_thread.start()</span><br><span class="line"><span class="comment"># 方式2：字典   </span></span><br><span class="line">sing_thread = threading.Thread(target=sing)</span><br><span class="line">dance_thread = threading.Thread(target=dance， kwangs=&#123;<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;我在跳舞，哈哈哈&quot;</span>&#125;)</span><br><span class="line">sing_thread.start()</span><br><span class="line">dance_thread.start()</span><br></pre></td></tr></table></figure><h2 id="6-网络编程"><a href="#6-网络编程" class="headerlink" title="6.网络编程"></a>6.网络编程</h2><p>Socket</p><p>Socket (简称套接字)是进程之间通信一个工具,好比现实生活中的插座,所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要Socket。</p><p>客户端和服务端</p><p>2个进程之间通过Socket进行相互通讯,就必须有服务端和客户端</p><p>Socket服务端:等待其它进程的连接、可接受发来的消息、可以回复消息Socket</p><p>客户端:主动连接服务端、可以发送消息、可以接收回复</p><p><img src="https://s2.loli.net/2023/09/14/HWkuKZUiGO7fbxg.png" alt="QQ图片20230914211103"></p><h2 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式"></a>7.正则表达式</h2><p>正则表达式，又称规则表达式(Regular Expression)，是使用单个字符串来描述、匹配某个句法规则的字符准，常被用来检索、替换那些符合某个模式(规则)的文本。</p><p>简单来说，正则表达式就是一种字符串验证的规则，通过特殊的字符串组合来确立规则,用规则去匹配字符串是否满足</p><p>比如,验证一个字符串是否是符合条件的电子邮箱地址，只需要配置好正则规则,即可匹配任意邮箱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如通过正则规则:(^[\w-]+(\.[w-]+)*@[\w-]+(\.[\w-]+)+$)即可匹配一个字符串是否是标准邮箱格式</span><br></pre></td></tr></table></figure><p>但如果不使用正则,使用if else来对字符串做判断就非常困难了。</p><ul><li>使用re模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>分别是: match、search、findall三个基础方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 从被匹配字符串开头进行匹配，匹配成功返回匹配对象（包含匹配的信息)，匹配不成功返回空None</span></span><br><span class="line">re.search(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 搜索整个字符串，找出匹配的。从前向后,找到第一个后，就停止,不会继续向后，整个字符串都找不到，返回None</span></span><br><span class="line">re.findall(匹配规则，被匹配字符串)</span><br><span class="line"><span class="comment"># 匹配整个字符串，找出全部的匹配项，找不到返回空list:[]</span></span><br></pre></td></tr></table></figure><ul><li>元字符匹配</li><li>字符串前面带上 r 的标记，表示当前字符串是原始字符串，即内部的转义字符无效而是普通字符</li></ul><p>单字符匹配</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>.</td><td>匹配任意1个字符(除了\n), \ . 匹配点本身</td></tr><tr><td>[ ]</td><td>匹配[ ]中列举的字符</td></tr><tr><td>\d</td><td>匹配数字，即0-9</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配空白，即空格、tab键</td></tr><tr><td>\S</td><td>匹配非空白</td></tr><tr><td>\w</td><td>匹配单词字符，即a-z、A-Z、0-9、_</td></tr><tr><td>\W</td><td>匹配非单词字符</td></tr></tbody></table></div><p>数量匹配</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个规则的字符出现0至无数次</td></tr><tr><td>+</td><td>匹配前一个规则的字符出现1至无数次</td></tr><tr><td>?</td><td>匹配前一个规则的字符出现0次或1次</td></tr><tr><td>{m}</td><td>匹配前一个规则的字符出现m次</td></tr><tr><td>{m, }</td><td>匹配前一个规则的字符出现最少m次</td></tr><tr><td>{m,n}</td><td>匹配前一个规则的字符出现m到n次</td></tr></tbody></table></div><p>边界匹配</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table></div><p>分组匹配</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>\</td><td></td><td>匹配左右任意一个表达式</td></tr><tr><td>( )</td><td>将括号中字符作为一个分组</td></tr></tbody></table></div><h2 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h2><p>递归在编程中是一种非常重要的算法</p><p>递归:即方法(函数)自己调用自己的一种特殊编程写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="keyword">if</span> ...:</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/14/7TE8Rpx4IJyOkAe.png" alt="QQ图片20230914221426"></p><p>递归需要注意什么?</p><ul><li>注意退出的条件，否则容易变成无限递归</li><li>注意返回值的传递，确保从最内层，层层传递到最外层，例如+=，将下一层函数的递归加到上面的一层函数</li></ul><p>递归需要调用os模块的3个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.listdir,列出指定目录下的内容</span><br><span class="line">os.path.isdir,判断给定路径是否是文件夹，是返回<span class="literal">True</span>,否返回<span class="literal">False</span></span><br><span class="line">os.path.exists,判断给定路径是否存在，存在返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-python基础&quot;&gt;&lt;a href=&quot;#1-python基础&quot; class=&quot;headerlink&quot; title=&quot;1 . python基础&quot;&gt;&lt;/a&gt;1 . python基础&lt;/h1&gt;&lt;p&gt;print()可以输出多份内容，多份内容可以用”,”隔开&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="http://putongl.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://putongl.github.io/git.html"/>
    <id>http://putongl.github.io/git.html</id>
    <published>2023-08-31T04:43:45.696Z</published>
    <updated>2023-08-31T04:43:32.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1．什么是-Git-仓库"><a href="#1．什么是-Git-仓库" class="headerlink" title="1．什么是 Git 仓库?"></a>1．什么是 Git 仓库?</h2><p>记录文件状态内容和历史记录的地方(.git文件夹)</p><h2 id="2．如何创建Git仓库"><a href="#2．如何创建Git仓库" class="headerlink" title="2．如何创建Git仓库?"></a>2．如何创建Git仓库?</h2><p>1.把本地文件夹转换成Git仓库:命令git init</p><p>2.从其他服务器上克隆Git仓库</p><h2 id="3-Git的三个区域"><a href="#3-Git的三个区域" class="headerlink" title="3 .    Git的三个区域"></a>3 .    Git的三个区域</h2><p>Git 使用时:</p><p>工作区:实际开发时操作的文件夹</p><p>暂存区:保存之前的准备区域（暂存改动过的文件)</p><p>版本库:提交并保存暂存区中的内容，产生一个版本快照</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git add 文件名</td><td>暂存指定文件</td></tr><tr><td>git add .</td><td>保存到暂存区，暂存所有改动的文件</td></tr><tr><td>git commit -m “注释说明”</td><td>保存到版本库，提交并保存，产生版本快照</td></tr></tbody></table></div><p><img src="https://s2.loli.net/2023/08/27/SpN3vhQYbmdnBt9.png" alt="img"></p><h2 id="4-Git文件状态"><a href="#4-Git文件状态" class="headerlink" title="4 .    Git文件状态"></a>4 .    Git文件状态</h2><p>Git文件2种状态:</p><p>未跟踪:新文件，从未被Git管理过</p><p>已跟踪:Git已经知道和管理的文件（新添加，未修改，已修改）</p><p>使用:修改文件，暂存，提交保存记录，如此反复</p><ul><li>使用git status -s查看文件状态</li><li>第一列是暂存区状态</li><li>第二列是工作区状态</li></ul><div class="table-container"><table><thead><tr><th>文件状态</th><th>概念</th><th>场景</th></tr></thead><tbody><tr><td>未跟踪（U）</td><td>从未被Git管理过</td><td>新文件</td></tr><tr><td>新添加（A）</td><td>第一次被Git暂存</td><td>之前版本记录无此文件</td></tr><tr><td>未修改（’’）</td><td>三个区域统一</td><td>提交后保存</td></tr><tr><td>已修改（M）</td><td>工作区内容无变化</td><td>修改了内容产生</td></tr></tbody></table></div><h2 id="5-Git暂存区使用"><a href="#5-Git暂存区使用" class="headerlink" title="5 .    Git暂存区使用"></a>5 .    Git暂存区使用</h2><p>暂存区:暂时存储，可以临时恢复代码内容，与版本库解耦</p><p>暂存区-&gt;覆盖-&gt;工作区，命令: git restore目标文件（注意∶完全确认覆盖时使用)</p><p>从暂存区移除文件，命令: git rm —cached目标文件</p><p>查看暂存区的内容，命令：git ls-files</p><p>查看之前所有的提交历史，命令：git log —oneline</p><p><img src="https://s2.loli.net/2023/08/27/8ys6h3CiZSFlkgf.png" alt="image-20230827133555585"></p><h2 id="6-Git回退版本"><a href="#6-Git回退版本" class="headerlink" title="6 .    Git回退版本"></a>6 .    Git回退版本</h2><p>概念:把版本库某个版本对应的内容快照，恢复到工作区/暂存区查看</p><p>提交历史:git log —oneline</p><p>查看所有的历史:git reflog —oneline</p><p>回退命令:</p><p>git reset —soft 版本号（其他文件未跟踪)    css，js暂存区工作区全部保留</p><p>git reset —hard 版本号    css，js暂存区工作区不保留直接删除，先恢复暂存区，再恢复工作区</p><p>git reset —mixed版本号(与git reset等价)    暂存区不保留，工作区保留</p><p>注意1:只有记录在版本库的提交记录才能恢复<br>注意2:回退后，继续修改-&gt;暂存-&gt;提交操作即可（产生新的提交记录过程)</p><h2 id="7-分支"><a href="#7-分支" class="headerlink" title="7 .    分支"></a>7 .    分支</h2><p>概念:本质上是指向提交节点的可变指针，默认名字是master</p><p>注意:HEAD指针影响工作区/暂存区的代码状态，指向哪个分支使用哪个分支</p><p>场景:开发新需求/修复Bug，保证主线代码随时可用，多人协同开发提高效率</p><h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1 . 创建分支"></a>1 . 创建分支</h3><p>1.创建分支命令:git branch 分支名，以HEAD指针指向的分支作为起点来创建分支</p><p>2.切换分支命令:git checkout 分支名，使HEAD指向这个分支，就能来操控这个分支</p><h3 id="2-合并并删除"><a href="#2-合并并删除" class="headerlink" title="2 .  合并并删除"></a>2 .  合并并删除</h3><p>1．切回到要合入的分支上: git checkout master</p><p>2．合并其他分支过来:git merge login-bug</p><p>3．删除合并后的分支指针: git branch -d login-bug</p><p>第二个分支合并：合并提交，发生于原分支产生了新的提交记录后，再合并回去时发生，自动使用多个快照记录合并后产生一次新的提交</p><p><img src="https://s2.loli.net/2023/08/27/39qTPKuyeYSEJsf.png" alt="QQ图片20230827202417"></p><p>注意:提交记录的顺序按照产生的先后顺序排列，而非合并的先后顺序</p><p><img src="https://s2.loli.net/2023/08/27/GJaUh5bkmH2xVnv.png" alt="image-20230827202532657"></p><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><img src="https://s2.loli.net/2023/08/27/V1HzftLTnRh9dcF.png" alt="QQ图片20230827211901"></p><p><img src="https://s2.loli.net/2023/08/27/d1i3QAqLgbVNo79.png" alt="QQ图片20230827211907"></p><p><img src="https://s2.loli.net/2023/08/31/YKAMmq1GZoaVCe7.png" alt="QQ图片20230831120423"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;1．什么是-Git-仓库&quot;&gt;&lt;a href=&quot;#1．什么是-Git-仓库&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="http://putongl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="http://putongl.github.io/2.html"/>
    <id>http://putongl.github.io/2.html</id>
    <published>2023-08-07T07:08:52.335Z</published>
    <updated>2023-08-27T03:50:52.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="1-判断相等或者不等于（-、-、-、-）运算符"><a href="#1-判断相等或者不等于（-、-、-、-）运算符" class="headerlink" title="1.判断相等或者不等于（==、===、!=、!==）运算符"></a>1.判断相等或者不等于（==、===、!=、!==）运算符</h2><div class="table-container"><table><thead><tr><th>等值检测运算符</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>==（相等）</td><td>比较两个操作数的值是否相等，会自动进行隐式转换，比如：18 == ‘18’，会为true</td></tr><tr><td>!=（不想等）</td><td>比较两个操作数的值是否不相等</td></tr><tr><td>===（全等）</td><td>比较两个操作数的值是否相等，同时检测它们的类型是否相同</td></tr><tr><td>!==（不全等）</td><td>比较两个操作数的值是否不相等，同时检测它们的类型是否不相同</td></tr></tbody></table></div><p>在相等运算中，应注意以下几个问题：</p><ul><li>如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。</li><li>如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。</li><li>如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。</li><li>如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。</li><li>如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。</li></ul><h2 id="2-短路运算"><a href="#2-短路运算" class="headerlink" title="2.短路运算"></a>2.短路运算</h2><h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>​    短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的 值; </p><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><ul><li><p>​    语法： 表达式1 &amp;&amp; 表达式2 </p></li><li><p>如果第一个表达式的值为真，则返回表达式2 </p></li><li><p>如果第一个表达式的值为假，则返回表达式1</p></li><li><pre><code>console.log( 123 &amp;&amp; 456 ); // 456console.log( 0 &amp;&amp; 456 ); // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 逻辑或 </span><br><span class="line"></span><br><span class="line">- ​语法： 表达式1 || 表达式2 </span><br><span class="line">- 如果第一个表达式的值为真，则返回表达式1</span><br><span class="line">- 如果第一个表达式的值为假，则返回表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure>console.log( 123 || 456 ); // 123console.log( 0 || 456 ); // 456console.log( 123 || 456 || 789 ); // 123<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.函数的参数</span><br><span class="line"></span><br><span class="line">### 3.1形参和实参</span><br><span class="line"></span><br><span class="line">在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br><span class="line">| 参数 | 说明                                                        |</span><br><span class="line">| ---- | ----------------------------------------------------------- |</span><br><span class="line">| 形参 | 形式上的参数 函数定义的时候，传递的参数，当时并不知道是什么 |</span><br><span class="line">| 实参 | 实际上的参数 函数调用的时候，传递的参数，实参是传递给形参的 |</span><br><span class="line"></span><br><span class="line">参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</span><br><span class="line"></span><br><span class="line">- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...);</code></pre></li></ul><h3 id="3-2函数形参和实参个数不匹配问题"><a href="#3-2函数形参和实参个数不匹配问题" class="headerlink" title="3.2函数形参和实参个数不匹配问题"></a>3.2函数形参和实参个数不匹配问题</h3><div class="table-container"><table><thead><tr><th>参数个数</th><th>说明</th></tr></thead><tbody><tr><td>实参的个数等于形参的个数</td><td>输出正确结果</td></tr><tr><td>实参的个数多于形参的个数</td><td>只取到形参的个数</td></tr><tr><td>实参的个数小于形参的个数</td><td>多的形参定义为undefined，结果为NaN</td></tr></tbody></table></div><h3 id="3-3arguments的使用"><a href="#3-3arguments的使用" class="headerlink" title="3.3arguments的使用"></a>3.3arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上 它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的 所有实参。</p><p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li>可以有无数多个参数，实参有几个，arguments就有几个</li><li>具有 length 属性 </li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ul><h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4.预解析"></a>4.预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两 步：预解析和代码执行。</p><ul><li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提 前声明或者定义。</p></li><li><p>代码执行： 从上到下执行JS语句。</p></li></ul><p>预解析会把变量和函数的声明在代码执行之前执行完成。</p><ul><li>函数预解析</li><li>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</li></ul><h2 id="5-事件对象"><a href="#5-事件对象" class="headerlink" title="5.事件对象"></a>5.事件对象</h2><p>e.target 和 this 的区别：</p><p>​    this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素），谁绑定了这个点击事件，那么就返回谁 </p><p>​    e.target 是事件触发的元素。点击了哪个元素，就返回哪个元素</p><p>给ul绑定事件，this指向的是ul，e.target指向的是li</p><p>eventTarget.addEventListener(‘click’, function(event) { </p><p>​        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </p><p>}）</p><ul><li>addEventListener(‘click’, function(event)，true)</li><li>第三个参数为true，则为捕获阶段</li><li>省略不写，或为false，为冒泡阶段</li></ul><h2 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h2><ul><li>定义:执行代码和收集异步任务的模型，在调用栈空闲，反复调用任务队列里回调函数的执行机制，就叫事件循环</li></ul><p>执行过程</p><p>1.执行同步代码，遇到异步代码交给宿主浏览器环境</p><p>2.执行异步有了结果后，把回调函数放入任务队列排队</p><p>3.当调用栈空闲后，反复调用任务队列里的回调函数</p><p><img src="https://s2.loli.net/2023/08/27/qLNrMJUvgkXTQom.png" alt="image-20230827115025297"></p><h2 id="7-宏任务和微任务"><a href="#7-宏任务和微任务" class="headerlink" title="7.宏任务和微任务"></a>7.宏任务和微任务</h2><ul><li>1．什么是宏任务?</li><li>浏览器执行的异步代码</li><li>例如:JS执行脚本事件，setTimeout/setlnterval,AJAX请求完成事件，用户交互事件等</li><li>2．什么是微任务?</li><li>JS引擎执行的异步代码</li><li>例如:Promise对象.then()的回调</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;h2 id=&quot;1-判断相等或者不等于（-、-、-、-）运算符&quot;&gt;&lt;a href=&quot;#1-判断相等或者不等于（-、-、-、-）运算符&quot; class</summary>
      
    
    
    
    
    <category term="js" scheme="http://putongl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="http://putongl.github.io/4.html"/>
    <id>http://putongl.github.io/4.html</id>
    <published>2023-08-07T07:08:50.520Z</published>
    <updated>2023-08-07T09:39:17.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？"><a href="#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？" class="headerlink" title="Visual Studio Code代码想要同时编辑多处，该怎么实现呢？"></a>Visual Studio Code代码想要同时编辑多处，该怎么实现呢？</h2><h3 id="1-重命名变量"><a href="#1-重命名变量" class="headerlink" title="1. 重命名变量"></a>1. 重命名变量</h3><p>首先看看自己需要同时修改多处的代码是不是要重命名一个变量，如果是的话，有现成的快捷键<code>f2</code></p><p>使用方法：</p><ul><li>选中一个变量，按<code>f2</code> 或者 按 <code>Fn + f2</code>，具体依据电脑品牌而定！</li><li>弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。</li></ul><p>注意:在<code>js文件</code>中，如果这个变量没有用<code>var或者const或者let</code>声明，会无法重命名</p><h3 id="2-多光标"><a href="#2-多光标" class="headerlink" title="2. 多光标"></a>2. 多光标</h3><blockquote><ol><li>按住<code>alt</code>，用鼠标<code>左键点击</code>，可以出现多个光标，输入的代码可以在光标处同时增加</li></ol><p><img src="https://s2.loli.net/2023/08/07/x1Yai5TOJtr7VIG.png" alt="在这里插入图片描述"></p><ol><li>按住<code>Ctrl + Alt</code>，再按键盘上向上或者向下的键，可以使一列上出现多个光标。</li></ol><p><img src="https://s2.loli.net/2023/08/07/fMbWCoecKLqyhA3.png" alt="在这里插入图片描述"></p><ol><li>选中一段文字，按<code>shift+alt+i</code>，可以在每行末尾出现光标</li></ol><p><img src="https://s2.loli.net/2023/08/07/e3PyGSgTMtpbEHB.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/LcGv4XFP6iWn2dV.png" alt="在这里插入图片描述"></p><ol><li>光标放在一个地方，按<code>ctrl+shift+L</code>或者<code>ctrl+f2</code>，可以在页面中出现这个词的不同地方都出现光标。<code>有时候这个快捷键的作用和f2重命名变量类似</code>，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。</li></ol><p><img src="https://s2.loli.net/2023/08/07/Gz9gh8JyCFPAvcR.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/qWl2I3RTDKmhjsy.png" alt="在这里插入图片描述"></p><ol><li>按<code>shift+alt</code>，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。</li></ol><p><img src="https://s2.loli.net/2023/08/07/JQBkh5OagERo67y.png" alt="在这里插入图片描述"></p><ol><li>任何光标操作，可以按<code>Ctrl + U</code>取消</li></ol></blockquote><h3 id="3-替换字符串"><a href="#3-替换字符串" class="headerlink" title="3. 替换字符串"></a>3. 替换字符串</h3><blockquote><ol><li><p>按<code>ctrl+f</code>，可以搜索当前页面，然后按搜索框左边的小三角符号，<code>可以切换成替换模式</code>。</p><p>有时候使用字符串替换，比多光标方便，但是注意别不小心替换掉不想替换的内容。</p></li></ol><p><img src="https://s2.loli.net/2023/08/07/fEYHuMR4poLmb7n.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/dGwyr54Vso9ZT7C.png" alt="QQ图片20230807173855"></p><p>以上就是<code>vscode</code>同时编辑多处的三种方法，希望大家喜欢，谢谢！</p></blockquote><h3 id="4-全局替换某些单词"><a href="#4-全局替换某些单词" class="headerlink" title="4.全局替换某些单词"></a>4.全局替换某些单词</h3><ul><li>​        快捷键：ctrl + h </li></ul><h3 id="5-快速定位到某一行"><a href="#5-快速定位到某一行" class="headerlink" title="5.快速定位到某一行"></a>5.快速定位到某一行</h3><ul><li>​        快捷键：ctrl + g</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot;&gt;&lt;a href=&quot;#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Code代码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue笔记</title>
    <link href="http://putongl.github.io/vue.html"/>
    <id>http://putongl.github.io/vue.html</id>
    <published>2023-08-02T07:15:31.884Z</published>
    <updated>2023-09-17T13:34:33.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h2 id="1-Vue-是什么"><a href="#1-Vue-是什么" class="headerlink" title="1.Vue 是什么"></a>1.Vue 是什么</h2><h3 id="1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架"><a href="#1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架" class="headerlink" title="1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架"></a>1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架</h3><p>基于数据渲染出用户看到的页面</p><ul><li>Vue 的两种使用方式：</li></ul><p>​        ① Vue 核心包开发</p><p>​                场景：局部 模块改造</p><p>​        ② Vue 核心包 &amp; Vue 插件 工程化开发</p><p>​                场景：整站 开发</p><h3 id="1-2-创建-Vue-实例，初始化渲染的核心步骤："><a href="#1-2-创建-Vue-实例，初始化渲染的核心步骤：" class="headerlink" title="1.2.创建 Vue 实例，初始化渲染的核心步骤："></a>1.2.创建 Vue 实例，初始化渲染的核心步骤：</h3><ol><li><p>准备容器</p></li><li><p>引包 (官网) - 开发版本 / 生产版本</p></li><li><p>创建 Vue 实例 new Vue()</p></li><li><p>指定配置项 el data =&gt; 渲染数据</p></li></ol><ul><li>① 通过el配置选择器 ，指定vue管理的是哪个盒子，作用跟vue脚手架中的main.js中的</li><li>$mount()作用一致</li><li>② data 提供数</li></ul><h3 id="1-3-插值表达式"><a href="#1-3-插值表达式" class="headerlink" title="1.3.插值表达式"></a>1.3.插值表达式</h3><p>插值表达式是一种 Vue 的模板语法</p><ol><li><p>作用: 利用表达式进行插值，渲染到页面中</p><p>​    表达式：是可以被求值的代码，JS引擎会将其计算出一个结果</p></li><li><p>语法：</p></li><li><p>注意点：</p><p>（1）使用的数据必须存在 （data） </p><p>（2）支持的是表达式，而非语句，比如：if for ..</p><p>（3）不能在标签属性中使用插值表达式</p></li></ol><h3 id="1-4-Vue-核心特性：响应"><a href="#1-4-Vue-核心特性：响应" class="headerlink" title="1.4.Vue 核心特性：响应"></a>1.4.Vue 核心特性：响应</h3><ul><li><p>​    数据的响应式处理 → 响应式：数据变化，视图自动更新</p><p>​        使用 Vue 开发，关注业务的核心逻辑，根据业务修改数据即可</p></li><li><p>​    如何访问或修改数据呢？</p><p>​        data中的数据, 最终会被添加到实例上</p><p>​            ① 访问数据： “实例.属性名”</p><p>​            ② 修改数据： “实例.属性名” = “值”</p></li></ul><h3 id="1-5-Vue-指令"><a href="#1-5-Vue-指令" class="headerlink" title="1.5.Vue 指令"></a>1.5.Vue 指令</h3><p>Vue 会根据不同的【指令】，针对标签实现不同的【功能】</p><p>​    指令：带有 v- 前缀 的 特殊 标签属性，不同属性 对应 不同的功能</p><p>v-html:作用：设置元素的 innerHTML语法：v-html = “表达式”</p><ul><li>​    动态解析标签</li></ul><pre><code>  msg: `    &lt;a href=&quot;http://douyin.com&quot;&gt;        抖音         &lt;/a&gt;   ` </code></pre><p>​    msg里面不是引号，是Tab上面的 `号</p><p>v-show and v-if</p><p>v-show</p><ol><li><p>作用： 控制元素显示隐藏</p></li><li><p>语法： v-show = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 切换 display:none 控制显示隐藏</p></li><li><p>场景： 频繁切换显示隐藏的场景</p></li></ol><p>v-if</p><ol><li><p>作用： 控制元素显示隐藏（条件渲染）</p></li><li><p>语法： v-if = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 基于条件判断，是否 创建 或 移除 元素节点</p></li><li><p>场景： 要么显示，要么隐藏，不频繁切换的场景</p></li></ol><p>v-else v-else-if</p><ol><li><p>作用： 辅助 v-if 进行判断渲染</p></li><li><p>语法： v-else v-else-if = “表达式”</p></li><li><p>注意： 需要紧挨着 v-if 一起使用</p></li></ol><p>v-on</p><ul><li><p>作用： 注册事件 = 添加监听 + 提供处理逻辑</p></li><li><p>语法：① v-on:事件名 = “内联语句”        @click=”count++”</p><p> ​           ② v-on:事件名 = “methods中的函数名”</p></li><li><p>简写：@事件名        v-on:click替换成@click</p></li><li>注意：methods函数内的 this 指向 Vue 实例 </li></ul><p>v-bind</p><ol><li><p>作用： 动态的设置html的标签属性 → src url title ..</p></li><li><p>语法： v-bind:属性名=”表达式”</p></li><li><p>注意： 简写形式  :属性名=”表达式”</p><p>v-for</p></li><li><p>作用： 基于数据循环， 多次渲染整个元素</p></li><li><p>遍历数组语法：</p><ul><li>v-for = “(item, index) in 数组”</li><li>item 数组中的每一项数据， index 下标</li><li>也可以省略 index: v-for = “item in 数组“</li></ul></li><li>v-for 中的 key<ul><li>语法： :key属性 = “唯一标识”</li><li>key前面加:表示动态的属性值</li><li>作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。</li><li>key 的值必须具有 唯一性</li><li>推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li></ul></li><li>v-for 的默认行为会尝试 原地修改元素 （就地复用）</li></ol><p>v-model</p><ol><li><p>作用: 给 表单元素 使用, 双向数据绑定 → 可以快速 获取 或 设置 表单元素内容 </p><p>① 数据变化 → 视图自动更新 </p><p>② 视图变化 → 数据自动更新 </p></li><li><p>语法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-model = &#x27;变量&#x27;</span><br></pre></td></tr></table></figure></li></ol><p><strong><code>v-model.trim()</code></strong> 方法从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串。此上下文中的空格是指所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）。</p><p><strong><code>v-model.number()</code></strong> 方法可以将输入的数据转换为Number类型，否则虽然你输入的是数字.但它的类型其实是String</p><p><strong><code>v-model.lazy()</code></strong>方法失去焦点更新，并不是实时改变，而是在失去焦点或者按回车时才会更新，类似懒加载</p><h3 id="1-6-指令修饰符"><a href="#1-6-指令修饰符" class="headerlink" title="1.6.指令修饰符"></a>1.6.指令修饰符</h3><ul><li>通过 “.” 指明一些指令 后缀，不同 后缀 封装了不同的处理操作 → 简化代码</li><li>① 按键修饰符<ul><li>@keyup.enter → 键盘回车监听</li></ul></li><li>② v-model修饰符<ul><li>v-model.trim → 去除首尾空格</li><li>v-model.number → 转数字</li></ul></li><li>③ 事件修饰符<ul><li>@事件名.stop → 阻止冒泡</li><li>@事件名.prevent → 阻止默认行为</li></ul></li></ul><h3 id="1-7-v-bind-对于样式控制的增强"><a href="#1-7-v-bind-对于样式控制的增强" class="headerlink" title="1.7.v-bind 对于样式控制的增强"></a>1.7.v-bind 对于样式控制的增强</h3><ul><li>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 class 类名 和 style 行内样式 进行控制 。</li></ul><ol><li><p>操作class</p><ul><li><p>语法 :class = “对象/数组” </p><p>① 对象 → 键就是类名，值是布尔值。如果值为 true，有这个类，否则没有这个类</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：一个类名，来回切换</p><p>​            ② 数组 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表 v-bind 对于样式控制的增强 - 操作class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;[ 类名1, 类名2, 类名3 ]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：批量添加或删除类</p></li><li><p>操作style</p><ul><li>语法 :style = “样式对象”</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :style=&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：某个具体属性的动态设置</p><h3 id="1-8-v-model-应用于其他表单元素"><a href="#1-8-v-model-应用于其他表单元素" class="headerlink" title="1.8.v-model 应用于其他表单元素"></a>1.8.v-model 应用于其他表单元素</h3><ul><li>​    常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值</li><li>​        v-model 应用于其他表单元素</li><li>​    它会根据 控件类型 自动选取 正确的方法 来更新元素</li></ul><h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9.计算属性"></a>1.9.计算属性</h3><ul><li>概念：基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。</li><li>语法：</li><li>① 声明在 computed 配置项中，一个计算属性对应一个函数</li><li>② 使用起来和普通属性一样使用 </li><li>计算属性 → 可以将一段 求值的代码 进行封装</li></ul><h3 id="1-10-computed-计算属性-vs-methods-方法"><a href="#1-10-computed-计算属性-vs-methods-方法" class="headerlink" title="1.10. computed 计算属性 vs methods 方法"></a>1.10. computed 计算属性 vs methods 方法</h3><ul><li>computed 计算属性：<ul><li>作用：封装了一段对于数据的处理，求得一个结果。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为属性，直接使用 → this.计算属性 </li></ul></li><li>缓存特性（提升性能）：<ul><li>计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 → 并再次缓存</li></ul></li></ul></li><li>methods 方法：<ul><li>作用：给实例提供一个方法，调用以处理业务逻辑。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为方法，需要调用 → this方法 /( ) </li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue笔记&quot;&gt;&lt;a href=&quot;#Vue笔记&quot; class=&quot;headerlink&quot; title=&quot;Vue笔记&quot;&gt;&lt;/a&gt;Vue笔记&lt;/h1&gt;&lt;h2 id=&quot;1-Vue-是什么&quot;&gt;&lt;a href=&quot;#1-Vue-是什么&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Vue" scheme="http://putongl.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>IKUN</title>
    <link href="http://putongl.github.io/888.html"/>
    <id>http://putongl.github.io/888.html</id>
    <published>2023-08-01T09:16:56.217Z</published>
    <updated>2023-08-02T11:56:45.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回忆录"><a href="#回忆录" class="headerlink" title="回忆录"></a>回忆录</h2><p>一个真正的IKUN，他会跳舞，比如这样</p><p><img src="https://s2.loli.net/2023/08/02/ucfJQoM1SIgnzVC.png" alt="3bfc6928d18ff1188d5e5a6a69778fa"></p><p>他用他优美的舞姿，展现出不一样的风采，一个练习时常两年半的真正的MAN</p><p>著名的麦克阿瑟表示，没想到谷桑成不欺我，他差点又说出那句练习两年半的深田坤桑最爱的话:哎呦，你干嘛！！我上我也行！！大型传奇纪录片:谷门吹牛逼术，持续为您播出！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回忆录&quot;&gt;&lt;a href=&quot;#回忆录&quot; class=&quot;headerlink&quot; title=&quot;回忆录&quot;&gt;&lt;/a&gt;回忆录&lt;/h2&gt;&lt;p&gt;一个真正的IKUN，他会跳舞，比如这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/0</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Yml文档</title>
    <link href="http://putongl.github.io/5.html"/>
    <id>http://putongl.github.io/5.html</id>
    <published>2023-07-31T07:53:33.760Z</published>
    <updated>2023-08-07T07:13:50.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yml内容"><a href="#yml内容" class="headerlink" title="yml内容"></a>yml内容</h2><p>乱码：改成utf-8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;yml内容&quot;&gt;&lt;a href=&quot;#yml内容&quot; class=&quot;headerlink&quot; title=&quot;yml内容&quot;&gt;&lt;/a&gt;yml内容&lt;/h2&gt;&lt;p&gt;乱码：改成utf-8&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>海贼王</title>
    <link href="http://putongl.github.io/1.html"/>
    <id>http://putongl.github.io/1.html</id>
    <published>2023-07-29T09:18:40.507Z</published>
    <updated>2023-08-07T07:14:05.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2023年8月6日路飞5档，起飞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;2023年8月6日路飞5档，起飞&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
