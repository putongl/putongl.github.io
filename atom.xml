<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>普通l</title>
  
  
  <link href="http://putongl.github.io/atom.xml" rel="self"/>
  
  <link href="http://putongl.github.io/"/>
  <updated>2023-09-13T09:22:15.074Z</updated>
  <id>http://putongl.github.io/</id>
  
  <author>
    <name>普通L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python</title>
    <link href="http://putongl.github.io/Python.html"/>
    <id>http://putongl.github.io/Python.html</id>
    <published>2023-09-13T09:22:35.062Z</published>
    <updated>2023-09-13T09:22:15.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-python基础"><a href="#1-python基础" class="headerlink" title="1 . python基础"></a>1 . python基础</h1><p>print()可以输出多份内容，多份内容可以用”,”隔开</p><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1 . 注释"></a>1 . 注释</h2><p>单行注释：以 # 开头，# 右边的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用</p><p>注意,#号和注释内容一般建议以一个空格隔开</p><p>多行注释： 以 一对三个双引号 引起来 (“”” “””)来解释说明一段代码的作用使用方法</p><h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2 . 类型转换"></a>2 . 类型转换</h2><p>type()查看数据的类型</p><div class="table-container"><table><thead><tr><th>语句（函数）</th><th>说明</th></tr></thead><tbody><tr><td>int(x)</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换为一个浮点数</td></tr><tr><td>str(x)</td><td>将对象x转换为一个字符数</td></tr></tbody></table></div><h2 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3 . 字符串格式化"></a>3 . 字符串格式化</h2><div class="table-container"><table><thead><tr><th>格式符号</th><th>转化</th></tr></thead><tbody><tr><td>%s</td><td>将内容转化为字符串，放入占位位置</td></tr><tr><td>%d</td><td>将内容转化为整数，放入占位位置</td></tr><tr><td>%f</td><td>将内容转化为浮点型，放入占位位置</td></tr></tbody></table></div><ul><li>数字精度控制</li></ul><p>我们可以使用辅助符号”m.n”来控制数据的宽度和精度</p><ul><li><p>m，控制宽度，要求是数字（很少使用),设置的宽度小于数字自身，不生效</p></li><li><p>.n，控制小数点精度，要求是数字，会进行小数的四舍五入</p><p>示例:</p></li><li><p>%5d:表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成   11，用三个空格补足宽度。</p></li><li><p>.%5.2f:表示将宽度控制为5，将小数点精度设置为2</p></li><li><p>小数点和小数部分也算入宽度计算。</p></li></ul><p>快速格式化</p><ul><li>f”内容{变量}”</li></ul><p>例子</p><ul><li>print(f”我是{name}”)</li></ul><h2 id="4-if语句"><a href="#4-if语句" class="headerlink" title="4 . if语句"></a>4 . if语句</h2><ol><li>if elif else语句的作用是?<br>可以完成多个条件的判断</li><li>使用if elif else的注意点有:<br>elif可以写多个<br>判断是互斥且有序的，上一个满足后面的就不会判断了<br>可以在条件判断中，直接写input语句，节省代码量</li></ol><h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5 . 循环语句"></a>5 . 循环语句</h2><ol><li><p>whlie循环</p><p>while 条件：</p><p>​        条件满足时，做的事情</p></li><li><p>for循环</p><p>语法格式是:<br>for 临时变量 in 待处理数据集(序列）:</p><pre><code>    循环满足条件时执行的代码</code></pre></li><li><p>while循环和for循环，都是循环语句，但细节不同:。</p><ul><li>在循环控制上:</li></ul><p>while循环可以自定循环条件﹐并自行控制<br>for循环不可以自定循环条件，只可以一个个从容器内取出数据。</p><ul><li>在无限循环上:</li></ul><p>while循环可以通过条件控制做到无限循环<br>for循环理论上不可以，因为被遍历的容器容量不是无限的</p><ul><li>在使用场景上:</li></ul><p>while循环适用于任何想要循环的场景<br>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</p></li></ol><h2 id="6-range语句"><a href="#6-range语句" class="headerlink" title="6 . range语句"></a>6 . range语句</h2><ul><li><p>语法1:</p></li><li><p>range(num)</p></li></ul><p>获取一个从0开始，到num结束的数字序列（不含num本身)</p><p>如range(5)取得的数据是:[0,1,2,3,4]</p><ul><li><p>语法2:</p></li><li><p>range(num1,num2)</p></li></ul><p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p><p>如,range(5,10)取得的数据是:[5,6,7,8,9]</p><ul><li><p>语法3:</p></li><li><p>range(num1, num2, step)</p></li></ul><p>获得一个从num1开始，到num2结束的数字序列（不含num2本身)</p><p>数字之间的步长，以step为准(step默认为1)</p><p>如，range(5,10,2)取得的数据是:[5,7,9]</p><h2 id="7-循环中断"><a href="#7-循环中断" class="headerlink" title="7 . 循环中断"></a>7 . 循环中断</h2><ul><li>continue：中断本次循环，直接进入下一次循环</li><li>break：直接结束整个循环</li></ul><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8 . 函数"></a>8 . 函数</h2><ul><li>函数的定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">函数名</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure><ul><li>函数的返回值：函数执行完之后，返回给调用者的结果</li></ul><p>函数体遇到return后就结束了，卸载return后面的代码不执行</p><p>1.什么是None</p><p>None是类型’NoneType’的字面量，用于表示:空的、无意义的</p><p>2.函数如何返回None</p><p>不使用return语句即返回None</p><p>主动return None</p><p>3.使用场景<br>函数返回值<br>if判断<br>变量定义(赋值为None，表示暂时不提供值)</p><h2 id="9-变量"><a href="#9-变量" class="headerlink" title="9 . 变量"></a>9 . 变量</h2><p>1.什么是局部变量<br>    作用范围在函数内部，在函数外部无法使用<br>2.什么是全局变量<br>    在函数内部和外部均可使用<br>3.如何将函数内定义的变量声明为全局变量<br>    使用global关键字，global变量</p><h2 id="10-数据容器"><a href="#10-数据容器" class="headerlink" title="10 . 数据容器"></a>10 . 数据容器</h2><h3 id="1-列表list"><a href="#1-列表list" class="headerlink" title="1 . 列表list"></a>1 . 列表list</h3><ul><li>list() 空列表</li><li>列表排序<ul><li>列表.sort(key=选择排序依据的函数，reverse=True l False)<ul><li>参数key，是要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排序的依据。</li><li>参数reverse，是否反转排序结果，True表示降序，False表示升序</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2023/09/06/uPUwFhj6o5lM1ds.png" alt="QQ图片20230906211908"></p><h3 id="2-元组tuple"><a href="#2-元组tuple" class="headerlink" title="2 . 元组tuple"></a>2 . 元组tuple</h3><ul><li>空元组( )，tuple()</li><li>注意：不可修改内容（可以修改内部list的内部元素）</li></ul><p><img src="https://s2.loli.net/2023/09/06/ezOmdgCiJI2XH3D.png" alt="QQ图片20230906215231"></p><h3 id="3-字符串str"><a href="#3-字符串str" class="headerlink" title="3 . 字符串str"></a>3 . 字符串str</h3><ul><li><p>“ “</p></li><li><p>字符串的比较大小，基于数字的ASCII码表的码值来进行比较</p></li></ul><p><img src="https://s2.loli.net/2023/09/06/DJMGCRn1gNdcjBH.png" alt="QQ图片20230906221041"></p><h3 id="4-序列的切片"><a href="#4-序列的切片" class="headerlink" title="4 . 序列的切片"></a>4 . 序列的切片</h3><ul><li><p>序列：列表，元组，字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列[起始:结束:步长]</span><br></pre></td></tr></table></figure></li></ul><p>​    起始可以省略，省略从头开始<br>​    结束可以省略，省略到尾结束（不包含尾）<br>​    步长可以省略，省略步长为1（可以为负数，表示倒序执行，负一表示反转)</p><h3 id="5-集合str"><a href="#5-集合str" class="headerlink" title="5 . 集合str"></a>5 . 集合str</h3><ul><li>set( )，定义空集合</li><li>无序，去重</li><li>不支持下标索引访问</li></ul><p><img src="https://s2.loli.net/2023/09/07/dCvGrIDVcf2A1QF.png" alt="QQ图片20230907103350"></p><h3 id="6-字典dict"><a href="#6-字典dict" class="headerlink" title="6 . 字典dict"></a>6 . 字典dict</h3><ul><li><p>字典{key:value,key:value}</p></li><li><p>空字典{}，dict()</p></li><li>不可以使用下标索引</li><li>获取value：字典[key]</li></ul><p><img src="https://s2.loli.net/2023/09/07/s89whRZQWfMGYtN.png" alt="QQ图片20230907115521"></p><p>直接对字典进行遍历，每一次循环得到的是key</p><p><img src="https://s2.loli.net/2023/09/07/t5ZQukl1ymvacRg.png" alt="QQ图片20230907191822"></p><ul><li>容器的通用操作</li></ul><p><img src="https://s2.loli.net/2023/09/07/nHgRM8pNySkIYja.png" alt="QQ图片20230907193354"></p><h2 id="11-函数进阶"><a href="#11-函数进阶" class="headerlink" title="11 . 函数进阶"></a>11 . 函数进阶</h2><ul><li>一个函数有多个返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">x,y,z = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><ul><li>函数多种传参方式</li></ul><p>1.掌握位置参数<br>    根据参数位置来传递参数<br>2.掌握关键字参数<br>    通过“键=值”形式传递参数,可以不限参数顺序·可以和位置参数混用，位置参数需在前<br>3.掌握缺省参数<br>    不传递参数值时会使用默认的参数值-默认值的参数必须定义在最后<br>4.掌握不定长参数<br>    位置不定长传递以<em>号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args<br>    关键字不定长传递以*</em>号标记一个形式参数，以字典的形式接受参数,形式参数一般命名为kwargs</p><ul><li>函数作为参数传递</li></ul><ol><li>函数本身是可以作为参数，传入另一个函数中进行使用</li><li>将函数传入的作用在于：传入计算逻辑，而非传入数据</li></ol><ul><li>lambda匿名函数</li></ul><p>函数的定义中</p><ul><li><p>def关键字，可以定义带有名称的函数</p></li><li><p>lambda关键字，可以定义匿名函数（无名称)</p></li></ul><p>有名称的函数，可以基于名称重复使用。</p><p>无名称的匿名函数，只可临时使用一次。</p><ul><li>匿名函数定义语法:</li><li>lambda传入参数:函数体(一行代码)</li></ul><p>lambda是关键字，表示定义匿名函数</p><p>传入参数表示匿名函数的形式参数，如:x, y表示接收2个形式参数</p><p>函数体，就是函数的执行逻辑，要注意:只能写一行，无法写多行代码</p><h2 id="12-python文件操作"><a href="#12-python文件操作" class="headerlink" title="12 . python文件操作"></a>12 . python文件操作</h2><h3 id="1-文件的读取操作"><a href="#1-文件的读取操作" class="headerlink" title="1 . 文件的读取操作"></a>1 . 文件的读取操作</h3><p><img src="https://s2.loli.net/2023/09/08/OoH3e9LfnGXuQCY.png" alt="QQ图片20230908194004"></p><ul><li>open中的encoding是“编码格式”</li><li>encoding顺序不是第三位，所以不能用位置参数，使用关键字参数直接指定</li><li>mode有三种访问文件模式</li></ul><p><img src="https://s2.loli.net/2023/09/08/LgqxHhYFp1leCN6.png" alt="QQ图片20230908194729"></p><h3 id="2-文件的写入操作"><a href="#2-文件的写入操作" class="headerlink" title="2 . 文件的写入操作"></a>2 . 文件的写入操作</h3><ul><li>w和a都可以进行写入操作</li><li>flush()，刷新内容到硬盘</li><li>close()，带有flush()的功能</li><li>可以用”\n”来写出换行符</li></ul><h2 id="13-异常，模块，包"><a href="#13-异常，模块，包" class="headerlink" title="13 . 异常，模块，包"></a>13 . 异常，模块，包</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1 . 异常"></a>1 . 异常</h3><p>1.为什么要捕获异常?</p><p>在可能发生异常的地方，进行捕获。当异常出现的时候，提供解决方式，而不是任由其导致程序无法运行。</p><p>2.捕获异常的语法?</p><p>[ ]表示可选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">可能要发生异常的语句</span><br><span class="line"><span class="keyword">except</span>[异常 <span class="keyword">as</span> 别名:]</span><br><span class="line">出现异常的准备手段</span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">未出现异常时应做的事情</span><br><span class="line">[<span class="keyword">finally</span>:]</span><br><span class="line">不管出不出现异常都会做的事情</span><br></pre></td></tr></table></figure><p>3.如何捕获所有异常?</p><p>异常的种类多种多样，如果想要不管什么类型的异常都能捕获到，那么<br>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">except</span>:</span><br><span class="line"><span class="number">2.</span><span class="keyword">except</span> Exception:</span><br></pre></td></tr></table></figure><p>4.异常的传递性</p><p>想要捕获异常，并不需要真正的深入的最底层的代码中进行捕获，只有你的函数有调用关系，我们在最顶级的可以调用直接捕获异常，因为会传递</p><h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2 . 模块"></a>2 . 模块</h3><ul><li><p>模块就是一个Python代码文件，内含类、函数、变量等，我们可以导入进行使用。</p></li><li><p>模块的导入</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块 | 类 | 变量 | 函数 | *] [<span class="keyword">as</span> 别名]</span><br></pre></td></tr></table></figure><p>常用的组合形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类、变量、方法等</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure><ul><li>自定义模块</li></ul><p><img src="https://s2.loli.net/2023/09/09/Hg7KDxnuBieq29r.png" alt="QQ图片20230909144743"></p><h3 id="3-包"><a href="#3-包" class="headerlink" title="3 . 包"></a>3 . 包</h3><p><img src="https://s2.loli.net/2023/09/09/KqxtFfP3z96Gl7o.png" alt="QQ图片20230909144743"></p><ul><li>导入包的方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">import</span> 包名.模块名</span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure><h2 id="14-json"><a href="#14-json" class="headerlink" title="14 . json"></a>14 . json</h2><ol><li><p>json:是一种轻量级的数据交互格式,采用完全独立于编程语言的文本格式来存储和表示数据（就是字符串)<br> Python语言使用JSON有很大优势，因为:JSON无非就是python的一个单独的字典或一个内部元素都是字典的列表<br> 所以JSON可以直接和Python的字典或列表进行无缝转换。</p></li><li><p>json格式数据转化<br> 通过json. dumps (data)方法把python数据转化为了json数据</p><p>​    data = json. dumps (data)</p><p>​    如果有中文可以带上: ensure_ascii=False参数来确保中文正常转换</p><p>通过json.loads (data)方法把josn数据转化为了python列表或字典</p></li><li><p><code>loads</code>操作的是字符串</p></li><li><p><code>load</code>操作的是文件流</p><p>​    data = json.loads(data)</p></li></ol><h1 id="2-python面向对象"><a href="#2-python面向对象" class="headerlink" title="2 . python面向对象"></a>2 . python面向对象</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 . 对象"></a>1 . 对象</h2><ul><li>函数：类外面的函数叫函数</li><li>方法：类内部的函数叫方法</li></ul><p>1.在程序中设计表格，我们称之为:设计类(class)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="comment">#class是关键字，表示要定义类了</span></span><br><span class="line">name = <span class="literal">None</span><span class="comment">#记录学生姓名</span></span><br><span class="line">    <span class="comment">#类的属性，即在类中定义的成员变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hi大家好,我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#类的行为，即定义在类中的成员方法</span></span><br></pre></td></tr></table></figure><p>2.在程序中打印生产表格，我们称之为:创建对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于类创建对象的语法</span></span><br><span class="line">对象 = 类名称()</span><br><span class="line"></span><br><span class="line">stu_1 = Student()</span><br><span class="line">stu_2 = Student()</span><br></pre></td></tr></table></figure><p>3.在程序中填写表格，我们称之为:对象属性赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu_1.name = <span class="string">&quot;周杰轮&quot;</span><span class="comment"># 为学生1对象赋予名称属性值</span></span><br><span class="line">stu_2.name = <span class="string">&quot;林军杰&quot;</span><span class="comment"># 为学生2对象赋予名称属性值</span></span><br><span class="line">stu_1.name.say_hi()<span class="comment"># 输出：Hi大家好,我是周杰轮</span></span><br></pre></td></tr></table></figure><p>4.类和对象的关系是什么?</p><p>类是程序中的“设计图纸”<br>对象是基于图纸生产的具体实体</p><p>5.什么是面向对象编程?</p><p>面向对象编程就是,使用对象进行编程。<br>即，设计一个类，基于类创建对象，并使用对象来完成具体的工作</p><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 . 构造方法"></a>2 . 构造方法</h2><p>1．构造方法的名称是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__，注意init前后的2个下划线符号</span><br></pre></td></tr></table></figure><p>2.构造方法的作用:</p><p>构建类对象的时候，会自动运行<br>构建类对象的传参，会传递给构造方法，借此特性可以给成员变量赋值</p><p>3.注意事项:</p><p>构造方法不要忘记self关键字<br>在方法内使用成员变量需要使用self</p><ul><li>魔术方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__str__用于实现类对象转字符串的行为</span><br><span class="line">__lt__用于2个类对象进行小于或大于比较</span><br><span class="line">__le__用于2个类对象进行小于等于或大于等于比较</span><br><span class="line">__eq__用于2个类对象进行相等比较</span><br></pre></td></tr></table></figure><h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3 . 封装"></a>3 . 封装</h2><p>1.封装的概念是指?</p><p>​    将现实世界事物在类中描述为属性和方法，即为封装。</p><p>2.什么是私有成员?为什么需要私有成员?</p><p>​    现实事物有部分属性和行为是不公开对使用者开放的。同样在类中描述属性和方法的时候也需要达到这个要求，就需要定义私有成员了</p><p>3.如何定义私有成员?</p><p>​    成员变量和成员方法的命名均以__(两个下划线)作为开头即可</p><p>4.私有成员的访问限制?</p><p>​    类对象无法访问私有成员<br>​    类中的其它成员可以访问私有成员</p><p>5.封装的实际的意义</p><p>​    在类中提供仅供内部使用的属性和方法，而不对外开放（类对象无法使用)</p><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4 . 继承"></a>4 . 继承</h2><h3 id="1-继承的基础语法"><a href="#1-继承的基础语法" class="headerlink" title="1 . 继承的基础语法"></a>1 . 继承的基础语法</h3><ul><li><p>继承表示:将从父类那里继承(复制)来成员变量和成员方法(不含私有)</p></li><li><p>单继承——一个子类继承一个父类</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>)∶</span><br><span class="line">类内容体</span><br></pre></td></tr></table></figure><ul><li>多继承——一个子类继承多个父类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>,父类<span class="number">2</span>,....., 父类N)∶</span><br><span class="line">类内容体</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 空占位语句，类功能够用了，不想再添加新功能了</span></span><br></pre></td></tr></table></figure><ul><li>如果多继承中，父类有同名的方法或属性，先继承的优先级高于后继承</li></ul><h3 id="2-复写和使用父类成员"><a href="#2-复写和使用父类成员" class="headerlink" title="2 . 复写和使用父类成员"></a>2 . 复写和使用父类成员</h3><p>1.复写表示:</p><p>对父类的成员属性或成员方法进行重新定义</p><p>2.复写的语法:</p><p>在子类中重新实现同名成员方法或成员属性即可</p><p>3.在子类中，如何调用父类成员</p><ul><li>方式1:调用父类成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用成员变量:父类名.成员变量</span><br><span class="line">使用成员方法:父类名.成员方法(self)</span><br></pre></td></tr></table></figure><ul><li>方式2:使用super()调用父类成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用成员变量: super().成员变量</span><br><span class="line">使用成员方法: super().成员方法()</span><br></pre></td></tr></table></figure><ul><li>注意:只可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的</li></ul><h2 id="5-类型注解"><a href="#5-类型注解" class="headerlink" title="5 . 类型注解"></a>5 . 类型注解</h2><p>1.什么是类型注解，有什么作用?</p><p>​    在代码中涉及数据交互之时，对数据类型进行显式的说明，可以帮助:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+p查看类型</span><br></pre></td></tr></table></figure><p>​        PyCharm等开发工具对代码做类型推断协助做代码提示</p><p>​        开发者自身做类型的备注</p><p>2.类型注解支持:</p><p>​    变量的类型注解</p><p>​    函数（方法）的形参和返回值的类型注解</p><p>3.变量的类型注解</p><p>类对象也行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法1:变量:类型</span><br><span class="line">语法2:在注释中，# type:类型</span><br></pre></td></tr></table></figure><ul><li>容器类型的详细注解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量:容器类型[类型1，类型2....]</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>元组类型设置类型详细注解，需要将每一个元素都标记出来</li><li>字典类型设置类型详细注解，需要两个类型，第一个是key第二个是value</li></ul><p>4.函数(方法)的注解</p><ul><li>形参的类型注解</li><li>返回值的类型注解</li><li>语法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>(<span class="params">形参: 类型 , ...... , 形参: 类型</span>) -&gt; 返回值类型:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>5.注意事项</p><p>类型注解只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致错误</p><p>6.Union类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导包: <span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line">使用: <span class="built_in">dict</span> [<span class="built_in">str</span>,<span class="type">Union</span>[类型, ..... , 类型]]</span><br><span class="line">可以定义联合类型注解</span><br></pre></td></tr></table></figure><h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6 . 多态"></a>6 . 多态</h2><ul><li><p>多态，指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态</p></li><li><p>抽象类（接口)</p><ul><li>包含抽象方法的类，称之为抽象类。</li><li>抽象方法是指:没有具体实现的方法(只有pass)称之为抽象方法</li></ul></li><li><p>抽象类的作用</p><ul><li>多用于做顶层设计（设计标准)，以便子类做具体实现。<br>也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法<br>并配合多态使用，获得不同的工作状态。</li></ul></li></ul><h2 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7 . 数据库"></a>7 . 数据库</h2><ul><li>导入数据库pymysql</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line">Connection(主机,端口,账户,密码)即可得到连接对象</span><br><span class="line">连接对象.close()关闭和MySQL数据库的连接</span><br></pre></td></tr></table></figure><ul><li>执行sql</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过连接对象调用cursor()方法，得到游标对象</span><br><span class="line">游标对象.execute()执行sql语句</span><br><span class="line">游标对象.fetchall()可以得到全部的查询结果封装进元组</span><br></pre></td></tr></table></figure><ul><li>确认代码提交</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：手动提交：连接对象.commit()</span><br><span class="line">方法2：自动提交：在Connection()中加入autocommit=True</span><br></pre></td></tr></table></figure><hr><h1 id="3-Python进阶"><a href="#3-Python进阶" class="headerlink" title="3 . Python进阶"></a>3 . Python进阶</h1><h2 id="1-PySpark"><a href="#1-PySpark" class="headerlink" title="1.PySpark"></a>1.PySpark</h2><p>1.什么是Spark、什么是PySpark</p><p>​    Spark是Apache基金会旗下的顶级开源项目，用于对海量数据进行大规模分布式计算。</p><p>​    PySpark是Spark的Python实现，是Spark为Python开发者提供的编程入口，用于以Python代码完成Spark任务的开发</p><p>​    PySpark不仅可以作为Python第三方库使用，也可以将程序提交的Spark集群环境中,调度大规模集群进行执行。</p><p>2.为什么要学习PySpark?</p><p>​    大数据开发是Python众多就业方向中的明星赛道,薪资高岗位多，Spark(PySpark)又是大数据开发中的核心技术</p><ul><li>PySpark的功能都是从SparkContext对象作为执行入口</li></ul><h3 id="1-数据输入"><a href="#1-数据输入" class="headerlink" title="1.数据输入"></a>1.数据输入</h3><p>1.RDD对象是什么?为什么要使用它?</p><p>​    RDD对象称之为分布式弹性数据集，是PySpark中数据计算的载体，它可以:<br>​        提供数据存储<br>​        提供数据计算的各类方法<br>​        数据计算的方法,返回值依旧是RDD (RDD迭代计算)<br>​    后续对数据进行各类计算,都是基于RDD对象进行</p><p>2.如何输入数据到Spark(即得到RDD对象)1</p><p>​    通过SparkContext的parallelize()成员方法，将Python数据容器转换为RDD对象<br>​    通过SparkContext的textFile()成员方法，读取文本文件得到RDD对象</p><h3 id="2-数据计算"><a href="#2-数据计算" class="headerlink" title="2.数据计算"></a>2.数据计算</h3><blockquote><p>RDD对象称之为分布式弹性数据集，是PySpark中数据计算的载体，它可以:<br>       提供数据存储<br>       提供数据计算的各类方法<br>       数据计算的方法,返回值依旧是RDD (RDD迭代计算)<br>   后续对数据进行各类计算,都是基于RDD对象进行</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-python基础&quot;&gt;&lt;a href=&quot;#1-python基础&quot; class=&quot;headerlink&quot; title=&quot;1 . python基础&quot;&gt;&lt;/a&gt;1 . python基础&lt;/h1&gt;&lt;p&gt;print()可以输出多份内容，多份内容可以用”,”隔开&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="http://putongl.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://putongl.github.io/git.html"/>
    <id>http://putongl.github.io/git.html</id>
    <published>2023-08-31T04:43:45.696Z</published>
    <updated>2023-08-31T04:43:32.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1．什么是-Git-仓库"><a href="#1．什么是-Git-仓库" class="headerlink" title="1．什么是 Git 仓库?"></a>1．什么是 Git 仓库?</h2><p>记录文件状态内容和历史记录的地方(.git文件夹)</p><h2 id="2．如何创建Git仓库"><a href="#2．如何创建Git仓库" class="headerlink" title="2．如何创建Git仓库?"></a>2．如何创建Git仓库?</h2><p>1.把本地文件夹转换成Git仓库:命令git init</p><p>2.从其他服务器上克隆Git仓库</p><h2 id="3-Git的三个区域"><a href="#3-Git的三个区域" class="headerlink" title="3 .    Git的三个区域"></a>3 .    Git的三个区域</h2><p>Git 使用时:</p><p>工作区:实际开发时操作的文件夹</p><p>暂存区:保存之前的准备区域（暂存改动过的文件)</p><p>版本库:提交并保存暂存区中的内容，产生一个版本快照</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git add 文件名</td><td>暂存指定文件</td></tr><tr><td>git add .</td><td>保存到暂存区，暂存所有改动的文件</td></tr><tr><td>git commit -m “注释说明”</td><td>保存到版本库，提交并保存，产生版本快照</td></tr></tbody></table></div><p><img src="https://s2.loli.net/2023/08/27/SpN3vhQYbmdnBt9.png" alt="img"></p><h2 id="4-Git文件状态"><a href="#4-Git文件状态" class="headerlink" title="4 .    Git文件状态"></a>4 .    Git文件状态</h2><p>Git文件2种状态:</p><p>未跟踪:新文件，从未被Git管理过</p><p>已跟踪:Git已经知道和管理的文件（新添加，未修改，已修改）</p><p>使用:修改文件，暂存，提交保存记录，如此反复</p><ul><li>使用git status -s查看文件状态</li><li>第一列是暂存区状态</li><li>第二列是工作区状态</li></ul><div class="table-container"><table><thead><tr><th>文件状态</th><th>概念</th><th>场景</th></tr></thead><tbody><tr><td>未跟踪（U）</td><td>从未被Git管理过</td><td>新文件</td></tr><tr><td>新添加（A）</td><td>第一次被Git暂存</td><td>之前版本记录无此文件</td></tr><tr><td>未修改（’’）</td><td>三个区域统一</td><td>提交后保存</td></tr><tr><td>已修改（M）</td><td>工作区内容无变化</td><td>修改了内容产生</td></tr></tbody></table></div><h2 id="5-Git暂存区使用"><a href="#5-Git暂存区使用" class="headerlink" title="5 .    Git暂存区使用"></a>5 .    Git暂存区使用</h2><p>暂存区:暂时存储，可以临时恢复代码内容，与版本库解耦</p><p>暂存区-&gt;覆盖-&gt;工作区，命令: git restore目标文件（注意∶完全确认覆盖时使用)</p><p>从暂存区移除文件，命令: git rm —cached目标文件</p><p>查看暂存区的内容，命令：git ls-files</p><p>查看之前所有的提交历史，命令：git log —oneline</p><p><img src="https://s2.loli.net/2023/08/27/8ys6h3CiZSFlkgf.png" alt="image-20230827133555585"></p><h2 id="6-Git回退版本"><a href="#6-Git回退版本" class="headerlink" title="6 .    Git回退版本"></a>6 .    Git回退版本</h2><p>概念:把版本库某个版本对应的内容快照，恢复到工作区/暂存区查看</p><p>提交历史:git log —oneline</p><p>查看所有的历史:git reflog —oneline</p><p>回退命令:</p><p>git reset —soft 版本号（其他文件未跟踪)    css，js暂存区工作区全部保留</p><p>git reset —hard 版本号    css，js暂存区工作区不保留直接删除，先恢复暂存区，再恢复工作区</p><p>git reset —mixed版本号(与git reset等价)    暂存区不保留，工作区保留</p><p>注意1:只有记录在版本库的提交记录才能恢复<br>注意2:回退后，继续修改-&gt;暂存-&gt;提交操作即可（产生新的提交记录过程)</p><h2 id="7-分支"><a href="#7-分支" class="headerlink" title="7 .    分支"></a>7 .    分支</h2><p>概念:本质上是指向提交节点的可变指针，默认名字是master</p><p>注意:HEAD指针影响工作区/暂存区的代码状态，指向哪个分支使用哪个分支</p><p>场景:开发新需求/修复Bug，保证主线代码随时可用，多人协同开发提高效率</p><h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1 . 创建分支"></a>1 . 创建分支</h3><p>1.创建分支命令:git branch 分支名，以HEAD指针指向的分支作为起点来创建分支</p><p>2.切换分支命令:git checkout 分支名，使HEAD指向这个分支，就能来操控这个分支</p><h3 id="2-合并并删除"><a href="#2-合并并删除" class="headerlink" title="2 .  合并并删除"></a>2 .  合并并删除</h3><p>1．切回到要合入的分支上: git checkout master</p><p>2．合并其他分支过来:git merge login-bug</p><p>3．删除合并后的分支指针: git branch -d login-bug</p><p>第二个分支合并：合并提交，发生于原分支产生了新的提交记录后，再合并回去时发生，自动使用多个快照记录合并后产生一次新的提交</p><p><img src="https://s2.loli.net/2023/08/27/39qTPKuyeYSEJsf.png" alt="QQ图片20230827202417"></p><p>注意:提交记录的顺序按照产生的先后顺序排列，而非合并的先后顺序</p><p><img src="https://s2.loli.net/2023/08/27/GJaUh5bkmH2xVnv.png" alt="image-20230827202532657"></p><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><img src="https://s2.loli.net/2023/08/27/V1HzftLTnRh9dcF.png" alt="QQ图片20230827211901"></p><p><img src="https://s2.loli.net/2023/08/27/d1i3QAqLgbVNo79.png" alt="QQ图片20230827211907"></p><p><img src="https://s2.loli.net/2023/08/31/YKAMmq1GZoaVCe7.png" alt="QQ图片20230831120423"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;1．什么是-Git-仓库&quot;&gt;&lt;a href=&quot;#1．什么是-Git-仓库&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="http://putongl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="http://putongl.github.io/2.html"/>
    <id>http://putongl.github.io/2.html</id>
    <published>2023-08-07T07:08:52.335Z</published>
    <updated>2023-08-27T03:50:52.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="1-判断相等或者不等于（-、-、-、-）运算符"><a href="#1-判断相等或者不等于（-、-、-、-）运算符" class="headerlink" title="1.判断相等或者不等于（==、===、!=、!==）运算符"></a>1.判断相等或者不等于（==、===、!=、!==）运算符</h2><div class="table-container"><table><thead><tr><th>等值检测运算符</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>==（相等）</td><td>比较两个操作数的值是否相等，会自动进行隐式转换，比如：18 == ‘18’，会为true</td></tr><tr><td>!=（不想等）</td><td>比较两个操作数的值是否不相等</td></tr><tr><td>===（全等）</td><td>比较两个操作数的值是否相等，同时检测它们的类型是否相同</td></tr><tr><td>!==（不全等）</td><td>比较两个操作数的值是否不相等，同时检测它们的类型是否不相同</td></tr></tbody></table></div><p>在相等运算中，应注意以下几个问题：</p><ul><li>如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。</li><li>如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。</li><li>如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。</li><li>如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。</li><li>如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。</li></ul><h2 id="2-短路运算"><a href="#2-短路运算" class="headerlink" title="2.短路运算"></a>2.短路运算</h2><h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>​    短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的 值; </p><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><ul><li><p>​    语法： 表达式1 &amp;&amp; 表达式2 </p></li><li><p>如果第一个表达式的值为真，则返回表达式2 </p></li><li><p>如果第一个表达式的值为假，则返回表达式1</p></li><li><pre><code>console.log( 123 &amp;&amp; 456 ); // 456console.log( 0 &amp;&amp; 456 ); // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 逻辑或 </span><br><span class="line"></span><br><span class="line">- ​语法： 表达式1 || 表达式2 </span><br><span class="line">- 如果第一个表达式的值为真，则返回表达式1</span><br><span class="line">- 如果第一个表达式的值为假，则返回表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure>console.log( 123 || 456 ); // 123console.log( 0 || 456 ); // 456console.log( 123 || 456 || 789 ); // 123<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.函数的参数</span><br><span class="line"></span><br><span class="line">### 3.1形参和实参</span><br><span class="line"></span><br><span class="line">在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br><span class="line">| 参数 | 说明                                                        |</span><br><span class="line">| ---- | ----------------------------------------------------------- |</span><br><span class="line">| 形参 | 形式上的参数 函数定义的时候，传递的参数，当时并不知道是什么 |</span><br><span class="line">| 实参 | 实际上的参数 函数调用的时候，传递的参数，实参是传递给形参的 |</span><br><span class="line"></span><br><span class="line">参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</span><br><span class="line"></span><br><span class="line">- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...);</code></pre></li></ul><h3 id="3-2函数形参和实参个数不匹配问题"><a href="#3-2函数形参和实参个数不匹配问题" class="headerlink" title="3.2函数形参和实参个数不匹配问题"></a>3.2函数形参和实参个数不匹配问题</h3><div class="table-container"><table><thead><tr><th>参数个数</th><th>说明</th></tr></thead><tbody><tr><td>实参的个数等于形参的个数</td><td>输出正确结果</td></tr><tr><td>实参的个数多于形参的个数</td><td>只取到形参的个数</td></tr><tr><td>实参的个数小于形参的个数</td><td>多的形参定义为undefined，结果为NaN</td></tr></tbody></table></div><h3 id="3-3arguments的使用"><a href="#3-3arguments的使用" class="headerlink" title="3.3arguments的使用"></a>3.3arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上 它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的 所有实参。</p><p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li>可以有无数多个参数，实参有几个，arguments就有几个</li><li>具有 length 属性 </li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ul><h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4.预解析"></a>4.预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两 步：预解析和代码执行。</p><ul><li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提 前声明或者定义。</p></li><li><p>代码执行： 从上到下执行JS语句。</p></li></ul><p>预解析会把变量和函数的声明在代码执行之前执行完成。</p><ul><li>函数预解析</li><li>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</li></ul><h2 id="5-事件对象"><a href="#5-事件对象" class="headerlink" title="5.事件对象"></a>5.事件对象</h2><p>e.target 和 this 的区别：</p><p>​    this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素），谁绑定了这个点击事件，那么就返回谁 </p><p>​    e.target 是事件触发的元素。点击了哪个元素，就返回哪个元素</p><p>给ul绑定事件，this指向的是ul，e.target指向的是li</p><p>eventTarget.addEventListener(‘click’, function(event) { </p><p>​        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </p><p>}）</p><ul><li>addEventListener(‘click’, function(event)，true)</li><li>第三个参数为true，则为捕获阶段</li><li>省略不写，或为false，为冒泡阶段</li></ul><h2 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h2><ul><li>定义:执行代码和收集异步任务的模型，在调用栈空闲，反复调用任务队列里回调函数的执行机制，就叫事件循环</li></ul><p>执行过程</p><p>1.执行同步代码，遇到异步代码交给宿主浏览器环境</p><p>2.执行异步有了结果后，把回调函数放入任务队列排队</p><p>3.当调用栈空闲后，反复调用任务队列里的回调函数</p><p><img src="https://s2.loli.net/2023/08/27/qLNrMJUvgkXTQom.png" alt="image-20230827115025297"></p><h2 id="7-宏任务和微任务"><a href="#7-宏任务和微任务" class="headerlink" title="7.宏任务和微任务"></a>7.宏任务和微任务</h2><ul><li>1．什么是宏任务?</li><li>浏览器执行的异步代码</li><li>例如:JS执行脚本事件，setTimeout/setlnterval,AJAX请求完成事件，用户交互事件等</li><li>2．什么是微任务?</li><li>JS引擎执行的异步代码</li><li>例如:Promise对象.then()的回调</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;h2 id=&quot;1-判断相等或者不等于（-、-、-、-）运算符&quot;&gt;&lt;a href=&quot;#1-判断相等或者不等于（-、-、-、-）运算符&quot; class</summary>
      
    
    
    
    
    <category term="js" scheme="http://putongl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="http://putongl.github.io/4.html"/>
    <id>http://putongl.github.io/4.html</id>
    <published>2023-08-07T07:08:50.520Z</published>
    <updated>2023-08-07T09:39:17.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？"><a href="#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？" class="headerlink" title="Visual Studio Code代码想要同时编辑多处，该怎么实现呢？"></a>Visual Studio Code代码想要同时编辑多处，该怎么实现呢？</h2><h3 id="1-重命名变量"><a href="#1-重命名变量" class="headerlink" title="1. 重命名变量"></a>1. 重命名变量</h3><p>首先看看自己需要同时修改多处的代码是不是要重命名一个变量，如果是的话，有现成的快捷键<code>f2</code></p><p>使用方法：</p><ul><li>选中一个变量，按<code>f2</code> 或者 按 <code>Fn + f2</code>，具体依据电脑品牌而定！</li><li>弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。</li></ul><p>注意:在<code>js文件</code>中，如果这个变量没有用<code>var或者const或者let</code>声明，会无法重命名</p><h3 id="2-多光标"><a href="#2-多光标" class="headerlink" title="2. 多光标"></a>2. 多光标</h3><blockquote><ol><li>按住<code>alt</code>，用鼠标<code>左键点击</code>，可以出现多个光标，输入的代码可以在光标处同时增加</li></ol><p><img src="https://s2.loli.net/2023/08/07/x1Yai5TOJtr7VIG.png" alt="在这里插入图片描述"></p><ol><li>按住<code>Ctrl + Alt</code>，再按键盘上向上或者向下的键，可以使一列上出现多个光标。</li></ol><p><img src="https://s2.loli.net/2023/08/07/fMbWCoecKLqyhA3.png" alt="在这里插入图片描述"></p><ol><li>选中一段文字，按<code>shift+alt+i</code>，可以在每行末尾出现光标</li></ol><p><img src="https://s2.loli.net/2023/08/07/e3PyGSgTMtpbEHB.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/LcGv4XFP6iWn2dV.png" alt="在这里插入图片描述"></p><ol><li>光标放在一个地方，按<code>ctrl+shift+L</code>或者<code>ctrl+f2</code>，可以在页面中出现这个词的不同地方都出现光标。<code>有时候这个快捷键的作用和f2重命名变量类似</code>，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。</li></ol><p><img src="https://s2.loli.net/2023/08/07/Gz9gh8JyCFPAvcR.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/qWl2I3RTDKmhjsy.png" alt="在这里插入图片描述"></p><ol><li>按<code>shift+alt</code>，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。</li></ol><p><img src="https://s2.loli.net/2023/08/07/JQBkh5OagERo67y.png" alt="在这里插入图片描述"></p><ol><li>任何光标操作，可以按<code>Ctrl + U</code>取消</li></ol></blockquote><h3 id="3-替换字符串"><a href="#3-替换字符串" class="headerlink" title="3. 替换字符串"></a>3. 替换字符串</h3><blockquote><ol><li><p>按<code>ctrl+f</code>，可以搜索当前页面，然后按搜索框左边的小三角符号，<code>可以切换成替换模式</code>。</p><p>有时候使用字符串替换，比多光标方便，但是注意别不小心替换掉不想替换的内容。</p></li></ol><p><img src="https://s2.loli.net/2023/08/07/fEYHuMR4poLmb7n.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/dGwyr54Vso9ZT7C.png" alt="QQ图片20230807173855"></p><p>以上就是<code>vscode</code>同时编辑多处的三种方法，希望大家喜欢，谢谢！</p></blockquote><h3 id="4-全局替换某些单词"><a href="#4-全局替换某些单词" class="headerlink" title="4.全局替换某些单词"></a>4.全局替换某些单词</h3><ul><li>​        快捷键：ctrl + h </li></ul><h3 id="5-快速定位到某一行"><a href="#5-快速定位到某一行" class="headerlink" title="5.快速定位到某一行"></a>5.快速定位到某一行</h3><ul><li>​        快捷键：ctrl + g</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot;&gt;&lt;a href=&quot;#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Code代码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue笔记</title>
    <link href="http://putongl.github.io/vue.html"/>
    <id>http://putongl.github.io/vue.html</id>
    <published>2023-08-02T07:15:31.884Z</published>
    <updated>2023-08-31T11:00:17.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h2 id="1-Vue-是什么"><a href="#1-Vue-是什么" class="headerlink" title="1.Vue 是什么"></a>1.Vue 是什么</h2><h3 id="1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架"><a href="#1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架" class="headerlink" title="1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架"></a>1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架</h3><p>基于数据渲染出用户看到的页面</p><ul><li>Vue 的两种使用方式：</li></ul><p>​        ① Vue 核心包开发</p><p>​                场景：局部 模块改造</p><p>​        ② Vue 核心包 &amp; Vue 插件 工程化开发</p><p>​                场景：整站 开发</p><h3 id="1-2-创建-Vue-实例，初始化渲染的核心步骤："><a href="#1-2-创建-Vue-实例，初始化渲染的核心步骤：" class="headerlink" title="1.2.创建 Vue 实例，初始化渲染的核心步骤："></a>1.2.创建 Vue 实例，初始化渲染的核心步骤：</h3><ol><li><p>准备容器</p></li><li><p>引包 (官网) - 开发版本 / 生产版本</p></li><li><p>创建 Vue 实例 new Vue()</p></li><li><p>指定配置项 el data =&gt; 渲染数据</p></li></ol><ul><li>① 通过el配置选择器 ，指定vue管理的是哪个盒子，作用跟vue脚手架中的main.js中的</li><li>$mount()作用一致</li><li>② data 提供数</li></ul><h3 id="1-3-插值表达式"><a href="#1-3-插值表达式" class="headerlink" title="1.3.插值表达式"></a>1.3.插值表达式</h3><p>插值表达式是一种 Vue 的模板语法</p><ol><li><p>作用: 利用表达式进行插值，渲染到页面中</p><p>​    表达式：是可以被求值的代码，JS引擎会将其计算出一个结果</p></li><li><p>语法：</p></li><li><p>注意点：</p><p>（1）使用的数据必须存在 （data） </p><p>（2）支持的是表达式，而非语句，比如：if for ..</p><p>（3）不能在标签属性中使用插值表达式</p></li></ol><h3 id="1-4-Vue-核心特性：响应"><a href="#1-4-Vue-核心特性：响应" class="headerlink" title="1.4.Vue 核心特性：响应"></a>1.4.Vue 核心特性：响应</h3><ul><li><p>​    数据的响应式处理 → 响应式：数据变化，视图自动更新</p><p>​        使用 Vue 开发，关注业务的核心逻辑，根据业务修改数据即可</p></li><li><p>​    如何访问或修改数据呢？</p><p>​        data中的数据, 最终会被添加到实例上</p><p>​            ① 访问数据： “实例.属性名”</p><p>​            ② 修改数据： “实例.属性名” = “值”</p></li></ul><h3 id="1-5-Vue-指令"><a href="#1-5-Vue-指令" class="headerlink" title="1.5.Vue 指令"></a>1.5.Vue 指令</h3><p>Vue 会根据不同的【指令】，针对标签实现不同的【功能】</p><p>​    指令：带有 v- 前缀 的 特殊 标签属性，不同属性 对应 不同的功能</p><p>v-html:作用：设置元素的 innerHTML语法：v-html = “表达式”</p><ul><li>​    动态解析标签</li></ul><pre><code>  msg: `    &lt;a href=&quot;http://douyin.com&quot;&gt;        抖音         &lt;/a&gt;   ` </code></pre><p>​    msg里面不是引号，是Tab上面的 `号</p><p>v-show and v-if</p><p>v-show</p><ol><li><p>作用： 控制元素显示隐藏</p></li><li><p>语法： v-show = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 切换 display:none 控制显示隐藏</p></li><li><p>场景： 频繁切换显示隐藏的场景</p></li></ol><p>v-if</p><ol><li><p>作用： 控制元素显示隐藏（条件渲染）</p></li><li><p>语法： v-if = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 基于条件判断，是否 创建 或 移除 元素节点</p></li><li><p>场景： 要么显示，要么隐藏，不频繁切换的场景</p></li></ol><p>v-else v-else-if</p><ol><li><p>作用： 辅助 v-if 进行判断渲染</p></li><li><p>语法： v-else v-else-if = “表达式”</p></li><li><p>注意： 需要紧挨着 v-if 一起使用</p></li></ol><p>v-on</p><ul><li><p>作用： 注册事件 = 添加监听 + 提供处理逻辑</p></li><li><p>语法：① v-on:事件名 = “内联语句”        @click=”count++”</p><p> ​           ② v-on:事件名 = “methods中的函数名”</p></li><li><p>简写：@事件名        v-on:click替换成@click</p></li><li>注意：methods函数内的 this 指向 Vue 实例 </li></ul><p>v-bind</p><ol><li><p>作用： 动态的设置html的标签属性 → src url title ..</p></li><li><p>语法： v-bind:属性名=”表达式”</p></li><li><p>注意： 简写形式  :属性名=”表达式”</p><p>v-for</p></li><li><p>作用： 基于数据循环， 多次渲染整个元素</p></li><li><p>遍历数组语法：</p><ul><li>v-for = “(item, index) in 数组”</li><li>item 数组中的每一项数据， index 下标</li><li>也可以省略 index: v-for = “item in 数组“</li></ul></li><li>v-for 中的 key<ul><li>语法： :key属性 = “唯一标识”</li><li>作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。</li><li>key 的值必须具有 唯一性</li><li>推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li></ul></li><li>v-for 的默认行为会尝试 原地修改元素 （就地复用）</li></ol><p>v-model</p><ol><li><p>作用: 给 表单元素 使用, 双向数据绑定 → 可以快速 获取 或 设置 表单元素内容 </p><p>① 数据变化 → 视图自动更新 </p><p>② 视图变化 → 数据自动更新 </p></li><li><p>语法: v-model = ‘变量’</p></li></ol><p><strong><code>v-model.trim()</code></strong> 方法从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串。此上下文中的空格是指所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）。</p><p><strong><code>v-model.number()</code></strong> 方法可以将输入的数据转换为Number类型，否则虽然你输入的是数字.但它的类型其实是String</p><p><strong><code>v-model.lazy()</code></strong>方法失去焦点更新，并不是实时改变，而是在失去焦点或者按回车时才会更新，类似懒加载</p><h3 id="1-6-指令修饰符"><a href="#1-6-指令修饰符" class="headerlink" title="1.6.指令修饰符"></a>1.6.指令修饰符</h3><ul><li>通过 “.” 指明一些指令 后缀，不同 后缀 封装了不同的处理操作 → 简化代码</li><li>① 按键修饰符<ul><li>@keyup.enter → 键盘回车监听</li></ul></li><li>② v-model修饰符<ul><li>v-model.trim → 去除首尾空格</li><li>v-model.number → 转数字</li></ul></li><li>③ 事件修饰符<ul><li>@事件名.stop → 阻止冒泡</li><li>@事件名.prevent → 阻止默认行为</li></ul></li></ul><h3 id="1-7-v-bind-对于样式控制的增强"><a href="#1-7-v-bind-对于样式控制的增强" class="headerlink" title="1.7.v-bind 对于样式控制的增强"></a>1.7.v-bind 对于样式控制的增强</h3><ul><li>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 class 类名 和 style 行内样式 进行控制 。</li></ul><ol><li><p>操作class</p><ul><li><p>语法 :class = “对象/数组” </p><p>① 对象 → 键就是类名，值是布尔值。如果值为 true，有这个类，否则没有这个类</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：一个类名，来回切换</p><p>​            ② 数组 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表 v-bind 对于样式控制的增强 - 操作class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;[ 类名1, 类名2, 类名3 ]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：批量添加或删除类</p></li><li><p>操作style</p><ul><li>语法 :style = “样式对象”</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :style=&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：某个具体属性的动态设置</p><h3 id="1-8-v-model-应用于其他表单元素"><a href="#1-8-v-model-应用于其他表单元素" class="headerlink" title="1.8.v-model 应用于其他表单元素"></a>1.8.v-model 应用于其他表单元素</h3><ul><li>​    常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值</li><li>​        v-model 应用于其他表单元素</li><li>​    它会根据 控件类型 自动选取 正确的方法 来更新元素</li></ul><h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9.计算属性"></a>1.9.计算属性</h3><ul><li>概念：基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。</li><li>语法：</li><li>① 声明在 computed 配置项中，一个计算属性对应一个函数</li><li>② 使用起来和普通属性一样使用 </li><li>计算属性 → 可以将一段 求值的代码 进行封装</li></ul><h3 id="1-10-computed-计算属性-vs-methods-方法"><a href="#1-10-computed-计算属性-vs-methods-方法" class="headerlink" title="1.10. computed 计算属性 vs methods 方法"></a>1.10. computed 计算属性 vs methods 方法</h3><ul><li>computed 计算属性：<ul><li>作用：封装了一段对于数据的处理，求得一个结果。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为属性，直接使用 → this.计算属性 </li></ul></li><li>缓存特性（提升性能）：<ul><li>计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 → 并再次缓存</li></ul></li></ul></li><li>methods 方法：<ul><li>作用：给实例提供一个方法，调用以处理业务逻辑。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为方法，需要调用 → this方法 /( ) </li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue笔记&quot;&gt;&lt;a href=&quot;#Vue笔记&quot; class=&quot;headerlink&quot; title=&quot;Vue笔记&quot;&gt;&lt;/a&gt;Vue笔记&lt;/h1&gt;&lt;h2 id=&quot;1-Vue-是什么&quot;&gt;&lt;a href=&quot;#1-Vue-是什么&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Vue" scheme="http://putongl.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>IKUN</title>
    <link href="http://putongl.github.io/888.html"/>
    <id>http://putongl.github.io/888.html</id>
    <published>2023-08-01T09:16:56.217Z</published>
    <updated>2023-08-02T11:56:45.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回忆录"><a href="#回忆录" class="headerlink" title="回忆录"></a>回忆录</h2><p>一个真正的IKUN，他会跳舞，比如这样</p><p><img src="https://s2.loli.net/2023/08/02/ucfJQoM1SIgnzVC.png" alt="3bfc6928d18ff1188d5e5a6a69778fa"></p><p>他用他优美的舞姿，展现出不一样的风采，一个练习时常两年半的真正的MAN</p><p>著名的麦克阿瑟表示，没想到谷桑成不欺我，他差点又说出那句练习两年半的深田坤桑最爱的话:哎呦，你干嘛！！我上我也行！！大型传奇纪录片:谷门吹牛逼术，持续为您播出！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回忆录&quot;&gt;&lt;a href=&quot;#回忆录&quot; class=&quot;headerlink&quot; title=&quot;回忆录&quot;&gt;&lt;/a&gt;回忆录&lt;/h2&gt;&lt;p&gt;一个真正的IKUN，他会跳舞，比如这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/0</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Yml文档</title>
    <link href="http://putongl.github.io/5.html"/>
    <id>http://putongl.github.io/5.html</id>
    <published>2023-07-31T07:53:33.760Z</published>
    <updated>2023-08-07T07:13:50.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yml内容"><a href="#yml内容" class="headerlink" title="yml内容"></a>yml内容</h2><p>乱码：改成utf-8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;yml内容&quot;&gt;&lt;a href=&quot;#yml内容&quot; class=&quot;headerlink&quot; title=&quot;yml内容&quot;&gt;&lt;/a&gt;yml内容&lt;/h2&gt;&lt;p&gt;乱码：改成utf-8&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>海贼王</title>
    <link href="http://putongl.github.io/1.html"/>
    <id>http://putongl.github.io/1.html</id>
    <published>2023-07-29T09:18:40.507Z</published>
    <updated>2023-08-07T07:14:05.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2023年8月6日路飞5档，起飞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;2023年8月6日路飞5档，起飞&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
