<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>普通l</title>
  
  
  <link href="http://putongl.github.io/atom.xml" rel="self"/>
  
  <link href="http://putongl.github.io/"/>
  <updated>2023-08-31T04:43:32.089Z</updated>
  <id>http://putongl.github.io/</id>
  
  <author>
    <name>普通L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git</title>
    <link href="http://putongl.github.io/git.html"/>
    <id>http://putongl.github.io/git.html</id>
    <published>2023-08-31T04:43:45.696Z</published>
    <updated>2023-08-31T04:43:32.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1．什么是-Git-仓库"><a href="#1．什么是-Git-仓库" class="headerlink" title="1．什么是 Git 仓库?"></a>1．什么是 Git 仓库?</h2><p>记录文件状态内容和历史记录的地方(.git文件夹)</p><h2 id="2．如何创建Git仓库"><a href="#2．如何创建Git仓库" class="headerlink" title="2．如何创建Git仓库?"></a>2．如何创建Git仓库?</h2><p>1.把本地文件夹转换成Git仓库:命令git init</p><p>2.从其他服务器上克隆Git仓库</p><h2 id="3-Git的三个区域"><a href="#3-Git的三个区域" class="headerlink" title="3 .    Git的三个区域"></a>3 .    Git的三个区域</h2><p>Git 使用时:</p><p>工作区:实际开发时操作的文件夹</p><p>暂存区:保存之前的准备区域（暂存改动过的文件)</p><p>版本库:提交并保存暂存区中的内容，产生一个版本快照</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git add 文件名</td><td>暂存指定文件</td></tr><tr><td>git add .</td><td>保存到暂存区，暂存所有改动的文件</td></tr><tr><td>git commit -m “注释说明”</td><td>保存到版本库，提交并保存，产生版本快照</td></tr></tbody></table></div><p><img src="https://s2.loli.net/2023/08/27/SpN3vhQYbmdnBt9.png" alt="img"></p><h2 id="4-Git文件状态"><a href="#4-Git文件状态" class="headerlink" title="4 .    Git文件状态"></a>4 .    Git文件状态</h2><p>Git文件2种状态:</p><p>未跟踪:新文件，从未被Git管理过</p><p>已跟踪:Git已经知道和管理的文件（新添加，未修改，已修改）</p><p>使用:修改文件，暂存，提交保存记录，如此反复</p><ul><li>使用git status -s查看文件状态</li><li>第一列是暂存区状态</li><li>第二列是工作区状态</li></ul><div class="table-container"><table><thead><tr><th>文件状态</th><th>概念</th><th>场景</th></tr></thead><tbody><tr><td>未跟踪（U）</td><td>从未被Git管理过</td><td>新文件</td></tr><tr><td>新添加（A）</td><td>第一次被Git暂存</td><td>之前版本记录无此文件</td></tr><tr><td>未修改（’’）</td><td>三个区域统一</td><td>提交后保存</td></tr><tr><td>已修改（M）</td><td>工作区内容无变化</td><td>修改了内容产生</td></tr></tbody></table></div><h2 id="5-Git暂存区使用"><a href="#5-Git暂存区使用" class="headerlink" title="5 .    Git暂存区使用"></a>5 .    Git暂存区使用</h2><p>暂存区:暂时存储，可以临时恢复代码内容，与版本库解耦</p><p>暂存区-&gt;覆盖-&gt;工作区，命令: git restore目标文件（注意∶完全确认覆盖时使用)</p><p>从暂存区移除文件，命令: git rm —cached目标文件</p><p>查看暂存区的内容，命令：git ls-files</p><p>查看之前所有的提交历史，命令：git log —oneline</p><p><img src="https://s2.loli.net/2023/08/27/8ys6h3CiZSFlkgf.png" alt="image-20230827133555585"></p><h2 id="6-Git回退版本"><a href="#6-Git回退版本" class="headerlink" title="6 .    Git回退版本"></a>6 .    Git回退版本</h2><p>概念:把版本库某个版本对应的内容快照，恢复到工作区/暂存区查看</p><p>提交历史:git log —oneline</p><p>查看所有的历史:git reflog —oneline</p><p>回退命令:</p><p>git reset —soft 版本号（其他文件未跟踪)    css，js暂存区工作区全部保留</p><p>git reset —hard 版本号    css，js暂存区工作区不保留直接删除，先恢复暂存区，再恢复工作区</p><p>git reset —mixed版本号(与git reset等价)    暂存区不保留，工作区保留</p><p>注意1:只有记录在版本库的提交记录才能恢复<br>注意2:回退后，继续修改-&gt;暂存-&gt;提交操作即可（产生新的提交记录过程)</p><h2 id="7-分支"><a href="#7-分支" class="headerlink" title="7 .    分支"></a>7 .    分支</h2><p>概念:本质上是指向提交节点的可变指针，默认名字是master</p><p>注意:HEAD指针影响工作区/暂存区的代码状态，指向哪个分支使用哪个分支</p><p>场景:开发新需求/修复Bug，保证主线代码随时可用，多人协同开发提高效率</p><h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1 . 创建分支"></a>1 . 创建分支</h3><p>1.创建分支命令:git branch 分支名，以HEAD指针指向的分支作为起点来创建分支</p><p>2.切换分支命令:git checkout 分支名，使HEAD指向这个分支，就能来操控这个分支</p><h3 id="2-合并并删除"><a href="#2-合并并删除" class="headerlink" title="2 .  合并并删除"></a>2 .  合并并删除</h3><p>1．切回到要合入的分支上: git checkout master</p><p>2．合并其他分支过来:git merge login-bug</p><p>3．删除合并后的分支指针: git branch -d login-bug</p><p>第二个分支合并：合并提交，发生于原分支产生了新的提交记录后，再合并回去时发生，自动使用多个快照记录合并后产生一次新的提交</p><p><img src="https://s2.loli.net/2023/08/27/39qTPKuyeYSEJsf.png" alt="QQ图片20230827202417"></p><p>注意:提交记录的顺序按照产生的先后顺序排列，而非合并的先后顺序</p><p><img src="https://s2.loli.net/2023/08/27/GJaUh5bkmH2xVnv.png" alt="image-20230827202532657"></p><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><img src="https://s2.loli.net/2023/08/27/V1HzftLTnRh9dcF.png" alt="QQ图片20230827211901"></p><p><img src="https://s2.loli.net/2023/08/27/d1i3QAqLgbVNo79.png" alt="QQ图片20230827211907"></p><p><img src="https://s2.loli.net/2023/08/31/YKAMmq1GZoaVCe7.png" alt="QQ图片20230831120423"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;1．什么是-Git-仓库&quot;&gt;&lt;a href=&quot;#1．什么是-Git-仓库&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="http://putongl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="http://putongl.github.io/2.html"/>
    <id>http://putongl.github.io/2.html</id>
    <published>2023-08-07T07:08:52.335Z</published>
    <updated>2023-08-27T03:50:52.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="1-判断相等或者不等于（-、-、-、-）运算符"><a href="#1-判断相等或者不等于（-、-、-、-）运算符" class="headerlink" title="1.判断相等或者不等于（==、===、!=、!==）运算符"></a>1.判断相等或者不等于（==、===、!=、!==）运算符</h2><div class="table-container"><table><thead><tr><th>等值检测运算符</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>==（相等）</td><td>比较两个操作数的值是否相等，会自动进行隐式转换，比如：18 == ‘18’，会为true</td></tr><tr><td>!=（不想等）</td><td>比较两个操作数的值是否不相等</td></tr><tr><td>===（全等）</td><td>比较两个操作数的值是否相等，同时检测它们的类型是否相同</td></tr><tr><td>!==（不全等）</td><td>比较两个操作数的值是否不相等，同时检测它们的类型是否不相同</td></tr></tbody></table></div><p>在相等运算中，应注意以下几个问题：</p><ul><li>如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。</li><li>如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。</li><li>如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。</li><li>如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。</li><li>如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。</li></ul><h2 id="2-短路运算"><a href="#2-短路运算" class="headerlink" title="2.短路运算"></a>2.短路运算</h2><h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>​    短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的 值; </p><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><ul><li><p>​    语法： 表达式1 &amp;&amp; 表达式2 </p></li><li><p>如果第一个表达式的值为真，则返回表达式2 </p></li><li><p>如果第一个表达式的值为假，则返回表达式1</p></li><li><pre><code>console.log( 123 &amp;&amp; 456 ); // 456console.log( 0 &amp;&amp; 456 ); // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 逻辑或 </span><br><span class="line"></span><br><span class="line">- ​语法： 表达式1 || 表达式2 </span><br><span class="line">- 如果第一个表达式的值为真，则返回表达式1</span><br><span class="line">- 如果第一个表达式的值为假，则返回表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure>console.log( 123 || 456 ); // 123console.log( 0 || 456 ); // 456console.log( 123 || 456 || 789 ); // 123<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.函数的参数</span><br><span class="line"></span><br><span class="line">### 3.1形参和实参</span><br><span class="line"></span><br><span class="line">在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br><span class="line">| 参数 | 说明                                                        |</span><br><span class="line">| ---- | ----------------------------------------------------------- |</span><br><span class="line">| 形参 | 形式上的参数 函数定义的时候，传递的参数，当时并不知道是什么 |</span><br><span class="line">| 实参 | 实际上的参数 函数调用的时候，传递的参数，实参是传递给形参的 |</span><br><span class="line"></span><br><span class="line">参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</span><br><span class="line"></span><br><span class="line">- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...);</code></pre></li></ul><h3 id="3-2函数形参和实参个数不匹配问题"><a href="#3-2函数形参和实参个数不匹配问题" class="headerlink" title="3.2函数形参和实参个数不匹配问题"></a>3.2函数形参和实参个数不匹配问题</h3><div class="table-container"><table><thead><tr><th>参数个数</th><th>说明</th></tr></thead><tbody><tr><td>实参的个数等于形参的个数</td><td>输出正确结果</td></tr><tr><td>实参的个数多于形参的个数</td><td>只取到形参的个数</td></tr><tr><td>实参的个数小于形参的个数</td><td>多的形参定义为undefined，结果为NaN</td></tr></tbody></table></div><h3 id="3-3arguments的使用"><a href="#3-3arguments的使用" class="headerlink" title="3.3arguments的使用"></a>3.3arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上 它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的 所有实参。</p><p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li>可以有无数多个参数，实参有几个，arguments就有几个</li><li>具有 length 属性 </li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ul><h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4.预解析"></a>4.预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两 步：预解析和代码执行。</p><ul><li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提 前声明或者定义。</p></li><li><p>代码执行： 从上到下执行JS语句。</p></li></ul><p>预解析会把变量和函数的声明在代码执行之前执行完成。</p><ul><li>函数预解析</li><li>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</li></ul><h2 id="5-事件对象"><a href="#5-事件对象" class="headerlink" title="5.事件对象"></a>5.事件对象</h2><p>e.target 和 this 的区别：</p><p>​    this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素），谁绑定了这个点击事件，那么就返回谁 </p><p>​    e.target 是事件触发的元素。点击了哪个元素，就返回哪个元素</p><p>给ul绑定事件，this指向的是ul，e.target指向的是li</p><p>eventTarget.addEventListener(‘click’, function(event) { </p><p>​        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </p><p>}）</p><ul><li>addEventListener(‘click’, function(event)，true)</li><li>第三个参数为true，则为捕获阶段</li><li>省略不写，或为false，为冒泡阶段</li></ul><h2 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h2><ul><li>定义:执行代码和收集异步任务的模型，在调用栈空闲，反复调用任务队列里回调函数的执行机制，就叫事件循环</li></ul><p>执行过程</p><p>1.执行同步代码，遇到异步代码交给宿主浏览器环境</p><p>2.执行异步有了结果后，把回调函数放入任务队列排队</p><p>3.当调用栈空闲后，反复调用任务队列里的回调函数</p><p><img src="https://s2.loli.net/2023/08/27/qLNrMJUvgkXTQom.png" alt="image-20230827115025297"></p><h2 id="7-宏任务和微任务"><a href="#7-宏任务和微任务" class="headerlink" title="7.宏任务和微任务"></a>7.宏任务和微任务</h2><ul><li>1．什么是宏任务?</li><li>浏览器执行的异步代码</li><li>例如:JS执行脚本事件，setTimeout/setlnterval,AJAX请求完成事件，用户交互事件等</li><li>2．什么是微任务?</li><li>JS引擎执行的异步代码</li><li>例如:Promise对象.then()的回调</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;h2 id=&quot;1-判断相等或者不等于（-、-、-、-）运算符&quot;&gt;&lt;a href=&quot;#1-判断相等或者不等于（-、-、-、-）运算符&quot; class</summary>
      
    
    
    
    
    <category term="js" scheme="http://putongl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="http://putongl.github.io/4.html"/>
    <id>http://putongl.github.io/4.html</id>
    <published>2023-08-07T07:08:50.520Z</published>
    <updated>2023-08-07T09:39:17.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？"><a href="#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？" class="headerlink" title="Visual Studio Code代码想要同时编辑多处，该怎么实现呢？"></a>Visual Studio Code代码想要同时编辑多处，该怎么实现呢？</h2><h3 id="1-重命名变量"><a href="#1-重命名变量" class="headerlink" title="1. 重命名变量"></a>1. 重命名变量</h3><p>首先看看自己需要同时修改多处的代码是不是要重命名一个变量，如果是的话，有现成的快捷键<code>f2</code></p><p>使用方法：</p><ul><li>选中一个变量，按<code>f2</code> 或者 按 <code>Fn + f2</code>，具体依据电脑品牌而定！</li><li>弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。</li></ul><p>注意:在<code>js文件</code>中，如果这个变量没有用<code>var或者const或者let</code>声明，会无法重命名</p><h3 id="2-多光标"><a href="#2-多光标" class="headerlink" title="2. 多光标"></a>2. 多光标</h3><blockquote><ol><li>按住<code>alt</code>，用鼠标<code>左键点击</code>，可以出现多个光标，输入的代码可以在光标处同时增加</li></ol><p><img src="https://s2.loli.net/2023/08/07/x1Yai5TOJtr7VIG.png" alt="在这里插入图片描述"></p><ol><li>按住<code>Ctrl + Alt</code>，再按键盘上向上或者向下的键，可以使一列上出现多个光标。</li></ol><p><img src="https://s2.loli.net/2023/08/07/fMbWCoecKLqyhA3.png" alt="在这里插入图片描述"></p><ol><li>选中一段文字，按<code>shift+alt+i</code>，可以在每行末尾出现光标</li></ol><p><img src="https://s2.loli.net/2023/08/07/e3PyGSgTMtpbEHB.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/LcGv4XFP6iWn2dV.png" alt="在这里插入图片描述"></p><ol><li>光标放在一个地方，按<code>ctrl+shift+L</code>或者<code>ctrl+f2</code>，可以在页面中出现这个词的不同地方都出现光标。<code>有时候这个快捷键的作用和f2重命名变量类似</code>，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。</li></ol><p><img src="https://s2.loli.net/2023/08/07/Gz9gh8JyCFPAvcR.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/qWl2I3RTDKmhjsy.png" alt="在这里插入图片描述"></p><ol><li>按<code>shift+alt</code>，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。</li></ol><p><img src="https://s2.loli.net/2023/08/07/JQBkh5OagERo67y.png" alt="在这里插入图片描述"></p><ol><li>任何光标操作，可以按<code>Ctrl + U</code>取消</li></ol></blockquote><h3 id="3-替换字符串"><a href="#3-替换字符串" class="headerlink" title="3. 替换字符串"></a>3. 替换字符串</h3><blockquote><ol><li><p>按<code>ctrl+f</code>，可以搜索当前页面，然后按搜索框左边的小三角符号，<code>可以切换成替换模式</code>。</p><p>有时候使用字符串替换，比多光标方便，但是注意别不小心替换掉不想替换的内容。</p></li></ol><p><img src="https://s2.loli.net/2023/08/07/fEYHuMR4poLmb7n.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2023/08/07/dGwyr54Vso9ZT7C.png" alt="QQ图片20230807173855"></p><p>以上就是<code>vscode</code>同时编辑多处的三种方法，希望大家喜欢，谢谢！</p></blockquote><h3 id="4-全局替换某些单词"><a href="#4-全局替换某些单词" class="headerlink" title="4.全局替换某些单词"></a>4.全局替换某些单词</h3><ul><li>​        快捷键：ctrl + h </li></ul><h3 id="5-快速定位到某一行"><a href="#5-快速定位到某一行" class="headerlink" title="5.快速定位到某一行"></a>5.快速定位到某一行</h3><ul><li>​        快捷键：ctrl + g</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot;&gt;&lt;a href=&quot;#Visual-Studio-Code代码想要同时编辑多处，该怎么实现呢？&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Code代码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue笔记</title>
    <link href="http://putongl.github.io/vue.html"/>
    <id>http://putongl.github.io/vue.html</id>
    <published>2023-08-02T07:15:31.884Z</published>
    <updated>2023-08-26T11:40:51.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h2 id="1-Vue-是什么"><a href="#1-Vue-是什么" class="headerlink" title="1.Vue 是什么"></a>1.Vue 是什么</h2><h3 id="1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架"><a href="#1-1-概念：Vue-是一个用于-构建用户界面-的-渐进式-框架" class="headerlink" title="1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架"></a>1.1.概念：Vue 是一个用于 构建用户界面 的 渐进式 框架</h3><p>基于数据渲染出用户看到的页面</p><ul><li>Vue 的两种使用方式：</li></ul><p>​        ① Vue 核心包开发</p><p>​                场景：局部 模块改造</p><p>​        ② Vue 核心包 &amp; Vue 插件 工程化开发</p><p>​                场景：整站 开发</p><h3 id="1-2-创建-Vue-实例，初始化渲染的核心步骤："><a href="#1-2-创建-Vue-实例，初始化渲染的核心步骤：" class="headerlink" title="1.2.创建 Vue 实例，初始化渲染的核心步骤："></a>1.2.创建 Vue 实例，初始化渲染的核心步骤：</h3><ol><li><p>准备容器</p></li><li><p>引包 (官网) - 开发版本 / 生产版本</p></li><li><p>创建 Vue 实例 new Vue()</p></li><li><p>指定配置项 el data =&gt; 渲染数据</p></li></ol><ul><li>① 通过el配置选择器 ，指定vue管理的是哪个盒子，作用跟vue脚手架中的main.js中的</li><li>$mount()作用一致</li><li>② data 提供数</li></ul><h3 id="1-3-插值表达式"><a href="#1-3-插值表达式" class="headerlink" title="1.3.插值表达式"></a>1.3.插值表达式</h3><p>插值表达式是一种 Vue 的模板语法</p><ol><li><p>作用: 利用表达式进行插值，渲染到页面中</p><p>​    表达式：是可以被求值的代码，JS引擎会将其计算出一个结果</p></li><li><p>语法：</p></li><li><p>注意点：</p><p>（1）使用的数据必须存在 （data） </p><p>（2）支持的是表达式，而非语句，比如：if for ..</p><p>（3）不能在标签属性中使用插值表达式</p></li></ol><h3 id="1-4-Vue-核心特性：响应"><a href="#1-4-Vue-核心特性：响应" class="headerlink" title="1.4.Vue 核心特性：响应"></a>1.4.Vue 核心特性：响应</h3><ul><li><p>​    数据的响应式处理 → 响应式：数据变化，视图自动更新</p><p>​        使用 Vue 开发，关注业务的核心逻辑，根据业务修改数据即可</p></li><li><p>​    如何访问或修改数据呢？</p><p>​        data中的数据, 最终会被添加到实例上</p><p>​            ① 访问数据： “实例.属性名”</p><p>​            ② 修改数据： “实例.属性名” = “值”</p></li></ul><h3 id="1-5-Vue-指令"><a href="#1-5-Vue-指令" class="headerlink" title="1.5.Vue 指令"></a>1.5.Vue 指令</h3><p>Vue 会根据不同的【指令】，针对标签实现不同的【功能】</p><p>​    指令：带有 v- 前缀 的 特殊 标签属性，不同属性 对应 不同的功能</p><p>v-html:作用：设置元素的 innerHTML语法：v-html = “表达式”</p><ul><li>​    动态解析标签</li></ul><pre><code>  msg: `    &lt;a href=&quot;http://douyin.com&quot;&gt;        抖音         &lt;/a&gt;   ` </code></pre><p>​    msg里面不是引号，是Tab上面的 `号</p><p>v-show and v-if</p><p>v-show</p><ol><li><p>作用： 控制元素显示隐藏</p></li><li><p>语法： v-show = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 切换 display:none 控制显示隐藏</p></li><li><p>场景： 频繁切换显示隐藏的场景</p></li></ol><p>v-if</p><ol><li><p>作用： 控制元素显示隐藏（条件渲染）</p></li><li><p>语法： v-if = “表达式” 表达式值 true 显示， false 隐藏</p></li><li><p>原理： 基于条件判断，是否 创建 或 移除 元素节点</p></li><li><p>场景： 要么显示，要么隐藏，不频繁切换的场景</p></li></ol><p>v-else v-else-if</p><ol><li><p>作用： 辅助 v-if 进行判断渲染</p></li><li><p>语法： v-else v-else-if = “表达式”</p></li><li><p>注意： 需要紧挨着 v-if 一起使用</p></li></ol><p>v-on</p><ul><li><p>作用： 注册事件 = 添加监听 + 提供处理逻辑</p></li><li><p>语法：① v-on:事件名 = “内联语句”        @click=”count++”</p><p> ​           ② v-on:事件名 = “methods中的函数名”</p></li><li><p>简写：@事件名        v-on:click替换成@click</p></li><li>注意：methods函数内的 this 指向 Vue 实例 </li></ul><p>v-bind</p><ol><li><p>作用： 动态的设置html的标签属性 → src url title ..</p></li><li><p>语法： v-bind:属性名=”表达式”</p></li><li><p>注意： 简写形式  :属性名=”表达式”</p><p>v-for</p></li><li><p>作用： 基于数据循环， 多次渲染整个元素</p></li><li><p>遍历数组语法：</p><ul><li>v-for = “(item, index) in 数组”</li><li>item 数组中的每一项数据， index 下标</li><li>也可以省略 index: v-for = “item in 数组“</li></ul></li><li>v-for 中的 key<ul><li>语法： :key属性 = “唯一标识”</li><li>作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。</li><li>key 的值必须具有 唯一性</li><li>推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li></ul></li><li>v-for 的默认行为会尝试 原地修改元素 （就地复用）</li></ol><p>v-model</p><ol><li><p>作用: 给 表单元素 使用, 双向数据绑定 → 可以快速 获取 或 设置 表单元素内容 </p><p>① 数据变化 → 视图自动更新 </p><p>② 视图变化 → 数据自动更新 </p></li><li><p>语法: v-model = ‘变量’</p></li></ol><p><strong><code>v-model.trim()</code></strong> 方法从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串。此上下文中的空格是指所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）。</p><p><strong><code>v-model.number()</code></strong> 方法可以将输入的数据转换为Number类型，否则虽然你输入的是数字.但它的类型其实是String</p><p><strong><code>v-model.lazy()</code></strong>方法失去焦点更新，并不是实时改变，而是在失去焦点或者按回车时才会更新，类似懒加载</p><h3 id="1-6-指令修饰符"><a href="#1-6-指令修饰符" class="headerlink" title="1.6.指令修饰符"></a>1.6.指令修饰符</h3><ul><li>通过 “.” 指明一些指令 后缀，不同 后缀 封装了不同的处理操作 → 简化代码</li><li>① 按键修饰符<ul><li>@keyup.enter → 键盘回车监听</li></ul></li><li>② v-model修饰符<ul><li>v-model.trim → 去除首尾空格</li><li>v-model.number → 转数字</li></ul></li><li>③ 事件修饰符<ul><li>@事件名.stop → 阻止冒泡</li><li>@事件名.prevent → 阻止默认行为</li></ul></li></ul><h3 id="1-7-v-bind-对于样式控制的增强"><a href="#1-7-v-bind-对于样式控制的增强" class="headerlink" title="1.7.v-bind 对于样式控制的增强"></a>1.7.v-bind 对于样式控制的增强</h3><ul><li>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 class 类名 和 style 行内样式 进行控制 。</li></ul><ol><li><p>操作class</p><ul><li><p>语法 :class = “对象/数组” </p><p>① 对象 → 键就是类名，值是布尔值。如果值为 true，有这个类，否则没有这个类</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：一个类名，来回切换</p><p>​            ② 数组 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表 v-bind 对于样式控制的增强 - 操作class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :class=&quot;[ 类名1, 类名2, 类名3 ]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：批量添加或删除类</p></li><li><p>操作style</p><ul><li>语法 :style = “样式对象”</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot; :style=&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>​        适用场景：某个具体属性的动态设置</p><h3 id="1-8-v-model-应用于其他表单元素"><a href="#1-8-v-model-应用于其他表单元素" class="headerlink" title="1.8.v-model 应用于其他表单元素"></a>1.8.v-model 应用于其他表单元素</h3><ul><li>​    常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值</li><li>​        v-model 应用于其他表单元素</li><li>​    它会根据 控件类型 自动选取 正确的方法 来更新元素</li></ul><h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9.计算属性"></a>1.9.计算属性</h3><ul><li>概念：基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。</li><li>语法：</li><li>① 声明在 computed 配置项中，一个计算属性对应一个函数</li><li>② 使用起来和普通属性一样使用 </li><li>计算属性 → 可以将一段 求值的代码 进行封装</li></ul><h3 id="1-10-computed-计算属性-vs-methods-方法"><a href="#1-10-computed-计算属性-vs-methods-方法" class="headerlink" title="1.10. computed 计算属性 vs methods 方法"></a>1.10. computed 计算属性 vs methods 方法</h3><ul><li>computed 计算属性：<ul><li>作用：封装了一段对于数据的处理，求得一个结果。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为属性，直接使用 → this.计算属性 </li></ul></li><li>缓存特性（提升性能）：<ul><li>计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 → 并再次缓存</li></ul></li></ul></li><li>methods 方法：<ul><li>作用：给实例提供一个方法，调用以处理业务逻辑。</li><li>语法：<ul><li>① 写在方法的配置项中</li><li>② 作为方法，需要调用 → this方法 /( ) </li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue笔记&quot;&gt;&lt;a href=&quot;#Vue笔记&quot; class=&quot;headerlink&quot; title=&quot;Vue笔记&quot;&gt;&lt;/a&gt;Vue笔记&lt;/h1&gt;&lt;h2 id=&quot;1-Vue-是什么&quot;&gt;&lt;a href=&quot;#1-Vue-是什么&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://putongl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Vue" scheme="http://putongl.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>IKUN</title>
    <link href="http://putongl.github.io/888.html"/>
    <id>http://putongl.github.io/888.html</id>
    <published>2023-08-01T09:16:56.217Z</published>
    <updated>2023-08-02T11:56:45.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回忆录"><a href="#回忆录" class="headerlink" title="回忆录"></a>回忆录</h2><p>一个真正的IKUN，他会跳舞，比如这样</p><p><img src="https://s2.loli.net/2023/08/02/ucfJQoM1SIgnzVC.png" alt="3bfc6928d18ff1188d5e5a6a69778fa"></p><p>他用他优美的舞姿，展现出不一样的风采，一个练习时常两年半的真正的MAN</p><p>著名的麦克阿瑟表示，没想到谷桑成不欺我，他差点又说出那句练习两年半的深田坤桑最爱的话:哎呦，你干嘛！！我上我也行！！大型传奇纪录片:谷门吹牛逼术，持续为您播出！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回忆录&quot;&gt;&lt;a href=&quot;#回忆录&quot; class=&quot;headerlink&quot; title=&quot;回忆录&quot;&gt;&lt;/a&gt;回忆录&lt;/h2&gt;&lt;p&gt;一个真正的IKUN，他会跳舞，比如这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/0</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Yml文档</title>
    <link href="http://putongl.github.io/5.html"/>
    <id>http://putongl.github.io/5.html</id>
    <published>2023-07-31T07:53:33.760Z</published>
    <updated>2023-08-07T07:13:50.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yml内容"><a href="#yml内容" class="headerlink" title="yml内容"></a>yml内容</h2><p>乱码：改成utf-8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;yml内容&quot;&gt;&lt;a href=&quot;#yml内容&quot; class=&quot;headerlink&quot; title=&quot;yml内容&quot;&gt;&lt;/a&gt;yml内容&lt;/h2&gt;&lt;p&gt;乱码：改成utf-8&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>海贼王</title>
    <link href="http://putongl.github.io/1.html"/>
    <id>http://putongl.github.io/1.html</id>
    <published>2023-07-29T09:18:40.507Z</published>
    <updated>2023-08-07T07:14:05.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2023年8月6日路飞5档，起飞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;2023年8月6日路飞5档，起飞&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
